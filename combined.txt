### ğŸŒ³ Codebase File Tree (Excluding ignored directories)

â”œâ”€â”€ Project/
â””â”€â”€ â”œâ”€â”€ Engine/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FollowCamera.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FollowCamera.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ NormalCamera.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ NormalCamera.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AABBCollider.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AABBCollider.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Collider.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ColliderConcept.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collision/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ColliderCollision.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ ColliderCollision.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OBBCollider.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OBBCollider.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SphereCollider.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ SphereCollider.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Core/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ComPtr.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DXCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DXCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Mii.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Mii.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StringUtility.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StringUtility.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WinApp.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ WinApp.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DataInfo/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AnimationData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BlendModeData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ColliderData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FunctionData.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FunctionData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ InputData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LevelData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LightData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LineObjectData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OceanData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OffScreenData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PipelineStateObjectType.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ SceneType.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Graphics/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ 2d/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ IndexBuffer2D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ IndexBuffer2D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Material2D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Material2D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object2DCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object2DCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Transform2D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Transform2D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ VertexBuffer2D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ VertexBuffer2D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Sprite/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SpriteCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ SpriteCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ 3d/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ IndexBuffer3D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ IndexBuffer3D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Material3D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Material3D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ObjectCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ObjectCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Transform3D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Transform3D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ VertexBuffer3D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ VertexBuffer3D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Line/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LineObject3D.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ LineObject3D.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AnimationModel.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AnimationModel.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ ModelCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Ocean/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Ocean.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Ocean.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OceanCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OceanCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OceanWaveCompute.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ OceanWaveCompute.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Primitive3D/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Primitive3DCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Primitive3DCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ SkyBox/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SkyBox.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ SkyBox.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BufferBase.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BufferBase.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ UAV.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ UAV.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OffScreen/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Effect/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BoxFilter3x3Effect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BoxFilter3x3Effect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BoxFilter5x5Effect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BoxFilter5x5Effect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CopyImageEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CopyImageEffect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DissolveEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DissolveEffect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GrayScaleEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GrayScaleEffect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OutLineEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OutLineEffect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RadiusBlurEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RadiusBlurEffect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ShatterGlassEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ShatterGlassEffect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ VignetteEffect.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ VignetteEffect.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OffScreenRenderer.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OffScreenRenderer.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderPass.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderPass.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderTexture.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ RenderTexture.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleDefinition.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleDefinition.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleFactory.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleFactory.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleGroup.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleGroup.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleParameter.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleParameter.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleSetUp.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ ParticleSetUp.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Pipeline/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ CS/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ CSPSOCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ CSPSOCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ CSRootSignature.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ CSRootSignature.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Compiler.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Compiler.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GS/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ BlendState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ BlendState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DepthStencil.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DepthStencil.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ GSPSOCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ GSPSOCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ GSRootSignature.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ GSRootSignature.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ InputLayout.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ InputLayout.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ RasterizerState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ RasterizerState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ PSOBase.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ PSOBase.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Scene/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AbstractSceneFactory.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AbstractSceneFactory.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Debug/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleEditorScene.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ ParticleEditorScene.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ IScene.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ IScene.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MyGame.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MyGame.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SceneFactory.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SceneFactory.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Transition/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SceneTransitionBase.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ SceneTransitionBase.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SceneTransitionManager.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SceneTransitionManager.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ShatterGlassTransition.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ ShatterGlassTransition.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ System/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DeltraTime/
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DeltaTime.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ DeltaTime.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Editor/
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ParticleEditor.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ ParticleEditor.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ImGui/
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SceneView.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ SceneView.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Input/
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Controller.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Controller.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ InputCommon.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ InputCommon.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Keyboard.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Keyboard.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Mouse.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ Mouse.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Managers/
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AnimationManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AnimationManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AudioManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AudioManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ CSVManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ CSVManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ CameraManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ CameraManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ColliderManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ColliderManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DSVManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ DSVManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ImGuiManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ImGuiManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ LevelManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ LevelManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ModelManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ModelManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ParticleManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ ParticleManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PiplineManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PiplineManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ RTVManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ RTVManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SRVManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SRVManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SceneManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SceneManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ TextureManager.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ TextureManager.h
â””â”€â”€ â””â”€â”€     â””â”€â”€ Service/
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ AudioService.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ AudioService.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ CameraService.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ CameraService.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ ColliderService.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ ColliderService.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ DeltaTimeSevice.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ DeltaTimeSevice.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ GraphicsResourceGetter.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ GraphicsResourceGetter.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ InputService.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ InputService.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ Loader.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ Loader.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ OffScreenService.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ OffScreenService.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ ParticleService.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ ParticleService.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ Render.cpp
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ Render.h
â””â”€â”€ â””â”€â”€         â”œâ”€â”€ ServiceLocator.cpp
â””â”€â”€ â””â”€â”€         â””â”€â”€ ServiceLocator.h
â””â”€â”€ â”œâ”€â”€ FallenAscent.vcxproj
â””â”€â”€ â”œâ”€â”€ FallenAscent.vcxproj.filters
â””â”€â”€ â”œâ”€â”€ Math/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EasingMath.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EasingMath.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix3x3.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix3x3.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix4x4.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Matrix4x4.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MatrixMath.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MatrixMath.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Quaternion.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Quaternion.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector2.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector2.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector3.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector3.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector4.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Vector4.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ sMath.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ sMath.h
â””â”€â”€ â”œâ”€â”€ Resource/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Animations/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ human/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ simpleSkin/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BGM/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Fonts/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Json/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Attacks/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Level/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Particles/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Models/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Ground/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Level/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ MonsterBall/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object1/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object2/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Particle/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Cube/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Plane/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sphere/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Triangle/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayerWeapon/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ terrain/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Shaders/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ 2D/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ 3D/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ OffScreen/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Particle/
â””â”€â”€ â””â”€â”€ â””â”€â”€ Textures/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Animation/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DDS/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GameUI/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ OffScreen/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Particle/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TitleUI/
â””â”€â”€ â”œâ”€â”€ application/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Drawing/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ 2d/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Sprite.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ 3d/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Line.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Line.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Object3d.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ Object3d.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Game/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Animation/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearAnimation.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameClearAnimation.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverAnimation.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameOverAnimation.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StartAnimation.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ StartAnimation.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameCamera.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ GameCamera.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Entity/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ BaseEnemy.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CloseRange/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CloseRangeEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ CloseRangeEnemy.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Component/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyHitReactionComponent.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyHitReactionComponent.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyMoveComponent.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ EnemyMoveComponent.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LongRange/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LongRangeEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LongRangeEnemy.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LongRangeEnemyBullet.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ LongRangeEnemyBullet.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Manager/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyManager.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ EnemyManager.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ State/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ EnemyState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ EnemyState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyAttackState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyAttackState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyHitReactionState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyHitReactionState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyMoveState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyMoveState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ EnemyPrePareAttackState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ EnemyPrePareAttackState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameCharacter/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameCharacter.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameCharacter.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameCharacterCollision.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ GameCharacterCollision.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Player/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Component/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PlayerAttackComponent.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PlayerAttackComponent.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PlayerAvoidanceComponent.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PlayerAvoidanceComponent.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PlayerMoveComponent.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ PlayerMoveComponent.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Editor/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AttackDataSerializer.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AttackDataSerializer.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AttackEditor.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AttackEditor.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ Data/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€     â””â”€â”€ AttackData.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Player.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Player.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ State/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AttackState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AttackState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AvoidanceState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AvoidanceState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ Base/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayerState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ â””â”€â”€ PlayerState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ MoveState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ MoveState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ RootState.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ RootState.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ Weapon/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€         â”œâ”€â”€ PlayerWeapon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€         â””â”€â”€ PlayerWeapon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameGround/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Ground.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Ground.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GroundOcean.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ GroundOcean.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameObject/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameObject.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ GameObject.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameStage.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ GameStage.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ StageObject/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ StageObject.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ StageObject.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ UI/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Game/
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ GameSceneUI.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ GameSceneUI.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PlayerUI.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ PlayerUI.h
â””â”€â”€ â””â”€â”€ â””â”€â”€     â””â”€â”€ Title/
â””â”€â”€ â””â”€â”€ â””â”€â”€         â”œâ”€â”€ TitleUI.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€         â””â”€â”€ TitleUI.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ Scene/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ClearScene.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ ClearScene.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ Debug/
â””â”€â”€ â””â”€â”€     â””â”€â”€ â”œâ”€â”€ AttackEditorScene.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ â””â”€â”€ AttackEditorScene.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GameOverScene.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GameOverScene.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GameScene.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GameScene.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SelectScene.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SelectScene.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ TitleScene.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ TitleScene.h
â””â”€â”€ â””â”€â”€ main.cpp
================================================================================


============================================================
File Path: Project/Engine/Camera/FollowCamera.cpp
============================================================
#include "FollowCamera.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"
#include "Math/MatrixMath.h"
// ImGUi
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI


///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
FollowCamera::~FollowCamera() {
	targetPos_ = nullptr;
	targetRot_ = nullptr;
}

///-------------------------------------------/// 
/// FollowCameraã®è¨­å®š
///-------------------------------------------///
void FollowCamera::SetFollowCamera(FollowCameraType type) {
	cameraType_ = type;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// è¿½å¾“ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å–å¾—
const Vector3& FollowCamera::GetOffset() const { return offset_; }
// å›è»¢å‹è¿½å¾“ã‚«ãƒ¡ãƒ©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å–å¾—
const Vector3& FollowCamera::GetOrbitingOffset() const { return OrbitingOffset_; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// è¿½å¾“å¯¾è±¡ã®åº§æ¨™ã‚’è¨­å®š
void FollowCamera::SetTarget(Vector3* position, Quaternion* rotation) {
	targetPos_ = position;
	targetRot_ = rotation;
}
// è¿½å¾“ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
void FollowCamera::SetOffset(const Vector3& offset) { offset_ = offset; }
void FollowCamera::SetOrbitingOffset(const Vector3& offset) { OrbitingOffset_ = offset; }
// è¿½å¾“é€Ÿåº¦ã‚’è¨­å®š
void FollowCamera::SetFollowSpeed(float speed) { followSpeed_ = speed; }
// å›è»¢è£œé–“é€Ÿåº¦
void FollowCamera::SetLerpSpeed(float speed) { rotationLerpSpeed_ = speed; }
// å›è»¢ã®é‡ã¿
void FollowCamera::SetStick(const Vector2& stickValue) { stickValue_ = stickValue; }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void FollowCamera::Initialize() {
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–ã‚’å‘¼ã¶
	NormalCamera::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void FollowCamera::Update() {
	if (targetPos_ && targetRot_) {
		// è¿½å¾“å‡¦ç†
		UpdateFollowCamera();
	}

	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®æ›´æ–°ã‚’å‘¼ã¶ï¼ˆè¡Œåˆ—è¨ˆç®—ï¼‰
	NormalCamera::Update();
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®æ›´æ–°
///-------------------------------------------///
void FollowCamera::ImGuiUpdate() {
#ifdef USE_IMGUI
	ImGui::Begin("FollowCamera");
	ImGui::DragFloat3("Offset", &offset_.x, 0.01f);
	ImGui::DragFloat3("OrbitingOffset_", &OrbitingOffset_.x, 0.01f);
	ImGui::DragFloat("followSpeed_", &followSpeed_, 0.01f);
	ImGui::DragFloat("rotationLerpSpeed_", &rotationLerpSpeed_, 0.01f);
	ImGui::End();
	NormalCamera::ImGuiUpdate();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¿½å¾“å‡¦ç†
///-------------------------------------------///
void FollowCamera::UpdateFollowCamera() {
	switch (cameraType_) {
	case FollowCameraType::FixedOffset:
		FollowFixedOffset();
		break;
	case FollowCameraType::Interpolated:
		FollowInterpolated();
		break;
	case FollowCameraType::Orbiting:
		FollowOrbiting();
		break;
	case FollowCameraType::CollisionAvoidance:
		FollowCollisionAvoidance();
		break;
	case FollowCameraType::TopDown:
		FollowTopDown();
		break;
	}
}

// å›è»¢è»¸ãŒYåº§æ¨™ã ã‘ã®è¿½å¾“å‡¦ç†
void FollowCamera::FollowFixedOffset() {
	// ç›®æ¨™ã®å›è»¢ï¼ˆQuaternionï¼‰ã® Yaw æˆåˆ†ã®ã¿ã‚’å–å¾—
	float targetYaw = Math::GetYAngle(*targetRot_);
	Quaternion targetYawRotation = Math::MakeRotateAxisAngle(Vector3(0, 1, 0), targetYaw);

	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã® Y è»¸å›è»¢ã«åŸºã¥ã„ã¦å›è»¢
	Vector3 rotatedOffset = Math::RotateVector(offset_, targetYawRotation);

	// ç›®æ¨™ä½ç½®ã‚’ç®—å‡º
	Vector3 targetCameraPos = *targetPos_ + rotatedOffset;

	// ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’è£œé–“ï¼ˆLerpï¼‰ã§æ»‘ã‚‰ã‹ã«ç§»å‹•
	transform_.translate = Math::Lerp(transform_.translate, targetCameraPos, followSpeed_);

	// ã‚«ãƒ¡ãƒ©ã®å›è»¢ã‚’ Yaw ã®ã¿ã«åˆ¶é™ã—ã¦è£œé–“
	transform_.rotate = Math::SLerp(transform_.rotate, targetYawRotation, rotationLerpSpeed_);
}

// å›è»¢è»¸ãŒXã¨Yåº§æ¨™ã®è¿½å¾“å‡¦ç†
void FollowCamera::FollowInterpolated() {
	// ç›®æ¨™ã®å›è»¢ï¼ˆQuaternionï¼‰ã‚’å–å¾—
	Quaternion targetRotation = *targetRot_;

	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å›è»¢ã«åŸºã¥ã„ã¦å›è»¢
	Vector3 rotatedOffset = Math::RotateVector(offset_, targetRotation);

	// ç›®æ¨™ä½ç½®ã‚’ç®—å‡º
	Vector3 targetCameraPos = *targetPos_ + rotatedOffset;

	// ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’è£œé–“ï¼ˆLerpï¼‰ã§æ»‘ã‚‰ã‹ã«ç§»å‹•
	transform_.translate = Math::Lerp(transform_.translate, targetCameraPos, followSpeed_);

	// ã‚«ãƒ¡ãƒ©ã®å›è»¢ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«è£œé–“ï¼ˆSlerp ã‚’ä½¿ç”¨ï¼‰
	//transform_.rotate = Math::SLerp(transform_.rotate, targetRotation, rotationLerpSpeed_);
}

// è‡ªåˆ†ã®å‘¨ã‚Šã‚’ã¾ã‚ã‚‹ã‚«ãƒ¡ãƒ©ã®è¿½å¾“å‡¦ç†
void FollowCamera::FollowOrbiting() {
	// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§å›è»¢ã‚’ç®¡ç†
	Quaternion rotationDelta = Math::IdentityQuaternion();

	// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®Xãƒ»Yè»¸ã®å€¤ã‚’å–å¾— (-32768 ï½ 32767)
	float rightStickX = stickValue_.x; // Yawï¼ˆå·¦å³å›è»¢ï¼‰
	float rightStickY = stickValue_.y; // Pitchï¼ˆä¸Šä¸‹å›è»¢ï¼‰

	// ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³å‡¦ç†ï¼ˆã‚¹ãƒ†ã‚£ãƒƒã‚¯ãŒã‚ãšã‹ã«å‚¾ã„ãŸã¨ãã®ç„¡åŠ¹åŒ–ï¼‰
	const float DEADZONE = 0.2f;
	if (fabs(rightStickX) < DEADZONE) rightStickX = 0.0f;
	if (fabs(rightStickY) < DEADZONE) rightStickY = 0.0f;

	// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å…¥åŠ›ã‚’å›è»¢é‡ã«å¤‰æ›
	float deltaYaw = rightStickX * 0.05f;  // æ„Ÿåº¦èª¿æ•´
	float deltaPitch = rightStickY * 0.05f;

	// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’ç”¨ã„ãŸå›è»¢è¨ˆç®—
	Quaternion yawRotation = Math::MakeRotateAxisAngle(
		Vector3(0, 1, 0), deltaYaw);
	Quaternion pitchRotation = Math::MakeRotateAxisAngle(
		Math::RotateVector(Vector3(1, 0, 0), yawRotation * transform_.rotate), deltaPitch);

	// å›è»¢ã®è£œé–“
	rotationDelta = pitchRotation * yawRotation;

	// ç´¯ç©å›è»¢ã‚’æ›´æ–°
	transform_.rotate = rotationDelta * transform_.rotate;

	offset_ = OrbitingOffset_;

	// å›è»¢ã‚’é©ç”¨
	offset_ = Math::RotateVector(offset_, transform_.rotate);
	transform_.translate = offset_ + *targetPos_;

	transform_.rotate = Normalize(transform_.rotate); // ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’æ­£è¦åŒ–ã—ã¦æ•°å€¤èª¤å·®ã‚’é˜²ã
}

// éšœå®³ç‰©ã‚’é¿ã‘ã‚‹è¿½å¾“å‡¦ç†
void FollowCamera::FollowCollisionAvoidance() {
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢ã‚’åŸºã«Yè»¸å›è»¢è¡Œåˆ—ã‚’ä½œæˆ
	Matrix4x4 rotationMatrix = Math::MakeRotateYMatrix(targetRot_->y);

	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å›è»¢è¡Œåˆ—ã§å¤‰æ›ã—ã€é©åˆ‡ãªä½ç½®ã«èª¿æ•´
	Vector3 rotatedOffset = Math::TransformVector(offset_, rotationMatrix);

	// ç›®æ¨™ä½ç½®ã‚’ç®—å‡º
	Vector3 targetCameraPos = *targetPos_ + rotatedOffset;

	// éšœå®³ç‰©ã®æœ‰ç„¡ã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã‚’ä½¿ç”¨äºˆå®šï¼‰
	bool hitWall = false; // ã“ã“ã«ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆã‚’å®Ÿè£…ã™ã‚‹ï¼ˆä»®ï¼‰

	// å£ãŒã‚ã‚‹å ´åˆã¯ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å¯„ã‚‹
	if (hitWall) {
		transform_.translate = Math::Lerp(transform_.translate, *targetPos_, followSpeed_);
	} else {
		transform_.translate = Math::Lerp(transform_.translate, targetCameraPos, followSpeed_);
	}

	// ã‚«ãƒ¡ãƒ©ã®å‘ãã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢ã«åˆã‚ã›ã‚‹
	transform_.rotate = *targetRot_;
}

///-------------------------------------------/// 
/// ä¸Šã‹ã‚‰ã®è¦‹ä¸‹ã‚ã—ã‚«ãƒ¡ãƒ©ã®è¿½å¾“å‡¦ç†
///-------------------------------------------///
void FollowCamera::FollowTopDown() {
	const float deadzone = 0.1f;
	const float radius = 15.0f; // å›è»¢åŠå¾„ï¼ˆãŠå¥½ã¿ã§ï¼‰

	Vector3 desiredPosition = *targetPos_ + offset_; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆä½ç½®ï¼ˆè¿½å¾“å¯¾è±¡ã®çœŸä¸Šï¼‰

	// ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›ãŒã‚ã‚‹å ´åˆã¯ã‚«ãƒ¡ãƒ©ã‚’å††é‹å‹•ã•ã›ã‚‹
	if (fabsf(stickValue_.x) > deadzone || fabsf(stickValue_.y) > deadzone) {
		// å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«ã®æ­£è¦åŒ–ï¼ˆæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼‰
		Vector2 norm = Normalize(stickValue_);

		// å††ä¸Šã®ä½ç½®ã‚’è¨ˆç®—
		Vector3 offsetCircle = {
			norm.x * radius,
			offset_.y,           // Yï¼ˆé«˜ã•ï¼‰ã¯å›ºå®š
			norm.y * radius
		};

		Vector3 translate = offset_ + *targetPos_;
		translate.y = 1.0f;

		desiredPosition = translate + offsetCircle;
	}

	// ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’è£œé–“ã§æ»‘ã‚‰ã‹ã«ç§»å‹•
	transform_.translate = Math::Lerp(transform_.translate, desiredPosition, followSpeed_);
}

============================================================
File Path: Project/Engine/Camera/FollowCamera.h
============================================================
#pragma once
/// ===Include=== ///
#include "NormalCamera.h"

/// === ã‚«ãƒ¡ãƒ©ã®ç¨®é¡ã‚’è¡¨ã™åˆ—æŒ™å‹ === ///
enum class FollowCameraType {
	FixedOffset,        // å›ºå®šã‚ªãƒ•ã‚»ãƒƒãƒˆå‹ï¼ˆä¸€å®šã®ã‚ªãƒ•ã‚»ãƒƒãƒˆè·é›¢ã§è¿½å¾“ï¼‰
	Interpolated,       // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°è¿½å¾“å‹ï¼ˆè£œé–“ã§æ»‘ã‚‰ã‹ã«è¿½å¾“ï¼‰
	Orbiting,           // å›è»¢å¯èƒ½å‹ï¼ˆå¯¾è±¡ã®å‘¨ã‚Šã‚’å›ã‚‹ã‚«ãƒ¡ãƒ©ï¼‰
	CollisionAvoidance, // è¡çªå›é¿å‹ï¼ˆéšœå®³ç‰©ã‚’é¿ã‘ã‚‹ï¼‰
	TopDown,           // ä¸Šã‹ã‚‰ã®è¦–ç‚¹
};

///=====================================================/// 
/// è¿½å¾“ã‚«ãƒ¡ãƒ©ã‚¯ãƒ©ã‚¹
///=====================================================///
class FollowCamera : public NormalCamera {
public:
	FollowCamera() = default;
	~FollowCamera() override;

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update() override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®æ›´æ–°
	/// </summary>
	virtual void ImGuiUpdate() override;

	/// <summary>
	/// è¿½å¾“ã‚«ãƒ¡ãƒ©ã®ç¨®é¡ã‚’è¨­å®š
	/// </summary>
	/// <param name="type">è¨­å®šã™ã‚‹ãƒ•ã‚©ãƒ­ãƒ¼ã‚«ãƒ¡ãƒ©ã®ç¨®é¡ï¼ˆFollowCameraType å‹ï¼‰ã€‚</param>
	void SetFollowCamera(FollowCameraType type);

public: /// ===Getter=== ///

	const Vector3& GetOffset() const;
	const Vector3& GetOrbitingOffset() const;

public:/// ===Setter=== ///
	// è¿½å¾“å¯¾è±¡ã®åº§æ¨™ã‚’è¨­å®š
	void SetTarget(Vector3* position, Quaternion* rotation);
	// è¿½å¾“ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	void SetOffset(const Vector3& offset);
	// å›è»¢å‹è¿½å¾“ã‚«ãƒ¡ãƒ©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	void SetOrbitingOffset(const Vector3& offset);
	// è¿½å¾“é€Ÿåº¦ã‚’è¨­å®š
	void SetFollowSpeed(float speed);
	// å›è»¢è£œé–“é€Ÿåº¦ã‚’è¨­å®š
	void SetLerpSpeed(float speed);
	// ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›
	void SetStick(const Vector2& stickValue);

private:/// ===å¤‰æ•°=== ///
	/// ===è¿½å¾“=== ///
	Vector3* targetPos_ = nullptr;  // è¿½å¾“å¯¾è±¡ã®åº§æ¨™ãƒã‚¤ãƒ³ã‚¿
	Quaternion* targetRot_ = nullptr;  // è¿½å¾“å¯¾è±¡ã®å›è»¢ãƒã‚¤ãƒ³ã‚¿
	Vector3 offset_ = { 0.0f, 0.0f, -20.0f }; // ã‚«ãƒ¡ãƒ©ã®åˆæœŸã‚ªãƒ•ã‚»ãƒƒãƒˆ
	Vector3 OrbitingOffset_ = { 0.0f, 0.5f, -20.0f }; // å›è»¢ã‚«ãƒ¡ãƒ©ç”¨ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	float followSpeed_ = 0.1f;      // è¿½å¾“é€Ÿåº¦
	float rotationLerpSpeed_ = 0.1f; // å›è»¢è£œé–“é€Ÿåº¦

	Vector2 stickValue_ = { 0.0f, 0.0f }; // ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›å€¤

	FollowCameraType cameraType_ = FollowCameraType::FixedOffset; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã‚¿ã‚¤ãƒ—

private:
	/// <summary>
	/// è¿½å¾“ã‚«ãƒ¡ãƒ©ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateFollowCamera();

	/// <summary>
	/// å›ºå®šã‚ªãƒ•ã‚»ãƒƒãƒˆå‹ã‚«ãƒ¡ãƒ©ã®å‡¦ç† 
	/// </summary>
	void FollowFixedOffset();

	/// <summary>
	/// ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°è¿½å¾“å‹ã‚«ãƒ¡ãƒ©ã®å‡¦ç† 
	/// </summary>
	void FollowInterpolated();

	/// <summary>
	/// å›è»¢å¯èƒ½å‹ã‚«ãƒ¡ãƒ©ã®å‡¦ç† 
	/// </summary>
	void FollowOrbiting();

	/// <summary>
	/// è¡çªå›é¿å‹ã‚«ãƒ¡ãƒ©ã®å‡¦ç† 
	/// </summary>
	void FollowCollisionAvoidance();

	/// <summary>
	/// ä¸Šã‹ã‚‰ã®è¦‹ä¸‹ã‚ã—è¿½å¾“ã‚«ãƒ¡ãƒ©ã®å‡¦ç†
	/// </summary>
	void FollowTopDown();
};

============================================================
File Path: Project/Engine/Camera/NormalCamera.cpp
============================================================
#include "NormalCamera.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"
#include "Math/MatrixMath.h"
// Service
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/DeltaTimeSevice.h"
// C++
#include <random>
#include <ctime>
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI
// Debug
#ifdef _DEBUG
#include "Engine/System/Service/InputService.h"
#endif // _DEBUG

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// WorldMatrix
const Matrix4x4& NormalCamera::GetWorldMatrix() const { return worldMatrix_; }
// ViewMatrix
const Matrix4x4& NormalCamera::GetViewMatrix() const { return viewMatrix_; }
// ProjectionMatrix
const Matrix4x4& NormalCamera::GetProjectionMatrix() const { return projectionMatrix_; }
// ViewProjectionMatrix
const Matrix4x4& NormalCamera::GetViewProjectionMatrix() const { return viewProjectionMatrix_; }
// Translate
const Vector3& NormalCamera::GetTranslate() const { return transform_.translate; }
// Rotate
const Quaternion& NormalCamera::GetRotate() const { return transform_.rotate; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Translate
void NormalCamera::SetTranslate(const Vector3& translate) { transform_.translate = translate; }
// Rotate
void NormalCamera::SetRotate(const Quaternion& rotate) { transform_.rotate = rotate; }
// ForY
void NormalCamera::SetForY(const float& forY) { horizontalView_ = forY; }
// AspectRatio
void NormalCamera::SetAspectRatio(const float& aspect) { aspect_ = aspect; }
// NearClip
void NormalCamera::SetNearClip(const float& nearClip) { nearClip_ = nearClip; }
// FarClip
void NormalCamera::SetFarClip(const float& farClip) { farClip_ = farClip; }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void NormalCamera::Initialize() {
	transform_ = { {1.0f, 1.0f, 1.0f},{0.0f, 0.0f, 0.0f, 1.0f}, {0.0f, 0.0f, 0.0f} };
	horizontalView_ = 0.45f;
	aspect_ = static_cast<float>(GraphicsResourceGetter::GetWindowWidth()) / static_cast<float>(GraphicsResourceGetter::GetWindowHeight());
	nearClip_ = 0.1f;
	farClip_ = 100.0f;

	UpdateMatrices();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void NormalCamera::Update() {
	UpdateMatrices();
}


///-------------------------------------------/// 
/// æƒ…å ±
///-------------------------------------------///
void NormalCamera::ImGuiUpdate() {
#ifdef USE_IMGUI
	ImGui::Begin("ã‚«ãƒ¡ãƒ©");
	ImGui::DragFloat3("ä½ç½®", &transform_.translate.x, 0.01f);
	ImGui::DragFloat4("å›è»¢", &transform_.rotate.x, 0.001f);
	ImGui::DragFloat("Horizontal View", &horizontalView_, 0.01f);
	ImGui::DragFloat("Aspect Ratio", &aspect_, 0.01f);
	ImGui::DragFloat("Near Clip", &nearClip_, 0.01f);
	ImGui::DragFloat("Far Clip", &farClip_, 0.01f);
	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ‡ãƒãƒƒã‚°ç”¨ã®æ›´æ–°
///-------------------------------------------///
void NormalCamera::DebugUpdate() {
#ifdef _DEBUG
	// ã‚«ãƒ¡ãƒ©ã®ãƒ­ãƒ¼ã‚«ãƒ«Xè»¸ï¼ˆå³æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼‰ã‚’å–å¾—
	Vector3 right = Math::RotateVector({ 1.0f, 0.0f, 0.0f }, transform_.rotate);

	/// ===ã‚«ãƒ¡ãƒ©ã®ç§»å‹•=== ///
	if (InputService::PushKey(DIK_D)) {
		transform_.translate.x += 0.01f;
	} else if (InputService::PushKey(DIK_A)) {
		transform_.translate.x -= 0.01f;
	}
	if (InputService::PushKey(DIK_W)) {
		transform_.translate.z += 0.01f;
	} else if (InputService::PushKey(DIK_S)) {
		transform_.translate.z -= 0.01f;
	}
	if (InputService::PushKey(DIK_SPACE)) {
		transform_.translate.y += 0.01f;
	} else if (InputService::PushKey(DIK_LSHIFT)) {
		transform_.translate.y -= 0.01f;
	}

	// ãƒ”ãƒƒãƒï¼ˆç¸¦å›è»¢ï¼‰
	if (InputService::PushKey(DIK_UP)) {
		Quaternion delta = Math::MakeRotateAxisAngle(right, -0.01f);
		transform_.rotate = delta * transform_.rotate;
	} else if (InputService::PushKey(DIK_DOWN)) {
		Quaternion delta = Math::MakeRotateAxisAngle(right, +0.01f);
		transform_.rotate = delta * transform_.rotate;
	}

	// ãƒ¨ãƒ¼ï¼ˆå·¦å³å›è»¢ï¼‰
	if (InputService::PushKey(DIK_LEFT)) {
		Quaternion delta = Math::RotateY(-0.01f);
		transform_.rotate = delta * transform_.rotate;
	} else if (InputService::PushKey(DIK_RIGHT)) {
		Quaternion delta = Math::RotateY(+0.01f);
		transform_.rotate = delta * transform_.rotate;
	}
#endif // _DEBUG
}

///-------------------------------------------/// 
/// ã‚·ã‚§ã‚¤ã‚¯é–‹å§‹å‡¦ç†
///-------------------------------------------///
void NormalCamera::StartShake(float intensity, float duration, float frequency) {
	isShaking_ = true;
	shakeIntensity_ = intensity;
	shakeDuration_ = duration;
	shakeTimer_ = 0.0f;
	shakeFrequency_ = frequency;

	// ãƒ©ãƒ³ãƒ€ãƒ ãªæ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ç”Ÿæˆï¼ˆå„è»¸ã§ç•°ãªã‚‹æ³¢å½¢ã«ã™ã‚‹ãŸã‚ï¼‰
	static std::random_device rd;
	static std::mt19937 gen(rd());
	std::uniform_real_distribution<float> dist(0.0f, 2.0f * 3.14159f);
	shakeTimeOffset_ = dist(gen);
}

///-------------------------------------------/// 
/// ã‚·ã‚§ã‚¤ã‚¯å‡¦ç†çµ‚äº†
///-------------------------------------------///
void NormalCamera::StopShake() {
	isShaking_ = false;
	shakeTimer_ = 0.0f;
	shakeOffset_ = { 0.0f, 0.0f, 0.0f };
}

///-------------------------------------------/// 
/// è¡Œåˆ—ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void NormalCamera::UpdateMatrices() {
	/// ===ã‚·ã‚§ã‚¤ã‚¯=== ///
	// ã‚·ã‚§ã‚¤ã‚¯ã®æ›´æ–°
	UpdateShake();
	// ã‚·ã‚§ã‚¤ã‚¯ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	Vector3 finalPosition = transform_.translate + shakeOffset_;

	// è¡Œåˆ—ã®è¨ˆç®—
	worldMatrix_ = Math::MakeAffineQuaternionMatrix(transform_.scale, transform_.rotate, finalPosition);
	viewMatrix_ = Math::Inverse4x4(worldMatrix_);

	// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®æ›´æ–°
	projectionMatrix_ = Math::MakePerspectiveFovMatrix(horizontalView_, aspect_, nearClip_, farClip_);

	// åˆæˆè¡Œåˆ—
	viewProjectionMatrix_ = Multiply(viewMatrix_, projectionMatrix_);
}

///-------------------------------------------/// 
/// ã‚·ã‚§ã‚¤ã‚¯å‡¦ç†
///-------------------------------------------///
void NormalCamera::UpdateShake() {
	if (!isShaking_) {
		shakeOffset_ = { 0.0f, 0.0f, 0.0f };
		return;
	}

	shakeTimer_ += DeltaTimeSevice::GetDeltaTime();

	// ã‚·ã‚§ã‚¤ã‚¯çµ‚äº†åˆ¤å®š
	if (shakeTimer_ >= shakeDuration_) {
		StopShake();
		return;
	}

	// æ¸›è¡°ã‚«ãƒ¼ãƒ–ï¼ˆæ™‚é–“çµŒéã¨ã¨ã‚‚ã«å¼±ããªã‚‹ï¼‰
	float decayFactor = 1.0f - (shakeTimer_ / shakeDuration_);
	decayFactor = decayFactor * decayFactor; // äºŒä¹—ã§æ€¥æ¿€ãªæ¸›è¡°

	// Sinæ³¢ã‚’ä½¿ã£ãŸã‚·ã‚§ã‚¤ã‚¯è¨ˆç®—ï¼ˆå„è»¸ã§ç•°ãªã‚‹ä½ç›¸ï¼‰
	float time = shakeTimer_ * shakeFrequency_;

	shakeOffset_.x = sin(time + shakeTimeOffset_) * shakeIntensity_ * decayFactor;
	shakeOffset_.y = sin(time + shakeTimeOffset_ + 1.57f) * shakeIntensity_ * decayFactor * 0.7f; // Yè»¸ã¯å°‘ã—å¼±ã
	shakeOffset_.z = sin(time + shakeTimeOffset_ + 3.14f) * shakeIntensity_ * decayFactor * 0.5f; // Zè»¸ã¯ã•ã‚‰ã«å¼±ã

	// ãƒ©ãƒ³ãƒ€ãƒ è¦ç´ ã‚’è¿½åŠ ã—ã¦ã‚ˆã‚Šè‡ªç„¶ã«
	static std::random_device rd;
	static std::mt19937 gen(rd());
	std::uniform_real_distribution<float> randomDist(-0.3f, 0.3f);

	shakeOffset_.x += randomDist(gen) * shakeIntensity_ * decayFactor;
	shakeOffset_.y += randomDist(gen) * shakeIntensity_ * decayFactor * 0.7f;
	shakeOffset_.z += randomDist(gen) * shakeIntensity_ * decayFactor * 0.5f;
}


============================================================
File Path: Project/Engine/Camera/NormalCamera.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/CData.h"

///=====================================================/// 
/// ã‚«ãƒ¡ãƒ©åŸºåº•ã‚¯ãƒ©ã‚¹
///=====================================================///
class NormalCamera {
public:
	NormalCamera() = default;
	virtual ~NormalCamera() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	virtual void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update();

	/// <summary>
	/// ImGuiæƒ…å ±ã®æ›´æ–°
	/// </summary>
	virtual void ImGuiUpdate();

	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°ç”¨ã®æ›´æ–°
	/// </summary>
	void DebugUpdate();

	/// <summary>
	/// ã‚·ã‚§ã‚¤ã‚¯ï¼ˆæŒ¯å‹•ï¼‰åŠ¹æœã‚’é–‹å§‹ã™ã‚‹å‡¦ç†
	/// </summary>
	/// <param name="intensity">ã‚·ã‚§ã‚¤ã‚¯ã®å¼·ã•ã€‚å€¤ãŒå¤§ãã„ã»ã©æŒ¯å‹•ãŒå¤§ãããªã‚‹ã€‚</param>
	/// <param name="duration">ã‚·ã‚§ã‚¤ã‚¯ã®ç¶™ç¶šæ™‚é–“ï¼ˆç§’ï¼‰ã€‚</param>
	/// <param name="frequency">ã‚·ã‚§ã‚¤ã‚¯ã®å‘¨æ³¢æ•°ï¼ˆ1ç§’ã‚ãŸã‚Šã®æŒ¯å‹•å›æ•°ï¼‰ã€‚çœç•¥æ™‚ã®æ—¢å®šå€¤ã¯ 10.0fã€‚</param>
	void StartShake(float intensity, float duration, float frequency = 10.0f);

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯å‡¦ç†ã‚’åœæ­¢
	/// </summary>
	void StopShake();


public:/// ===Getter=== ///
	// WorldMatrix
	const Matrix4x4& GetWorldMatrix()const;
	// ViewMatrix
	const Matrix4x4& GetViewMatrix()const;
	// ProjectionMatrix
	const Matrix4x4& GetProjectionMatrix()const;
	// ViewProjectionMatrix
	const Matrix4x4& GetViewProjectionMatrix()const;
	// Translate
	const Vector3& GetTranslate()const;
	// Rotate
	const Quaternion& GetRotate()const;

public:/// ===Setter=== ///
	// Translate
	void SetTranslate(const Vector3& translate);
	// Rotate
	void SetRotate(const Quaternion& rotate);
	// ForY
	void SetForY(const float& forY);
	// Aspect
	void SetAspectRatio(const float& aspect);
	// NearClip
	void SetNearClip(const float& nearClip);
	// FarClip
	void SetFarClip(const float& farClip);

protected:/// ===å¤‰æ•°=== ///
	/// ===ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿=== ///
	QuaternionTransform transform_;
	Matrix4x4 worldMatrix_;
	Matrix4x4 viewMatrix_;

	/// ===ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿=== ///
	Matrix4x4 projectionMatrix_;
	float horizontalView_; // æ°´å¹³æ–¹å‘è¦–é‡è§’
	float aspect_;         // ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
	float nearClip_;       // ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—è·é›¢
	float farClip_;        // ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—è·é›¢

	/// ===åˆæˆè¡Œåˆ—=== ///
	Matrix4x4 viewProjectionMatrix_;

	/// ===ã‚·ã‚§ã‚¤ã‚¯=== ///
	bool isShaking_ = false;        // ã‚·ã‚§ã‚¤ã‚¯ä¸­ãƒ•ãƒ©ã‚°
	float shakeIntensity_ = 0.0f;   // ã‚·ã‚§ã‚¤ã‚¯ã®å¼·åº¦
	float shakeDuration_ = 0.0f;    // ã‚·ã‚§ã‚¤ã‚¯ã®ç¶™ç¶šæ™‚é–“
	float shakeTimer_ = 0.0f;       // ã‚·ã‚§ã‚¤ã‚¯ã®ã‚¿ã‚¤ãƒãƒ¼
	float shakeFrequency_ = 10.0f;  // ã‚·ã‚§ã‚¤ã‚¯ã®å‘¨æ³¢æ•°
	Vector3 shakeOffset_;           // ã‚·ã‚§ã‚¤ã‚¯ã«ã‚ˆã‚‹ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	float shakeTimeOffset_;         // ãƒ©ãƒ³ãƒ€ãƒ ãªæ™‚é–“ã‚ªãƒ•ã‚»ãƒƒãƒˆ

private:
	/// <summary>
	/// è¡Œåˆ—ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateMatrices();
	
	/// <summary>
	/// ã‚·ã‚§ã‚¤ã‚¯ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateShake();
};

============================================================
File Path: Project/Engine/Collider/AABBCollider.cpp
============================================================
#include "AABBCollider.h"
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void AABBCollider::Initialize() {
	type_ = ColliderType::AABB;

	// Colliderã®åˆæœŸåŒ–
	Collider::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void AABBCollider::Update() {

	/// ===Object3Dã®æ›´æ–°=== ///
	object3d_->SetTranslate(transform_.translate);
	object3d_->SetRotate(transform_.rotate);
	object3d_->SetScale(transform_.scale);
	object3d_->SetColor(color_);

	// Colliderã®æ›´æ–°å‡¦ç†
	Collider::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void AABBCollider::Draw(BlendMode mode) {

	// Line
#ifdef _DEBUG
	// ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã¿æç”»
	line_->DrawAABB(aabb_, lineColor_);

#endif // DEBUG

	// Colliderã®æç”»å‡¦ç†
	Collider::Draw(mode);
}

///-------------------------------------------/// 
/// æƒ…å ±
///-------------------------------------------///
void AABBCollider::Information() {
#ifdef USE_IMGUI
	Collider::Information();
	ImGui::Text("OBBInfo");
	ImGui::DragFloat3("Min", &aabb_.min.x, 0.1f);
	ImGui::DragFloat3("Max", &aabb_.max.x, 0.1f);
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çªå‡¦ç†
///-------------------------------------------///
void AABBCollider::OnCollision(Collider* collider) { collider; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void AABBCollider::SetAABB(const AABB& aabb) { aabb_ = aabb; }

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
AABB AABBCollider::GetAABB() const {
	return aabb_;
}


============================================================
File Path: Project/Engine/Collider/AABBCollider.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Collider/Base/Collider.h"

///=====================================================/// 
/// AABB
///=====================================================///
class AABBCollider : public Collider {
public:

	AABBCollider() = default;
	~AABBCollider() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	virtual void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»æ™‚ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã™ã‚‹å€¤ï¼ˆBlendMode å‹ï¼‰ã€‚</param>
	virtual void Draw(BlendMode mode) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®æ›´æ–°
	/// </summary>
	virtual void Information()override;

public: /// ===è¡çª=== ///
	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã® Collider ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚è¡çªã«é–¢ã™ã‚‹æƒ…å ±ã‚’å–å¾—ãƒ»å‡¦ç†ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚</param>
	virtual void OnCollision(Collider* collider) override;

public: /// ===Setter=== ///
	// AABBã®è¨­å®š
	void SetAABB(const AABB& aabb);

public: /// ===Getter=== ///
	// AABBã®å–å¾—
	AABB GetAABB() const;

private:
	AABB aabb_;
};



============================================================
File Path: Project/Engine/Collider/Base/Collider.cpp
============================================================
#include "Collider.h"
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

///-------------------------------------------/// 
/// è¦ªå­é–¢ä¿‚
///-------------------------------------------///
void Collider::SetParent(ModelCommon* parent) {object3d_->SetParent(parent);}
void Collider::ClearParent() {object3d_->ClearParent();}
ModelCommon* Collider::GetModelCommon() { return object3d_->GetModelCommon(); }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Object3D
void Collider::SetTranslate(const Vector3& translate) { transform_.translate = translate; }
void Collider::SetRotate(const Quaternion& rotate) { transform_.rotate = rotate; }
void Collider::SetScale(const Vector3& scale) { transform_.scale = scale; }
void Collider::SetColor(const Vector4& color) { color_ = color; }
// Light
void Collider::SetLight(LightType type) { object3d_->SetLight(type); }
void Collider::SetLightData(LightInfo light) { object3d_->SetLightData(light); }
// IsCollision
void Collider::SetIsCollision(bool flag) { isCollision_ = flag; }

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// Type
ColliderType Collider::GetColliderType() const { return type_; }
// Name
ColliderName Collider::GetColliderName() const { return name_; }
// Transform
QuaternionTransform Collider::GetTransform() const { return transform_; }
// Color
Vector4 Collider::GetColor() const { return color_; }
// IsCollision
bool Collider::GetIsCollision() const { return isCollision_; }


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Collider::Initialize() {
#ifdef _DEBUG
	line_ = std::make_unique<Line>();
#endif // _DEBUG

	/// ===Transformã®åˆæœŸè¨­å®š=== ///
	transform_.translate = { 0.0f, 0.0f, 0.0f };
	transform_.rotate = { 0.0f, 0.0f, 0.0f, 1.0f };
	transform_.scale = { 1.0f, 1.0f, 1.0f };
	color_ = { 1.0f, 1.0f, 1.0f, 1.0f };
}


///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
void Collider::Update() {

#ifdef _DEBUG
	// ç·šã®è‰²ã‚’æ›´æ–°
	if (isCollision_) {
		lineColor_ = Vector4(1.0f, 0.0f, 0.0f, 1.0f);
	} else {
		lineColor_ = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	}
#endif // _DEBUG	

	// Object3Dã®æ›´æ–°
	object3d_->Update();
}


///-------------------------------------------/// 
/// æç”»å‡¦ç†
///-------------------------------------------///
void Collider::Draw(BlendMode mode) {
	// Object3Dã®æç”»
	object3d_->Draw(mode);
}

///-------------------------------------------/// 
/// æƒ…å ±
///-------------------------------------------///
void Collider::Information() {
#ifdef USE_IMGUI
	ImGui::DragFloat3("Translate", &transform_.translate.x, 0.1f);
	ImGui::DragFloat4("Rotate", &transform_.rotate.x, 0.1f);
	ImGui::DragFloat3("Scale", &transform_.scale.x, 0.1f);
	ImGui::ColorEdit4("Color", &color_.x);
#endif // USE_IMGUI

}

============================================================
File Path: Project/Engine/Collider/Base/Collider.h
============================================================
#pragma once
/// ===Include=== ///
// map
#include <map>
#include <string>
// Object3D
#include "application/Drawing/3d/Object3d.h"
// Data
#include "Engine/DataInfo/ColliderData.h"
// ColliderCollision
#include "Engine/Collider/Collision/ColliderCollision.h"
// Line
#include "application/Drawing/3d/Line.h"

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
///=====================================================///
class Collider {
public:

    Collider() = default;
    virtual ~Collider() = default;

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    virtual void Initialize();

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    virtual void Update();

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    /// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
    virtual void Draw(BlendMode mode);

    /// <summary>
	/// ImGuiæƒ…å ±ã®æ›´æ–°
    /// </summary>
    virtual void Information();

public: /// ===è¡çª=== ///
    /// <summary>
    /// è¡çªå‡¦ç†
    /// </summary>
    /// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è©²å½“ã™ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼æƒ…å ±ã‚’ç¤ºã™ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã€‚</param>
    virtual void OnCollision(Collider* collider) = 0;

public: /// ===è¦ªå­é–¢ä¿‚=== ///
	// è¦ªã®è¨­å®š
    void SetParent(ModelCommon* parent);
	// è¦ªã®è§£é™¤
	void ClearParent();
	// ModelCommonã®å–å¾—
	ModelCommon* GetModelCommon();

public: /// ===Setter=== ///
    // Transform
    void SetTranslate(const Vector3& translate);
    void SetRotate(const Quaternion& rotate);
    void SetScale(const Vector3& scale);
    // color
    void SetColor(const Vector4& color);
    // Light
    void SetLight(LightType type);
    void SetLightData(LightInfo light);
    // IsCollision
    void SetIsCollision(bool flag);

public: /// ===Getter=== ///
    // Type
    ColliderType GetColliderType() const;
    // CollisionName
    ColliderName GetColliderName() const;
    // Transform
    QuaternionTransform GetTransform() const;
    // Color
    Vector4 GetColor() const;
    // IsCollision
    bool GetIsCollision() const;

protected:
    /// ===Collider=== ///
    // Type
    ColliderType type_;
    // ColliderName
    ColliderName name_;

    /// ===Object=== ///
    // Object3D
    std::unique_ptr<Object3d> object3d_;
    // Transform
    QuaternionTransform transform_;
    // color
    Vector4 color_;

    /// ===Collision=== ///
    // è¡çªãƒ•ãƒ©ã‚°
    bool isCollision_ = false;

    /// ===Debug=== ///
#ifdef _DEBUG
    // Line
    std::unique_ptr<Line> line_;
    Vector4 lineColor_ = { 1.0f, 1.0f, 1.0f, 1.0f };
#endif // _DEBUG
};



============================================================
File Path: Project/Engine/Collider/ColliderConcept.h
============================================================
#pragma once
/// ===Include=== ///
// Collider
#include "Engine/Collider/Base/Collider.h"
// C++
#include <type_traits>

/// ===Concepts=== ///
template<typename T>
concept IsCollider = std::is_base_of_v<Collider, T> && !std::is_abstract_v<T> && std::is_default_constructible_v<T>;

============================================================
File Path: Project/Engine/Collider/Collision/ColliderCollision.cpp
============================================================
#include "ColliderCollision.h"
#include "Engine/Collider/Base/Collider.h"
#include "Engine/Collider/AABBCollider.h"
#include "Engine/Collider/SphereCollider.h"
#include "Engine/Collider/OBBCollider.h"
#include <algorithm>
#include <cmath>
#include "Math/sMath.h"

///-------------------------------------------/// 
/// æ±ç”¨è¡çªå‡¦ç†
///-------------------------------------------///
void ColliderCollision::ProcessCollision(Collider* colliderA, Collider* colliderB, float pushBackRatio) {
	// nullãƒã‚§ãƒƒã‚¯
	if (!colliderA || !colliderB) {
		return;
	}

	// pushBackRatioã‚’0.0~1.0ã«ã‚¯ãƒ©ãƒ³ãƒ—
	pushBackRatio = std::clamp(pushBackRatio, 0.0f, 1.0f);

	ColliderType typeA = colliderA->GetColliderType();
	ColliderType typeB = colliderB->GetColliderType();

	if (typeA == typeB) {
		// åŒã˜ã‚¿ã‚¤ãƒ—åŒå£«ã®è¡çªå‡¦ç†
		switch (typeA) {
		case ColliderType::Sphere:
			SphereToSphereCollision(dynamic_cast<SphereCollider*>(colliderA), dynamic_cast<SphereCollider*>(colliderB), pushBackRatio);
			break;
		case ColliderType::OBB:
			OBBToOBBCollision(dynamic_cast<OBBCollider*>(colliderA), dynamic_cast<OBBCollider*>(colliderB), pushBackRatio);
			break;
		}
	} else {
		// ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—åŒå£«ã®è¡çªå‡¦ç†
		ProcessMixdeTypeCollision(colliderA, colliderB, typeA, typeB, pushBackRatio);
	}
}

///-------------------------------------------/// 
/// ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—åŒå£«ã®è¡çªå‡¦ç†
///-------------------------------------------///
void ColliderCollision::ProcessMixdeTypeCollision(Collider* colliderA, Collider* colliderB, ColliderType typeA, ColliderType typeB, float pushBackRationA) {
	/// ===ç•°ãªã‚‹Collideræ¯ã®å‡¦ç†=== ///
	if ((typeA == ColliderType::Sphere && typeB == ColliderType::AABB) || (typeA == ColliderType::AABB && typeB == ColliderType::Sphere)) {

		// ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹åˆ¤åˆ¥
		SphereCollider* sphere = (typeA == ColliderType::Sphere) 
			? dynamic_cast<SphereCollider*>(colliderA) 
			: dynamic_cast<SphereCollider*>(colliderB);
		AABBCollider* aabb = (typeA == ColliderType::AABB) 
			? dynamic_cast<AABBCollider*>(colliderA) 
			: dynamic_cast<AABBCollider*>(colliderB);
		float ration = (typeA == ColliderType::Sphere) ? pushBackRationA : (1.0f - pushBackRationA);
		// è¡çªåˆ¤å®šã«ã‚ˆã‚‹æŠ¼ã—æˆ»ã—å‡¦ç†
		SphereToAABBCollision(sphere, aabb, ration);

	} else if ((typeA == ColliderType::Sphere && typeB == ColliderType::OBB) || (typeA == ColliderType::OBB && typeB == ColliderType::Sphere)) {

		// ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹åˆ¤åˆ¥
		SphereCollider* sphere = (typeA == ColliderType::Sphere) 
			? dynamic_cast<SphereCollider*>(colliderA) 
			: dynamic_cast<SphereCollider*>(colliderB);
		OBBCollider* obb = (typeA == ColliderType::OBB) 
			? dynamic_cast<OBBCollider*>(colliderA) 
			: dynamic_cast<OBBCollider*>(colliderB);
		float ration = (typeA == ColliderType::Sphere) ? pushBackRationA : (1.0f - pushBackRationA);
		// è¡çªåˆ¤å®šã«ã‚ˆã‚‹æŠ¼ã—æˆ»ã—å‡¦ç†
		SphereToOBBCollision(sphere, obb, ration);

	} else if ((typeA == ColliderType::AABB && typeB == ColliderType::OBB) || (typeA == ColliderType::OBB && typeB == ColliderType::AABB)) {

		// ã‚¿ã‚¤ãƒ—ã«ã‚ˆã‚‹åˆ¤åˆ¥
		AABBCollider* aabb = (typeA == ColliderType::AABB) 
			? dynamic_cast<AABBCollider*>(colliderA) 
			: dynamic_cast<AABBCollider*>(colliderB);
		OBBCollider* obb = (typeA == ColliderType::OBB) 
			? dynamic_cast<OBBCollider*>(colliderA) 
			: dynamic_cast<OBBCollider*>(colliderB);
		float ration = (typeA == ColliderType::AABB) ? pushBackRationA : (1.0f - pushBackRationA);
		// è¡çªåˆ¤å®šã«ã‚ˆã‚‹æŠ¼ã—æˆ»ã—å‡¦ç†
		AABBToOBBCollision(aabb, obb, ration);
	 }
}

///-------------------------------------------/// 
/// çƒã¨çƒã¨ã®è¡çªå‡¦ç†
///-------------------------------------------///
void ColliderCollision::SphereToSphereCollision(SphereCollider* sphereA, SphereCollider* sphereB, float pushBackRatio) {
	Vector3 posA = sphereA->GetTransform().translate;
	Vector3 posB = sphereB->GetTransform().translate;

	Vector3 direction = posB - posA;
	float distance = Length(direction);

	float radiusA = sphereA->GetSphere().radius;
	float radiusB = sphereB->GetSphere().radius;
	float totalRadius = radiusA + radiusB;

	// æ­£è¦åŒ–
	if (distance < EPSILON) {
		direction = Vector3(0.0f, 1.0f, 0.0f);
		distance = EPSILON;
	} else {
		direction = Normalize(direction);
	}

	// ã‚ã‚Šè¾¼ã¿æ·±åº¦ã‚’è¨ˆç®—
	float penetrationDepth = totalRadius - distance;

	// ã‚ã‚Šè¾¼ã‚“ã§ã„ã‚‹å ´åˆã®ã¿æŠ¼ã—æˆ»ã— (ãƒãƒ¼ã‚¸ãƒ³ã¯å«ã‚ãªã„)
	if (penetrationDepth > 0.0f) {
		float moveA = penetrationDepth * (1.0f - pushBackRatio);
		float moveB = penetrationDepth * pushBackRatio;

		posA -= direction * moveA;
		posB += direction * moveB;

		sphereA->SetTranslate(posA);
		sphereB->SetTranslate(posB);
	}
}

///-------------------------------------------/// 
/// OBBã¨OBBã¨ã®è¡çªå‡¦ç†
///-------------------------------------------///
void ColliderCollision::OBBToOBBCollision(OBBCollider* obbA, OBBCollider* obbB, float pushBackRatio) {
	// ä½ç½®ã®å–å¾—
	Vector3 posA = obbA->GetTransform().translate;
	Vector3 posB = obbB->GetTransform().translate;

	// åˆ†é›¢è»¸åˆ¤å®šã‚’å®Ÿè¡Œ
	SATResult result = PerformSAT(obbA->GetOBB(), obbB->GetOBB());

	// è»¸ã®æ–¹å‘ã‚’ç¢ºèª(Aã‹ã‚‰Bã¸ã®ãƒ™ã‚¯ãƒˆãƒ«ã¨åŒã˜å‘ãã«ã™ã‚‹)
	Vector3 centerDiff = posB - posA;
	float centerDiffLength = Length(centerDiff);

	// ä¸­å¿ƒãŒé‡ãªã£ã¦ã„ã‚‹å ´åˆã®å‡¦ç†
	if (centerDiffLength < EPSILON) {
		// æœ€ã‚‚ä¿¡é ¼ã§ãã‚‹è»¸ã‚’ä½¿ç”¨(é€šå¸¸ã¯Yè»¸)
		result.axis = Vector3(0.0f, 1.0f, 0.0f);
	} else {
		// è»¸ã®å‘ãã‚’ä¸­å¿ƒé–“ãƒ™ã‚¯ãƒˆãƒ«ã«åˆã‚ã›ã‚‹
		if (Dot(result.axis, centerDiff) < 0.0f) {
			result.axis = -result.axis;
		}
	}

	// ãƒãƒ¼ã‚¸ãƒ³
	const float PushMargin = 0.5f;

	// ã‚ã‚Šè¾¼ã‚“ã§ã„ã‚‹å ´åˆã®ã¿æŠ¼ã—æˆ»ã— 
	if (result.depth > 0.0f) {
		// ãƒãƒ¼ã‚¸ãƒ³ã‚’è€ƒæ…®ã—ãŸèª¿æ•´æ·±åº¦
		float adjustDepth = result.depth * PushMargin;

		float moveAABB = adjustDepth * (1.0f - pushBackRatio);
		float moveOBB = adjustDepth * pushBackRatio;

		posA -= result.axis * moveAABB;
		posB += result.axis * moveOBB;

		obbA->SetTranslate(posA);
		obbB->SetTranslate(posB);
	}
}

///-------------------------------------------/// 
/// çƒã¨OBBã¨ã®è¡çªå‡¦ç†
///-------------------------------------------///
void ColliderCollision::SphereToOBBCollision(SphereCollider* sphere, OBBCollider* obb, float pushBackRatio) {
	Vector3 obbPos = obb->GetTransform().translate;
	Vector3 spherePos = sphere->GetTransform().translate;
	float sphereRadius = sphere->GetSphere().radius;

	// çƒä½“ã®ä¸­å¿ƒã‹ã‚‰OBBä¸Šã®æœ€ã‚‚è¿‘ã„ç‚¹ã‚’è¨ˆç®—
	Vector3 closestPoint = CalculateClosestPointOnOBB(spherePos, obb->GetOBB());
	Vector3 direction = spherePos - closestPoint;
	float distance = Length(direction);

	// æ–¹å‘ã®æ­£è¦åŒ–
	if (distance < EPSILON) {
		// OBBã®ä¸­å¿ƒã‹ã‚‰çƒã®ä¸­å¿ƒã¸ã®æ–¹å‘ã‚’ä½¿ç”¨
		direction = spherePos - obb->GetOBB().center;
		float centerDist = Length(direction);

		if (centerDist < EPSILON) {
			// å®Œå…¨ã«é‡ãªã£ã¦ã„ã‚‹å ´åˆã€ä¸Šæ–¹å‘ã«æŠ¼ã—å‡ºã™
			direction = Vector3(0.0f, 1.0f, 0.0f);
		} else {
			direction = Normalize(direction);
		}

		// å†…éƒ¨ã«ã„ã‚‹å ´åˆã€è·é›¢ã¯0ã¨ã—ã¦æ‰±ã†
		distance = 0.0f;
	} else {
		direction = Normalize(direction);
	}

	// ã‚ã‚Šè¾¼ã¿æ·±åº¦ã‚’è¨ˆç®—
	float penetrationDepth = sphereRadius - distance;

	// ã‚ã‚Šè¾¼ã‚“ã§ã„ã‚‹å ´åˆã®ã¿æŠ¼ã—æˆ»ã—
	if (penetrationDepth > 0.0f) {
		float moveSphere = penetrationDepth * pushBackRatio;
		float moveOBB = penetrationDepth * (1.0f - pushBackRatio);

		spherePos += direction * moveSphere;
		obbPos -= direction * moveOBB;

		sphere->SetTranslate(spherePos);
		obb->SetTranslate(obbPos);
	}
}

///-------------------------------------------/// 
/// çƒã¨AABBã¨ã®è¡çªå‡¦ç†
///-------------------------------------------///
void ColliderCollision::SphereToAABBCollision(SphereCollider* sphere, AABBCollider* aabb, float pushBackRatio) {
	Vector3 aabbPos = aabb->GetTransform().translate;
	Vector3 spherePos = sphere->GetTransform().translate;
	float sphereRadius = sphere->GetSphere().radius;

	// AABBä¸Šã®æœ€è¿‘ç‚¹è¨ˆç®—
	AABB aabbData = aabb->GetAABB();
	Vector3 closestPoint;
	closestPoint.x = std::clamp(spherePos.x, aabbData.min.x, aabbData.max.x);
	closestPoint.y = std::clamp(spherePos.y, aabbData.min.y, aabbData.max.y);
	closestPoint.z = std::clamp(spherePos.z, aabbData.min.z, aabbData.max.z);

	// çƒä½“ã®ä¸­å¿ƒã‹ã‚‰æœ€ã‚‚è¿‘ã„ç‚¹ã¸ã®æ–¹å‘
	Vector3 direction = spherePos - closestPoint;
	float distance = Length(direction);

	// æ–¹å‘ã®æ­£è¦åŒ–
	if (distance < EPSILON) {
		// çƒã®ä¸­å¿ƒãŒAABBå†…éƒ¨ã«ã‚ã‚‹å ´åˆ
		Vector3 aabbCenter = (aabbData.min + aabbData.max) * 0.5f;
		direction = spherePos - aabbCenter;
		float centerDist = Length(direction);

		if (centerDist < EPSILON) {
			direction = Vector3(0.0f, 1.0f, 0.0f);
		} else {
			direction = Normalize(direction);
		}

		// å†…éƒ¨ã«ã„ã‚‹å ´åˆã€è·é›¢ã¯0ã¨ã—ã¦æ‰±ã†
		distance = 0.0f;
	} else {
		direction = Normalize(direction);
	}

	// ã‚ã‚Šè¾¼ã¿æ·±åº¦ã‚’è¨ˆç®—
	float penetrationDepth = sphereRadius - distance;

	// ã‚ã‚Šè¾¼ã‚“ã§ã„ã‚‹å ´åˆã®ã¿æŠ¼ã—æˆ»ã—
	if (penetrationDepth > 0.0f) {
		float moveSphere = penetrationDepth * pushBackRatio;
		float moveAABB = penetrationDepth * (1.0f - pushBackRatio);

		spherePos += direction * moveSphere;
		aabbPos -= direction * moveAABB;

		sphere->SetTranslate(spherePos);
		aabb->SetTranslate(aabbPos);
	}
}

///-------------------------------------------/// 
/// AABBã¨OBBã¨ã®è¡çªå‡¦ç†
///-------------------------------------------///
void ColliderCollision::AABBToOBBCollision(AABBCollider* aabb, OBBCollider* obb, float pushBackRatio) {
	// AABBã‚’OBBã¨ã—ã¦æ‰±ã†
	OBB aabbAsOBB;
	AABB aabbData = aabb->GetAABB();
	aabbAsOBB.center = (aabbData.min + aabbData.max) * 0.5f;
	aabbAsOBB.halfSize = (aabbData.max - aabbData.min) * 0.5f;

	// è»¸ã¯å˜ä½è»¸
	aabbAsOBB.axis[0] = Vector3(1.0f, 0.0f, 0.0f);
	aabbAsOBB.axis[1] = Vector3(0.0f, 1.0f, 0.0f);
	aabbAsOBB.axis[2] = Vector3(0.0f, 0.0f, 1.0f);

	// SATã§è¡çªåˆ¤å®š
	SATResult result = PerformSAT(aabbAsOBB, obb->GetOBB());

	// ä½ç½®ã®å–å¾—
	Vector3 aabbPos = aabb->GetTransform().translate;
	Vector3 obbPos = obb->GetTransform().translate;

	// è»¸ã®æ–¹å‘ã‚’ç¢ºèª
	Vector3 centerDiff = obbPos - aabbPos;
	if (Dot(result.axis, centerDiff) < 0.0f) {
		result.axis = -result.axis;
	}

	// ãƒãƒ¼ã‚¸ãƒ³
	const float PushMargin = 0.5f;

	// ã‚ã‚Šè¾¼ã‚“ã§ã„ã‚‹å ´åˆã®ã¿æŠ¼ã—æˆ»ã— 
	if (result.depth > 0.0f) {
		// ãƒãƒ¼ã‚¸ãƒ³ã‚’è€ƒæ…®ã—ãŸèª¿æ•´æ·±åº¦
		float adjustDepth = result.depth * PushMargin;

		float moveAABB = adjustDepth * (1.0f - pushBackRatio);
		float moveOBB = adjustDepth * pushBackRatio;

		aabbPos -= result.axis * moveAABB;
		obbPos += result.axis * moveOBB;

		aabb->SetTranslate(aabbPos);
		obb->SetTranslate(obbPos);
	}
}

///-------------------------------------------/// 
/// åˆ†é›¢è»¸åˆ¤å®š(SAT)ã®å®Ÿè£…
///-------------------------------------------///
ColliderCollision::SATResult ColliderCollision::PerformSAT(const OBB& obbA, const OBB& obbB) {
	SATResult result;
	result.depth = FLT_MAX;
	result.axis = Vector3(0.0f, 1.0f, 0.0f); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè»¸

	// ãƒ†ã‚¹ãƒˆã™ã‚‹è»¸ã®ãƒªã‚¹ãƒˆ
	Vector3 testAxes[15];
	int axisCount = 0;

	// OBB Aã®3è»¸
	for (int i = 0; i < 3; ++i) {
		testAxes[axisCount++] = obbA.axis[i];
	}

	// OBB Bã®3è»¸
	for (int i = 0; i < 3; ++i) {
		testAxes[axisCount++] = obbB.axis[i];
	}

	// å¤–ç©ã«ã‚ˆã‚‹9è»¸
	for (int i = 0; i < 3; ++i) {
		for (int j = 0; j < 3; ++j) {
			Vector3 cross = Math::Cross(obbA.axis[i], obbB.axis[j]);
			float crossLength = Length(cross);

			// ã»ã¼å¹³è¡Œãªè»¸ã¯ã‚¹ã‚­ãƒƒãƒ—(å®‰å®šæ€§å‘ä¸Š)
			const float PARALLEL_THRESHOLD = 0.01f; // EPSILONã‚ˆã‚Šå¤§ãã„å€¤
			if (crossLength > PARALLEL_THRESHOLD) {
				testAxes[axisCount++] = cross / crossLength;
			}
		}
	}

	// æœ€å°ã®é‡ãªã‚Šã‚’æŒã¤è»¸ã‚’è¦‹ã¤ã‘ã‚‹
	//bool hasCollision = true;

	for (int i = 0; i < axisCount; ++i) {
		float overlap;
		if (!TestAxisOverlap(obbA, obbB, testAxes[i], overlap)) {
			// åˆ†é›¢è»¸ãŒè¦‹ã¤ã‹ã£ãŸ = è¡çªã—ã¦ã„ãªã„
			result.depth = 0.0f;
			return result;
		}

		// æœ€å°ã®é‡ãªã‚Šã‚’è¨˜éŒ²(ã‚ˆã‚Šå®‰å®šã—ãŸè»¸ã‚’é¸æŠ)
		if (overlap < result.depth) {
			result.depth = overlap;
			result.axis = testAxes[i];
		}
	}

	return result;
}

///-------------------------------------------/// 
/// è»¸ã¸ã®æŠ•å½±
///-------------------------------------------///
float ColliderCollision::ProjectOBBOntoAxis(const OBB& obb, const Vector3& axis) {
	// OBBã®å„è»¸ã®å¯„ä¸ã‚’è¨ˆç®—
	float projection = 0.0f;
	for (int i = 0; i < 3; ++i) {
		float extent = (i == 0) ? obb.halfSize.x : (i == 1) ? obb.halfSize.y : obb.halfSize.z;
		projection += extent * std::abs(Dot(obb.axis[i], axis));
	}
	return projection;
}

///-------------------------------------------/// 
/// è»¸ä¸Šã§ã®é‡ãªã‚Šãƒ†ã‚¹ãƒˆ
///-------------------------------------------///
bool ColliderCollision::TestAxisOverlap(const OBB& obbA, const OBB& obbB, const Vector3& axis, float& outOverlap) {
	// è»¸ãŒæ­£è¦åŒ–ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
	float axisLength = Length(axis);
	if (axisLength < EPSILON) {
		outOverlap = 0.0f;
		return true;  // ç„¡åŠ¹ãªè»¸ã¯è¡çªã¨ã¿ãªã™
	}
	Vector3 normalizedAxis = axis / axisLength;

	// å„OBBã®ä¸­å¿ƒã‚’è»¸ã«æŠ•å½±
	float centerA = Dot(obbA.center, normalizedAxis);
	float centerB = Dot(obbB.center, normalizedAxis);

	// å„OBBã®ç¯„å›²ã‚’è¨ˆç®—
	float radiusA = ProjectOBBOntoAxis(obbA, normalizedAxis);
	float radiusB = ProjectOBBOntoAxis(obbB, normalizedAxis);

	// ä¸­å¿ƒé–“ã®è·é›¢
	float distance = std::abs(centerB - centerA);

	// é‡ãªã‚Šåˆ¤å®š
	float totalRadius = radiusA + radiusB;

	// ãƒãƒ¼ã‚¸ãƒ³ä»˜ãåˆ¤å®š(å®‰å®šæ€§å‘ä¸Š)
	const float COLLISION_MARGIN = 0.0001f;
	if (distance > totalRadius + COLLISION_MARGIN) {
		return false;  // åˆ†é›¢ã—ã¦ã„ã‚‹
	}

	outOverlap = totalRadius - distance;
	return true;
}

///-------------------------------------------/// 
/// OBBä¸Šã®æœ€è¿‘ç‚¹è¨ˆç®—
///-------------------------------------------///
Vector3 ColliderCollision::CalculateClosestPointOnOBB(const Vector3& point, const OBB& obb) {
	Vector3 dir = point - obb.center;
	Vector3 closest = obb.center;

	// OBBç©ºé–“ã«ãŠã‘ã‚‹æœ€è¿‘ç‚¹ã‚’è¨ˆç®—
	for (int i = 0; i < 3; ++i) {
		float axisExtent = (i == 0) ? obb.halfSize.x : (i == 1) ? obb.halfSize.y : obb.halfSize.z;
		float dist = Dot(dir, obb.axis[i]);
		dist = std::clamp(dist, -axisExtent, axisExtent);
		closest += obb.axis[i] * dist;
	}

	return closest;
}

============================================================
File Path: Project/Engine/Collider/Collision/ColliderCollision.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/ColliderData.h"
#include "Math/sMath.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Collider;
class SphereCollider;
class AABBCollider;
class OBBCollider;

///=====================================================/// 
/// ColliderCollision
///=====================================================///
class ColliderCollision {
public:

	ColliderCollision() = default;
	~ColliderCollision() = default;

	/// <summary>
	/// 2ã¤ã®Collideré–“ã®è¡çªã‚’å‡¦ç†ã—ã¾ã™ã€‚è¡çªã«ã‚ˆã‚‹æŠ¼ã—æˆ»ã—ã‚„ä½ç½®èª¿æ•´ãªã©ã®ç‰©ç†çš„å¿œç­”ã‚’è¡Œã„ã¾ã™ã€‚
	/// ã‚ã‚Šè¾¼ã¿ã‚’è§£æ¶ˆã—ã€æ¥è§¦é¢ã«é…ç½®ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="colliderA">è¡çªã™ã‚‹æœ€åˆã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã€‚</param>
	/// <param name="colliderB">è¡çªã™ã‚‹2ç•ªç›®ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã€‚</param>
	/// <param name="pushBackRatio">Aã¨Bã®è³ªé‡æ¯”ã€‚0.0f~1.0fã®ç¯„å›²ã§ã€0.0fã¯Aã ã‘ãŒå‹•ã, 0.5fã¯ç­‰è³ªé‡, 1.0fã¯Bã ã‘ãŒå‹•ãã“ã¨ã‚’æ„å‘³ã—ã¾ã™ã€‚</param>
	void ProcessCollision(Collider* colliderA, Collider* colliderB, float pushBackRatio = 0.5f);

private:

	// å®šæ•°å®šç¾©
	const float EPSILON = 1e-6f;

	// OBBã®è¡çªæƒ…å ±
	struct SATResult {
		Vector3 axis;      // æœ€å°ä¾µå…¥æ·±åº¦ã®è»¸
		float depth;       // ä¾µå…¥æ·±åº¦
	};

private:

	/// <summary>
	/// ç•°ãªã‚‹ã‚¿ã‚¤ãƒ—ã®2ã¤ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼é–“ã®è¡çªã‚’å‡¦ç†ã—ã¾ã™ã€‚è¡çªå¿œç­”ã¯ ColliderType ã«åŸºã¥ã„ã¦æ±ºå®šã•ã‚Œã€å¿…è¦ã«å¿œã˜ã¦ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®çŠ¶æ…‹ï¼ˆä½ç½®ãƒ»é€Ÿåº¦ãªã©ï¼‰ã‚’å¤‰æ›´ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="colliderA">è¡çªå‡¦ç†ã®å¯¾è±¡ã¨ãªã‚‹æœ€åˆã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚é–¢æ•°ã¯ã“ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®çŠ¶æ…‹ã‚’å¤‰æ›´ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</param>
	/// <param name="colliderB">è¡çªå‡¦ç†ã®å¯¾è±¡ã¨ãªã‚‹2ç•ªç›®ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚å¿…è¦ã«å¿œã˜ã¦çŠ¶æ…‹ãŒå¤‰æ›´ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="typeA">colliderA ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’ç¤ºã™å€¤ã€‚è¡çªå¿œç­”ã®åˆ¤å®šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="typeB">colliderB ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¿ã‚¤ãƒ—ã‚’ç¤ºã™å€¤ã€‚è¡çªå¿œç­”ã®åˆ¤å®šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="pushBackRationA">colliderA ã«å¯¾ã—ã¦é©ç”¨ã™ã‚‹æŠ¼ã—æˆ»ã—æ¯”ç‡ã€‚å®Ÿè£…ã«ã‚ˆã‚Š 0.0ã€œ1.0 ã®ç¯„å›²ã§æ‰±ã‚ã‚Œã‚‹ã“ã¨ãŒæƒ³å®šã•ã‚Œã€å€¤ãŒå¤§ãã„ã»ã© colliderA ã‚’å¼·ãæŠ¼ã—æˆ»ã—ã¾ã™ï¼ˆæ­£ç¢ºãªæ„å‘³ã¯å®Ÿè£…ä¾å­˜ï¼‰ã€‚</param>
	void ProcessMixdeTypeCollision(Collider* colliderA, Collider* colliderB, ColliderType typeA, ColliderType typeB, float pushBackRationA);

	/// <summary>
	/// 2ã¤ã®çƒä½“ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼é–“ã®è¡çªåˆ¤å®šã¨è¡çªè§£æ±ºï¼ˆä½ç½®ã®æŠ¼ã—æˆ»ã—ãªã©ï¼‰ã‚’è¡Œã†é–¢æ•°ã€‚
	/// </summary>
	void SphereToSphereCollision(SphereCollider* sphereA, SphereCollider* sphereB, float pushBackRatio);

	/// <summary>
	/// 2ã¤ã®OBBï¼ˆå‘ãä»˜ãå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼é–“ã®è¡çªåˆ¤å®šã¨è¡çªå¿œç­”ï¼ˆæŠ¼ã—æˆ»ã—ï¼‰ã‚’è¡Œã„ã¾ã™ã€‚
	/// åˆ†é›¢è»¸åˆ¤å®š(SAT)ã‚’ä½¿ç”¨ã—ã¦æ­£ç¢ºãªè¡çªæ¤œå‡ºã‚’å®Ÿè£…ã€‚
	/// </summary>
	void OBBToOBBCollision(OBBCollider* obbA, OBBCollider* obbB, float pushBackRatio);

	/// <summary>
	/// çƒ (SphereCollider) ã¨ OBB (OBBCollider) ã®è¡çªã‚’åˆ¤å®šã—ã€è¡çªãŒã‚ã‚Œã°æŠ¼ã—æˆ»ã—ã‚’é©ç”¨ã™ã‚‹é–¢æ•°ã€‚
	/// </summary>
	void SphereToOBBCollision(SphereCollider* sphere, OBBCollider* obb, float pushBackRatio);

	/// <summary>
	/// çƒã¨è»¸å¹³è¡Œå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼ˆAABBï¼‰é–“ã®è¡çªåˆ¤å®šã¨è§£æ±ºã‚’è¡Œã†é–¢æ•°ã€‚
	/// </summary>
	void SphereToAABBCollision(SphereCollider* sphere, AABBCollider* aabb, float pushBackRatio);

	/// <summary>
	/// è»¸æ•´åˆ—å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ (AABB) ã¨å‘ãä»˜ã‘ã‚‰ã‚ŒãŸå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ (OBB) ã®è¡çªæ¤œå‡ºã¨è§£æ±ºã‚’è¡Œã„ã¾ã™ã€‚
	/// </summary>
	void AABBToOBBCollision(AABBCollider* aabb, OBBCollider* obb, float pushBackRatio);

	/// <summary>
	/// ä¸ãˆã‚‰ã‚ŒãŸç‚¹ã‹ã‚‰æœ€ã‚‚è¿‘ã„ã€æŒ‡å®šã•ã‚ŒãŸå‘ãä»˜ã‘ã‚‰ã‚ŒãŸå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ (OBB) ä¸Šã®ç‚¹ã‚’è¨ˆç®—ã—ã¦è¿”ã—ã¾ã™ã€‚
	/// </summary>
	Vector3 CalculateClosestPointOnOBB(const Vector3& point, const OBB& obb);

	// ===== OBBè¡çªæ¤œå‡ºç”¨ã®ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ===== //

	/// <summary>
	/// åˆ†é›¢è»¸åˆ¤å®š(SAT)ã§ä½¿ç”¨ã™ã‚‹è»¸ã¸ã®æŠ•å½±ã‚’è¨ˆç®—
	/// </summary>
	float ProjectOBBOntoAxis(const OBB& obb, const Vector3& axis);

	/// <summary>
	/// 2ã¤ã®OBBé–“ã§æŒ‡å®šã•ã‚ŒãŸè»¸ã«ãŠã‘ã‚‹é‡ãªã‚Šé‡ã‚’è¨ˆç®—
	/// </summary>
	bool TestAxisOverlap(const OBB& obbA, const OBB& obbB, const Vector3& axis, float& outOverlap);

	/// <summary>
	/// åˆ†é›¢è»¸åˆ¤å®šã‚’ä½¿ç”¨ã—ã¦OBBåŒå£«ã®è¡çªæƒ…å ±ã‚’å–å¾—
	/// </summary>
	SATResult PerformSAT(const OBB& obbA, const OBB& obbB);
};

============================================================
File Path: Project/Engine/Collider/OBBCollider.cpp
============================================================
#include "OBBCollider.h"
#include "Math/MatrixMath.h"
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void OBBCollider::Initialize() {
	type_ = ColliderType::OBB;

	obb_.center = object3d_->GetWorldTranslate();
	SetOBBAxisFromQuaternion(obb_, object3d_->GetWorldRotate());

	// Colliderã®åˆæœŸåŒ–
	Collider::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void OBBCollider::Update() {

	/// ===Object3Dã®æ›´æ–°=== ///
	object3d_->SetTranslate(transform_.translate);
	object3d_->SetRotate(transform_.rotate);
	object3d_->SetScale(transform_.scale);
	object3d_->SetColor(color_);

	//ã‚»ãƒ³ã‚¿ãƒ¼ã®ä½ç½®ã‚’æ›´æ–°
	obb_.center = object3d_->GetWorldTranslate();
	// å›è»¢ã«ã‚ˆã£ã¦OBBã®è»¸ã‚’æ›´æ–°
	SetOBBAxisFromQuaternion(obb_, object3d_->GetWorldRotate());

	// Colliderã®æ›´æ–°å‡¦ç†
	Collider::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void OBBCollider::Draw(BlendMode mode) {
	// Line
#ifdef _DEBUG
	// ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã¿æç”»
	line_->DrawOBB(obb_, lineColor_);

#endif // DEBUG

	// Colliderã®æç”»å‡¦ç†
	Collider::Draw(mode);
}

///-------------------------------------------/// 
/// æƒ…å ±
///-------------------------------------------///
void OBBCollider::Information() {
#ifdef USE_IMGUI
	Collider::Information();
	ImGui::Text("OBBInfo");
	ImGui::DragFloat3("Center", &obb_.center.x, 0.1f);
	ImGui::SliderFloat3("HalfSize", &obb_.halfSize.x, 0.1f, 10.0f);
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çªå‡¦ç†
///-------------------------------------------///
void OBBCollider::OnCollision(Collider* collider) { collider; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void OBBCollider::SetHalfSize(const Vector3& halfSize) {
	obb_.halfSize = halfSize;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
OBB OBBCollider::GetOBB() const {
	return obb_;
}

///-------------------------------------------/// 
/// Quaternionã‹ã‚‰OBBã®è»¸ã‚’è¨­å®š
///-------------------------------------------///
void OBBCollider::SetOBBAxisFromQuaternion(OBB& obb, const Quaternion& rotate) {
	// å›è»¢è¡Œåˆ—ã«å¤‰æ›
	Matrix4x4 rotMatrix = Math::MakeRotateQuaternionMatrix(rotate);

	// âœ… å„è»¸ã‚’è¡Œåˆ—ã®ã€Œåˆ—ãƒ™ã‚¯ãƒˆãƒ«ã€ã‹ã‚‰å–å¾—
	// Xè»¸ = ç¬¬0åˆ—
	obb.axis[0] = Vector3(
		rotMatrix.m[0][0],  // 1è¡Œç›®ã®0åˆ—ç›®
		rotMatrix.m[1][0],  // 2è¡Œç›®ã®0åˆ—ç›®
		rotMatrix.m[2][0]   // 3è¡Œç›®ã®0åˆ—ç›®
	);

	// Yè»¸ = ç¬¬1åˆ—
	obb.axis[1] = Vector3(
		rotMatrix.m[0][1],  // 1è¡Œç›®ã®1åˆ—ç›®
		rotMatrix.m[1][1],  // 2è¡Œç›®ã®1åˆ—ç›®
		rotMatrix.m[2][1]   // 3è¡Œç›®ã®1åˆ—ç›®
	);

	// Zè»¸ = ç¬¬2åˆ—
	obb.axis[2] = Vector3(
		rotMatrix.m[0][2],  // 1è¡Œç›®ã®2åˆ—ç›®
		rotMatrix.m[1][2],  // 2è¡Œç›®ã®2åˆ—ç›®
		rotMatrix.m[2][2]   // 3è¡Œç›®ã®2åˆ—ç›®
	);

	// å¿µã®ãŸã‚æ­£è¦åŒ–ï¼ˆå›è»¢è¡Œåˆ—ãŒæ­£ã—ã‘ã‚Œã°ä¸è¦ã ãŒã€å®‰å…¨ã®ãŸã‚ï¼‰
	obb.axis[0] = Normalize(obb.axis[0]);
	obb.axis[1] = Normalize(obb.axis[1]);
	obb.axis[2] = Normalize(obb.axis[2]);
}


============================================================
File Path: Project/Engine/Collider/OBBCollider.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Collider/Base/Collider.h"

///-------------------------------------------/// 
/// OBBCollider
///-------------------------------------------///
class OBBCollider : public Collider {
public:

    OBBCollider() = default;
	~OBBCollider() = default;

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    virtual void Initialize() override;

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    virtual void Update() override;

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    /// <param name="mode">æç”»ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã™ã‚‹BlendModeå€¤ã€‚æç”»ã®åˆæˆã‚„ãƒ–ãƒ¬ãƒ³ãƒ‰å‹•ä½œã‚’æ±ºå®šã—ã¾ã™ã€‚</param>
    virtual void Draw(BlendMode mode) override;

    /// <summary>
	/// ImGuiæƒ…å ±ã®æ›´æ–°
    /// </summary>
    virtual void Information()override;

public: /// ===è¡çª=== ///
    /// <summary>
    /// è¡çªå‡¦ç†
    /// </summary>
    /// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã® Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è¡çªå¯¾è±¡ã«é–¢ã™ã‚‹æƒ…å ±ã‚’è¡¨ã—ã¾ã™ã€‚</param>
    virtual void OnCollision(Collider* collider) override;

public: /// ===Setter=== ///
    // OBBã®è¨­å®š
	void SetHalfSize(const Vector3& halfSize);

public: /// ===Getter=== ///
	// OBBã®å–å¾—
    OBB GetOBB() const;

private:
    OBB obb_;

private:
    /// <summary>
    /// OBBã®Axisã‚’Quaternionã‹ã‚‰è¨­å®š
    /// </summary>
    /// <param name="obb">è»¸ã‚’è¨­å®šã™ã‚‹ OBB ã¸ã®å‚ç…§ã€‚é–¢æ•°å†…ã§ã“ã® OBB ã®è»¸ãŒæ›´æ–°ã•ã‚Œã¾ã™ã€‚</param>
    /// <param name="rotate">é©ç”¨ã™ã‚‹å›è»¢ã‚’è¡¨ã™ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã€‚OBB ã®è»¸è¨ˆç®—ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
    void SetOBBAxisFromQuaternion(OBB& obb, const Quaternion& rotate);
};



============================================================
File Path: Project/Engine/Collider/SphereCollider.cpp
============================================================
#include "SphereCollider.h"
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void SphereCollider::Initialize() {
	type_ = ColliderType::Sphere;
	sphere_.center = object3d_->GetWorldTranslate();

	// Colliderã®åˆæœŸåŒ–
	Collider::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void SphereCollider::Update() {
	
	/// ===Object3Dã®æ›´æ–°=== ///
	object3d_->SetTranslate(transform_.translate);
	object3d_->SetRotate(transform_.rotate);
	object3d_->SetScale(transform_.scale);
	object3d_->SetColor(color_);

	// Sphereã®ã‚»ãƒ³ã‚¿ãƒ¼åº§æ¨™ã‚’æ›´æ–°
	sphere_.center = object3d_->GetWorldTranslate();

	// Colliderã®æ›´æ–°å‡¦ç†
	Collider::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void SphereCollider::Draw(BlendMode mode) {

	// Line
#ifdef _DEBUG
	// ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã¿æç”»
	line_->DrawSphere(sphere_, lineColor_);

#endif // DEBUG

	// Colliderã®æç”»å‡¦ç†
	Collider::Draw(mode);
}

///-------------------------------------------/// 
/// æƒ…å ±
///-------------------------------------------///
void SphereCollider::Information() {
#ifdef USE_IMGUI
	Collider::Information();
	ImGui::Text("SphereInfo");
	ImGui::DragFloat("Radius", &sphere_.radius, 0.1f, 0.0f);
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çªå‡¦ç†
///-------------------------------------------///
void SphereCollider::OnCollision(Collider* collider) { collider; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void SphereCollider::SetRadius(const float& radius) { sphere_.radius = radius; }

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// Radius
Sphere SphereCollider::GetSphere() const {
	return sphere_;
}


============================================================
File Path: Project/Engine/Collider/SphereCollider.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Collider/Base/Collider.h"

///=====================================================/// 
/// SphereCollider
///=====================================================///
class SphereCollider : public Collider {
public:

	SphereCollider() = default;
	~SphereCollider() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	virtual void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚BlendMode å‹ã®å€¤ã§åˆæˆæ–¹æ³•ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	virtual void Draw(BlendMode mode) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®æ›´æ–°
	/// </summary>
	virtual void Information()override;

public: /// ===è¡çª=== ///
	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªå¯¾è±¡ã®ã‚³ãƒ©ã‚¤ãƒ€ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è¡çªã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æƒ…å ±ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	virtual void OnCollision(Collider* collider) override;

public: /// ===Setter=== ///
	// Sphereã®è¨­å®š
	void SetRadius(const float& radius);

public: /// ===Getter=== ///
	// Sphereã®å–å¾—
	Sphere GetSphere()const;

private:
	Sphere sphere_;
};



============================================================
File Path: Project/Engine/Core/ComPtr.h
============================================================
#pragma once
#include <wrl.h>

// ComPtrã®çœåŠ›
//NOTE:Microsoft::WRLã‚’çœåŠ›ã™ã‚‹
using namespace Microsoft::WRL;

============================================================
File Path: Project/Engine/Core/DXCommon.cpp
============================================================
#include "DXCommon.h"
#include "Engine/Core/Logger.h"
#include "Engine/Core/WinApp.h"
#include "Engine/System/Managers/RTVManager.h"
#include "Engine/System/Managers/DSVManager.h"

#include <algorithm>
#include <cassert>
#include <thread>
#include <timeapi.h>
#include <vector>
#include <format>

#ifdef USE_IMGUI
#include "imgui.h"
#include "imgui_impl_dx12.h"
#include "imgui_impl_win32.h"
#endif // USE_IMGUI

#pragma comment(lib, "d3d12.lib")
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "dxguid.lib")
#pragma comment(lib, "Winmm.lib")

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
DXCommon::~DXCommon() {
	commandQueue_.Reset();
	swapChain_.Reset();
	commandList_.Reset();
	commandAllocator_.Reset();
	fence_.Reset();
	swapChainResource_->Reset();
	backBuffers_.clear();
	device_.Reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void DXCommon::Initialize(
	WinApp* winApp, int32_t backBufferWidth, int32_t backBufferHeight) {
	// nullptrãƒã‚§ãƒƒã‚¯
	assert(winApp);

	// FPSå›ºå®šã®åˆæœŸåŒ–
	InitializeFixFPS();

	/* sleepã®åˆ†è§£èƒ½ã‚’ä¸Šã’ã¦ãŠã
	(ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¤ãƒãƒ¼ã®ã‚«ã‚¦ãƒ³ãƒˆæ•°ã‚’1ãƒŸãƒªç§’ã«ã™ã‚‹) */
	timeBeginPeriod(1);

	winApp_ = winApp;
	backBufferWidth_ = backBufferWidth;
	backBufferHeight_ = backBufferHeight;

	// ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼
	DebugLayer();

	// DXGIãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
	InitializeDXGIDevice();

	// ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘Š
	DebugInfo();

	// ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
	InitializeCommand();

	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆ
	CreateSwapChain();

	// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆ
	CreateFence();

	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ
	CreateViewport(backBufferWidth_, backBufferHeight_);

	// ã‚·ã‚¶ãƒ¼çŸ©å½¢
	CreateScissor(backBufferWidth_, backBufferHeight_);

	// DXCã®åˆæœŸåŒ–
	InitializeCompiler();
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
/// ===RenderTexture=== ///
void DXCommon::PreDrawRenderTexture(ID3D12Resource* resource) {
	// ãƒãƒªã‚¢ã®è¨­å®š
	barrierRenderTexture_.Transition.pResource = resource;
	barrierRenderTexture_.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierRenderTexture_.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrierRenderTexture_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
}
/// ===EffectTexture=== ///
void DXCommon::PreDrawEffectTexture(ID3D12Resource* resource) {
	// ãƒãƒªã‚¢ã®è¨­å®š
	barrierEffectTexture_.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrierEffectTexture_.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrierEffectTexture_.Transition.pResource = resource;
	barrierEffectTexture_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
}
/// ===ImGui=== ///
void DXCommon::PreDrawImGui(RTVManager* rtv) {
	// ã“ã‚Œã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	UINT backBufferIndex = swapChain_->GetCurrentBackBufferIndex();

	/* ///////////////////
		ã€€ ãƒãƒªã‚¢ã‚’å¼µã‚‹
	*/ ///////////////////
	// TransitionBarrierã®è¨­å®š
	// ä»Šå›ã®ãƒãƒªã‚¢ã¯Transition
	barrierSwapChain_.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;

	// Noneã«ã—ã¦ãŠã
	barrierSwapChain_.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;

	// ãƒãƒªã‚¢ã‚’å¼µã‚‹å¯¾è±¡ã®ãƒªã‚½ãƒ¼ã‚¹ã€‚ç¾åœ¨ã®ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã—ã¦è¡Œã†
	barrierSwapChain_.Transition.pResource = swapChainResource_[backBufferIndex].Get();

	// é·ç§»å‰(ç¾åœ¨)ã®ResourceState
	barrierSwapChain_.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;

	// é·ç§»å¾Œã®ResourceState
	barrierSwapChain_.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;

	// TransitionBarrierã‚’å¼µã‚‹
	commandList_->ResourceBarrier(1, &barrierSwapChain_);
	
	// RTVã®è¨­å®š
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandel = rtv->GetCPUDescriptorHandle(backBufferIndex);
	commandList_->OMSetRenderTargets(1, &rtvHandel, false, nullptr);
	// RTVã®ã‚¯ãƒªã‚¢
	const float clearColor[] = { 0.1f, 0.25f, 0.5f, 1.0f }; // é’è‰²ã£ã£ã½ã„è‰²ã€RGBAã®é †
	rtv->ClearRenderTargetView(commandList_.Get(), backBufferIndex, clearColor);
}

///-------------------------------------------/// 
/// ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
///-------------------------------------------///
void DXCommon::BeginCommand() {
	// ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	commandList_->RSSetViewports(1, &viewPort_); // viewportã‚’è¨­å®š
	commandList_->RSSetScissorRects(1, &scissorRect_); // scissorã‚’è¨­å®š
}


///-------------------------------------------/// 
/// ãƒãƒªã‚¢ã®çŠ¶æ…‹é·ç§»
///-------------------------------------------///
/// ===RenderTexture=== ///
void DXCommon::TransitionRenderTarget() {
	// ãƒªã‚½ãƒ¼ã‚¹ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
	assert(barrierRenderTexture_.Transition.pResource != nullptr);

	// é·ç§»å‰(ç¾åœ¨)ã®ResourceState
	barrierRenderTexture_.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	// é·ç§»å¾Œã®ResourceState
	barrierRenderTexture_.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
	// SubResourceã‚’æ˜ç¤ºçš„ã«è¨­å®š
	barrierRenderTexture_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	// TransitionBarrierã‚’å¼µã‚‹
	commandList_->ResourceBarrier(1, &barrierRenderTexture_);
}
/// ===EffectTexture=== ///
void DXCommon::TransitionEffectTexture() {
	// é·ç§»å‰(ç¾åœ¨)ã®ResourceState
	barrierEffectTexture_.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	// é·ç§»å¾Œã®ResourceState
	barrierEffectTexture_.Transition.StateAfter = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
	// SubResourceã‚’æ˜ç¤ºçš„ã«è¨­å®š
	barrierEffectTexture_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	// TransitionBarrierã‚’å¼µã‚‹
	commandList_->ResourceBarrier(1, &barrierEffectTexture_);
}

///-------------------------------------------/// 
/// æç”»å¾Œå‡¦ç†
///-------------------------------------------///
void DXCommon::PostDraw() {
	HRESULT hr;

	// RenderTargetã‹ã‚‰Presentã«ã™ã‚‹
	// RenderTexture
	barrierRenderTexture_.Transition.StateBefore = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
	barrierRenderTexture_.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrierRenderTexture_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

	// EffectTexture
	barrierEffectTexture_.Transition.StateBefore = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
	barrierEffectTexture_.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrierEffectTexture_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

	// SwapChain
	barrierSwapChain_.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrierSwapChain_.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
	barrierSwapChain_.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;

	// 3ã¤ã®ãƒãƒªã‚¢ã‚’ä¸€åº¦ã«å®Ÿè¡Œ
	D3D12_RESOURCE_BARRIER barriers[] = { 
		barrierRenderTexture_, 
		barrierEffectTexture_, 
		barrierSwapChain_ 
	};
	commandList_->ResourceBarrier(3, barriers);

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹
	hr = commandList_->Close();
	assert(SUCCEEDED(hr));

	// GPUã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œ
	ID3D12CommandList* commandList[] = { commandList_.Get() };
	commandQueue_->ExecuteCommandLists(1, commandList); // ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ã‚­ãƒƒã‚¯

	//GPUã¨OSã«ç”»é¢ã®äº¤æ›ã‚’è¡Œã†ã‚ˆã†ã«é€šçŸ¥ã™ã‚‹
	swapChain_->Present(1, 0); // ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ãƒãƒƒãƒ•ã‚¡ã‚’è¡¨ç¤º

	// GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸã¨ãã«ã€Fenceã®å½“ãŸå€¤ã‚’æŒ‡å®šã—ãŸå€¤ã«ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
	commandQueue_->Signal(fence_.Get(), ++fenceValue_); // ãƒ•ã‚§ãƒ³ã‚¹ã‚’æ›´æ–°

	// Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
	// GetCompletedValueã®åˆæœŸå€¤ã¯Fenceä½œæˆæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
	if (fence_->GetCompletedValue() < fenceValue_) {

		// Fenceã®Signalã‚’å¾…ã¤ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
		HANDLE fenceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		assert(fenceEvent != nullptr); // ã‚¤ãƒ™ãƒ³ãƒˆã®ä½œæˆãŒæˆåŠŸã—ãŸã‹ç¢ºèª

		// æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šç€ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
		fence_->SetEventOnCompletion(fenceValue_, fenceEvent); // ãƒ•ã‚§ãƒ³ã‚¹ã®ã‚·ã‚°ãƒŠãƒ«è¨­å®š

		// ã‚¤ãƒ™ãƒ³ãƒˆå¾…ã¤
		WaitForSingleObject(fenceEvent, INFINITE); // æŒ‡å®šã®ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚·ã‚°ãƒŠãƒ«çŠ¶æ…‹ã«ãªã‚‹ã¾ã§å¾…æ©Ÿ

		//ã‚¤ãƒ™ãƒ³ãƒˆã®è§£æ”¾
		CloseHandle(fenceEvent); // ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ«ã®è§£æ”¾
	}

	// FPSå›ºå®š
	UpdateFixFPS(); // ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆã‚’å›ºå®šã™ã‚‹å‡¦ç†

	// æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
	hr = commandAllocator_->Reset(); // ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
	assert(SUCCEEDED(hr)); // ãƒªã‚»ãƒƒãƒˆãŒæˆåŠŸã—ãŸã‹ç¢ºèª
	hr = commandList_->Reset(commandAllocator_.Get(), nullptr); // æ–°ã—ã„ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
	assert(SUCCEEDED(hr)); // ãƒªã‚»ãƒƒãƒˆãŒæˆåŠŸã—ãŸã‹ç¢ºèª
}

///-------------------------------------------/// 
/// DescriptorHeapã®ç”Ÿæˆ
///-------------------------------------------///
ComPtr<ID3D12DescriptorHeap> DXCommon::CreateDescriptorHeap(
	D3D12_DESCRIPTOR_HEAP_TYPE heapType, UINT numDescriptors, bool shaderVisible) {
	ComPtr<ID3D12DescriptorHeap> descriptorHeap = nullptr;
	D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc{};
	descriptorHeapDesc.Type = heapType;
	descriptorHeapDesc.NumDescriptors = numDescriptors;
	descriptorHeapDesc.Flags = shaderVisible ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	HRESULT hr = device_->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&descriptorHeap));
	assert(SUCCEEDED(hr));
	hr;
	return descriptorHeap;
}
///-------------------------------------------/// 
/// DescriptorSizeã®å–å¾—
///-------------------------------------------///
const uint32_t DXCommon::GetRTVDescriptorSize() { return device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV); }
const uint32_t DXCommon::GetDSVDescriptorSize() { return device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV); }
const uint32_t DXCommon::GetSRVDescriptorSize() { return device_->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV); }

///-------------------------------------------/// 
/// ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼
///-------------------------------------------///
void DXCommon::DebugLayer() {
	ComPtr<ID3D12Debug1> debugController = nullptr;
	if ((SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController))))) {

		// ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æœ‰åŠ¹åŒ–
		debugController->EnableDebugLayer();

		// ã•ã‚‰ã«GPUå´ã§ã‚‚ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ã‚ˆã†ã«ã™ã‚‹
		debugController->SetEnableGPUBasedValidation(TRUE);
	}
}

///-------------------------------------------/// 
/// ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘Š
///-------------------------------------------///
void DXCommon::DebugInfo() {
	ComPtr<ID3D12InfoQueue> infoQueue = nullptr;
	if (SUCCEEDED(device_->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {

		// ã‚„ã°ã„ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);

		// ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);

		// è­¦å‘Šæ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);

		// è§£æ”¾
		//infoQueue->Release();

		/// *****************************************************
		/// ã‚¨ãƒ©ãƒ¼ã¨è­¦å‘Šã®æŠ‘åˆ¶
		/// *****************************************************
		// æŠ‘åˆ¶ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		D3D12_MESSAGE_ID denyIds[] = {
			// Windows11ã§ã®DXGIãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨DX12ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¸äº’ä½œç”¨ãƒã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
			// https:/stackoverflow.com/questions/69805245/DirectX-12-application-is-crashing-in-windows11
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE
		};

		// æŠ‘åˆ¶ã™ã‚‹ãƒ¬ãƒ™ãƒ«
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;

		// æŒ‡å®šã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºã‚’æŠ‘åˆ¶ã™ã‚‹
		infoQueue->PushStorageFilter(&filter);
	}
}

///-------------------------------------------/// 
/// DXGIãƒ‡ãƒã‚¤ã‚¹åˆæœŸåŒ–
///-------------------------------------------///
void DXCommon::InitializeDXGIDevice() {

	/* /////////////////////////////////////////////////////
						DirectX12ã®åˆæœŸåŒ–
	*/ /////////////////////////////////////////////////////
	// HEWSULTã¯Windowsç³»ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Šã€
	// é–¢æ•°ãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’SUCCEEDEDãƒã‚¯ãƒ­ã§åˆ¤æ–­ã§ãã‚‹
	HRESULT hr = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory_));

	// åˆæœŸåŒ–ã®æ ¹æœ¬çš„ãªéƒ¨åˆ†ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸå ´åˆã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–“é•ã£ã¦ã„ã‚‹ã‹ã€
	// ã©ã†ã«ã‚‚ã§ããªã„å ´åˆãŒå¤šã„ã®ã§Assertã«ã—ã¦ãŠã
	assert(SUCCEEDED(hr));

	// ä½¿ç”¨ã™ã‚‹ã‚¢ãƒ€ãƒ—ã‚¿ç”¨ã®å¤‰æ•°
	ComPtr<IDXGIAdapter4> useAdapter = nullptr;

	//è‰¯ã„é †ã«ã‚¢ãƒ€ãƒ—ã‚¿ã‚’é ¼ã‚€
	for (UINT i = 0; dxgiFactory_->EnumAdapterByGpuPreference(
		i, DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(&useAdapter)) != DXGI_ERROR_NOT_FOUND; ++i) {

		//ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
		DXGI_ADAPTER_DESC3 adapterDesc{};
		hr = useAdapter->GetDesc3(&adapterDesc);
		assert(SUCCEEDED(hr)); // å–å¾—ã§ããªã„ã®ã¯ä¸€å¤§äº‹

		//  ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ã§ãªã‘ã‚Œã°æ¡ç”¨ï¼
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE)) {

			// æ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ã®æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ›ã€‚wstringã®æ–¹ãªã®ã§æ³¨æ„
			Log(std::format(L"Use Adapter:{}\n", adapterDesc.Description));
			break;
		}

		useAdapter = nullptr;
	}

	// é©åˆ‡ãªã‚¢ãƒ€ãƒ—ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(useAdapter != nullptr);

	// å¯¾å¿œãƒ¬ãƒ™ãƒ«ã®é…åˆ—
	D3D_FEATURE_LEVEL levels[] = {
		D3D_FEATURE_LEVEL_12_2, D3D_FEATURE_LEVEL_12_1, D3D_FEATURE_LEVEL_12_0
	};

	const char* featureLevelStrings[] = {
		"12.2", "12.1", "12.0"
	};

	//é«˜ã„é †ã«ç”Ÿæˆã§ãã‚‹ã‹è©¦ã—ã¦ã¿ã‚‹
	for (size_t i = 0; i < _countof(levels); ++i) {

		//æ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
		hr = D3D12CreateDevice(useAdapter.Get(), levels[i], IID_PPV_ARGS(&device_));

		// æŒ‡å®šã—ãŸæ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã§ãƒ‡ãƒã‚¤ã‚¹ãŒç”Ÿæˆã§ããŸã‹ã‚’ç¢ºèª	
		if (SUCCEEDED(hr)) {
			//
			Log(std::format("FeatureLevel : {}\n", featureLevelStrings[i]));
			break;
		}
	}

	//åˆæœŸåŒ–å®Œäº†ã®ãƒ­ã‚°ã‚’å‡ºã™
	assert(device_ != nullptr);
	Log("Complete create D3D12Device!!!\n");

#ifdef _DEBUG
	/* /////////////////////////////////////////////////////
						ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘Šã€å³ã¡åœæ­¢
	*/ /////////////////////////////////////////////////////
	ComPtr<ID3D12InfoQueue> infoQueue = nullptr;
	if (SUCCEEDED(device_->QueryInterface(IID_PPV_ARGS(&infoQueue)))) {

		// ã‚„ã°ã„ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);

		// ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);

		// è­¦å‘Šæ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);

		/* /////////////////////////////////////////////////////
							ã‚¨ãƒ©ãƒ¼ã¨è­¦å‘Šã®æŠ‘åˆ¶
		*/ /////////////////////////////////////////////////////
		// æŠ‘åˆ¶ã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		D3D12_MESSAGE_ID denyIds[] = {
			// Windows11ã§ã®DXGIãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨DX12ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¸äº’ä½œç”¨ãƒã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
			// https:/stackoverflow.com/questions/69805245/DirectX-12-application-is-crashing-in-windows11
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_MISMATCHING_COMMAND_LIST_TYPE
		};

		// æŠ‘åˆ¶ã™ã‚‹ãƒ¬ãƒ™ãƒ«
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;

		// æŒ‡å®šã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®è¡¨ç¤ºã‚’æŠ‘åˆ¶ã™ã‚‹
		infoQueue->PushStorageFilter(&filter);
	}
#endif
}

///-------------------------------------------/// 
/// ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
///-------------------------------------------///
void DXCommon::InitializeCommand() {
	HRESULT hr;

	// ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã®ç”Ÿæˆ
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};
	hr = device_->CreateCommandQueue(
		&commandQueueDesc, IID_PPV_ARGS(&commandQueue_));
	assert(SUCCEEDED(hr));

	// ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ã®ç”Ÿæˆ
	hr = device_->CreateCommandAllocator(
		D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator_));
	assert(SUCCEEDED(hr));

	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ç”Ÿæˆ
	hr = device_->CreateCommandList(
		0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator_.Get(), nullptr, IID_PPV_ARGS(&commandList_));
	assert(SUCCEEDED(hr));
}

///-------------------------------------------/// 
/// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆ
///-------------------------------------------///
void DXCommon::CreateSwapChain() {
	HRESULT hr;

	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã‚’ç”Ÿæˆã™ã‚‹
	swapChainDesc_.Width = backBufferWidth_;      // ç”»é¢ã®å¹…ã€‚ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc_.Height = backBufferHeight_;     // ç”»é¢ã®é«˜ã•ã€‚ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc_.Format = DXGI_FORMAT_R8G8B8A8_UNORM; // è‰²ã®å½¢å¼
	swapChainDesc_.SampleDesc.Count = 1;  // ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã—ãªã„
	swapChainDesc_.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT; // æç”»ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦åˆ©ç”¨ã™ã‚‹
	swapChainDesc_.BufferCount = 2;  // ãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡
	swapChainDesc_.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;  // ãƒ¢ãƒ‹ã‚¿ã«ç§»ã—ãŸã‚‰ã€ä¸­èº«ã‚’ç ´æ£„
	swapChainDesc_.Scaling = DXGI_SCALING_NONE;	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ä¼¸ç¸®

	// ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã€è¨­å®šã‚’æ¸¡ã—ã¦ç”Ÿæˆã™ã‚‹
	hr = dxgiFactory_->CreateSwapChainForHwnd(
		commandQueue_.Get(), winApp_->GetHwnd(), &swapChainDesc_,
		nullptr, nullptr, reinterpret_cast<IDXGISwapChain1**>(swapChain_.GetAddressOf()));
	assert(SUCCEEDED(hr));

	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã‹ã‚‰Resourceã‚’å¼•ã£å¼µã£ã¦ãã‚‹
	hr = swapChain_->GetBuffer(0, IID_PPV_ARGS(&swapChainResource_[0]));

	// ã†ã¾ãå–å¾—ã§ããªã‘ã‚Œã°èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
	hr = swapChain_->GetBuffer(1, IID_PPV_ARGS(&swapChainResource_[1]));
	assert(SUCCEEDED(hr));
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆ
///-------------------------------------------///
void DXCommon::CreateFence() {
	HRESULT hr;

	// åˆæœŸå€¤0ã§Fenceã‚’ä½œã‚‹
	hr = device_->CreateFence(fenceValue_, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(&fence_));
	assert(SUCCEEDED(hr));
}

///-------------------------------------------/// 
/// DXCã®åˆæœŸåŒ–
///-------------------------------------------///
void DXCommon::InitializeCompiler() {
	HRESULT hr;

	// dxcUtils
	hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(&dxcUtils_));
	assert(SUCCEEDED(hr));

	// dxcCompiler
	hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(&dxcCompiler_));
	assert(SUCCEEDED(hr));

	// IncludeHandler
	hr = dxcUtils_->CreateDefaultIncludeHandler(&includeHandler_);
	assert(SUCCEEDED(hr));
}

///-------------------------------------------/// 
/// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ
///-------------------------------------------///
void DXCommon::CreateViewport(const int32_t kClientWindth, const int32_t kClientHeight) {

	// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®ã‚µã‚¤ã‚ºã¨ä¸€ç·’ã«ã—ã¦ç”»é¢å…¨ä½“ã«è¡¨ç¤º
	viewPort_.Width = float(kClientWindth);
	viewPort_.Height = float(kClientHeight);
	viewPort_.TopLeftX = 0;
	viewPort_.TopLeftY = 0;
	viewPort_.MinDepth = 0.0f;
	viewPort_.MaxDepth = 1.0f;
}

///-------------------------------------------/// 
/// ã‚·ã‚¶ãƒ¼çŸ©å½¢
///-------------------------------------------///
void DXCommon::CreateScissor(const int32_t kClientWindth, const int32_t kClientHeight) {

	// åŸºæœ¬çš„ã«ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨åŒã˜çŸ©å½¢ãŒæ§‹æˆã•ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹
	scissorRect_.left = 0;
	scissorRect_.right = kClientWindth;
	scissorRect_.top = 0;
	scissorRect_.bottom = kClientHeight;
}

///-------------------------------------------/// 
/// FPSå›ºå®šã®åˆæœŸåŒ–
///-------------------------------------------///
void DXCommon::InitializeFixFPS() {

	// ç¾åœ¨ã®æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();
}

///-------------------------------------------/// 
/// FPSå›ºå®šã®æ›´æ–°
///-------------------------------------------///
void DXCommon::UpdateFixFPS() {

	// 1/60ç§’ãƒ”ãƒƒã‚¿ãƒªã®æ™‚é–“
	const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 60.0f));

	// 1/60ç§’ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“
	const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 65.0f));

	// ç¾åœ¨ã®æ™‚é–“ã‚’å–å¾—
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();

	// å‰å›ã®è¨˜éŒ²ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::microseconds elapsed =
		std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

	// 1/60ç§’(ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“)çµŒã£ã¦ã„ãªã„å ´åˆ
	if (elapsed < kMinTime) {
		// 1/60ç§’çµŒéã™ã‚‹ã¾ã§å¾®å°ãªã‚¹ãƒªãƒ¼ãƒ—ã‚’ç¹°ã‚Šè¿”ã™
		while (std::chrono::steady_clock::now() - reference_ < kMinTime) {
			// 1ãƒã‚¤ã‚¯ãƒ­ç§’ã‚¹ãƒªãƒ¼ãƒ—
			std::this_thread::sleep_for(std::chrono::microseconds(1));
		}
	}

	// ç¾åœ¨ã®æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ¨ªå¹…ã®å–å¾—
int32_t DXCommon::GetBackBufferWidth() const { return backBufferWidth_; }
// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç¸¦å¹…ã®å–å¾—
int32_t DXCommon::GetBackBufferHeight() const { return backBufferHeight_; }
// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ•°ã‚’å–å¾—
size_t DXCommon::GetBackBufferCount() const { return swapChainDesc_.BufferCount; }
// DXGFactoryã®å–å¾—
IDXGIFactory7* DXCommon::GetDXGFactory() const { return dxgiFactory_.Get(); }
// ãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—
ID3D12Device* DXCommon::GetDevice() const { return device_.Get(); }
// dxcUtilsã®å–å¾—
IDxcUtils* DXCommon::GetDxcUtils() const { return dxcUtils_.Get(); }
//  dxcCompilerã®å–å¾—
IDxcCompiler3* DXCommon::GetDxcCompiler() const { return dxcCompiler_.Get(); }
// IncludeHandlerã®å–å¾—
IDxcIncludeHandler* DXCommon::GetIncludeHandler() const { return includeHandler_.Get(); }
// æç”»ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å–å¾—
ID3D12GraphicsCommandList* DXCommon::GetCommandList() const { return commandList_.Get(); }
// SwapChainã®å–å¾—
UINT DXCommon::GetBackBufferIndex() const { return swapChain_->GetCurrentBackBufferIndex(); }
// SwapChainResourceã®å–å¾—
ID3D12Resource* DXCommon::GetSwapChainResource(uint32_t index) const {
	assert(index < 2);
	return swapChainResource_[index].Get(); 
}
// CPUã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾— 
D3D12_CPU_DESCRIPTOR_HANDLE DXCommon::GetCPUDescriptorHandle(
	const ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index) {

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å…ˆé ­ã‚’å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize * index);

	return handleCPU;
}
// GPUã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
D3D12_GPU_DESCRIPTOR_HANDLE DXCommon::GetGPUDescriptorHandle(
	const ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index) {

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å…ˆé ­ã‚’å–å¾—
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize * index);

	return handleGPU;
}

============================================================
File Path: Project/Engine/Core/DXCommon.h
============================================================
#pragma once
/// ====Include== ///
// Engine
#include "Engine/Core/ComPtr.h"
// DirectX
#include <d3d12.h>
#include <dxgi1_6.h>
#include <dxcapi.h>
// c++
#include <cstdlib>
#include <chrono>
#include <wrl.h>

#pragma comment(lib, "dxcompiler.lib")

/// ===å‰æ–¹å®£è¨€=== ///
class WinApp;
class RTVManager;
class DSVManager;

///=====================================================/// 
/// DirectXæ±ç”¨
///=====================================================///
class DXCommon {
public:

	DXCommon() = default;
	~DXCommon();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="winApp">åˆæœŸåŒ–å¯¾è±¡ã® WinApp ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="backBufferWidth">ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚</param>
	/// <param name="backBufferHeight">ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®é«˜ã•ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚</param>
	void Initialize(WinApp* winApp, int32_t backBufferWidth, int32_t backBufferHeight);

	/// <summary>
	/// RenderTextureã¸ã®æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="resource">æº–å‚™å¯¾è±¡ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¡¨ã™ ID3D12Resource ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã“ã¨ãŒæƒ³å®šã•ã‚Œã¾ã™ã€‚</param>
	void PreDrawRenderTexture(ID3D12Resource* resource);

	/// <summary>
	/// ãƒãƒªã‚¢ã®çŠ¶æ…‹é·ç§»
	/// </summary>
	void TransitionRenderTarget();

	/// <summary>
	/// EffectTextureã¸ã®æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="resource">æº–å‚™å¯¾è±¡ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¡¨ã™ ID3D12Resource ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void PreDrawEffectTexture(ID3D12Resource* resource);

	/// <summary>
	/// EffectTextureã®ãƒãƒªã‚¢çŠ¶æ…‹é·ç§»
	/// </summary>
	void TransitionEffectTexture();

	/// <summary>
	/// SwapChainã¸ã®æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="rtv">RTVManager å‹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ï¼ˆRTVï¼‰ã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã¨ã—ã¦ä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	void PreDrawImGui(RTVManager* rtv);

	/// <summary>
	/// ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	/// </summary>
	void BeginCommand();

	

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	void PostDraw();

	/// <summary>
	/// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	/// </summary>
	/// <param name="heapType">ä½œæˆã™ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç¨®é¡ï¼ˆD3D12_DESCRIPTOR_HEAP_TYPEï¼‰ã€‚</param>
	/// <param name="numDescriptors">ãƒ’ãƒ¼ãƒ—ã«å«ã‚ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ï¼ˆUINTï¼‰ã€‚</param>
	/// <param name="shaderVisible">true ã®å ´åˆã€ãƒ’ãƒ¼ãƒ—ã¯ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ï¼ˆGPU å¯è¦–ï¼‰ã«ãªã‚Šã¾ã™ã€‚false ã®å ´åˆã¯ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‹ã‚‰ã¯ã‚¢ã‚¯ã‚»ã‚¹ã§ãã¾ã›ã‚“ã€‚</param>
	/// <returns>ä½œæˆã•ã‚ŒãŸID3D12DescriptorHeapã¸ã®ComPtrã€‚ä½œæˆã«å¤±æ•—ã—ãŸå ´åˆã¯ç©ºã®ComPtrãŒè¿”ã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	ComPtr<ID3D12DescriptorHeap> CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE heapType, UINT numDescriptors, bool shaderVisible);

	/// ===DescriptorSizeã®å–å¾—=== ///
	const uint32_t GetRTVDescriptorSize(); // RTV
	const uint32_t GetDSVDescriptorSize(); // DSV
	const uint32_t GetSRVDescriptorSize(); // SRV

public:/// ===Getter=== ///
	// DXGFactoryã®å–å¾—
	IDXGIFactory7* GetDXGFactory()const;
	// ãƒ‡ãƒã‚¤ã‚¹ã®å–å¾—
	ID3D12Device* GetDevice()const;
	// DxcUtilsã®å–å¾—
	IDxcUtils* GetDxcUtils()const;
	// DxcCompilerã®å–å¾—
	IDxcCompiler3* GetDxcCompiler()const;
	// IncludeHandlerã®å–å¾—
	IDxcIncludeHandler* GetIncludeHandler()const;
	// æç”»ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å–å¾—
	ID3D12GraphicsCommandList* GetCommandList()const;
	// BackVBufferIndexã®å–å¾—
	UINT GetBackBufferIndex()const;
	// SwapChainResourceã®å–å¾—
	ID3D12Resource* GetSwapChainResource(uint32_t index)const;
	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ¨ªå¹…ã®å–å¾—
	int32_t GetBackBufferWidth()const;
	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç¸¦å¹…ã®å–å¾—
	int32_t GetBackBufferHeight()const;
	// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ•°ã‚’å–å¾—
	size_t GetBackBufferCount()const;
	// CPUã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	// <param name="descriptorHeap">ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã¸ã®å‚ç…§ã€‚ID3D12DescriptorHeap ã® ComPtrã€‚</param>
	// <param name="descriptorSize">ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ 1 ã¤åˆ†ã®ã‚µã‚¤ã‚º (ãƒã‚¤ãƒˆå˜ä½)ã€‚</param>
	// <param name="index">å–å¾—ã™ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</param>
	// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹ D3D12_CPU_DESCRIPTOR_HANDLE ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(
		const ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index);
	// GPUã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	// <param name="descriptorHeap">ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã¸ã®å‚ç…§ã€‚ID3D12DescriptorHeap ã® ComPtrã€‚</param>
	// <param name="descriptorSize">ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ 1 ã¤åˆ†ã®ã‚µã‚¤ã‚º (ãƒã‚¤ãƒˆå˜ä½)ã€‚</param>
	// <param name="index">å–å¾—ã™ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</param>
	// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹ D3D12_GPU_DESCRIPTOR_HANDLE ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(
		const ComPtr<ID3D12DescriptorHeap> descriptorHeap, uint32_t descriptorSize, uint32_t index);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚ºã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ç®¡ç†
	WinApp* winApp_;

	/* //////////////////
		ã€€Direct3Dé–¢é€£
	*/ //////////////////
	ComPtr<IDXGIFactory7> dxgiFactory_; // DXGIFactory
	ComPtr<ID3D12Device> device_; // D3D12Device
	ComPtr<IDxcUtils> dxcUtils_; // DxcUtils
	ComPtr<IDxcCompiler3> dxcCompiler_; // DxcCompiler
	ComPtr<IDxcIncludeHandler> includeHandler_; // includeHandler

	/// ===command=== ///
	ComPtr<ID3D12GraphicsCommandList> commandList_; // CommandList
	ComPtr<ID3D12CommandAllocator> commandAllocator_; // CommandAllocator
	ComPtr<ID3D12CommandQueue> commandQueue_; // CommandQueue

	/// ===swapChain=== ///
	ComPtr<IDXGISwapChain4> swapChain_; // SwapChain
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc_{};
	ComPtr<ID3D12Resource> swapChainResource_[2];

	/// ===backBuffer=== ///
	std::vector<ComPtr<ID3D12Resource>> backBuffers_; // BackBuffer

	/// ===fence=== ///
	ComPtr<ID3D12Fence> fence_; // Fence
	uint64_t fenceValue_ = 0;  // FenceValue

	/// ===ãƒãƒªã‚¢=== ///
	D3D12_RESOURCE_BARRIER barrierRenderTexture_{};
	D3D12_RESOURCE_BARRIER barrierEffectTexture_{};
	D3D12_RESOURCE_BARRIER barrierSwapChain_{};

	/// ===FPSå›ºå®š=== ///
	std::chrono::steady_clock::time_point reference_; // è¨˜éŒ²æ™‚é–“(FPSå›ºå®šç”¨)

	/// ===viewPort=== ///
	D3D12_VIEWPORT viewPort_; // ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆ

	/// ===scissor=== ///
	D3D12_RECT scissorRect_; // ã‚·ã‚¶ãƒ¼çŸ©å½¢

	/// ===backBufferSize=== ///
	int32_t backBufferWidth_ = 0;
	int32_t backBufferHeight_ = 0;

private:/// ===é–¢æ•°=== ///

	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼
	/// </summary>
	void DebugLayer();

	/// <summary>
	/// ã‚¨ãƒ©ãƒ¼ãƒ»è­¦å‘Š
	/// </summary>
	void DebugInfo();

	/// <summary>
	/// DXGIãƒ‡ãƒã‚¤ã‚¹åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void InitializeDXGIDevice();

	/// <summary>
	/// ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void InitializeCommand();

	/// <summary>
	/// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	void CreateSwapChain();

	/// <summary>
	/// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	void CreateFence();

	/// <summary>
	/// DXCã®åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void InitializeCompiler();

	/// <summary>
	/// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="kClientWidth">ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰ã€‚</param>
	/// <param name="kClientHeight">ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®é«˜ã•ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰ã€‚</param>
	void CreateViewport(const int32_t kClientWidth, const int32_t kClientHeight);

	/// <summary>
	/// ã‚·ã‚¶ãƒ¼çŸ©å½¢ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="kClientWidth">ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®å¹…ï¼ˆint32_tã€ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚é–¢æ•°å†…ã§ä½¿ç”¨ã•ã‚Œã‚‹èª­ã¿å–ã‚Šå°‚ç”¨ã®å€¤ã§ã™ã€‚</param>
	/// <param name="kClientHeight">ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®é«˜ã•ï¼ˆint32_tã€ãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚é–¢æ•°å†…ã§ä½¿ç”¨ã•ã‚Œã‚‹èª­ã¿å–ã‚Šå°‚ç”¨ã®å€¤ã§ã™ã€‚</param>
	void CreateScissor(const int32_t kClientWidth, const int32_t kClientHeight);

	/// <summary>
	/// FPSå›ºå®šã®åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void InitializeFixFPS();

	/// <summary>
	/// FPSå›ºå®šã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateFixFPS();
};


============================================================
File Path: Project/Engine/Core/Logger.cpp
============================================================
#include "Logger.h"

///-------------------------------------------/// 
/// å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ–‡å­—è¡¨ç¤º
///-------------------------------------------///
void Log(const std::string& message) {

	OutputDebugStringA(message.c_str());
}

///-------------------------------------------/// 
/// å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ–‡å­—è¡¨ç¤º
///-------------------------------------------///
void Log(const std::wstring& message) {

	OutputDebugStringW(message.c_str());
}

///-------------------------------------------/// 
/// string->wstringã«å¤‰æ›
///-------------------------------------------///
std::wstring ConvertString(const std::string& str) {

	if (str.empty()) {
		return std::wstring();
	}

	auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
	if (sizeNeeded == 0) {
		return std::wstring();
	}
	std::wstring result(sizeNeeded, 0);
	MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
	return result;
}

///-------------------------------------------/// 
/// wstring->stringã«å¤‰æ›
///-------------------------------------------///
std::string ConvertString(const std::wstring& str) {

	if (str.empty()) {
		return std::string();
	}

	auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
	if (sizeNeeded == 0) {
		return std::string();
	}
	std::string result(sizeNeeded, 0);
	WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
	return result;
}

============================================================
File Path: Project/Engine/Core/Logger.h
============================================================
#pragma once
/// ===include=== ///
// Windows
#include <Windows.h>

// C++
#include <string>
#include <format>

/// <summary>
/// å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ–‡å­—è¡¨ç¤º
/// </summary>
/// <param name="message"></param>
void Log(const std::string& message);

/// <summary>
/// å‡ºåŠ›ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ–‡å­—è¡¨ç¤º
/// </summary>
/// <param name="message"></param>
void Log(const std::wstring& message);

/// <summary>
/// string->wstringã«å¤‰æ›
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
std::wstring ConvertString(const std::string& str);

/// <summary>
/// wstring->stringã«å¤‰æ›
/// </summary>
/// <param name="str"></param>
/// <returns></returns>
std::string ConvertString(const std::wstring& str);

============================================================
File Path: Project/Engine/Core/Mii.cpp
============================================================
#include "Mii.h"

///=====================================================/// 
/// ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®åˆæœŸåŒ–
///=====================================================///
void Mii::Initialize(const wchar_t* title, int width, int height) {

	// ã‚²ãƒ¼ãƒ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ä½œæˆ
	winApp_ = std::make_unique<WinApp>();
	winApp_->CreateGameWindow(title, width, height);

	// DirectXã®ç”Ÿæˆ
	dXCommon_ = std::make_unique<DXCommon>();
	dXCommon_->Initialize(winApp_.get(), width, height);

	// SRVManagerã®ç”Ÿæˆ
	srvManager_ = std::make_unique<SRVManager>();
	srvManager_->Initialize(dXCommon_.get());

	// RTVManagerã®ç”Ÿæˆ
	rtvManager_ = std::make_unique<RTVManager>();
	rtvManager_->Initialize(dXCommon_.get());
	rtvManager_->CreateSwapChainRenderTargetView();

	// DSVManagerã®ç”Ÿæˆ
	dsvManager_ = std::make_unique<DSVManager>();
	dsvManager_->Initialize(dXCommon_.get(), winApp_.get());
	dsvManager_->CreateDepthBufferView(0);

	// ImGuiManagerã®ç”Ÿæˆ
	imGuiManager_ = std::make_unique<ImGuiManager>();
	imGuiManager_->Initialize(winApp_.get(), dXCommon_.get(), srvManager_.get());

	// PipelineManagerã®ç”Ÿæˆ
	pipelineManager_ = std::make_unique<PipelineManager>();
	pipelineManager_->Initialize(dXCommon_.get());

	// OffScreenRendererã®ç”Ÿæˆ
	offScreenRenderer_ = std::make_unique<OffScreenRenderer>();
	offScreenRenderer_->Initialize(
		dXCommon_->GetDevice(),
		srvManager_.get(), rtvManager_.get(),
		width, height, Vector4(0.47f, 0.81f, 0.62f, 1.0f)); // ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼ã‚’ã“ã“ã§è¨­å®š

	// SceneViewã®ç”Ÿæˆ
	sceneView_ = std::make_unique<SceneView>();
	sceneView_->SetTextureHandle(offScreenRenderer_->GetResultSRV());
	imGuiManager_->SetSceneView(sceneView_.get());

	// TextureManagerã®ç”Ÿæˆ
	textureManager_ = std::make_unique<TextureManager>();
	textureManager_->Initialize(dXCommon_.get(), srvManager_.get());

	// ModelManagerã®ç”Ÿæˆ	
	modelManager_ = std::make_unique<ModelManager>();
	modelManager_->Initialize(textureManager_.get());

	// AnimationManagerã®ç”Ÿæˆ
	animationManager_ = std::make_unique<AnimationManager>();

	// AudioManagerã®ç”Ÿæˆ
	audioManager_ = std::make_unique<AudioManager>();
	audioManager_->Initialze();

	// CSVManagerã®ç”Ÿæˆ
	csvManager_ = std::make_unique<CSVManager>();

	// LevelManagerã®ç”Ÿæˆ
	levelManager_ = std::make_unique<LevelManager>();

	// LineObject3Dã®ç”Ÿæˆ
	lineObject3D_ = std::make_unique<LineObject3D>();
	lineObject3D_->Initialize(dXCommon_->GetDevice());

	// InputCommonã®ç”Ÿæˆ
	inputCommon_ = std::make_unique<InputCommon>();
	inputCommon_->Initialize(winApp_.get());

	// Keyboardã®ç”Ÿæˆ
	keyboard_ = std::make_unique<Keyboard>();
	keyboard_->Initialize(winApp_.get(), inputCommon_->GetDirectInput().Get());

	// Mouseã®ç”Ÿæˆ
	mouse_ = std::make_unique<Mouse>();
	mouse_->Initialize(winApp_.get(), inputCommon_->GetDirectInput().Get());

	// Controllerã®ç”Ÿæˆ
	controller_ = std::make_unique<Controller>();
	controller_->Initialize();
}

///=====================================================/// 
/// æ›´æ–°
///=====================================================///
void Mii::Update() {
	// Input
	keyboard_->Update();
	mouse_->Update();
	controller_->Update();
	// ImGui
	imGuiManager_->Begin();
	
#ifdef USE_IMGUI
	// OffScreenRendererã®ImGui
	offScreenRenderer_->DrawImGui();
#endif // USE_IMGUI
}

///=====================================================/// 
/// ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®çµ‚äº†
///=====================================================///
void Mii::Finalize() {
	// èª­ã¿è¾¼ã‚“ã éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ‹¬åœæ­¢ãƒ»è§£æ”¾
	audioManager_->StopAll();
	audioManager_->UnloadAll();
	// LineObject3D
	lineObject3D_->Reset();
	// ImGuiã®çµ‚äº†å‡¦ç†
	imGuiManager_->Finalize();
	// ã‚²ãƒ¼ãƒ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç ´æ£„
	winApp_->TerminateGameWindow();

	// æ‰‹å‹•ã®è§£æ”¾
	// Input
	controller_.reset();		// Controller
	mouse_.reset();				// Mouse
	keyboard_.reset();			// Keyboard
	inputCommon_.reset();		// InputCommon
	lineObject3D_.reset();      // LineObject3D

	// Manager
	levelManager_.reset();		// LevelManager
	csvManager_.reset();		// CSVManager
	audioManager_.reset();		// AudioManager
	animationManager_.reset();	// AnimationManager
	modelManager_.reset();		// ModelManager
	textureManager_.reset();	// TextureManager
	
	// SceneView
	sceneView_.reset();
	// OffScreen
	offScreenRenderer_.reset();
	// PipelineManager
	pipelineManager_.reset();
	// ImGui
	imGuiManager_.reset();
	// SRV, RTV, DSV
	dsvManager_.reset();		// DSVManager
	rtvManager_.reset();		// RTVManager
	srvManager_.reset();		// SRVManager
	// DXCommon
	dXCommon_.reset();
	// WinApp
	winApp_.reset();

	// COMã®çµ‚äº†
	CoUninitialize();
}


///=====================================================/// 
/// ãƒ•ãƒ¬ãƒ¼ãƒ é–‹å§‹å‡¦ç†
///=====================================================///
void Mii::BeginFrame() {
	// æç”»å‰å‡¦ç†
	// CommandListã®å–å¾—
	ID3D12GraphicsCommandList* commandList = dXCommon_->GetCommandList();

	// Barrierã®è¨­å®š
	dXCommon_->PreDrawRenderTexture(offScreenRenderer_->GetSceneBuffer());
	dXCommon_->PreDrawEffectTexture(offScreenRenderer_->GetEffectBuffer());

	// æç”»å…ˆã®RTVã‚’è¨­å®šã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dsvManager_->GetCPUDescriptorHandle(0); // é€šå¸¸DSVã¯1ã¤
	// OffScreenã§RTVã¨DSVã‚’ã‚»ãƒƒãƒˆã—ã¦RTVã‚’ã‚¯ãƒªã‚¢ã—ã¦ã„ã‚‹
	offScreenRenderer_->PreDraw(commandList, dsvHandle);
	// DSVã¯OffScreenã§ä½¿ç”¨ã—ã¦ã„ãªã„ã®ã§ã“ã“ã§ã‚¯ãƒªã‚¢
	dsvManager_->ClearDepthBufferView(commandList);

	// ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	dXCommon_->BeginCommand();

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ãƒã‚¤ãƒ³ãƒ‰
	srvManager_->PreDraw();
}


///=====================================================/// 
/// ãƒ•ãƒ¬ãƒ¼ãƒ çµ‚äº†å‡¦ç†
///=====================================================///
void Mii::EndFrame() {
	// ImGuiã®æç”»æº–å‚™
	dXCommon_->PreDrawImGui(rtvManager_.get());

	// sceneTextureã®ãƒãƒªã‚¢ã®çŠ¶æ…‹é·ç§»
	dXCommon_->TransitionRenderTarget();

	// OffScreenã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’SwapChainã«æç”»
	offScreenRenderer_->Draw(dXCommon_->GetCommandList());

	// EffectTextureã®ãƒãƒªã‚¢çŠ¶æ…‹é·ç§»
	dXCommon_->TransitionEffectTexture();

	// effectTexture_ ã‚’ SwapChain ã«ã‚³ãƒ”ãƒ¼
	UINT backBufferIndex = dXCommon_->GetBackBufferIndex();
	D3D12_CPU_DESCRIPTOR_HANDLE swapChainRTV = rtvManager_->GetCPUDescriptorHandle(backBufferIndex);
	offScreenRenderer_->CopyToSwapChain(dXCommon_->GetCommandList(), swapChainRTV);

	// ImGuiã®UIæç”»
	imGuiManager_->Draw();

	// ImGuiã®æç”»å®Ÿè¡Œ
	imGuiManager_->End();

	// DXCommonã®æç”»å¾Œå‡¦ç†
	dXCommon_->PostDraw();
}


///=====================================================/// 
/// Windowsã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ã™ã‚‹
///=====================================================///
int Mii::ProcessMessage() { return winApp_->ProcessMessage(); }


///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
#pragma region é–‹ç™ºè€…ç”¨
// DXCommon
DXCommon* Mii::GetDXCommon() { return dXCommon_.get(); }
// WinApp
WinApp* Mii::GetWinApp() { return winApp_.get(); }
// SRVManager
SRVManager* Mii::GetSRVManager() {return srvManager_.get();}
// RTVManager
RTVManager* Mii::GetRTVManager() { return rtvManager_.get(); }
// DSVManager
DSVManager* Mii::GetDSVManager() { return dsvManager_.get(); }
// PipelineManager
PipelineManager* Mii::GetPipelineManager() { return pipelineManager_.get(); }
// TextureManager
TextureManager* Mii::GetTextureManager() { return textureManager_.get(); }
// ModelManager
ModelManager* Mii::GetModelManager() { return modelManager_.get(); }
// AudioManager
AudioManager* Mii::GetAudioManager() { return audioManager_.get(); }
// CSVManager
CSVManager* Mii::GetCSVManager() { return csvManager_.get(); }
// LevelManager
LevelManager* Mii::GetLevelManager() { return levelManager_.get(); }
// AnimationManager
AnimationManager* Mii::GetAnimationManager() { return animationManager_.get(); }
// OffScreenRenderer
OffScreenRenderer* Mii::GetOffScreenRenderer() { return offScreenRenderer_.get(); }
// LineObject3D
LineObject3D* Mii::GetLineObject3D() { return lineObject3D_.get(); }
// Keyboard
Keyboard* Mii::GetKeyboard() { return keyboard_.get(); }
// Mouse
Mouse* Mii::GetMouse() { return mouse_.get(); }
// Controller
Controller* Mii::GetController() { return controller_.get(); }
#pragma endregion


============================================================
File Path: Project/Engine/Core/Mii.h
============================================================
#pragma once
/// ===include=== ///
// C++
#include <memory>
// Engine
#include "Engine/Core/WinApp.h"
#include "Engine/Core/DXCommon.h"
// Input
#include "Engine/System/Input/InputCommon.h"
#include "Engine/System/Input/Keyboard.h"
#include "Engine/System/Input/Mouse.h"
#include "Engine/System/Input/Controller.h"
// Manager
#include "Engine/System/Managers/SRVManager.h"
#include "Engine/System/Managers/RTVManager.h"
#include "Engine/System/Managers/DSVManager.h"
#include "Engine/System/Managers/PiplineManager.h"
#include "Engine/System/Managers/TextureManager.h"
#include "Engine/System/Managers/ModelManager.h"
#include "Engine/System/Managers/ImGuiManager.h"
#include "Engine/System/Managers/AudioManager.h"
#include "Engine/System/Managers/CSVManager.h"
#include "Engine/System/Managers/AnimationManager.h"
#include "Engine/System/Managers/LevelManager.h"
// OffScreenRender
#include "Engine/Graphics/OffScreen/OffScreenRenderer.h"
// ImGui
#include "Engine/System/ImGui/SceneView.h"
// LineObject
#include "Engine/Graphics/3d/Line/LineObject3D.h"


///=====================================================///
/// ã‚·ã‚¹ãƒ†ãƒ 
///=====================================================///
class Mii {
public:

	Mii() = default;
	~Mii() = default;

public:/// ===é–‹ç™ºè€…ç”¨é–¢æ•°(ã‚·ã‚¹ãƒ†ãƒ )=== ///

	/// <summary>
	/// ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="title">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ã‚¿ã‚¤ãƒˆãƒ«ã®ãƒŒãƒ«çµ‚ç«¯ãƒ¯ã‚¤ãƒ‰æ–‡å­—åˆ—ï¼ˆconst wchar_t*ï¼‰ã€‚</param>
	/// <param name="width">å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰ã€‚çœç•¥æ™‚ã®æ—¢å®šå€¤ã¯1920ã€‚</param>
	/// <param name="height">é«˜ã•ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰ã€‚çœç•¥æ™‚ã®æ—¢å®šå€¤ã¯1080ã€‚</param>
	void Initialize(const wchar_t* title, int width = 1920, int height = 1080);

	/// <summary>
	/// ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();
			
	/// <summary>
	/// ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã®çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ãƒ•ãƒ¬ãƒ¼ãƒ é–‹å§‹å‡¦ç†
	/// </summary>
	void BeginFrame();

	/// <summary>
	/// ãƒ•ãƒ¬ãƒ¼ãƒ çµ‚äº†å‡¦ç†
	/// </summary>
	void EndFrame();

	/// <summary>
	/// Windowsã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†
	/// </summary>
	/// <returns>å‡¦ç†çµæœã‚’è¡¨ã™æ•´æ•°å€¤ï¼ˆæ„å‘³ã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ï¼‰ã€‚</returns>
	int ProcessMessage();

public:/// ===é–‹ç™ºè€…ç”¨é–¢æ•°(Getter)=== ///
	// DXCommonã®å–å¾—
	DXCommon* GetDXCommon();
	// WinAppã®å–å¾—
	WinApp* GetWinApp();
	// SRVManagerã®å–å¾—
	SRVManager* GetSRVManager();
	// RTVManagerã®å–å¾—
	RTVManager* GetRTVManager();
	// DSVManagerã®å–å¾—
	DSVManager* GetDSVManager();
	// PiplelineManagerã®å–å¾—
	PipelineManager* GetPipelineManager();
	// TextureManagerã®å–å¾—
	TextureManager* GetTextureManager();
	// ModelManagerã®å–å¾—
	ModelManager* GetModelManager();
	// AudioManagerã®å–å¾—
	AudioManager* GetAudioManager();
	// CSVManagerã®å–å¾—
	CSVManager* GetCSVManager();
	// LevelManagerã®å–å¾—
	LevelManager* GetLevelManager();
	// AnimationManagerã®å–å¾—
	AnimationManager* GetAnimationManager();
	// OffScreenRendererã®å–å¾—
	OffScreenRenderer* GetOffScreenRenderer();
	// LineObject3Dã®å–å¾—
	LineObject3D* GetLineObject3D();
	// Keyboardã®å–å¾—
	Keyboard* GetKeyboard();
	// Mouseã®å–å¾—
	Mouse* GetMouse();
	// Controllerã®å–å¾—
	Controller* GetController();

private:/// ===Variables(å¤‰æ•°)=== ///
	// Core
	std::unique_ptr<WinApp> winApp_;                     // WinApp
	std::unique_ptr<DXCommon> dXCommon_;                 // DirectXCommon
	// Input
	std::unique_ptr<InputCommon> inputCommon_;           // inputCommon
	std::unique_ptr<Keyboard> keyboard_;                 // Keyboard
	std::unique_ptr<Mouse> mouse_;                       // Mouse
	std::unique_ptr<Controller> controller_;             // Controller
	// Manager
	std::unique_ptr<SRVManager> srvManager_;             // SRVManager
	std::unique_ptr<RTVManager> rtvManager_;             // RTVManager
	std::unique_ptr<DSVManager> dsvManager_;             // DSVManager
	std::unique_ptr<PipelineManager> pipelineManager_;   // PipelineManager
	std::unique_ptr<TextureManager> textureManager_;     // TextureManager
	std::unique_ptr<ModelManager> modelManager_;         // ModelManager
	std::unique_ptr<ImGuiManager> imGuiManager_;         // ImGuiManager
	std::unique_ptr<AudioManager> audioManager_;         // AudioMangaer
	std::unique_ptr<CSVManager> csvManager_;             // CSVManager
	std::unique_ptr<AnimationManager> animationManager_; // AnimationManager
	// OffScreen
	std::unique_ptr<OffScreenRenderer> offScreenRenderer_;// OffScreen
	// ImGui
	std::unique_ptr<SceneView> sceneView_;                // SceneView
	// Line
	std::unique_ptr<LineObject3D> lineObject3D_;          // LineObject3D
	// Level
	std::unique_ptr<LevelManager> levelManager_;			  // LevelLoader

private:
	///=====================================================/// 
	/// ReportLiveObjects()
	///=====================================================///
	struct D3DResourceLeakChecker {

		~D3DResourceLeakChecker() {

			// ãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯
			ComPtr<IDXGIDebug1> debug;
			if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debug)))) {
				debug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
				debug->ReportLiveObjects(DXGI_DEBUG_APP, DXGI_DEBUG_RLO_ALL);
				debug->ReportLiveObjects(DXGI_DEBUG_D3D12, DXGI_DEBUG_RLO_ALL);
			}
		}
	};

	// ReportLiveObjects
	D3DResourceLeakChecker leakCheck;
};



============================================================
File Path: Project/Engine/Core/StringUtility.cpp
============================================================
#include "StringUtility.h"

#include <windows.h>

///-------------------------------------------/// 
/// string->wstring
///-------------------------------------------///
std::wstring StringUtility::ConvertString(const std::string& str) {
	if (str.empty()) {
		return std::wstring();
	}

	auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
	if (sizeNeeded == 0) {
		return std::wstring();
	}
	std::wstring result(sizeNeeded, 0);
	MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
	return result;
}

///-------------------------------------------/// 
/// wstring->string
///-------------------------------------------///
std::string StringUtility::ConvertString(const std::wstring& str) {
	if (str.empty()) {
		return std::string();
	}

	auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
	if (sizeNeeded == 0) {
		return std::string();
	}
	std::string result(sizeNeeded, 0);
	WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
	return result;
}


============================================================
File Path: Project/Engine/Core/StringUtility.h
============================================================
#pragma once
#include <string>

///=====================================================/// 
/// æ–‡å­—ã‚³ãƒ¼ãƒ‰ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
///=====================================================///
namespace StringUtility {
	/// <summary>
	/// stringã‚’wstringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str"></param>
	/// <returns></returns>
	std::wstring ConvertString(const std::string& str);

	/// <summary>
	/// wstringã‚’stringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str"></param>
	/// <returns></returns>
	std::string ConvertString(const std::wstring& str);
}

============================================================
File Path: Project/Engine/Core/WinApp.cpp
============================================================
#include "WinApp.h"
#include <string>

#ifdef USE_IMGUI
#include <imGui.h>
#endif // USE_IMGUI


#ifdef _DEBUG
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
#endif // _DEBUG

// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®åå‰
const wchar_t WinApp::kWindowClassName[] = L"DeathsDoor";

///-------------------------------------------/// 
/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ¨ªå¹…ã®å–å¾—
///-------------------------------------------///
const int WinApp::GetWindowWidth() const { return windowWidth_; }

///-------------------------------------------/// 
/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç¸¦å¹…ã®å–å¾—
///-------------------------------------------///
const int WinApp::GetWindowHeight() const { return windowHeight_; }

///-------------------------------------------/// 
/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ£
///-------------------------------------------///
LRESULT WinApp::WindowProc(HWND hwnd, UINT msg, WPARAM WPARAM, LPARAM LPARAM) {
#ifdef USE_IMGUI
	if (ImGui_ImplWin32_WndProcHandler(hwnd, msg, WPARAM, LPARAM)) {
		return true;
	}
#endif // USE_IMGUI

	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¿œã˜ãŸã‚²ãƒ¼ãƒ å›ºæœ‰ã®å‡¦ç†
	switch (msg) {

		// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒç ´æ£„ã•ã‚ŒãŸ
	case WM_DESTROY:

		// OSã«å¯¾ã—ã¦ã€ã‚¢ãƒ—ãƒªã®çµ‚äº†ã‚’ä¼ãˆã‚‹
		PostQuitMessage(0);
		return 0;
	}

	// æ¨™æº–ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã‚’è¡Œã†
	return DefWindowProc(hwnd, msg, WPARAM, LPARAM);
}

///-------------------------------------------/// 
/// ã‚²ãƒ¼ãƒ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ä½œæˆ
///-------------------------------------------///
void WinApp::CreateGameWindow(const wchar_t* title, int32_t kClientWidth, int32_t kClientHeight) {

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã®è¨­å®š
	windowWidth_ = kClientWidth;
	windowHeight_ = kClientHeight;

	/* /////////////////////////////////////
					COMã®åˆæœŸåŒ–
	*/ /////////////////////////////////////
	// COMã®åˆæœŸåŒ–
	HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
	if (FAILED(hr)) {
		// åˆæœŸåŒ–å¤±æ•—æ™‚ã®ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
		MessageBox(nullptr, L"COMã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚", L"ã‚¨ãƒ©ãƒ¼", MB_OK | MB_ICONERROR);
		return;
	}

	/* /////////////////////////////////////
				ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®ç™»éŒ²
	*/ /////////////////////////////////////
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ£
	wndClass_.lpfnWndProc = WindowProc;

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹å
	wndClass_.lpszClassName = kWindowClassName;

	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
	wndClass_.hInstance = GetModuleHandle(nullptr);

	// ã‚«ãƒ¼ã‚½ãƒ«
	wndClass_.hCursor = LoadCursor(nullptr, IDC_ARROW);

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’ç™»éŒ²
	RegisterClass(&wndClass_);

	/* /////////////////////////////////////
			ã€€ã€€ã€€ã€€ã‚¦ã‚£ãƒ³ãƒ‰ã®ä½œæˆ
	*/ /////////////////////////////////////
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’è¡¨ã™æ§‹é€ ä½“ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’å…¥ã‚Œã‚‹
	RECT wrc = { 0, 0, kClientWidth, kClientHeight };

	// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’å…ƒã«å®Ÿéš›ã®ã‚µã‚¤ã‚ºã«wrcã‚’å¤‰æ›´ã—ã¦ã‚‚ã‚‰ã†
	AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç”Ÿæˆ
	hwnd_ = CreateWindow(
		wndClass_.lpszClassName,    // åˆ©ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¹å
		title,                      // ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ã®æ–‡å­—
		WS_OVERLAPPEDWINDOW,        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ã‚¿ã‚¤ãƒ«
		CW_USEDEFAULT,              // è¡¨ç¤ºXåº§æ¨™
		CW_USEDEFAULT,              // è¡¨ç¤ºYåº§æ¨™
		wrc.right - wrc.left,       // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ¨ªå¹…
		wrc.bottom - wrc.top,       // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç¸¦å¹…
		nullptr,                    // è¦ªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
		nullptr,                    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ³ãƒ‰ãƒ«
		wndClass_.hInstance,        // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
		nullptr);                   // ã‚ªãƒ—ã‚·ãƒ§ãƒ³

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã™ã‚‹
	ShowWindow(hwnd_, SW_SHOW);
}

///-------------------------------------------/// 
/// ã‚²ãƒ¼ãƒ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç ´æ£„
///-------------------------------------------///
void WinApp::TerminateGameWindow() {
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’ç™»éŒ²è§£é™¤
	UnregisterClass(wndClass_.lpszClassName, wndClass_.hInstance);
}

///-------------------------------------------/// 
/// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
///-------------------------------------------///
bool WinApp::ProcessMessage() {
	MSG msg{}; // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸

	// Windowã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ã¦ãŸã‚‰æœ€å„ªå…ˆã§å‡¦ç†ã•ã›ã‚‹
	if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg); // ã‚­ãƒ¼å…¥åŠ›ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
		DispatchMessage(&msg); // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ã‚‹
	}

	if (msg.message == WM_QUIT) { //ã€€çµ‚äº†ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ãŸã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		return true;
	}

	return false;
}

/// <summary>
/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
/// </summary>
HWND WinApp::GetHwnd() const { return hwnd_; }

/// <summary>
/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®å–å¾—
/// </summary>
/// <returns></returns>
WNDCLASS WinApp::GetWNDClass() const { return wndClass_; }


============================================================
File Path: Project/Engine/Core/WinApp.h
============================================================
#pragma once
// Windows
#include <Windows.h>

// int32_tã‚’ä½¿ã†ãŸã‚ã®ã‚‚ã®
#include <cstdint>

class WinApp {
public:
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹å
	static const wchar_t kWindowClassName[];

public:

	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æ¨ªå¹…ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	const int GetWindowWidth() const;

	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç¸¦å¹…ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	const int GetWindowHeight() const;

	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ãƒ¼ã‚¸ãƒ£
	/// </summary>
	/// <param name="hwnd"></param>
	/// <param name="msg"></param>
	/// <param name="WPARAM"></param>
	/// <param name="LPARAM"></param>
	/// <returns></returns>
	static LRESULT WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

	/// <summary>
	/// ã‚²ãƒ¼ãƒ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ä½œæˆé–¢æ•°
	/// </summary>
	/// <param name="kWindowClassName"></param>
	/// <param name="kClientWidth"></param>
	/// <param name="kClientHeight"></param>
	void CreateGameWindow(const wchar_t* title, int32_t kClientWidth, int32_t kClientHeight);

	/// <summary>
	/// ã‚²ãƒ¼ãƒ ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç ´æ£„
	/// </summary>
	void TerminateGameWindow();

	/// <summary>
	/// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†
	/// </summary>
	/// <returns></returns>
	bool ProcessMessage();

	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	HWND GetHwnd() const;

	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦classã®å–å¾—
	/// </summary>
	/// <returns></returns>
	WNDCLASS GetWNDClass() const;

private:// ãƒ¡ãƒ³ãƒå¤‰æ•°

	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
	int32_t windowWidth_ = 1280;  // æ¨ªå¹…
	int32_t windowHeight_ = 720;  // ç¸¦å¹…

	WNDCLASS wndClass_{};		// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹
	HWND hwnd_ = nullptr;		// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
	UINT windowStyle_;			// 
	bool isFullScreen_ = false; // 
	RECT windowRect_;			// 
};

============================================================
File Path: Project/Engine/DataInfo/AnimationData.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
#include "CData.h"
// Math
#include "Math/Quaternion.h"
#include "Math/Vector3.h"
#include "Math/Matrix4x4.h"
// c++
#include <vector>
#include <map>
#include <string>
#include <optional>
#include <span>
#include <array>

/// <summary>
/// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ(Keyframe)
/// </summary>
/// <typeparam name="tValue"></typeparam>
template <typename tValue>
struct Keyframe {
	float time;
	tValue value;
};
using KeyframeVector3 = Keyframe<Vector3>;
using KeyframeQuaternion = Keyframe<Quaternion>;

/// <summary>
/// ãƒãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
/// </summary>
//struct NodeAnimation {
//	std::vector<KeyframeVector3> translate;
//	std::vector<KeyframeQuaternion> rotate;
//	std::vector<KeyframeVector3> scale;
//};

/// <summary>
/// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ(NodeAnimation)
/// </summary>
/// <typeparam name="tValue"></typeparam>
template<typename tValue>
struct AnimationCurve {
	std::vector<Keyframe<tValue>> keyframes;
};

/// <summary>
/// ãƒãƒ¼ãƒ‰ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
/// </summary>
struct NodeAnimation {
	AnimationCurve<Vector3> translate;
	AnimationCurve<Quaternion> rotate;
	AnimationCurve<Vector3> scale;
};

/// <summary>
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ§‹é€ ä½“
/// </summary>
struct Animation {
	float duration; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å…¨ä½“ã®å°º(å˜ä½ã¯ç§’)
	// NodeAnimationã®é›†åˆã€‚Nodeåã§å¼•ã‘ã‚‹ã‚ˆã†ã«ã—ã¦ãŠã
	std::map<std::string, NodeAnimation> nodeAnimations;
};

/// <summary>
/// Jointã®æ§‹é€ ä½“
/// </summary>
struct Joint {
	QuaternionTransform transform;	// Transformæƒ…å ±
	Matrix4x4 localMatrix;			// localMatrix
	Matrix4x4 skeletonSpaceMatrix;	// skeletonSpaceã§ã®å¤‰æ›è¡Œåˆ—
	std::string name;				// åå‰
	std::vector<int32_t> children;	// å­Jointã®Indexã®ãƒªã‚¹ãƒˆã€‚ã„ãªã‘ã‚Œã°ç©º
	int32_t index;					// è‡ªèº«ã®Index
	std::optional<int32_t> parent;	// è¦ªJointã®Indexã€‚ã„ãªã‘ã‚Œã°null
};

/// <summary>
/// Skeleton
/// </summary>
struct Skeleton {
	int32_t root; // RootJointã®Index
	std::map<std::string, int32_t> jointMap; // Jointåã¨Indexã¨ã®è¾æ›¸
	std::vector<Joint> joints; // æ‰€å±ã—ã¦ã„ã‚‹ã‚¸ãƒ§ã‚¤ãƒ³ãƒˆ
};

/// <summary>
/// Influence(ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚¹)
/// </summary>
const uint32_t kNumMaxInfluence = 4;
struct VertexInfluence {
	std::array<float, kNumMaxInfluence> weights;
	std::array<int32_t, kNumMaxInfluence> jointIndices;
};

/// <summary>
/// MatrixPalette(ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ãƒ‘ãƒ¬ãƒƒãƒˆ)
/// </summary>
struct WellForGPU {
	Matrix4x4 skeletonSpaceMatrix; // ä½ç½®ç”¨
	Matrix4x4 skeletonSpaceInverseTransposeMatrix; // æ³•ç·šç”¨
};

/// <summary>
/// SkinCluster
/// </summary>
struct SkinCluster {
	std::vector<Matrix4x4> inverseBindPoseMatrices;
	ComPtr<ID3D12Resource> influenceResource;
	D3D12_VERTEX_BUFFER_VIEW influenceBufferView;
	std::span<VertexInfluence> mappedInfluence;
	ComPtr<ID3D12Resource> paletteResource;
	std::span<WellForGPU> mappedPalette;
	std::pair<D3D12_CPU_DESCRIPTOR_HANDLE, D3D12_GPU_DESCRIPTOR_HANDLE> paletteSrvHandle;
};

============================================================
File Path: Project/Engine/DataInfo/BlendModeData.h
============================================================
#pragma once
// c++
#include <cstdint>
#include <array>

///-------------------------------------------/// 
/// BlendMode
///-------------------------------------------///
enum BlendMode {
	//!< ãƒ–ãƒ¬ãƒ³ãƒ‰ãªã—
	kBlendModeNone,

	//!< é€šå¸¸ãƒ–ãƒ¬ãƒ³ãƒ‰ã€‚
	KBlendModeNormal,

	//!< åŠ ç®—
	kBlendModeAdd,

	//!< æ¸›ç®—
	kBlendModeSubtract,

	//!< ä¹—ç®—
	kBlendModeMultily,

	//!< ã‚¹ã‚¯ãƒªãƒ¼ãƒ³
	kBlendModeScreen,

	// ç·æ•°(ã“ã‚Œã¯æœ€å¾Œã«ã—ãªã‘ã‚Œã°ã„ã‘ãªã„)
	kCountOfBlendMode,
};

constexpr std::array<BlendMode, static_cast<size_t>(BlendMode::kCountOfBlendMode)> AllBlendModes() {
	return { BlendMode::kBlendModeNone, BlendMode::KBlendModeNormal, BlendMode::kBlendModeAdd,
			 BlendMode::kBlendModeSubtract, BlendMode::kBlendModeMultily, BlendMode::kBlendModeScreen };
}

============================================================
File Path: Project/Engine/DataInfo/CData.h
============================================================
#pragma once
/// ===include=== ///
// C++
#include <Windows.h>
#include <chrono>
#include <cstdlib>
#include <map>

// DirectX
#include <d3d12.h>
#include <dxgi1_6.h>
#include <dxcapi.h>
#include <wrl.h>

// Math
#include "Math/Vector2.h"
#include "Math/Vector3.h"
#include "Math/Vector4.h"
#include "Math/Matrix3x3.h"
#include "Math/Matrix4x4.h"
#include "Math/Quaternion.h"

#pragma region Bufferæƒ…å ±
/// ===VertexData(2D)=== ///
struct VertexData2D {
	Vector4 position;
	Vector2 texcoord;
};
/// ===VertexData(3D)=== ///
struct VertexData3D {
	Vector4 position;
	Vector2 texcoord;
	Vector3 normal;
};
/// ===Material(2D)=== ///
struct MaterialData2D {
	Vector4 color;
	Matrix4x4 uvTransform;
};
/// ===Material(3D)=== ///
struct MaterialData3D {

	Vector4 color;
	int32_t enableLighting;
	float padding[3];
	Matrix4x4 uvTransform;
	float shininess;
};
/// ===TransformationMatrix(2D)=== ///
struct TransformationMatrix2D {
	Matrix4x4 WVP;
};
/// ===TransformationMatrix(3D)=== ///
struct TransformationMatrix3D {
	Matrix4x4 WVP;
	Matrix4x4 World;
	Matrix4x4 WorldInverseTranspose;
};
#pragma endregion
#pragma region Transformæƒ…å ±
/// ===EulerTransform=== ///
struct EulerTransform {
	Vector3 scale;
	Vector3 rotate; // Eulerã§ã®å›è»¢
	Vector3 translate;
};
/// ===QuaternionTransform=== ///
struct QuaternionTransform {
	Vector3 scale;
	Quaternion rotate;
	Vector3 translate;
};
#pragma endregion
#pragma region ãƒ¢ãƒ‡ãƒ«æƒ…å ±
/// ===VertexWeightData=== ///
struct VertexWeightData {
	float weight;
	uint32_t vertexIndex;
};
/// ===JointWeightData=== ///
struct jointWeightData {
	Matrix4x4 inverseBindPoseMatrix;
	std::vector<VertexWeightData> vertexWeights;
};
/// ===ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿=== ///
struct  MaterialData {
	std::string textureFilePath;
};
/// ===ãƒãƒ¼ãƒ‰=== ///
struct Node {
	QuaternionTransform transform;
	Matrix4x4 localMatrix;
	std::string name;
	std::vector<Node> children;
};
/// ===ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿=== ///
struct ModelData {
	std::map<std::string, jointWeightData> skinClusterData;
	std::vector<VertexData3D> vertices;
	std::vector<uint32_t> indices;
	MaterialData material;
	Node rootNode;
	bool haveBone;
};
#pragma endregion
#pragma region ãƒ©ã‚¤ãƒˆæƒ…å ±
/// ===å¹³è¡Œå…‰æºã®æ‹¡å¼µ=== ///
struct DirectionalLight {
	Vector4 color;     // ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 direction; // ãƒ©ã‚¤ãƒˆã®å‘ã
	float intensity;   // ãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•(è¼åº¦)
};
/// ===ã‚«ãƒ¡ãƒ©ã®ä½ç½®=== ///
struct CameraForGPU {
	Vector3 worldPosition; // ã‚«ãƒ¡ãƒ©ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰ä½ç½®W
};
/// ===ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆ=== ///
struct PointLight {
	Vector4 color; 		// ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 position;	// ãƒ©ã‚¤ãƒˆã®ä½ç½®
	float intensity;	// ãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•(è¼åº¦)
	float radius;		// ãƒ©ã‚¤ãƒˆã®åŠå¾„
	float decay;		// æ¸›è¡°ç‡
	float padding[2];	// ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
};
/// ===ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ=== ///
struct SpotLight {
	Vector4 color;		// ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 position;	// ãƒ©ã‚¤ãƒˆã®ä½ç½®
	float intensity;	// ãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•(è¼åº¦)
	Vector3 direction;	// ãƒ©ã‚¤ãƒˆã®å‘ã
	float distance;		// ãƒ©ã‚¤ãƒˆã®è·é›¢
	float decay;		// æ¸›è¡°ç‡
	float cosAngle;		// ã‚³ã‚µã‚¤ãƒ³è§’åº¦(ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®è§’åº¦)
	float padding[3];	// ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
};
#pragma endregion
#pragma region ç’°å¢ƒãƒãƒƒãƒ—
/// ===ç’°å¢ƒãƒãƒƒãƒ—=== ///
struct EnviromentMap {
	int32_t enable;		// ç’°å¢ƒãƒãƒƒãƒ—ã®æœ‰åŠ¹åŒ–
	float strength;		// ç’°å¢ƒãƒãƒƒãƒ—ã®å¼·åº¦
	float padding[2];   // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
};
#pragma endregion

============================================================
File Path: Project/Engine/DataInfo/ColliderData.h
============================================================
#pragma once
#include "Math/Vector2.h"
#include "Math/Vector3.h"

///-------------------------------------------/// 
/// ColliderType
///-------------------------------------------///
enum class ColliderType {
    AABB,      // è»¸æ•´åˆãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ï¼ˆçŸ©å½¢ï¼‰
    Sphere,    // çƒä½“
    OBB,       // ä»»æ„æ–¹å‘ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹
    Count      // é…åˆ—ã‚µã‚¤ã‚ºç”¨
};

///-------------------------------------------/// 
/// ColliderName
///-------------------------------------------///
enum class ColliderName {
    Player,    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    Enemy,     // æ•µ
    PlayerBullet, // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¼¾
    PlayerWeapon, // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ­¦å™¨
    EnemyBullet,  // æ•µã®å¼¾
    Object,      // å£
    Ground,     // åºŠ
    Ceiling,   // å¤©äº•
    None       // ç„¡ã—
};

///-------------------------------------------/// 
/// AABBã®æ§‹é€ ä½“
///-------------------------------------------///
struct AABB {
    Vector3 min; //!<æœ€å°ç‚¹
    Vector3 max; //!<æœ€å¤§ç‚¹
};

///-------------------------------------------/// 
/// OBBã®æ§‹é€ ä½“
///-------------------------------------------///
struct OBB {
    Vector3 center;          // !<ä¸­å¿ƒ
    Vector3 axis[3];         // !<åº§æ¨™è»¸ã€‚æ­£è¦åŒ–ãƒ»ç›´äº¤å¿…é ˆ
    Vector3 halfSize;        // !<åº§æ¨™è»¸æ–¹å‘ã®é•·ã•ã®åŠåˆ†ã€‚ä¸­å¿ƒç©ºé¢ã¾ã§ã®è·é›¢
};

///-------------------------------------------/// 
/// Sphereã®æ§‹é€ ä½“
///-------------------------------------------///
struct Sphere {
    Vector3 center;  // ä¸­å¿ƒ
    float radius;    // åŠå¾„
};



============================================================
File Path: Project/Engine/DataInfo/FunctionData.cpp
============================================================
#include "FunctionData.h"
// C++
#include <cassert>
///-------------------------------------------/// 
/// CreateBufferResource
///-------------------------------------------///
ID3D12Resource* CreateBufferResource(
	ID3D12Device* device, 
	size_t sizeInBytes, 
	DXGI_FORMAT format, 
	D3D12_RESOURCE_FLAGS flags) {

	HRESULT hr;

	// ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
	D3D12_HEAP_PROPERTIES uploadHeapProperties{};
	uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;  // UploadHeapã‚’ä½¿ã†

	// ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
	D3D12_RESOURCE_DESC resourceDesc{};

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã¾ãŸåˆ¥ã®è¨­å®šã‚’ã™ã‚‹
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = sizeInBytes; // ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã€‚ä»Šå›ã¯Vector4ã‚’3é ‚ç‚¹åˆ†

	// ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã‚‰ã¯1ã«ã™ã‚‹æ±ºã¾ã‚Š
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;

	// Formatã®è¨­å®š
	resourceDesc.Format = format;
	// Flagsã®è¨­å®š
	resourceDesc.Flags = flags;

	// ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã«ã™ã‚‹æ±ºã¾ã‚Š
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	// å®Ÿéš›ã«é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	ID3D12Resource* bufferResource = nullptr;
	hr = device->CreateCommittedResource(
		&uploadHeapProperties, 
		D3D12_HEAP_FLAG_NONE, 
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, 
		nullptr, 
		IID_PPV_ARGS(&bufferResource)
	);
	assert(SUCCEEDED(hr));

	return bufferResource;
}

///-------------------------------------------/// 
/// CreateBufferResource(ComPtr)
///-------------------------------------------///
ComPtr<ID3D12Resource> CreateBufferResourceComPtr(
	ID3D12Device* device, 
	size_t sizeInBytes, 
	DXGI_FORMAT format, 
	D3D12_RESOURCE_FLAGS flags) {

	HRESULT hr;

	// ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
	D3D12_HEAP_PROPERTIES uploadHeapProperties{};
	uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;  // UploadHeapã‚’ä½¿ã†

	// ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
	D3D12_RESOURCE_DESC resourceDesc{};

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã¾ãŸåˆ¥ã®è¨­å®šã‚’ã™ã‚‹
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = sizeInBytes; // ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã€‚ä»Šå›ã¯Vector4ã‚’3é ‚ç‚¹åˆ†

	// ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã‚‰ã¯1ã«ã™ã‚‹æ±ºã¾ã‚Š
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;

	// Formatã®è¨­å®š
	resourceDesc.Format = format;
	// Flagsã®è¨­å®š
	resourceDesc.Flags = flags;

	// ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã«ã™ã‚‹æ±ºã¾ã‚Š
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	// å®Ÿéš›ã«é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	ComPtr<ID3D12Resource> bufferResource = nullptr;
	hr = device->CreateCommittedResource(
		&uploadHeapProperties, 
		D3D12_HEAP_FLAG_NONE, 
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr, 
		IID_PPV_ARGS(&bufferResource)
	);
	assert(SUCCEEDED(hr));

	return bufferResource;
}


============================================================
File Path: Project/Engine/DataInfo/FunctionData.h
============================================================
#pragma once
#include "Engine/Core/ComPtr.h"
#include "Engine/DataInfo/CData.h"

/// <summary>
/// æŒ‡å®šã—ãŸãƒ‡ãƒã‚¤ã‚¹ä¸Šã§ãƒã‚¤ãƒˆå˜ä½ã®ã‚µã‚¤ã‚ºã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ãƒ•ãƒ©ã‚°ã‚’ä½¿ç”¨ã—ã¦ãƒãƒƒãƒ•ã‚¡ç”¨ã® ID3D12Resource ã‚’ä½œæˆã—ã¾ã™ã€‚
/// </summary>
/// <param name="device">ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆã™ã‚‹ Direct3D 12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
/// <param name="sizeInBytes">ä½œæˆã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆå˜ä½ï¼‰ã€‚</param>
/// <param name="format">ãƒªã‚½ãƒ¼ã‚¹ã® DXGI ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€‚æ—¢å®šã¯ DXGI_FORMAT_UNKNOWNã€‚å‹ä»˜ããƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ãªå ´åˆãªã©ã«æŒ‡å®šã—ã¾ã™ã€‚</param>
/// <param name="flags">ãƒªã‚½ãƒ¼ã‚¹ä½œæˆæ™‚ã® D3D12_RESOURCE_FLAGSï¼ˆä¾‹: UAV è¨±å¯ãªã©ï¼‰ã€‚æ—¢å®šã¯ D3D12_RESOURCE_FLAG_NONEã€‚</param>
/// <returns>ä½œæˆã•ã‚ŒãŸ ID3D12Resource ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ä½œæˆã«å¤±æ•—ã—ãŸå ´åˆã¯ nullptr ã‚’è¿”ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚è¿”ã•ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã®å‚ç…§è§£æ”¾ï¼ˆReleaseï¼‰ã¯å‘¼ã³å‡ºã—å´ã®è²¬ä»»ã§ã™ã€‚</returns>
ID3D12Resource* CreateBufferResource(
	ID3D12Device* device, 
	size_t sizeInBytes, 
	DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN, 
	D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE);

/// <summary>
/// æŒ‡å®šã—ãŸã‚µã‚¤ã‚ºã¨ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼ãƒ•ãƒ©ã‚°ã§ãƒãƒƒãƒ•ã‚¡ç”¨ã® ID3D12Resource ã‚’ä½œæˆã—ã€ComPtr<ID3D12Resource> ã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
/// </summary>
/// <param name="device">ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
/// <param name="sizeInBytes">ä½œæˆã™ã‚‹ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆå˜ä½ï¼‰ã€‚</param>
/// <param name="format">ãƒªã‚½ãƒ¼ã‚¹ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æŒ‡å®šã—ã¾ã™ã€‚æ—¢å®šå€¤ã¯ DXGI_FORMAT_UNKNOWNï¼ˆæœªæŒ‡å®šï¼‰ã€‚</param>
/// <param name="flags">ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã«ä½¿ç”¨ã™ã‚‹ D3D12_RESOURCE_FLAGSã€‚æ—¢å®šå€¤ã¯ D3D12_RESOURCE_FLAG_NONEã€‚</param>
/// <returns>ä½œæˆã•ã‚ŒãŸ ID3D12Resource ã‚’æ‰€æœ‰ã™ã‚‹ ComPtrã€‚ä½œæˆã«å¤±æ•—ã—ãŸå ´åˆã¯ nullptr ã«ãªã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
ComPtr<ID3D12Resource> CreateBufferResourceComPtr(
	ID3D12Device* device, 
	size_t sizeInBytes, 
	DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN, 
	D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE);



============================================================
File Path: Project/Engine/DataInfo/InputData.h
============================================================
#pragma once
/// ===Include=== ///
#define DIRECTINPUT_VERSION   0x0800   // DirectInputã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
#include <dinput.h>
#include <XInput.h>
#include <Windows.h>

#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")
#pragma comment(lib, "xinput.lib")

/// ===ãƒã‚¦ã‚¹ã®ã‚­ãƒ¼ã‚’æŒ‡å®šã™ã‚‹ç‚ºã®åˆ—æŒ™å‹=== ///
enum class MouseButtonType {
	Left,       // å·¦ã‚¯ãƒªãƒƒã‚¯
	Right,      // å³ã‚¯ãƒªãƒƒã‚¯
	Scroll,     // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³
	Button1,    // ãƒœã‚¿ãƒ³1
};

/// ===ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚­ãƒ¼ã‚’æŒ‡å®šã™ã‚‹ãŸã‚ã®åˆ—æŒ™å‹=== ///
enum class ControllerButtonType {
	A,          // Aãƒœã‚¿ãƒ³
	B,          // Bãƒœã‚¿ãƒ³
	X,          // Xãƒœã‚¿ãƒ³
	Y,          // Yãƒœã‚¿ãƒ³
	RB,         // RBãƒœã‚¿ãƒ³
	RT,         // RTãƒœã‚¿ãƒ³
	LB,         // LBãƒœã‚¿ãƒ³
	LT,         // LTãƒœã‚¿ãƒ³
	LeftStick,  // LeftStickæŠ¼ã—è¾¼ã¿
	RightStick, // RightStickæŠ¼ã—è¾¼ã¿
	DPadUP,     // åå­—ã‚­ãƒ¼ä¸Š 
	DPadDOWN,   // åå­—ã‚­ãƒ¼ä¸‹
	DPadLEFT,   // åå­—ã‚­ãƒ¼å·¦
	DPadRIGHT,  // åå­—ã‚­ãƒ¼å³
};

/// ===ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ³ã‚’ãˆã‚‹ãŸã‚ã®åˆ—æŒ™å‹=== ///
enum class ControllerValueType {
	LX, // å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯Xè»¸
	LY, // å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯Yè»¸
	RX, // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯Xè»¸
	RY, // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯Yè»¸
};

/// ===ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®å‡¦ç†ã‚’ç®¡ç†ã™ã‚‹ãŸã‚ã®æ§‹é€ ä½“=== ///
struct StickState {
	float x;
	float y;
};

============================================================
File Path: Project/Engine/DataInfo/LevelData.h
============================================================
#pragma once
#include <string>
#include <vector>

#include "Math/Vector3.h"

/// ===LevelData=== ///
struct LevelData {

	/// ===ClassType=== ///
	enum class ClassTypeLevel {
		None,
		Player1,
		Player2,
		Enemy1,
		Enemy2,
		Enemy3,
		Enemy4,
		Enemy5,
		Enemy6,
		Enemy7,
		Enemy8,
		Enemy9,
		Enemy10,
		Object1,
		Object2,
		Object3,
		Object4,
		Object5,
		Object6,
		Object7,
		Object8,
		Object9,
		Object10,
		Ground1,
		Ground2,
		Ground3,
		Ground4,
		Ground5,
		Ground6,
		Ground7,
		Ground8,
		Ground9,
		Ground10,
		SkyBox1,
		SkyBox2,
		SkyBox3,
		SkyBox4,
		SkyBox5,
		SkyBox6,
		SkyBox7,
		SkyBox8,
		SkyBox9,
		SkyBox10,
	};

	/// ===ColliderType=== ///
	enum class ColliderTypeLevel {
		None,
		Sphere,
		AABB,
		OBB,
	};

	/// ===JSONObjectData=== ///
	struct JsonObjectData {
		std::string fileName;			// ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«å
		ClassTypeLevel classType;		// ã‚¯ãƒ©ã‚¹ç¨®é¡
		ColliderTypeLevel colliderType; // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ç¨®é¡
		Vector3 translation;			// åº§æ¨™
		Vector3 rotation;				// å›è»¢
		Vector3 scaling;				// ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
		Vector3 colliderInfo1;			// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼æƒ…å ±A
		Vector3 colliderInfo2;			// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼æƒ…å ±B
	};

	// vectoré…åˆ—
	std::vector<JsonObjectData> objects;
};

============================================================
File Path: Project/Engine/DataInfo/LightData.h
============================================================
#pragma once
#include "Math/Vector3.h"
#include "Math/Vector4.h"
#include <string>

/// ===Lightã®ç¨®é¡ã®enum=== ///
enum class LightType {
	Lambert,
	HalfLambert,
	PointLight,
	SpotLight,
	None
};

/// ===DirectionalLight=== ///
struct DirectionalLightInfo {
	Vector4 color;		// ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 direction;	// ãƒ©ã‚¤ãƒˆã®å‘ã
	float intensity;	// ãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•(è¼åº¦)
};
/// ===ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆ=== ///
struct PointLightInfo {
	Vector4 color; 		// ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 position;	// ãƒ©ã‚¤ãƒˆã®ä½ç½®
	float intensity;	// ãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•(è¼åº¦)
	float radius;		// ãƒ©ã‚¤ãƒˆã®åŠå¾„
	float decay;		// æ¸›è¡°ç‡
};
/// ===ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆ=== ///
struct SpotLightInfo {
	Vector4 color; 		// ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 position;	// ãƒ©ã‚¤ãƒˆã®ä½ç½®
	float intensity;	// ãƒ©ã‚¤ãƒˆã®æ˜ã‚‹ã•(è¼åº¦)
	Vector3 direction;	// ãƒ©ã‚¤ãƒˆã®å‘ã
	float distance;		// ãƒ©ã‚¤ãƒˆã®è·é›¢
	float decay;		// æ¸›è¡°ç‡
	float cosAngle;		// ã‚³ã‚µã‚¤ãƒ³è§’åº¦(ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®è§’åº¦)
};
/// ===LightInfo=== ///
struct LightInfo {
	float shininess; 				  // å…‰æ²¢åº¦
	DirectionalLightInfo directional; // å¹³è¡Œå…‰æºã®æƒ…å ±
	PointLightInfo point; 			  // ãƒã‚¤ãƒ³ãƒˆãƒ©ã‚¤ãƒˆã®æƒ…å ±
	SpotLightInfo spot; 			  // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆã®æƒ…å ±
};
/// ===EnvironmentMapInfo=== ///
struct EnvironmentMapInfo {
	std::string textureName; // ç’°å¢ƒãƒãƒƒãƒ—ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£å
	bool isEnvironmentMap; // ç’°å¢ƒãƒãƒƒãƒ—ã®æœ‰åŠ¹/ç„¡åŠ¹
	float strength;      // ç’°å¢ƒãƒãƒƒãƒ—ã®å¼·åº¦
};

============================================================
File Path: Project/Engine/DataInfo/LineObjectData.h
============================================================
#pragma once
/// ===Include=== ///
#include "Math/Matrix4x4.h"
#include "Math/Vector3.h"
#include "Math/Vector4.h"

struct LineVertexData3D {
	Vector3 position;
	Vector4 color;
};

struct LineTransformMatrixData3D {
	Matrix4x4 WVP;
};

struct BezierControlPointData {
	Vector3 position;
	float time;
};


============================================================
File Path: Project/Engine/DataInfo/OceanData.h
============================================================
#pragma once
#include "Math/Vector2.h"
#include "Math/Vector3.h"

///=====================================================/// 
/// Ocean Shaderç”¨ãƒ‡ãƒ¼ã‚¿æ§‹é€ 
///=====================================================///

const int kWaveCount_ = 3; // ä½¿ç”¨ã™ã‚‹æ³¢ã®æ•°

/// <summary>
/// æ³¢æƒ…å ±æ§‹é€ ä½“ï¼ˆã‚²ãƒ«ã‚¹ãƒˆãƒŠãƒ¼æ³¢ç”¨ï¼‰
/// </summary>
struct OceanShaderInfo {
    Vector3 distance;   // æ³¢ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
    float amplitude;    // æ³¢ã®æŒ¯å¹…
    float length;       // æ³¢ã®æ³¢é•·
    float speed;        // æ³¢ã®é€Ÿåº¦
    float time;         // æ™‚é–“
    float padding;      // ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆç”¨ï¼ˆ16ãƒã‚¤ãƒˆå¢ƒç•Œï¼‰
};

/// <summary>
/// æ³¢ç´‹æƒ…å ±æ§‹é€ ä½“
/// </summary>
struct RippleInfo {
    Vector2 position;   // æ³¢ç´‹ã®ä¸­å¿ƒä½ç½®(XZå¹³é¢)
    float startTime;    // æ³¢ç´‹ã®é–‹å§‹æ™‚é–“
    float intensity;    // æ³¢ç´‹ã®å¼·åº¦
    float duration;     // æ³¢ç´‹ã®æŒç¶šæ™‚é–“
    float maxRadius;    // æ³¢ç´‹ã®æœ€å¤§åŠå¾„
    float speed;        // æ³¢ç´‹ã®æ‹¡æ•£é€Ÿåº¦
    float padding;      // ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆç”¨
};

/// <summary>
/// æ³¢ç´‹ãƒ‡ãƒ¼ã‚¿ï¼ˆCPUå´ç®¡ç†ç”¨ï¼‰
/// </summary>
struct RippleData {
    Vector2 position;
    float startTime;
    float intensity;
    float duration;
    float maxRadius;
    float speed;
    int priority;       // å„ªå…ˆåº¦ï¼ˆæ–°ã—ã„ã»ã©é«˜ã„ï¼‰
    bool isActive;
};

/// <summary>
/// æ³¢ç´‹ãƒãƒƒãƒ•ã‚¡ï¼ˆGPUé€ä¿¡ç”¨ï¼‰
/// </summary>
struct RippleBufferForGPU {
    RippleInfo ripples[8];  // æœ€å¤§8ã¤ã®æ³¢ç´‹
    int activeCount;        // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªæ³¢ç´‹ã®æ•°
    float currentTime;      // ç¾åœ¨æ™‚åˆ»
    float rippleSpeed;      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ‹¡æ•£é€Ÿåº¦
    float rippleDecay;      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ¸›è¡°ç‡
};

/// <summary>
/// æµ·ã®è‰²æƒ…å ±
/// </summary>
struct OceanColorInfo {
    Vector3 seaBase;        // åŸºæœ¬ã®æµ·ã®è‰²
    float padding1;
    Vector3 seaShallow;     // æµ…ç€¬ã®è‰²
    float padding2;
    Vector3 sky;            // ç©ºã®è‰²
    float padding3;
    Vector3 deepWater;      // æ·±æµ·ã®è‰²
    float baseStrength;     // è‰²ã®å¼·åº¦
    float heightOffset;     // æ³¢ã®é«˜ã•ã«åŸºã¥ã„ãŸè‰²ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    float waterClarity;     // æ°´ã®é€æ˜åº¦
    float foamThreshold;    // æ³¡ã®é–¾å€¤
};

/// <summary>
/// Compute Shaderå‡ºåŠ›ç”¨é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
/// </summary>
struct WaveVertexData {
    Vector3 position;   // æ³¢ã®å½±éŸ¿ã‚’å—ã‘ãŸä½ç½®
    Vector3 normal;     // è¨ˆç®—ã•ã‚ŒãŸæ³•ç·š
    Vector2 worldXZ;    // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã®XZ
    float padding;      // ã‚¢ãƒ©ã‚¤ãƒ¡ãƒ³ãƒˆç”¨
};

============================================================
File Path: Project/Engine/DataInfo/OffScreenData.h
============================================================
#pragma once
/// ===ã‚¿ã‚¤ãƒ—=== ///
enum class OffScreenType {
	CopyImage,
	Grayscale,
	Vignette,
	BoxFilter3x3,
	BoxFilter5x5,
	RadiusBlur,
	OutLine,
	Dissolve,
	ShatterGlass,
};

============================================================
File Path: Project/Engine/DataInfo/ParticleData.h
============================================================
#pragma once
#include "Engine/DataInfo/CData.h"

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å½¢çŠ¶ã‚¿ã‚¤ãƒ—
///=====================================================///
enum class shapeType {
	kCircle,    // å††
	kCylinder,  // å††æŸ±
	kNone,      // ãªã—ï¼ˆé€šå¸¸ã®ãƒ—ãƒ¬ãƒ¼ãƒ³ï¼‰
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰
/// â€»æ—¢å­˜ã®BlendModeã¨é‡è¤‡ã™ã‚‹å ´åˆã¯å‰Šé™¤
///=====================================================///
enum class ParticleBlendMode {
	kNormal,    // é€šå¸¸
	kAdd,       // åŠ ç®—
	kSubtract,  // æ¸›ç®—
	kMultiply,  // ä¹—ç®—
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‡ãƒ¼ã‚¿ï¼ˆå®Ÿè¡Œæ™‚ï¼‰
///=====================================================///
struct ParticleData {
	EulerTransform transform;  // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	Vector3 velocity;          // é€Ÿåº¦
	Vector4 color;             // è‰²
	float lifeTime;            // å¯¿å‘½
	float currentTime;         // çµŒéæ™‚é–“
	Vector3 rotationSpeed;     // å›è»¢é€Ÿåº¦
	Vector3 initialScale;      // åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«
	Vector4 initialColor;      // åˆæœŸè‰²
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«GPUé€ä¿¡ç”¨ãƒ‡ãƒ¼ã‚¿
///=====================================================///
struct ParticleForGPU {
	Matrix4x4 WVP;    // ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	Matrix4x4 World;  // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
	Vector4 color;    // è‰²
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç‰©ç†è¨­å®š
///=====================================================///
struct ParticlePhysicsSettings {
	Vector3 velocityMin = { -1.0f, 1.0f, -1.0f };      // é€Ÿåº¦ã®æœ€å°å€¤
	Vector3 velocityMax = { 1.0f, 5.0f, 1.0f };        // é€Ÿåº¦ã®æœ€å¤§å€¤
	Vector3 acceleration = { 0.0f, 0.0f, 0.0f };       // åŠ é€Ÿåº¦
	float gravity = 0.0f;                              // é‡åŠ›
    Vector3 explosionRange = { 1.0f, 1.0f, 1.0f };     // ç™ºç”Ÿç¯„å›²ï¼ˆXã€Yã€Zè»¸ï¼‰
	float upwardForce = 0.0f;                          // ä¸Šæ–¹å‘ã®åŠ›
	bool useRandomVelocity = true;                     // ãƒ©ãƒ³ãƒ€ãƒ é€Ÿåº¦ã‚’ä½¿ç”¨
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è¦‹ãŸç›®è¨­å®š
///=====================================================///
struct ParticleAppearanceSettings {
	Vector4 startColor = { 1.0f, 1.0f, 1.0f, 1.0f };  // é–‹å§‹è‰²
	Vector4 endColor = { 1.0f, 1.0f, 1.0f, 0.0f };    // çµ‚äº†è‰²
	Vector3 startScaleMin = { 1.0f, 1.0f, 1.0f };     // é–‹å§‹ã‚¹ã‚±ãƒ¼ãƒ«æœ€å°
	Vector3 startScaleMax = { 1.0f, 1.0f, 1.0f };     // é–‹å§‹ã‚¹ã‚±ãƒ¼ãƒ«æœ€å¤§
	Vector3 endScale = { 0.5f, 0.5f, 0.5f };          // çµ‚äº†ã‚¹ã‚±ãƒ¼ãƒ«
	std::string texturePath = "";                     // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‘ã‚¹
	bool useColorGradient = false;                    // è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä½¿ç”¨
	bool useScaleAnimation = false;                   // ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä½¿ç”¨
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å›è»¢è¨­å®š
///=====================================================///
struct ParticleRotationSettings {
	Vector3 initialRotationMin = { 0.0f, 0.0f, 0.0f }; // åˆæœŸå›è»¢æœ€å°
	Vector3 initialRotationMax = { 0.0f, 0.0f, 0.0f }; // åˆæœŸå›è»¢æœ€å¤§
	Vector3 rotationSpeedMin = { 0.0f, 0.0f, 0.0f };  // å›è»¢é€Ÿåº¦æœ€å°
	Vector3 rotationSpeedMax = { 0.0f, 0.0f, 0.0f };  // å›è»¢é€Ÿåº¦æœ€å¤§
	bool randomRotation = false;                      // ãƒ©ãƒ³ãƒ€ãƒ å›è»¢ã‚’ä½¿ç”¨
	bool enableRotation = false;                      // å›è»¢ã‚’æœ‰åŠ¹åŒ–
	bool randomInitialRotation = false;               // ãƒ©ãƒ³ãƒ€ãƒ åˆæœŸå›è»¢ã‚’ä½¿ç”¨
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿè¨­å®š
///=====================================================///
struct ParticleEmissionSettings {
	float lifetimeMin = 1.0f;                          // å¯¿å‘½æœ€å°å€¤
	float lifetimeMax = 2.0f;                          // å¯¿å‘½æœ€å¤§å€¤
	float emissionRate = 10.0f;                        // ç™ºç”Ÿãƒ¬ãƒ¼ãƒˆï¼ˆç§’é–“ç™ºç”Ÿæ•°ï¼‰
	uint32_t burstCount = 0;                           // ãƒãƒ¼ã‚¹ãƒˆæ•°ï¼ˆ0ãªã‚‰é€£ç¶šç™ºç”Ÿï¼‰
	float frequency = 0.5f;                            // ç™ºç”Ÿé »åº¦ï¼ˆç§’ï¼‰
	bool isBurst = false;                              // ãƒãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‹•ä½œè¨­å®š
///=====================================================///
struct ParticleMotionSettings {
    // æ¸¦å·»ãè¨­å®š
    bool enableSwirling = false;           // æ¸¦å·»ãé‹å‹•ã‚’æœ‰åŠ¹åŒ–
    float swirlingSpeed = 3.0f;            // æ¸¦å·»ãé€Ÿåº¦
    float expansionRate = 0.8f;            // æ‹¡æ•£é€Ÿåº¦

    // è»Œè·¡è¿½å¾“è¨­å®š
    bool followEmitter = false;            // ã‚¨ãƒŸãƒƒã‚¿ã«è¿½å¾“ã™ã‚‹ã‹
    float followStrength = 1.0f;           // è¿½å¾“å¼·åº¦(0.0~1.0)

    // å›è»¢å½±éŸ¿è¨­å®š
    bool useRotationInfluence = false;     // ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢å½±éŸ¿ã‚’å—ã‘ã‚‹ã‹
    float rotationInfluence = 1.2f;        // å›è»¢é€Ÿåº¦ã®å½±éŸ¿ä¿‚æ•°

    // é€Ÿåº¦æ¸›è¡°
    float velocityDamping = 0.95f;         // é€Ÿåº¦æ¸›è¡°ç‡(0.0~1.0)

    // ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰å›è»¢
    bool enableBillboardRotation = false;   // ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰å›è»¢ã‚’æœ‰åŠ¹åŒ–
    float billboardRotationSpeed = 3.0f;   // ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰å›è»¢é€Ÿåº¦
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿãƒ‘ã‚¿ãƒ¼ãƒ³è¨­å®š
///=====================================================///
struct ParticleEmissionPattern {
    enum class Pattern {
        Point,          // ç‚¹ã‹ã‚‰ç™ºç”Ÿ
        Sphere,         // çƒçŠ¶ã«ç™ºç”Ÿ
        Cone,           // å††éŒçŠ¶ã«ç™ºç”Ÿ
        Trail,          // è»Œè·¡ã¨ã—ã¦ç™ºç”Ÿ
        Ring,           // ãƒªãƒ³ã‚°çŠ¶ã«ç™ºç”Ÿ
        Burst           // çˆ†ç™ºçš„ã«ç™ºç”Ÿ
    };

    Pattern pattern = Pattern::Sphere;
    float patternRadius = 0.25f;           // ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åŠå¾„
    float patternAngle = 0.0f;            // å††éŒã®è§’åº¦(åº¦)
    int particlesPerEmit = 5;             // 1å›ã®ç™ºç”Ÿã§ã®ç²’å­æ•°
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚«ãƒ©ãƒ¼ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
///=====================================================///
struct ParticleColorGradient {
    bool useGradient = false;              // ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã™ã‚‹ã‹
    Vector4 primaryColor = { 0.2f, 0.8f, 1.0f, 1.0f };    // ä¸»è¦è‰²
    Vector4 secondaryColor = { 1.0f, 0.9f, 0.3f, 1.0f };  // ã‚»ã‚«ãƒ³ãƒ€ãƒªè‰²
    float colorBlendCurve = 1.0f;          // ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚«ãƒ¼ãƒ–(1.0=ç·šå½¢)
    bool oscillateColor = false;           // è‰²ã‚’æŒ¯å‹•ã•ã›ã‚‹ã‹
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®š
///=====================================================///
struct ParticleScaleAnimation {
    enum class AnimationType {
        None,           // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—
        Linear,         // ç·šå½¢
        EaseIn,         // å¾ã€…ã«å¤§ãã
        EaseOut,        // å¾ã€…ã«å°ã•ã
        Bounce,         // è†¨ã‚‰ã‚“ã§ç¸®ã‚€
        Pulse           // è„ˆå‹•
    };

    AnimationType type = AnimationType::Bounce;
    float startScale = 0.3f;               // é–‹å§‹ã‚¹ã‚±ãƒ¼ãƒ«
    float maxScale = 1.5f;                 // æœ€å¤§ã‚¹ã‚±ãƒ¼ãƒ«
    float endScale = 0.1f;                 // çµ‚äº†ã‚¹ã‚±ãƒ¼ãƒ«
};

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«é«˜åº¦è¨­å®š
///-------------------------------------------///
struct ParticleAdvancedSettings {
    ParticleMotionSettings motion;
    ParticleEmissionPattern emissionPattern;
    ParticleColorGradient colorGradient;
    ParticleScaleAnimation scaleAnimation;

    // è»Œè·¡ç‰¹æœ‰ã®è¨­å®š
    bool isTrajectoryParticle = false;     // è»Œè·¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ¢ãƒ¼ãƒ‰
    float trailSpacing = 0.008f;           // è»Œè·¡ã®é–“éš”(ç§’)
    bool clearOnStop = true;               // åœæ­¢æ™‚ã«ã‚¯ãƒªã‚¢ã™ã‚‹ã‹
};

============================================================
File Path: Project/Engine/DataInfo/PipelineStateObjectType.h
============================================================
#pragma once
/// ===include=== ///
#include "Engine/DataInfo/BlendModeData.h"

///-------------------------------------------/// 
/// PipelineType
///-------------------------------------------///
enum PipelineType {
	// === GraphicsPipelines === //
	// å‰æ™¯2D
	ForGround2D,
	// èƒŒæ™¯2D
	BackGround2D,
	// CircularGauge(Sprite)
	CircularGauge2D,
	// 3D
	Obj3D,
	// SkyBox
	PrimitiveSkyBox,
	// Ocean
	PrimitiveOcean,
	// Particle
	Particle,
	// Skinning3D
	Skinning3D,
	// Line3D
	Line3D,
	// OffScreen
	OffScreen,
	// Grayscale
	Grayscale,
	// Vignette
	Vignette,
	// Dissolve
	Dissolve,
	// BoxFilter3x3
	BoxFilter3x3,
	// BoxFilter5x5
	BoxFilter5x5,
	// RadiusBlur
	RadiusBlur,
	// OutLine
	OutLine,
	// ShatterGlass
	ShatterGlass,

	// === ComputePipelines === //
	CSOcean,

	// ç·æ•°(ã“ã‚Œã¯æœ€å¾Œã«ã—ãªã‘ã‚Œã°ã„ã‘ãªã„)
	CountOfPipelineType,
};

// åˆ—æŒ™å‹ã®å…¨å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°
constexpr std::array<PipelineType, static_cast<size_t>(PipelineType::CountOfPipelineType)> AllPipelineTypes() {
	return {
		// Graphics Pipelines
		PipelineType::ForGround2D,
		PipelineType::BackGround2D,
		PipelineType::CircularGauge2D,
		PipelineType::Obj3D,
		PipelineType::PrimitiveSkyBox,
		PipelineType::Particle ,
		PipelineType::Skinning3D,
		PipelineType::PrimitiveOcean,
		PipelineType::Line3D,
		PipelineType::OffScreen,
		PipelineType::Grayscale,
		PipelineType::Vignette,
		PipelineType::Dissolve,
		PipelineType::BoxFilter3x3,
		PipelineType::BoxFilter5x5,
		PipelineType::RadiusBlur,
		PipelineType::OutLine,
		PipelineType::ShatterGlass,
		// Compute Pipelines
		PipelineType::CSOcean
	};
}

// Computeãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
inline bool IsComputePipeline(PipelineType type) {
	switch (type) {
		/// ===Compute Pipelines=== ///
	case PipelineType::CSOcean:
		return true;
		/// ===Graphics Pipelines=== ///
	case PipelineType::ForGround2D:
	case PipelineType::BackGround2D:
	case PipelineType::CircularGauge2D:
	case PipelineType::Obj3D:
	case PipelineType::Skinning3D:
	case PipelineType::PrimitiveSkyBox:
	case PipelineType::Particle:
	case PipelineType::PrimitiveOcean:
	case PipelineType::Line3D:
	case PipelineType::OffScreen:
	case PipelineType::Grayscale:
	case PipelineType::Vignette:
	case PipelineType::Dissolve:
	case PipelineType::BoxFilter3x3:
	case PipelineType::BoxFilter5x5:
	case PipelineType::RadiusBlur:
	case PipelineType::OutLine:
	case PipelineType::ShatterGlass:
		return false;

	default:
		return false;
	}
}

============================================================
File Path: Project/Engine/DataInfo/SceneType.h
============================================================
#pragma once
///=====================================================/// 
/// ã‚·ãƒ¼ãƒ³ã®åæ‰€
///=====================================================///
enum class SceneType {
	Title,
	Select,
	Game,
	Clear,
	GameOver,
	ParticleEditor,
	AttackEditor,
};

============================================================
File Path: Project/Engine/Graphics/2d/Base/IndexBuffer2D.cpp
============================================================
#include "IndexBuffer2D.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
IndexBuffer2D::~IndexBuffer2D() { buffer_.Reset(); }

///-------------------------------------------/// 
///ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
///-------------------------------------------///
void IndexBuffer2D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* IndexBuffer2D::GetBuffer() { return buffer_.Get(); }
uint32_t* IndexBuffer2D::GetData() { return data_; }


============================================================
File Path: Project/Engine/Graphics/2d/Base/IndexBuffer2D.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// IndexBuffer2D
///=====================================================///
class IndexBuffer2D {
public:

	IndexBuffer2D() = default;
	~IndexBuffer2D();

	/// <summary>
	/// Resourceã®ç”Ÿæˆ
	/// </summary>
	/// <param name="device"></param>
	/// <param name="sizeInBytes"></param>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	uint32_t* GetData();

private:

	ComPtr<ID3D12Resource> buffer_;

	uint32_t* data_;
};



============================================================
File Path: Project/Engine/Graphics/2d/Base/Material2D.cpp
============================================================
#include "Material2D.h"
// Math
#include "Math/sMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Material2D::~Material2D() { buffer_.Reset(); }

///-------------------------------------------/// 
/// ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
///-------------------------------------------///
void Material2D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* Material2D::GetBuffer() {return buffer_.Get();}
MaterialData2D* Material2D::GetData() {return data_;}


============================================================
File Path: Project/Engine/Graphics/2d/Base/Material2D.h
============================================================
#pragma once
/// ===include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// Material2D
///=====================================================///
class Material2D {
public:

	Material2D() = default;
	~Material2D();

	/// <summary>
	///ã€€ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	MaterialData2D* GetData();

private:
	// ãƒªã‚½ãƒ¼ã‚¹
	
	ComPtr<ID3D12Resource> buffer_;

	// ãƒ‡ãƒ¼ã‚¿
	MaterialData2D* data_;
};



============================================================
File Path: Project/Engine/Graphics/2d/Base/Object2DCommon.cpp
============================================================
#include "Object2DCommon.h"
// Math
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Object2DCommon::Object2DCommon() = default;
Object2DCommon::~Object2DCommon() {
	material_.reset();
	wvp_.reset();
}

///-------------------------------------------/// 
/// MaterialBufferã®åˆæœŸåŒ–
///-------------------------------------------///
void Object2DCommon::MaterialInitialize(ID3D12Device* device, uint32_t size) {
	// ç”Ÿæˆ
	material_ = std::make_unique<Material2D>();
	// buffer
	material_->Create(device, sizeof(MaterialData2D) * size);
	material_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&materialData_));
	materialData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	materialData_->uvTransform = Math::MakeIdentity4x4();
}

///-------------------------------------------/// 
/// WVPBufferã®åˆæœŸåŒ–
///-------------------------------------------///
void Object2DCommon::WVPMatrixInitialize(ID3D12Device* device) {
	// ç”Ÿæˆ
	wvp_ = std::make_unique<Transform2D>();
	// buffer
	wvp_->Create(device, sizeof(TransformationMatrix2D));
	wvp_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&wvpMatrixData_));
	wvpMatrixData_->WVP = Math::MakeIdentity4x4();
}

///-------------------------------------------/// 
/// CommandListã®è¨­å®š
///-------------------------------------------///
void Object2DCommon::Bind(ID3D12GraphicsCommandList* commandList) {

	// Materialã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(0, material_->GetBuffer()->GetGPUVirtualAddress());
	// wvpMatrixBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(1, wvp_->GetBuffer()->GetGPUVirtualAddress());
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void Object2DCommon::SetMateiralData(const Vector4& color, const Matrix4x4& uvTransform) {
	materialData_->color = color;
	materialData_->uvTransform = uvTransform;
}
void Object2DCommon::SetWVPData(const Matrix4x4& WVP) {
	wvpMatrixData_->WVP = WVP;
}


============================================================
File Path: Project/Engine/Graphics/2d/Base/Object2DCommon.h
============================================================
#pragma once
/// ===include=== ///
// Engine
#include "Material2D.h"
#include "Transform2D.h"
//c++
#include <memory>

///=====================================================/// 
/// Object2Då…±é€šéƒ¨
///=====================================================///
class Object2DCommon {
public:

	Object2DCommon();
	~Object2DCommon();

	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ Direct3D 12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã® ID3D12Device ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="Size">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆæ•°ã‚„è¦ç´ æ•°ãªã©ã€å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ï¼‰ã€‚</param>
	void MaterialInitialize(ID3D12Device* device, uint32_t Size);

	/// <summary>
	/// WVPï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ»ãƒ“ãƒ¥ãƒ¼ãƒ»ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³ï¼‰è¡Œåˆ—ã«é–¢ã™ã‚‹å†…éƒ¨ãƒªã‚½ãƒ¼ã‚¹ã®åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">WVP è¡Œåˆ—ã®åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ Direct3D 12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void WVPMatrixInitialize(ID3D12Device* device);

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">ãƒã‚¤ãƒ³ãƒ‰å¯¾è±¡ã®ID3D12GraphicsCommandListã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒã‚¤ãƒ³ãƒ‰å‡¦ç†ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Bind(ID3D12GraphicsCommandList* commandList);

public:/// ===Setter=== ///
	// Mateial
	void SetMateiralData(const Vector4& color, const Matrix4x4& uvTransform);
	// WVP
	void SetWVPData(const Matrix4x4& WVP);

private:/// ===Variables(å¤‰æ•°)=== ///

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	std::unique_ptr<Material2D> material_;
	std::unique_ptr<Transform2D> wvp_;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	MaterialData2D* materialData_ = nullptr;
	TransformationMatrix2D* wvpMatrixData_ = nullptr;
};




============================================================
File Path: Project/Engine/Graphics/2d/Base/Transform2D.cpp
============================================================
#include "Transform2D.h"
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Transform2D::~Transform2D() { buffer_.Reset(); }

///-------------------------------------------/// 
/// ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
///-------------------------------------------///
void Transform2D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Transform2D::WriteData(TransformationMatrix2D* data) {
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	buffer_->Map(0, nullptr, reinterpret_cast<void**>(&data_));

	data_ = data;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* Transform2D::GetBuffer() { return buffer_.Get(); }
TransformationMatrix2D* Transform2D::GetData() { return data_; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void Transform2D::SetData(TransformationMatrix2D* data) { data_ = data; }




============================================================
File Path: Project/Engine/Graphics/2d/Base/Transform2D.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// Transform2D
///=====================================================///
class Transform2D {
public:

	Transform2D() = default;
	~Transform2D();

	/// <summary>
	/// Resourceã®ç”Ÿæˆ
	/// </summary>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	/// </summary>
	/// <param name="transform"></param>
	void WriteData(TransformationMatrix2D* data);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	TransformationMatrix2D* GetData();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetData(TransformationMatrix2D* data);

private:

	ComPtr<ID3D12Resource> buffer_;

	TransformationMatrix2D* data_;
};



============================================================
File Path: Project/Engine/Graphics/2d/Base/VertexBuffer2D.cpp
============================================================
#include "VertexBuffer2D.h"

#include <cassert>

VertexBuffer2D::~VertexBuffer2D() { buffer_.Reset(); }

///-------------------------------------------/// 
/// ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
///-------------------------------------------///
void VertexBuffer2D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void VertexBuffer2D::WriteData(VertexData2D* data) {
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	buffer_->Map(0, nullptr, reinterpret_cast<void**>(&data_));

	data_ = data;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* VertexBuffer2D::GetBuffer() { return buffer_.Get(); }
VertexData2D* VertexBuffer2D::GetData() {return data_;}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void VertexBuffer2D::SetData(VertexData2D* data) { data_ = data; }




============================================================
File Path: Project/Engine/Graphics/2d/Base/VertexBuffer2D.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// VertexBuffer2D
///=====================================================///
class VertexBuffer2D {
public:

	VertexBuffer2D() = default;
	~VertexBuffer2D();

	/// <summary>
	/// Resourceã®ç”Ÿæˆ
	/// </summary>
	/// <param name="device"></param>
	/// <param name="sizeInBytes"></param>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	/// </summary>
	/// <param name="transform"></param>
	void WriteData(VertexData2D* data);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	VertexData2D* GetData();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetData(VertexData2D* data);

private:

	ComPtr<ID3D12Resource> buffer_;

	VertexData2D* data_;
};



============================================================
File Path: Project/Engine/Graphics/2d/Sprite/SpriteCommon.cpp
============================================================
#include "SpriteCommon.h"
// c++
#include <cassert>
// Engine
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
// Math
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
SpriteCommon::~SpriteCommon() {
	vertex_.reset();
	index_.reset();
	common_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void SpriteCommon::Initialize(const std::string textureFilePath) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12Device* device = GraphicsResourceGetter::GetDXDevice();

	/// ===ãƒ†ã‚¯ã‚¹ãƒãƒ£=== ///
	filePath_ = textureFilePath;
	AdjustTextureSize(textureFilePath);

	/// ===ç”Ÿæˆ=== ///
	vertex_ = std::make_unique<VertexBuffer2D>();
	index_ = std::make_unique<IndexBuffer2D>();
	common_ = std::make_unique<Object2DCommon>();

	/// ===vertex=== ///
	// buffer
	vertex_->Create(device, sizeof(VertexData2D) * vertexSize_);
	vertex_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&vertexData_));
	// view
	vertexBufferView_.BufferLocation = vertex_->GetBuffer()->GetGPUVirtualAddress(); // å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ç”¨
	vertexBufferView_.SizeInBytes = sizeof(VertexData2D) * vertexSize_; // ä½¿ç”¨ã™ã‚‹ã‚µã‚¤ã‚ºï¼ˆé ‚ç‚¹6ã¤åˆ†ï¼‰
	vertexBufferView_.StrideInBytes = sizeof(VertexData2D); // ï¼‘é ‚ç‚¹å½“ãŸã‚Šã®ã‚µã‚¤ã‚º
	// Dataæ›¸ãè¾¼ã¿(åˆæœŸ)
	VertexDataWrite();

	/// ===index=== ///
	// buffer
	index_->Create(device, sizeof(uint32_t) * indexSize_);
	index_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&indexData_));
	// view
	indexBufferView_.BufferLocation = index_->GetBuffer()->GetGPUVirtualAddress(); // å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ç”¨
	indexBufferView_.SizeInBytes = sizeof(uint32_t) * indexSize_; // ä½¿ç”¨ã™ã‚‹ã‚µã‚¤ã‚ºï¼ˆï¼–ã¤åˆ†ï¼‰
	indexBufferView_.Format = DXGI_FORMAT_R32_UINT; // uint32_tã¨ã™ã‚‹
	// Dataæ›¸ãè¾¼ã¿(åˆæœŸ)
	IndexDataWrite();

	/// ===ãƒãƒ†ãƒªã‚¢ãƒ«=== ///
	common_->MaterialInitialize(device, materialSize_);

	/// ===wvp=== ///
	common_->WVPMatrixInitialize(device);

	/// ===WorldTransformã®è¨­å®š=== ///
	worldTransform_ = { {1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f, }, { 0.0f, 0.0f, 0.0f } };
}


///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void SpriteCommon::Update() {

	// Dataæ›¸ãè¾¼ã¿(æ›´æ–°)
	MaterialDataWrite();
	TransformDataWrite();
	UpdateVertexDataWrite();
	SpecifyRange();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void SpriteCommon::Draw(GroundType type, BlendMode mode) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12GraphicsCommandList* commandList = GraphicsResourceGetter::GetDXCommandList();

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// PSOã®è¨­å®š
	if (type == GroundType::Front) {
		Render::SetPSO(commandList, PipelineType::ForGround2D, mode);
	} else if (type == GroundType::Back) {
		Render::SetPSO(commandList, PipelineType::BackGround2D, mode);
	}
	// VertexBufferViewã®è¨­å®š
	commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
	// IndexBufferViewã®è¨­å®š
	commandList->IASetIndexBuffer(&indexBufferView_);
	// Materialãƒ»WVPã®è¨­å®š
	common_->Bind(commandList);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
	Render::SetGraphicsRootDescriptorTable(commandList, 2, filePath_);
	// æç”»(ãƒ‰ãƒ­ãƒ¼ã‚³ãƒ¼ãƒ«)
	commandList->DrawIndexedInstanced(6, 1, 0, 0, 0);
}


///-------------------------------------------/// 
/// VertexResourceã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SpriteCommon::VertexDataWrite() {
	// å·¦ä¸‹
	vertexData_[0].position = { 0.0f, 1.0f, 0.0f, 1.0f };
	vertexData_[0].texcoord = { 0.0f, 1.0f };
	// å·¦ä¸Š
	vertexData_[1].position = { 0.0f, 0.0f, 0.0f, 1.0f };
	vertexData_[1].texcoord = { 0.0f, 0.0f };
	// å³ä¸‹
	vertexData_[2].position = { 1.0f, 1.0f, 0.0f, 1.0f };
	vertexData_[2].texcoord = { 1.0f, 1.0f };
	// å³ä¸Š
	vertexData_[3].position = { 1.0f, 0.0f, 0.0f, 1.0f };
	vertexData_[3].texcoord = { 1.0f, 0.0f };
}

///-------------------------------------------/// 
/// IndexResourceã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SpriteCommon::IndexDataWrite() {
	indexData_[0] = 0;
	indexData_[1] = 1;
	indexData_[2] = 2;
	indexData_[3] = 1;
	indexData_[4] = 3;
	indexData_[5] = 2;
}

///-------------------------------------------/// 
/// MaterialDataã¸ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SpriteCommon::MaterialDataWrite() {
	common_->SetMateiralData(
		color_,
		Math::MakeIdentity4x4()
	);
}


///-------------------------------------------/// 
/// TransformDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SpriteCommon::TransformDataWrite() {

	// åº§æ¨™ã®åæ˜ 
	worldTransform_.translate = { position_.x, position_.y, 0.0f };
	// å›è»¢ã®åæ˜ 
	worldTransform_.rotate = { 0.0, 0.0, rotation_ };
	// ã‚µã‚¤ã‚ºã®åæ˜ 
	worldTransform_.scale = { size_.x, size_.y, 1.0f };

	// WorldMatrix
	Matrix4x4 worldMatrix = Math::MakeAffineEulerMatrix(worldTransform_.scale, worldTransform_.rotate, worldTransform_.translate);
	// ViewMatrix
	Matrix4x4 viewMatrix = Math::MakeIdentity4x4();
	// ProjectionMatrix
	Matrix4x4 projectionMatrix = Math::MakeOrthographicMatrix(0.0f, 0.0f, static_cast<float>(GraphicsResourceGetter::GetWindowWidth()), static_cast<float>(GraphicsResourceGetter::GetWindowHeight()), 0.0f, 100.0f);

	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	common_->SetWVPData(Multiply(worldMatrix, Multiply(viewMatrix, projectionMatrix)));
}


///-------------------------------------------///  
/// UpdateVertexDataWrite
///-------------------------------------------///
void SpriteCommon::UpdateVertexDataWrite() {

	float left = 0.0f - anchorPoint_.x;
	float right = 1.0f - anchorPoint_.x;
	float top = 0.0f - anchorPoint_.y;
	float bottom = 1.0f - anchorPoint_.y;

	// å·¦å³åè»¢
	if (isFlipX_) {
		left = -left;
		right = -right;
	}

	// ä¸Šä¸‹åè»¢
	if (isFlipY_) {
		top = -top;
		bottom = -bottom;
	}

	// å·¦ä¸‹
	vertexData_[0].position = { left, bottom, 0.0f, 1.0f };
	// å·¦ä¸Š
	vertexData_[1].position = { left, top, 0.0f, 1.0f };
	// å³ä¸‹
	vertexData_[2].position = { right, bottom, 0.0f, 1.0f };
	// å³ä¸Š
	vertexData_[3].position = { right, top, 0.0f, 1.0f };
}


///-------------------------------------------/// 
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç¯„å›²æŒ‡å®š
///-------------------------------------------///
void SpriteCommon::SpecifyRange() {
	const DirectX::TexMetadata& metadata = GraphicsResourceGetter::GetMetaData(filePath_);
	float tex_left = textureLeftTop_.x / metadata.width;
	float tex_right = (textureLeftTop_.x + textureSize_.x) / metadata.width;
	float tex_top = textureLeftTop_.y / metadata.height;
	float tex_bottom = (textureLeftTop_.y + textureSize_.y) / metadata.height;

	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	vertexData_[0].texcoord = { tex_left, tex_bottom };
	vertexData_[1].texcoord = { tex_left, tex_top };
	vertexData_[2].texcoord = { tex_right, tex_bottom };
	vertexData_[3].texcoord = { tex_right, tex_top };
}


///-------------------------------------------/// 
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã‚’ã‚¤ãƒ¡ãƒ¼ã‚¸ã«åˆã‚ã›ã‚‹
///-------------------------------------------///
void SpriteCommon::AdjustTextureSize(const std::string& filePath) {
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	const DirectX::TexMetadata& metadata = GraphicsResourceGetter::GetMetaData(filePath);

	textureSize_.x = static_cast<float>(metadata.width);
	textureSize_.y = static_cast<float>(metadata.height);

	// ç”»åƒã‚µã‚¤ã‚ºã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
	size_ = textureSize_;
}


============================================================
File Path: Project/Engine/Graphics/2d/Sprite/SpriteCommon.h
============================================================
#pragma once
/// ===include=== ///
// Engine
#include "Engine/Graphics/2d/Base/Object2DCommon.h"
#include "Engine/Graphics/2d/Base/VertexBuffer2D.h"
#include "Engine/Graphics/2d/Base/IndexBuffer2D.h"
// Pipeline
#include "Engine/DataInfo/PipelineStateObjectType.h"

enum class GroundType {
	Front,
	Back
};

///=====================================================/// 
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šéƒ¨
///=====================================================///
class SpriteCommon {
public: /// ===åŸºæœ¬çš„ãªé–¢æ•°=== ///

	SpriteCommon() = default;
	~SpriteCommon();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="textureFilePath">èª­ã¿è¾¼ã‚€ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚é–¢æ•°ã¯ã“ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’èª­ã¿è¾¼ã¿åˆæœŸåŒ–ã‚’è¡Œã„ã¾ã™ã€‚</param>
	virtual void Initialize(const std::string textureFilePath);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="type">æç”»ã™ã‚‹åœ°é¢ã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ï¼ˆGroundTypeï¼‰ã€‚</param>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ï¼ˆBlendModeï¼‰ã€‚</param>
	virtual void Draw(GroundType type, BlendMode mode);

private:/// ===Variables(å¤‰æ•°)=== ///

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	std::unique_ptr<VertexBuffer2D> vertex_;
	std::unique_ptr<IndexBuffer2D> index_;
	std::unique_ptr<Object2DCommon> common_;

	// ã‚µã‚¤ã‚º
	uint32_t vertexSize_ = 6;
	uint32_t indexSize_ = 6;
	uint32_t materialSize_ = 3;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData2D* vertexData_ = nullptr;
	uint32_t* indexData_ = nullptr;

	// ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};
	D3D12_INDEX_BUFFER_VIEW indexBufferView_{};

protected:

	// WorldTransform
	EulerTransform worldTransform_; // Transform(scale, rotate, transform)

	/// ===ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæƒ…å ±=== ///
	std::string filePath_;                       // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
	Vector2 position_ = { 0.0f, 0.0f };          // åº§æ¨™
	float rotation_ = 0.0f;                      // å›è»¢
	Vector2 size_ = { 640.0f, 360.0f };          // ã‚µã‚¤ã‚º
	Vector4 color_ = { 1.0f, 1.0f, 1.0f, 1.0f }; // è‰²
	Vector2 anchorPoint_ = { 0.0f, 0.0f };       // ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	bool isFlipX_ = false;                       // å·¦å³ãƒ•ãƒªãƒƒãƒ—
	bool isFlipY_ = false;                       // ä¸Šä¸‹ãƒ•ãƒªãƒƒãƒ—
	Vector2 textureLeftTop_ = { 0.0f, 0.0f };    // ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Š
	Vector2 textureSize_ = { 100.0f, 100.0f };   // ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º

private:/// ===Functions(é–¢æ•°)=== ///

	/// <summary>
	/// VertexResourceã¸ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void VertexDataWrite();

	/// <summary>
	/// IndexResourceã¸ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void IndexDataWrite();

	/// <summary>
	/// MaterialDataã¸ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void MaterialDataWrite();

	/// <summary>
	/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void TransformDataWrite();

	/// <summary>
	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateVertexDataWrite();

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç¯„å›²æŒ‡å®šå‡¦ç†
	/// </summary>
	void SpecifyRange();

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºã‚’èª¿æ•´å‡¦ç†
	/// </summary>
	/// <param name="filePath">ã‚µã‚¤ã‚ºã‚’èª¿æ•´ã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚</param>
	void AdjustTextureSize(const std::string& filePath);
};



============================================================
File Path: Project/Engine/Graphics/3d/Base/IndexBuffer3D.cpp
============================================================
#include "IndexBuffer3D.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
IndexBuffer3D::~IndexBuffer3D() { buffer_.Reset(); }

///-------------------------------------------/// 
///ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
///-------------------------------------------///
void IndexBuffer3D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* IndexBuffer3D::GetBuffer() { return buffer_.Get(); }
uint32_t* IndexBuffer3D::GetData() { return data_; }

============================================================
File Path: Project/Engine/Graphics/3d/Base/IndexBuffer3D.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// IndexBuffer3D
///=====================================================///
class IndexBuffer3D {
public:

	IndexBuffer3D() = default;
	~IndexBuffer3D();

	/// <summary>
	/// Resourceã®ç”Ÿæˆ
	/// </summary>
	/// <param name="device"></param>
	/// <param name="sizeInBytes"></param>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	uint32_t* GetData();

private:

	ComPtr<ID3D12Resource> buffer_;

	uint32_t* data_;
};



============================================================
File Path: Project/Engine/Graphics/3d/Base/Material3D.cpp
============================================================
#include "Material3D.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Material3D::~Material3D() { buffer_.Reset(); }

///-------------------------------------------/// 
/// ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
///-------------------------------------------///
void Material3D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Material3D::WriteData(MaterialData3D* material) {
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	buffer_->Map(0, nullptr, reinterpret_cast<void**>(&data_));

	// è‰²ã®æ›¸ãè¾¼ã¿
	data_->color = material->color;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* Material3D::GetBuffer() { return buffer_.Get(); }



============================================================
File Path: Project/Engine/Graphics/3d/Base/Material3D.h
============================================================
#pragma once
/// ===include=== ///
// Engine
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// ãƒãƒ†ãƒªã‚¢ãƒ«3D
///=====================================================///
class Material3D {
public:
	
	Material3D() = default;
	~Material3D();

	/// <summary>
	///ã€€ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	/// </summary>
	/// <param name="material"></param>
	void WriteData(MaterialData3D* material);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

private:
	// ãƒªã‚½ãƒ¼ã‚¹
	ComPtr<ID3D12Resource> buffer_;

	// ãƒ‡ãƒ¼ã‚¿
	MaterialData3D* data_;
};



============================================================
File Path: Project/Engine/Graphics/3d/Base/ObjectCommon.cpp
============================================================
#include "ObjectCommon.h"
// Math
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ObjectCommon::ObjectCommon() = default;
ObjectCommon::~ObjectCommon() {
	material_.reset();
	wvp_.reset();
	directionallight_.reset();
	camera3D_.reset();
	pointLight_.reset();
	spotLight_.reset();
	enviromentMap_.reset();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
LightType ObjectCommon::GetLightType() const {
	if (materialData_->enableLighting == 1) {
		return LightType::Lambert;
	} else if (materialData_->enableLighting == 2) {
		return LightType::HalfLambert;
	} else if (materialData_->enableLighting == 3) {
		return LightType::PointLight;
	} else if (materialData_->enableLighting == 4) {
		return LightType::SpotLight;
	} else {
		return LightType::None;
	}
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// mateial
void ObjectCommon::SetMatiarlData(const Vector4& color, const float& shininess, const Matrix4x4& uvTransform) {
	materialData_->color = color;
	materialData_->shininess = shininess;
	materialData_->uvTransform = uvTransform;
}
// wvp
void ObjectCommon::SetTransformData(const Matrix4x4& WVP, const Matrix4x4& World, const Matrix4x4& WorldInverseTranspose) {
	wvpMatrixData_->WVP = WVP;
	wvpMatrixData_->World = World;
	wvpMatrixData_->WorldInverseTranspose = WorldInverseTranspose;
}
// LightType
void ObjectCommon::SetLightType(LightType type) {
	if (type == LightType::Lambert) {
		materialData_->enableLighting = 1;
	} else if (type == LightType::HalfLambert) {
		materialData_->enableLighting = 2;
	} else if (type == LightType::PointLight) {
		materialData_->enableLighting = 3;
	} else if (type == LightType::SpotLight) {
		materialData_->enableLighting = 4;
	} else {
		materialData_->enableLighting = 0;
	}
}
// DirectionlLight
void ObjectCommon::SetDirectionLight(const Vector4& color, const Vector3& direction, const float& intensity) {
	directionalLightData_->color = color;
	directionalLightData_->direction = direction;
	directionalLightData_->intensity = intensity;
}
// PointLight
void ObjectCommon::SetPointLightData(const Vector4& color, const Vector3& position, const float& intensity, const float& radius, const float& decay) {
	pointLightData_->color = color;
	pointLightData_->position = position;
	pointLightData_->intensity = intensity;
	pointLightData_->radius = radius;
	pointLightData_->decay = decay;
}
// SpotLight
void ObjectCommon::SetSpotLightData(const Vector4& color, const Vector3& position, const Vector3& direction, const float& intensity, const float& distance, const float& decay, const float& cosAngle) {
	spotLightData_->color = color;
	spotLightData_->position = position;
	spotLightData_->direction = direction;
	spotLightData_->intensity = intensity;
	spotLightData_->distance = distance;
	spotLightData_->decay = decay;
	spotLightData_->cosAngle = cosAngle;
}
// cameraForGPU
void ObjectCommon::SetCameraForGPU(const Vector3& translate) {
	cameraForGPUData_->worldPosition = translate;
}
// EnviromentMap
void ObjectCommon::SetEnviromentMapData(bool enable, float strength) {
	enviromentMapData_->enable = enable;
	enviromentMapData_->strength = strength;
}


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ObjectCommon::Initialize(ID3D12Device* device, LightType type) {

	/// ===ç”Ÿæˆ=== ///
	material_ = std::make_unique<Material3D>();
	wvp_ = std::make_unique<Transform3D>();
	camera3D_ = std::make_unique<BufferBase>();
	directionallight_ = std::make_unique<BufferBase>();
	pointLight_ = std::make_unique<BufferBase>();
	spotLight_ = std::make_unique<BufferBase>();
	enviromentMap_ = std::make_unique<BufferBase>();

	/// ===Material=== ///
	// buffer
	material_->Create(device, sizeof(MaterialData3D));
	material_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&materialData_));
	// Dataæ›¸ãè¾¼ã¿
	materialData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	if (type == LightType::Lambert) {
		materialData_->enableLighting = 1;
	} else if (type == LightType::HalfLambert) {
		materialData_->enableLighting = 2;
	} else if (type == LightType::PointLight) {
		materialData_->enableLighting = 3;
	} else if (type == LightType::SpotLight) {
		materialData_->enableLighting = 4;
	} else {
		materialData_->enableLighting = 0;
	}
	materialData_->shininess = 10.0f;
	materialData_->uvTransform = Math::MakeIdentity4x4();

	/// ===wvp=== ///
	// buffer
	wvp_->Create(device, sizeof(TransformationMatrix3D));
	wvp_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&wvpMatrixData_));
	// Dataã®æ›¸ãè¾¼ã¿
	wvpMatrixData_->WVP = Math::MakeIdentity4x4();
	wvpMatrixData_->World = Math::MakeIdentity4x4();
	wvpMatrixData_->WorldInverseTranspose = Math::Inverse4x4(wvpMatrixData_->World);

	/// ===DirectionalLight=== ///
	directionallight_->Create(device, sizeof(DirectionalLight));
	directionallight_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&directionalLightData_));
	directionalLightData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	directionalLightData_->direction = { 0.0f, -1.0f, 0.0f };
	directionalLightData_->intensity = 1.0f;

	/// ===Camera=== ///
	camera3D_->Create(device, sizeof(CameraForGPU));
	camera3D_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&cameraForGPUData_));
	cameraForGPUData_->worldPosition = { 0.0f, 4.0f, -10.0f };

	/// ===PointLight=== ///
	pointLight_->Create(device, sizeof(PointLight));
	pointLight_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&pointLightData_));
	pointLightData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	pointLightData_->position = { 0.0f, 0.0f, 0.0f };
	pointLightData_->intensity = 1.0f;

	/// ===SpotLight=== ///
	spotLight_->Create(device, sizeof(SpotLight));
	spotLight_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&spotLightData_));
	spotLightData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	spotLightData_->position = { 0.0f, 0.0f, 0.0f };
	spotLightData_->intensity = 1.0f;
	spotLightData_->direction = { 0.0f, 0.0f, 0.0f };
	spotLightData_->distance = 0.0f;
	spotLightData_->decay = 0.0f;
	spotLightData_->cosAngle = 0.0f;

	/// ===EnviromentMap=== ///
	enviromentMap_->Create(device, sizeof(EnviromentMap));
	enviromentMap_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&enviromentMapData_));
	enviromentMapData_->enable = 0; // ç’°å¢ƒãƒãƒƒãƒ—ã¯åˆæœŸçŠ¶æ…‹ã§ã¯ç„¡åŠ¹åŒ–
	enviromentMapData_->strength = 1.0f; // ç’°å¢ƒãƒãƒƒãƒ—ã®å¼·åº¦ã¯1.0fã«è¨­å®š
}


///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ObjectCommon::Bind(ID3D12GraphicsCommandList* commandList) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// MaterialBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(0, material_->GetBuffer()->GetGPUVirtualAddress());
	// wvpMatrixBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(1, wvp_->GetBuffer()->GetGPUVirtualAddress());
	// DirectionlLightã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(4, directionallight_->GetBuffer()->GetGPUVirtualAddress());
	// CameraBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(5, camera3D_->GetBuffer()->GetGPUVirtualAddress());
	// PointLight
	commandList->SetGraphicsRootConstantBufferView(6, pointLight_->GetBuffer()->GetGPUVirtualAddress());
	// SpotLight
	commandList->SetGraphicsRootConstantBufferView(7, spotLight_->GetBuffer()->GetGPUVirtualAddress());
	// EnviromentMap
	commandList->SetGraphicsRootConstantBufferView(8, enviromentMap_->GetBuffer()->GetGPUVirtualAddress());
}

============================================================
File Path: Project/Engine/Graphics/3d/Base/ObjectCommon.h
============================================================
#pragma once
/// ===include=== ///
#include "Engine/Graphics/3d/Base/Material3D.h"
#include "Engine/Graphics/3d/Base/Transform3D.h"
#include "Engine/Graphics/Base/BufferBase.h"
// Data
#include "Engine/DataInfo/LightData.h"
// c++
#include <memory>

///=====================================================/// 
/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨
///=====================================================///
class ObjectCommon {
public:
	ObjectCommon();
	~ObjectCommon();

	// åˆæœŸåŒ–
	void Initialize(ID3D12Device* device, LightType type); // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª­ã¿è¾¼ã¾ãªã„å ´åˆã®åˆæœŸåŒ–
	// æç”»
	void Bind(ID3D12GraphicsCommandList* commandList);

public: /// ===Getter=== ///

	LightType GetLightType() const;

public:/// ===Setter=== ///
	// Material
	void SetMatiarlData(const Vector4& color, const float& shininess, const Matrix4x4& uvTransform);
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	void SetTransformData(const Matrix4x4& WVP, const Matrix4x4& World, const Matrix4x4& WorldInverseTranspose);
	// Light
	void SetLightType(LightType type);
	// DirectionalLight
	void SetDirectionLight(const Vector4& color, const Vector3& direction, const float& intensity);
	// PointLight
	void SetPointLightData(const Vector4& color, const Vector3& position, const float& intensity, const float& radius, const float& decay);
	// SpotLight
	void SetSpotLightData(const Vector4& color, const Vector3& position, const Vector3& direction, const float& intensity, const float& distance, const float& decay, const float& cosAngle);
	// CameraForGPU
	void SetCameraForGPU(const Vector3& translate);
	// EnviromentMap
	void SetEnviromentMapData(bool enable, float strength);

private: /// ===Variables=== ///

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	std::unique_ptr<Material3D> material_;
	std::unique_ptr<Transform3D> wvp_;
	std::unique_ptr<BufferBase> directionallight_;
	std::unique_ptr<BufferBase> camera3D_;
	std::unique_ptr<BufferBase> pointLight_;
	std::unique_ptr<BufferBase> spotLight_;
	std::unique_ptr<BufferBase> enviromentMap_;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	MaterialData3D* materialData_ = nullptr;
	TransformationMatrix3D* wvpMatrixData_ = nullptr;
	DirectionalLight* directionalLightData_ = nullptr;
	CameraForGPU* cameraForGPUData_ = nullptr;
	PointLight* pointLightData_ = nullptr;
	SpotLight* spotLightData_ = nullptr;
	EnviromentMap* enviromentMapData_ = nullptr;
};



============================================================
File Path: Project/Engine/Graphics/3d/Base/Transform3D.cpp
============================================================
#include "Transform3D.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Transform3D::~Transform3D() { buffer_.Reset(); }

///-------------------------------------------/// 
///
///-------------------------------------------///
void Transform3D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* Transform3D::GetBuffer() { return buffer_.Get(); }
TransformationMatrix3D* Transform3D::GetData() { return data_; }

============================================================
File Path: Project/Engine/Graphics/3d/Base/Transform3D.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// Transform3D
///=====================================================///
class Transform3D {
public:

	Transform3D() = default;
	~Transform3D();

	/// <summary>
	/// Resourceã®ç”Ÿæˆ
	/// </summary>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	TransformationMatrix3D* GetData();
	
private:

	ComPtr<ID3D12Resource> buffer_;

	TransformationMatrix3D* data_;
};



============================================================
File Path: Project/Engine/Graphics/3d/Base/VertexBuffer3D.cpp
============================================================
#include "VertexBuffer3D.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
VertexBuffer3D::~VertexBuffer3D() { buffer_.Reset(); }

///-------------------------------------------/// 
/// ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
///-------------------------------------------///
void VertexBuffer3D::Create(ID3D12Device* device, size_t sizeInBytes) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes);
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* VertexBuffer3D::GetBuffer() { return buffer_.Get(); }
VertexData3D* VertexBuffer3D::GetData() { return data_; }

============================================================
File Path: Project/Engine/Graphics/3d/Base/VertexBuffer3D.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// VertexBuffer3D
///=====================================================///
class VertexBuffer3D {
public:

	VertexBuffer3D() = default;
	~VertexBuffer3D();

	// Resourceã®ç”Ÿæˆ
	// <param name="device">ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆã™ã‚‹ãŸã‚ã® ID3D12Device ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	// <param name="sizeInBytes">ä½œæˆã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚º (ãƒã‚¤ãƒˆå˜ä½)ã€‚</param>
	void Create(ID3D12Device* device, size_t sizeInBytes);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12Resource* GetBuffer();

	/// <summary>
	/// ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	VertexData3D* GetData();

private:

	ComPtr<ID3D12Resource> buffer_;

	VertexData3D* data_;
};



============================================================
File Path: Project/Engine/Graphics/3d/Line/LineObject3D.cpp
============================================================
#include "LineObject3D.h"
// Service
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
#include "Engine/System/Service/CameraService.h"
// Camera
#include "application/Game/Camera/GameCamera.h"
// DXCommon
#include "Engine/Core/DXCommon.h"
// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
LineObject3D::~LineObject3D() {
	vertex_.reset();
	wvp_.reset();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
const std::vector<Vector3> LineObject3D::GetSphereData() { return spheres_; }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void LineObject3D::Initialize(ID3D12Device* device) {
	
	/// ===ç”Ÿæˆ=== ///
	vertex_ = std::make_unique<VertexBuffer3D>();
	wvp_ = std::make_unique<Transform3D>();

	/// ===WorldTransform=== ///
	worldTransform_ = { { 1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f } };
	cameraTransform_ = { {1.0f, 1.0f,1.0f}, {0.3f, 0.0f, 0.0f}, {0.0f, 4.0f, -10.0f} };

	/// ===vertex=== ///
	// Buffer
	vertex_->Create(device, sizeof(LineVertexData3D) * kLineVertexCount_ * kMaxLineCount_);
	vertex_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&vertexData_));
	// View
	vertexBufferView_.BufferLocation = vertex_->GetBuffer()->GetGPUVirtualAddress();
	vertexBufferView_.StrideInBytes = sizeof(LineVertexData3D);
	vertexBufferView_.SizeInBytes = sizeof(LineVertexData3D) * kLineVertexCount_ * kMaxLineCount_;
	// 
	SphereVertexData();

	/// ===WVP=== ///
	wvp_->Create(device, sizeof(LineTransformMatrixData3D));
	wvp_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&wvpData_));
	wvpData_->WVP = Math::MakeIdentity4x4();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void LineObject3D::Update() {
	
	/// ===ã‚«ãƒ¡ãƒ©ã®è¨­å®š=== ///
	camera_ = CameraService::GetActiveCamera().get();

	/// ===Matrixã®ä½œæˆ=== ///
	const Matrix4x4& viewProjectionMatrix = camera_->GetViewProjectionMatrix();
	Matrix4x4 worldViewProjectionMatrix = viewProjectionMatrix;

	// Dataã®ä»£å…¥
	wvpData_->WVP = worldViewProjectionMatrix;
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void LineObject3D::Draw() {
	/// ===ç·šãŒæç”»ã•ã‚Œã¦ãªã‹ã£ãŸã‚‰æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³=== ///
	if (lineIndex_ == 0) {
		return;
	}

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12GraphicsCommandList* commandList = GraphicsResourceGetter::GetDXCommandList();

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// PSOã®è¨­å®š
	Render::SetPSO(commandList, PipelineType::Line3D, BlendMode::KBlendModeNormal, D3D_PRIMITIVE_TOPOLOGY_LINELIST);

	// vertexBufferã®è¨­å®š
	commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
	// wvpMatrixBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(0, wvp_->GetBuffer()->GetGPUVirtualAddress());
	// DrawCall
	commandList->DrawInstanced(lineIndex_, lineIndex_ / kLineVertexCount_, 0, 0);

	// ãƒªã‚»ãƒƒãƒˆ
	Reset();
}

///-------------------------------------------/// 
/// ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void LineObject3D::Reset() {
	lineIndex_ = 0;
}


///-------------------------------------------/// 
/// Lineã®ä½œæˆ
///-------------------------------------------///
void LineObject3D::CreateLine(const Vector3& start, const Vector3& end, const Vector4& color) {
	
	vertexData_[lineIndex_].position = start;
	vertexData_[lineIndex_ + 1].position = end;

	vertexData_[lineIndex_].color = color;
	vertexData_[lineIndex_ + 1].color = color;

	lineIndex_ += kLineVertexCount_;
}



///-------------------------------------------/// 
/// ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹ã‚’å¯è¦–åŒ–
///-------------------------------------------///
void LineObject3D::DrawBezierControlPoints(const std::vector<BezierControlPointData>& controlPoints, const Vector4& pointColor, const Vector4& lineColor, float pointSize) {
	if (controlPoints.empty()) {
		return;
	}

	// åˆ¶å¾¡ç‚¹åŒå£«ã‚’ç·šã§çµã¶
	for (size_t i = 0; i < controlPoints.size() - 1; ++i) {
		CreateLine(controlPoints[i].position, controlPoints[i + 1].position, lineColor);
	}

	// å„åˆ¶å¾¡ç‚¹ã«å°ã•ãªåå­—ã‚’æç”»
	for (const auto& point : controlPoints) {
		Vector3 center = point.position;

		// Xè»¸æ–¹å‘ã®ç·š
		CreateLine(
			Vector3{ center.x - pointSize, center.y, center.z },
			Vector3{ center.x + pointSize, center.y, center.z },
			pointColor
		);

		// Yè»¸æ–¹å‘ã®ç·š
		CreateLine(
			Vector3{ center.x, center.y - pointSize, center.z },
			Vector3{ center.x, center.y + pointSize, center.z },
			pointColor
		);

		// Zè»¸æ–¹å‘ã®ç·š
		CreateLine(
			Vector3{ center.x, center.y, center.z - pointSize },
			Vector3{ center.x, center.y, center.z + pointSize },
			pointColor
		);
	}
}

///-------------------------------------------/// 
/// çƒã®å½¢çŠ¶ã‚’è¨ˆç®—
///-------------------------------------------///
void LineObject3D::SphereVertexData() {

	const uint32_t kSubdivision = 8; // åˆ†å‰²æ•°
	const float kLonEvery = 2.0f * Math::Pi() / float(kSubdivision); // çµŒåº¦ã®1åˆ†å‰²ã®è§’åº¦
	const float kLatEvery = Math::Pi() / float(kSubdivision); // ç·¯åº¦ã®1åˆ†å‰²ã®è§’åº¦

	// ç·¯åº¦æ–¹å‘
	for (uint32_t latIndex = 0; latIndex < kSubdivision; latIndex++) {
		float lat = -Math::Pi() / 2.0f + kLatEvery * float(latIndex);
		// çµŒåº¦æ–¹å‘
		for (uint32_t lonIndex = 0; lonIndex < kSubdivision; lonIndex++) {
			float lon = kLonEvery * float(lonIndex);
			// çƒã®è¡¨é¢ä¸Šã®ç‚¹ã‚’æ±‚ã‚ã‚‹
			Vector3 a, b, c;
			a.x = cos(lat) * cos(lon);
			a.y = sin(lat);
			a.z = cos(lat) * sin(lon);

			b.x = cos(lat + kLatEvery) * cos(lon);
			b.y = sin(lat + kLatEvery);
			b.z = cos(lat + kLatEvery) * sin(lon);

			c.x = cos(lat) * cos(lon + kLonEvery);
			c.y = sin(lat);
			c.z = cos(lat) * sin(lon + kLonEvery);

			// åº§æ¨™ã‚’ä¿å­˜
			spheres_.push_back(a);
			spheres_.push_back(b);
			spheres_.push_back(c);
		}
	}
}

============================================================
File Path: Project/Engine/Graphics/3d/Line/LineObject3D.h
============================================================
#pragma once
/// ===Include=== ///
// Data
#include "Engine/DataInfo/LineObjectData.h"
#include "Engine/DataInfo/PipelineStateObjectType.h"
// Buffer
#include "Engine/Graphics/3d/Base/VertexBuffer3D.h"
#include "Engine/Graphics/3d/Base/Transform3D.h"
// C++
#include <memory>
#include <vector>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// LineObject3D
///=====================================================///
class LineObject3D {
public:
	LineObject3D() = default;
	~LineObject3D();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ Direct3D 12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒªã‚½ãƒ¼ã‚¹ä½œæˆã‚„ãƒ‡ãƒã‚¤ã‚¹æ©Ÿèƒ½ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	void Initialize(ID3D12Device* device);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

	/// <summary>
	/// é–‹å§‹ç‚¹ã‹ã‚‰çµ‚ç‚¹ã¾ã§ã®ç·šã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="start">ç·šã®é–‹å§‹ç‚¹ã€‚3æ¬¡å…ƒåº§æ¨™ã‚’è¡¨ã™ Vector3 å‹ã®å‚ç…§ã€‚</param>
	/// <param name="end">ç·šã®çµ‚ç‚¹ã€‚3æ¬¡å…ƒåº§æ¨™ã‚’è¡¨ã™ Vector3 å‹ã®å‚ç…§ã€‚</param>
	/// <param name="color">ç·šã®è‰²ã€‚4æˆåˆ†ã®ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆä¾‹: RGBAï¼‰ã‚’è¡¨ã™ Vector4 å‹ã®å‚ç…§ã€‚</param>
	void CreateLine(const Vector3& start, const Vector3& end, const Vector4& color);

	/// <summary>
	/// ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹ã‚’å¯è¦–åŒ–ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
	/// </summary>
	/// <param name="controlPoints">åˆ¶å¾¡ç‚¹ã®ãƒªã‚¹ãƒˆ</param>
	/// <param name="pointColor">åˆ¶å¾¡ç‚¹ã®è‰²</param>
	/// <param name="lineColor">åˆ¶å¾¡ç‚¹ã‚’çµã¶ç·šã®è‰²</param>
	/// <param name="pointSize">åˆ¶å¾¡ç‚¹ã®ã‚µã‚¤ã‚º</param>
	void DrawBezierControlPoints(const std::vector<BezierControlPointData>& controlPoints, const Vector4& pointColor = Vector4{ 1.0f, 1.0f, 0.0f, 1.0f }, const Vector4& lineColor = Vector4{ 0.5f, 0.5f, 0.5f, 1.0f }, float pointSize = 0.2f);

	/// <summary>
	/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¾ãŸã¯çŠ¶æ…‹ã‚’æ—¢å®šã®ï¼ˆåˆæœŸï¼‰çŠ¶æ…‹ã«ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
	/// </summary>
	void Reset();

public: /// ===Getter=== ///
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰Transformã®å–å¾—
	const std::vector<Vector3> GetSphereData();

private:

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹=== ///
	std::unique_ptr<VertexBuffer3D> vertex_;
	std::unique_ptr<Transform3D> wvp_;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼=== ///
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
	LineVertexData3D* vertexData_ = nullptr;
	LineTransformMatrixData3D* wvpData_ = nullptr;

	/// ===WorldTransform=== ///
	EulerTransform worldTransform_;
	EulerTransform cameraTransform_;

	/// ===Camera=== ///
	GameCamera* camera_ = nullptr;

	/// ===LineInfo=== ///
	uint32_t lineIndex_ = 0;
	const uint32_t kMaxLineCount_ = 100000;
	const uint32_t kLineVertexCount_ = 2;
	// 
	std::vector<Vector3> spheres_;

private:

	/// <summary>
	/// çƒã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆã¾ãŸã¯åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void SphereVertexData();
};



============================================================
File Path: Project/Engine/Graphics/3d/Model/AnimationModel.cpp
============================================================
#include "AnimationModel.h"
#define NOMINMAX
// c++
#include <Windows.h>
#include <cassert>
#include <fstream>
#include <vector>
#include <algorithm>
// Service
#include "Engine/System/Service/ServiceLocator.h"
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
// Manager
#include "Engine/System/Managers/SRVManager.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
AnimationModel::~AnimationModel() {}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
/// ===AnimationName=== ///
void AnimationModel::SetAnimation(const std::string& animationName, bool isLoop) { 
	animationName_ = animationName; 
	isLoop_ = isLoop;
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void AnimationModel::Initialize(const std::string & filename, LightType type) {
	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12Device* device = GraphicsResourceGetter::GetDXDevice();

	/// ===ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿=== ///
	modelData_ = GraphicsResourceGetter::GetModelData(filename); // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹

	/// ===Animationã®èª­ã¿è¾¼ã¿=== ///
	animation_ = GraphicsResourceGetter::GetAnimationData(filename); // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹

	/// ===BoneãŒã‚ã‚Œã°=== ///
	if (modelData_.haveBone) {
		/// ===Skeletonã®ä½œæˆ=== ///
		skeleton_ = CreateSkeleton(modelData_.rootNode);
		/// ===SkinClusterã®ä½œæˆ=== ///
		skinCluster_ = CreateSkinCluster(device, skeleton_, modelData_);
	}

	/// ===ModelCommonã®åˆæœŸåŒ–=== ///
	ModelCommon::Create(device, type);

	/// ===animation=== ///
	isLoop_ = true;
	animationTime_ = 0.0f;
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void AnimationModel::Update() {

	/// ===Animationã®å†ç”Ÿ=== ///
	float duration = animation_[animationName_].duration;
	// ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã‹ã®ifåˆ†
	if (isLoop_) {
		animationTime_ += 1.0f / 60.0f;
		animationTime_ = std::fmod(animationTime_, duration); // ãƒ«ãƒ¼ãƒ—
	} else {
		if (animationTime_ < duration) {
			animationTime_ += 1.0f / 60.0f;
			if (animationTime_ > duration) {
				animationTime_ = duration; // æ˜ç¤ºçš„ã«æ­¢ã‚ã‚‹
				// å¾Œã€…ã“ã“ã«ãƒ•ãƒ©ã‚°ãªã©ã‚’å…¥ã‚Œã¦ã‚‚OK
			}
		}
	}
	
	// Skeletonã«Animationã‚’é©ç”¨
	ApplyAnimation(skeleton_, animation_[animationName_], animationTime_);
	// Skeletonã®æ›´æ–°
	SkeletonUpdate(skeleton_);
	// SkinClusterã®æ›´æ–°
	SkinClusterUpdate(skinCluster_, skeleton_);

	/// ===ModelCommonã®æ›´æ–°=== ///
	ModelCommon::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void AnimationModel::Draw(BlendMode mode) {
	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12GraphicsCommandList* commandList = GraphicsResourceGetter::GetDXCommandList();
	if (modelData_.haveBone) {
		/// ===VBVã®è¨­å®š=== ///
		D3D12_VERTEX_BUFFER_VIEW vbvs[2] = {
			vertexBufferView_, // VertexDataã®VBV
			skinCluster_.influenceBufferView // Influenceã®VBV
		};

		/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
		// PSOã®è¨­å®š
		Render::SetPSO(commandList, PipelineType::Skinning3D, mode);
		// Viewã®è¨­å®š
		commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
		commandList->IASetVertexBuffers(0, 2, vbvs);
		commandList->IASetIndexBuffer(&indexBufferView_);
		
	} else {
		/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
		// PSOã®è¨­å®š
		Render::SetPSO(commandList, PipelineType::Obj3D, mode);
		// Viewã®è¨­å®š
		commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
		commandList->IASetIndexBuffer(&indexBufferView_);
	}

	/// ===ModelCommonã®æç”»=== ///
	ModelCommon::Bind(commandList);

	// GPUã‚’ç™»éŒ²
	commandList->SetGraphicsRootDescriptorTable(9, skinCluster_.paletteSrvHandle.second);

	// æç”»ï¼ˆDrawã‚³ãƒ¼ãƒ«ï¼‰
	commandList->DrawIndexedInstanced(UINT(modelData_.indices.size()), 1, 0, 0, 0);
}


///-------------------------------------------/// 
/// ä»»æ„ã®æ™‚åˆ»ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°
///-------------------------------------------///
Vector3 AnimationModel::CalculateValue(const std::vector<KeyframeVector3>& keyframes, float time) {
	/// ===ä»»æ„ã®æ™‚åˆ»ã®å€¤ã‚’å–å¾—ã™ã‚‹=== ///
	assert(!keyframes.empty()); // ã‚­ãƒ¼ãŒãªã„ç‰©ã¯è¿”ã™å€¤ãŒã‚ã‹ã‚‰ãªã„ã®ã§ã ã‚
	if (keyframes.size() == 1 || time <= keyframes[0].time) { // ã‚­ãƒ¼ãŒä¸€ã¤ã‹ã€æ™‚åˆ»ãŒã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ å‰ãªã‚‰æœ€åˆã®å€¤ã¨ã™ã‚‹
		return keyframes[0].value;
	}

	/// ===ä»»æ„ã®è‡ªå›½ã®å€¤ã‚’å–å¾—ã™ã‚‹2=== ///
	for (size_t index = 0; index < keyframes.size() - 1; ++index) {
		size_t nextIndex = index + 1;
		// indexã¨nextIndexã®2ã¤ã®keyframeã‚’å–å¾—ã—ã¦ç¯„å›²å†…ã«æ™‚åˆ»ãŒã‚ã‚‹ã‹ã‚’åˆ¤å®š
		if (keyframes[index].time <= time && time <= keyframes[nextIndex].time) {
			// ç¯„å›²å†…ã‚’ç·šå½¢è£œé–“ã™ã‚‹(Lerp)
			float t = (time - keyframes[index].time) / (keyframes[nextIndex].time - keyframes[index].time);
			return Math::Lerp(keyframes[index].value, keyframes[nextIndex].value, t);
		}
	}
	// ã“ã“ã¾ã§ã§ããŸå ´åˆã¯ä¸€ç•ªå¾Œã®æ™‚åˆ»ã‚ˆã‚Šã‚‚å¾Œã‚ãªã®ã§æœ€å¾Œã®å€¤ã‚’è¿”ã™ã“ã¨ã«ã™ã‚‹
	return (*keyframes.rbegin()).value;
}


///-------------------------------------------/// 
/// ä»»æ„ã®æ™‚åˆ»ã®å€¤ã‚’å–å¾—ã™ã‚‹é–¢æ•°(Quaternion)
///-------------------------------------------///
Quaternion AnimationModel::CalculateValue(const std::vector<KeyframeQuaternion>& keyframes, float time) {
	/// ===ä»»æ„ã®æ™‚åˆ»ã®å€¤ã‚’å–å¾—ã™ã‚‹=== ///
	assert(!keyframes.empty()); // ã‚­ãƒ¼ãŒãªã„ç‰©ã¯è¿”ã™å€¤ãŒã‚ã‹ã‚‰ãªã„ã®ã§ã ã‚
	if (keyframes.size() == 1 || time <= keyframes[0].time) { // ã‚­ãƒ¼ãŒä¸€ã¤ã‹ã€æ™‚åˆ»ãŒã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ å‰ãªã‚‰æœ€åˆã®å€¤ã¨ã™ã‚‹
		return keyframes[0].value;
	}

	/// ===ä»»æ„ã®è‡ªå›½ã®å€¤ã‚’å–å¾—ã™ã‚‹2=== ///
	for (size_t index = 0; index < keyframes.size() - 1; ++index) {
		size_t nextIndex = index + 1;
		// indexã¨nextIndexã®2ã¤ã®keyframeã‚’å–å¾—ã—ã¦ç¯„å›²å†…ã«æ™‚åˆ»ãŒã‚ã‚‹ã‹ã‚’åˆ¤å®š
		if (keyframes[index].time <= time && time <= keyframes[nextIndex].time) {
			// ç¯„å›²å†…ã‚’çƒé¢ç·šå½¢è£œé–“ã™ã‚‹(SLerp)
			float t = (time - keyframes[index].time) / (keyframes[nextIndex].time - keyframes[index].time);
			return Math::SLerp(keyframes[index].value, keyframes[nextIndex].value, t);
		}
	}
	// ã“ã“ã¾ã§ã§ããŸå ´åˆã¯ä¸€ç•ªå¾Œã®æ™‚åˆ»ã‚ˆã‚Šã‚‚å¾Œã‚ãªã®ã§æœ€å¾Œã®å€¤ã‚’è¿”ã™ã“ã¨ã«ã™ã‚‹
	return (*keyframes.rbegin()).value;
}

///-------------------------------------------/// 
/// Nodeã®éšå±¤æ§‹é€ ã‹ã‚‰Skeletonã‚’ä½œã‚‹é–¢æ•°
///-------------------------------------------///
Skeleton AnimationModel::CreateSkeleton(const Node& rootNode) {
	Skeleton skeleton;
	skeleton.root = CreateJoint(rootNode, {}, skeleton.joints);
	
	// åå‰ã¨Indexã®ãƒãƒƒãƒ”ãƒ³ã‚°
	for (const Joint& joint : skeleton.joints) {
		skeleton.jointMap.emplace(joint.name, joint.index);
	}

	return skeleton;
}

///-------------------------------------------/// 
/// Nodeã‹ã‚‰Jointã‚’ä½œã‚‹é–¢æ•°
///-------------------------------------------///
int32_t AnimationModel::CreateJoint(const Node& node, const std::optional<int32_t>& parent, std::vector<Joint>& joints) {
	Joint joint;
	joint.name = node.name;
	joint.localMatrix = node.localMatrix;
	joint.skeletonSpaceMatrix = Math::MakeIdentity4x4();
	joint.transform = node.transform;
	joint.index = int32_t(joints.size()); // ç¾åœ¨ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æ•°ã‚’Indexã«
	joint.parent = parent;
	joints.push_back(joint); // Skeletonã®Jointåˆ—ã«è¿½åŠ 
	for (const Node& child : node.children) {
		// å­Jointã‚’ä½œæˆã—ã€ãã®Indexã‚’ç™»éŒ²
		int32_t childIndex = CreateJoint(child, joint.index, joints);
		joints[joint.index].children.push_back(childIndex);
	}
	// è‡ªä¿¡ã®Indexã‚’è¿”ã™
	return joint.index;
}

///-------------------------------------------/// 
/// Skeletonã«å¯¾ã—ã¦Animationã®é©ç”¨ã‚’è¡Œã†é–¢æ•°
///-------------------------------------------///
void AnimationModel::ApplyAnimation(Skeleton& skeleton, const Animation& animation, float animationTime) {
	for (Joint& joint : skeleton.joints) {
		// å¯¾è±¡ã®Jointã®AnimationãŒã‚ã‚Œã°ã€å€¤ã®é©ç”¨ã‚’è¡Œã†ã€‚ä¸‹è¨˜ã®ifåˆ†ã¯c++17ã‹ã‚‰å¯èƒ½ã«ãªã£ãŸåˆæœŸåŒ–ä»˜ãifåˆ†
		if (auto it = animation.nodeAnimations.find(joint.name); it != animation.nodeAnimations.end()) {
			const NodeAnimation& rootNodeAnimation = (*it).second;
			joint.transform.translate = CalculateValue(rootNodeAnimation.translate.keyframes, animationTime);
			joint.transform.rotate = CalculateValue(rootNodeAnimation.rotate.keyframes, animationTime);
			joint.transform.scale = CalculateValue(rootNodeAnimation.scale.keyframes, animationTime);
		}
	}
}

///-------------------------------------------/// 
/// Skeletonã®æ›´æ–°é–¢æ•°
///-------------------------------------------///
void AnimationModel::SkeletonUpdate(Skeleton& skeleton) {
	// å…¨ã¦ã®Jointã‚’æ›´æ–°ã€‚è¦ªãŒè‹¥ã„ã®ã§é€šå¸¸ãƒ«ãƒ¼ãƒ—ã§å‡¦ç†ã‚’å¯èƒ½ã«ã—ã¦ã„ã‚‹ã€‚
	for (Joint& joint : skeleton.joints) {
		joint.localMatrix = Math::MakeAffineQuaternionMatrix(joint.transform.scale, joint.transform.rotate, joint.transform.translate);
		if (joint.parent) { // è¦ªãŒã„ãªã‘ã‚Œã°è¦ªã®è¡Œåˆ—ã‚’æ›ã‘ã‚‹
			joint.skeletonSpaceMatrix = Multiply(joint.localMatrix, skeleton.joints[*joint.parent].skeletonSpaceMatrix);
		} else { // è¦ªãŒã„ãªã„ã®ã§localMatrixã¨skeletonSpaceMatrixã¯ä¸€è‡´ã™ã‚‹
			joint.skeletonSpaceMatrix = joint.localMatrix;
		}
	}
}

///-------------------------------------------/// 
/// SkinClusterã®ç”Ÿæˆ
///-------------------------------------------///
SkinCluster AnimationModel::CreateSkinCluster(
	const ComPtr<ID3D12Device>& device, const Skeleton& skeleton, const ModelData& modelData) {

	SkinCluster skinCluster;
	/// ===Paletteç”¨ã®Resourceã‚’ç¢ºä¿=== ///
	uint32_t paletteIndex = ServiceLocator::GetSRVManager()->Allocate();
	skinCluster.paletteResource = CreateBufferResourceComPtr(device.Get(), sizeof(WellForGPU) * skeleton.joints.size());
	WellForGPU* mappedPalette = nullptr;
	skinCluster.paletteResource->Map(0, nullptr, reinterpret_cast<void**>(&mappedPalette));
	skinCluster.mappedPalette = { mappedPalette, skeleton.joints.size() }; // spanã‚’ä½¿ã£ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹
	skinCluster.paletteSrvHandle.first = ServiceLocator::GetSRVManager()->GetCPUDescriptorHandle(paletteIndex);
	skinCluster.paletteSrvHandle.second = ServiceLocator::GetSRVManager()->GetGPUDescriptorHandle(paletteIndex);

	/// ===Paletteç”¨ã®SRVã‚’ä½œæˆã€‚StructuredBufferã§ã‚¢ã‚¯ã‚»ã‚¹ã§ãã‚‹ã‚ˆã†ã«ã™ã‚‹=== ///
	D3D12_SHADER_RESOURCE_VIEW_DESC paletteSrvDesc{};
	paletteSrvDesc.Format = DXGI_FORMAT_UNKNOWN;
	paletteSrvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	paletteSrvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	paletteSrvDesc.Buffer.FirstElement = 0;
	paletteSrvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;
	paletteSrvDesc.Buffer.NumElements = UINT(skeleton.joints.size());
	paletteSrvDesc.Buffer.StructureByteStride = sizeof(WellForGPU);
	device->CreateShaderResourceView(skinCluster.paletteResource.Get(), &paletteSrvDesc, skinCluster.paletteSrvHandle.first);

	/// ===Influenceç”¨Resourceã®ä½œæˆ=== ///
	//uint32_t influenceIndex = srvManager->Allocate();
	skinCluster.influenceResource = CreateBufferResourceComPtr(device.Get(), sizeof(VertexInfluence) * modelData.vertices.size());
	VertexInfluence* mappedInfluence = nullptr;
	skinCluster.influenceResource->Map(0, nullptr, reinterpret_cast<void**>(&mappedInfluence));
	std::memset(mappedInfluence, 0, sizeof(VertexInfluence) * modelData.vertices.size()); // 0åŸ‹ã‚ã€‚weightã‚’0ã«ã—ã¦ãŠãã€‚
	skinCluster.mappedInfluence = { mappedInfluence, modelData.vertices.size() };
	// Influenceç”¨ã®VBVã‚’ä½œæˆ
	skinCluster.influenceBufferView.BufferLocation = skinCluster.influenceResource->GetGPUVirtualAddress();
	skinCluster.influenceBufferView.SizeInBytes = UINT(sizeof(VertexInfluence) * modelData.vertices.size());
	skinCluster.influenceBufferView.StrideInBytes = sizeof(VertexInfluence);
	// InverseBindPoseMatrixã‚’æ ¼ç´ã™ã‚‹å ´æ‰€ã‚’ä½œæˆã—ã¦ã€å˜ä½è¡Œåˆ—ã§åŸ‹ã‚ã‚‹
	skinCluster.inverseBindPoseMatrices.resize(skeleton.joints.size());
	std::generate(skinCluster.inverseBindPoseMatrices.begin(), skinCluster.inverseBindPoseMatrices.end(), Math::MakeIdentity4x4);

	/// ===ModelDataã‚’è§£æã—ã¦Influenceã‚’åŸ‹ã‚ã‚‹=== ///
	for (const auto& jointWeight : modelData.skinClusterData) { // Modelã®SkinClusterã®æƒ…å ±ã‚’è§£æ
		auto it = skeleton.jointMap.find(jointWeight.first); // jointWeight.firstã¯jointåãªã®ã§ã€skeletonã«å¯¾è±¡ã¨ãªã‚‹jointãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹åˆ¤æ–­
		if (it == skeleton.jointMap.end()) { // ãã‚“ãªåå‰ã®Jointã¯å­˜åœ¨ã—ãªã„ã€‚ãªã®ã§æ¬¡ã«å›ã™
			continue;
		}
		// (*it).secondã«ã¯Jointã®IndexãŒå…¥ã£ã¦ã„ã‚‹ã®ã§ã€è©²å½“ã®Indexã®inverseBindPoseMatrixã‚’ä»£å…¥
		skinCluster.inverseBindPoseMatrices[(*it).second] = jointWeight.second.inverseBindPoseMatrix;
		for (const auto& vertexWeight : jointWeight.second.vertexWeights) {
			auto& currentInfluence = skinCluster.mappedInfluence[vertexWeight.vertexIndex]; // è©²å½“ã®vertexIndexã®influenceæƒ…å ±ã‚’å‚ç…§ã—ã¦ãŠã
			for (uint32_t index = 0; index < kNumMaxInfluence; ++index) { // ç©ºã„ã¦ã„ã‚‹ã¨ã“ã‚ã«å…¥ã‚Œã‚‹
				if (currentInfluence.weights[index] == 0.0f) { // weight==0ãŒç©ºã„ã¦ã„ã‚‹çŠ¶æ…‹ãªã®ã§ã€ãã®å ´æ‰€ã«weightã¨jointã®indexã‚’ä»£å…¥
					currentInfluence.weights[index] = vertexWeight.weight;
					currentInfluence.jointIndices[index] = (*it).second;
					break;
				}
			}
		}
	}

	return skinCluster;
}

///-------------------------------------------/// 
/// SkinClusterã®æ›´æ–°é–¢æ•°
///-------------------------------------------///
void AnimationModel::SkinClusterUpdate(SkinCluster& skinCluster, const Skeleton& skeleton) {
	for (size_t jointIndex = 0; jointIndex < skeleton.joints.size(); ++jointIndex) {
		assert(jointIndex < skinCluster.inverseBindPoseMatrices.size()); // ã“ã“ã§æ­¢ã¾ã‚‹
		skinCluster.mappedPalette[jointIndex].skeletonSpaceMatrix =
			Multiply(skinCluster.inverseBindPoseMatrices[jointIndex], skeleton.joints[jointIndex].skeletonSpaceMatrix);
		skinCluster.mappedPalette[jointIndex].skeletonSpaceInverseTransposeMatrix =
			Math::TransposeMatrix(Math::Inverse4x4(skinCluster.mappedPalette[jointIndex].skeletonSpaceMatrix));
	}
}


============================================================
File Path: Project/Engine/Graphics/3d/Model/AnimationModel.h
============================================================
#pragma once
// Common
#include "Engine/Graphics/3d/Model/ModelCommon.h"
// Data
#include "Engine/DataInfo/AnimationData.h"
#include "Engine/DataInfo/PipelineStateObjectType.h"

///=====================================================/// 
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ‡ãƒ«
///=====================================================///
class AnimationModel : public ModelCommon {
public:

	AnimationModel() = default;
	~AnimationModel();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="filename">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã¾ãŸã¯ãƒ‘ã‚¹ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="type">ä½¿ç”¨ã™ã‚‹ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’ç¤ºã™ LightType å‹ã®å€¤ã§ã™ã€‚</param>
	void Initialize(const std::string& filename, LightType type) override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹åˆæˆï¼ˆãƒ–ãƒ¬ãƒ³ãƒ‰ï¼‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Draw(BlendMode mode) override;

public: /// ===Setter=== ///
	// Animation
	void SetAnimation(const std::string& animationName, bool isLoop);

private: /// ===Variables(å¤‰æ•°)=== ///

	/// ===Animation=== ///
	float animationTime_;
	std::map<std::string, Animation> animation_;
	std::string animationName_;
	Skeleton skeleton_;
	SkinCluster skinCluster_;
	bool isLoop_;

private: /// ===Functions(é–¢æ•°)=== ///

	/// <summary>
	/// ä»»æ„ã®æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹é–¢æ•°(Vector3)
	/// </summary>
	/// <param name="keyframes">è©•ä¾¡ã«ä½¿ç”¨ã™ã‚‹ KeyframeVector3 ã®é…åˆ—ï¼ˆconst å‚ç…§ï¼‰ã€‚å„ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ã®å€¤ã‚’åŸºã«ã€æŒ‡å®šæ™‚åˆ»ã§è£œé–“ã—ã¦å€¤ã‚’ç®—å‡ºã—ã¾ã™ã€‚</param>
	/// <param name="time">è©•ä¾¡ã™ã‚‹æ™‚åˆ»ã€‚ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã§è£œé–“ã™ã‚‹ä½ç½®ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šæ™‚åˆ»ã«ãŠã‘ã‚‹è£œé–“ã•ã‚ŒãŸ Vector3 å€¤ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	Vector3 CalculateValue(const std::vector<KeyframeVector3>& keyframes, float time);

	/// <summary>
	/// ä»»æ„ã®æ™‚åˆ»ã‚’å–å¾—ã™ã‚‹é–¢æ•°(Quaternion)
	/// </summary>
	/// <param name="keyframes">KeyframeQuaternion å‹ã®è¦ç´ ã‹ã‚‰ãªã‚‹ std::vectorã€‚å„è¦ç´ ã¯æ™‚åˆ»ã¨å¯¾å¿œã™ã‚‹ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³å€¤ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <param name="time">è©•ä¾¡ã™ã‚‹æ™‚åˆ»ï¼ˆæµ®å‹•å°æ•°ç‚¹ï¼‰ã€‚é–¢æ•°ã¯ã“ã®æ™‚åˆ»ã«ãŠã‘ã‚‹ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³å€¤ã‚’è¿”ã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã•ã‚ŒãŸæ™‚åˆ»ã«ãŠã‘ã‚‹ï¼ˆé€šå¸¸ã¯è£œé–“ã•ã‚ŒãŸï¼‰Quaternion å€¤ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	Quaternion CalculateValue(const std::vector<KeyframeQuaternion>& keyframes, float time);

	/// <summary>
	/// Nodeã®éšå±¤æ§‹é€ ã‹ã‚‰Skeletonã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="rootNode">ã‚¹ã‚±ãƒ«ãƒˆãƒ³ä½œæˆã®åŸºç‚¹ã¨ãªã‚‹ãƒãƒ¼ãƒ‰ã€‚ä½œæˆã«å¿…è¦ãªæƒ…å ±ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã« const å‚ç…§ã§æ¸¡ã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>rootNode ã®æ§‹é€ ã«åŸºã¥ã„ã¦åˆæœŸåŒ–ã•ã‚ŒãŸ Skeleton ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</returns>
	Skeleton CreateSkeleton(const Node& rootNode);

	/// <summary>
	/// Nodeã‹ã‚‰Jointã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="node">ã‚¸ãƒ§ã‚¤ãƒ³ãƒˆã®ä½œæˆã«å¿…è¦ãªæƒ…å ±ã‚’æŒã¤ Node ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆå…¥åŠ›ï¼‰ã€‚</param>
	/// <param name="parent">è¦ªã‚¸ãƒ§ã‚¤ãƒ³ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå­˜åœ¨ã™ã‚‹å ´åˆï¼‰ã€‚è¦ªãŒã„ãªã„å ´åˆã¯ std::nullopt ã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	/// <param name="joints">ä½œæˆã—ãŸ Joint ã‚’æ ¼ç´ã™ã‚‹ std::vector<Joint>ï¼ˆå‡ºåŠ›ï¼æ›´æ–°ã•ã‚Œã‚‹å‚ç…§ï¼‰ã€‚</param>
	/// <returns>ä½œæˆã•ã‚ŒãŸã‚¸ãƒ§ã‚¤ãƒ³ãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆjoints å†…ã®ä½ç½®ï¼‰ã‚’ç¤ºã™ int32_t ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	int32_t CreateJoint(const Node& node, const std::optional<int32_t>& parent, std::vector<Joint>& joints);

	/// <summary>
	/// Skeletonã«å¯¾ã—ã¦Animationã®é©ç”¨ã‚’è¡Œã†é–¢æ•°
	/// </summary>
	/// <param name="skeleton">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é©ç”¨ã™ã‚‹Skeletonã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã€‚é–¢æ•°ã¯ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚</param>
	/// <param name="animation">é©ç”¨ã™ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã¸ã®å‚ç…§ï¼ˆconstï¼‰ã€‚ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚</param>
	/// <param name="animationTime">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é©ç”¨æ™‚åˆ»ï¼ˆç§’ï¼‰ã€‚ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å†…ã®ã©ã®æ™‚ç‚¹ã‚’é©ç”¨ã™ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void ApplyAnimation(Skeleton& skeleton, const Animation& animation, float animationTime);

	/// <summary>
	/// Skeletonã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="skeleton">æ›´æ–°å¯¾è±¡ã® Skeleton ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã€‚é–¢æ•°ã¯ã“ã®å‚ç…§ã‚’é€šã˜ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®çŠ¶æ…‹ã‚’å¤‰æ›´ã—ã¾ã™ã€‚</param>
	void SkeletonUpdate(Skeleton& skeleton);

	/// <summary>
	/// SkinClusterã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="device">ID3D12Device ã¸ã® ComPtr ã®å‚ç…§ã€‚ã‚¹ã‚­ãƒ³ ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ä½œæˆã«ä½¿ç”¨ã™ã‚‹ Direct3D12 ãƒ‡ãƒã‚¤ã‚¹ã‚’æŒ‡å®šã—ã¾ã™ï¼ˆå…¥åŠ›å°‚ç”¨ï¼‰ã€‚</param>
	/// <param name="skeleton">ã‚¹ã‚±ãƒ«ãƒˆãƒ³æƒ…å ±ï¼ˆãƒœãƒ¼ãƒ³éšå±¤ã€ãƒã‚¤ãƒ³ãƒ‰ãƒãƒ¼ã‚ºãªã©ï¼‰ã€‚ã‚¹ã‚­ãƒ‹ãƒ³ã‚°ç”¨ã®éª¨æ§‹é€ ã‚’æä¾›ã—ã¾ã™ï¼ˆå…¥åŠ›å°‚ç”¨ï¼‰ã€‚</param>
	/// <param name="modelData">ãƒ¢ãƒ‡ãƒ«ã®ã‚¸ã‚ªãƒ¡ãƒˆãƒªã¨ã‚¦ã‚§ã‚¤ãƒˆæƒ…å ±ã‚’å«ã‚€ ModelDataã€‚ãƒ¡ãƒƒã‚·ãƒ¥ã€é ‚ç‚¹ã‚¦ã‚§ã‚¤ãƒˆã€é–¢é€£ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãªã©ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒ¼ç”Ÿæˆã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’æä¾›ã—ã¾ã™ï¼ˆå…¥åŠ›å°‚ç”¨ï¼‰ã€‚</param>
	/// <returns>ä½œæˆã•ã‚ŒãŸ SkinCluster ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚ã‚¹ã‚­ãƒ‹ãƒ³ã‚°æƒ…å ±ãŠã‚ˆã³é–¢é€£ã™ã‚‹ GPU ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</returns>
	SkinCluster CreateSkinCluster(const ComPtr<ID3D12Device>& device, const Skeleton& skeleton, const ModelData& modelData);

	/// <summary>
	/// SkinClusterã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="skinCluster">æ›´æ–°å¯¾è±¡ã® SkinCluster ã¸ã®å‚ç…§ã€‚</param>
	/// <param name="skeleton">æ›´æ–°ã«ä½¿ç”¨ã•ã‚Œã‚‹éª¨æ ¼ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿å–ã‚Šå°‚ç”¨å‚ç…§ã€‚ãƒœãƒ¼ãƒ³å¤‰æ›ã‚„å§¿å‹¢æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚</param>
	void SkinClusterUpdate(SkinCluster& skinCluster, const Skeleton& skeleton);
};



============================================================
File Path: Project/Engine/Graphics/3d/Model/Model.cpp
============================================================
#include "Model.h"
// c++
#include <cassert>
#include <fstream>
// Engine
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"


///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Model::Model() = default;
Model::~Model() = default;

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èª­ã¿è¾¼ã‚€å ´åˆ
void Model::Initialize(const std::string& filename, LightType type) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12Device* device = GraphicsResourceGetter::GetDXDevice();

	/// ===ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿=== ///
	modelData_ = GraphicsResourceGetter::GetModelData(filename); // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹

	/// ===ModelCommonã®åˆæœŸåŒ–=== ///
	ModelCommon::Create(device, type);
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Model::Update() {

	/// ===ModelCommonã®æ›´æ–°=== ///
	ModelCommon::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void Model::Draw(BlendMode mode) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12GraphicsCommandList* commandList = GraphicsResourceGetter::GetDXCommandList();

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// PSOã®è¨­å®š
	Render::SetPSO(commandList, PipelineType::Obj3D, mode);
	// Viewã®è¨­å®š
	commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
	commandList->IASetIndexBuffer(&indexBufferView_);
	// ModelCommonã®è¨­å®š
	ModelCommon::Bind(commandList);

	// æç”»ï¼ˆDrawã‚³ãƒ¼ãƒ«ï¼‰
	commandList->DrawIndexedInstanced(UINT(modelData_.indices.size()), 1, 0, 0, 0);
}

============================================================
File Path: Project/Engine/Graphics/3d/Model/Model.h
============================================================
#pragma once
/// ===include=== ///
// Common
#include "Engine/Graphics/3d/Model/ModelCommon.h"

///=====================================================/// 
/// ãƒ¢ãƒ‡ãƒ«
///=====================================================///
class Model : public ModelCommon {
public: /// ===åŸºæœ¬çš„ãªé–¢æ•°=== ///

	Model();
	~Model();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="filename">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯åå‰ï¼ˆconst std::string&ï¼‰ã€‚</param>
	/// <param name="type">ä½¿ç”¨ã™ã‚‹ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã€‚çœç•¥æ™‚ã¯ LightType::None ãŒä½¿ç”¨ã•ã‚Œã¾ã™ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°ï¼‰ã€‚</param>
	void Initialize(const std::string& filename, LightType type = LightType::None) override; 

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹åˆæˆï¼ˆãƒ–ãƒ¬ãƒ³ãƒ‰ï¼‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Draw(BlendMode mode) override;
};



============================================================
File Path: Project/Engine/Graphics/3d/Model/ModelCommon.cpp
============================================================
#include "ModelCommon.h"
// Math
#include "Math/MatrixMath.h"
#include "Math/sMath.h"
// Service
#include "Engine/System/Service/Render.h"
#include "Engine/System/Service/CameraService.h"
// Camera
#include "application/Game/Camera/GameCamera.h"

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ModelCommon::~ModelCommon() {
	// è¦ªå­é–¢ä¿‚ã®è§£é™¤
	ClearParent();

	// è§£æ”¾
	vertex_.reset();
	index_.reset();
	common_.reset();
}

///-------------------------------------------/// 
/// è¦ªå­é–¢ä¿‚
///-------------------------------------------///
// è¦ªã®è¨­å®š
void ModelCommon::SetParent(ModelCommon* parent) { parent_ = parent; }
// è¦ªã®è§£é™¤
void ModelCommon::ClearParent() { 
	SetParent(nullptr);
	parentOffset_ = { 0.0f,0.0f,0.0f };
}
// Offset
void ModelCommon::SetParentOffset(const Vector3& offset) { parentOffset_ = offset; }
const Vector3& ModelCommon::GetParentOffset() const { return parentOffset_; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Transform
void ModelCommon::SetTranslate(const Vector3& position) { 
	worldTransform_.translate = position; 
	worldTransformCacheDirtyTag_.translate = true;
}
void ModelCommon::SetRotate(const Quaternion& rotate) { 
	worldTransform_.rotate = rotate; 
	worldTransformCacheDirtyTag_.rotate = true;
}
void ModelCommon::SetScale(const Vector3& scale) { 
	worldTransform_.scale = scale; 
	worldTransformCacheDirtyTag_.scale = true;
}
// Color
void ModelCommon::SetColor(const Vector4& color) { color_ = color; }
// Light
void ModelCommon::SetLightType(LightType type) {common_->SetLightType(type);}
void ModelCommon::SetLightData(LightInfo light) { light_ = light; }
// ç’°å¢ƒãƒãƒƒãƒ—
void ModelCommon::SetEnvironmentMapData(bool flag, float string) {
	environmentMapInfo_.isEnvironmentMap = flag;
	environmentMapInfo_.strength = string;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// Translate 
const Vector3& ModelCommon::GetWorldTranslate() const {
	// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒæœ‰åŠ¹ãªã‚‰ãã®ã¾ã¾è¿”ã™
	if (!worldTransformCacheDirtyTag_.translate) {
		return cachedWorldTransform_.translate;
	}

	/// ===ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰ä½ç½®ã‚’å–å¾—=== ///
	cachedWorldTransform_.translate = {
		worldMatrix_.m[3][0],
		worldMatrix_.m[3][1],
		worldMatrix_.m[3][2]
	};

	worldTransformCacheDirtyTag_.translate = false; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æœ‰åŠ¹ã«ã™ã‚‹
	return cachedWorldTransform_.translate;
}
// Rotate
const Quaternion& ModelCommon::GetWorldRotate() const {
	// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒæœ‰åŠ¹ãªã‚‰ãã®ã¾ã¾è¿”ã™
	if (!worldTransformCacheDirtyTag_.rotate) {
		return cachedWorldTransform_.rotate;
	}
	/// ===ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰å›è»¢ã‚’å–å¾—=== ///
	Matrix4x4 rotateMatrix = {}; // å›è»¢è¡Œåˆ—
	for (int i = 0; i < 3; ++i) {
		for (int j = 0; j < 3; ++j) {
			rotateMatrix.m[i][j] = worldMatrix_.m[i][j];
		}
	}
	// ã‚¹ã‚±ãƒ¼ãƒ«ã§å‰²ã£ã¦æ­£è¦åŒ–
	if (cachedWorldTransform_.scale.x != 0.0f) {
		rotateMatrix.m[0][0] /= cachedWorldTransform_.scale.x;
		rotateMatrix.m[0][1] /= cachedWorldTransform_.scale.x;
		rotateMatrix.m[0][2] /= cachedWorldTransform_.scale.x;
	}
	if (cachedWorldTransform_.scale.y != 0.0f) {
		rotateMatrix.m[1][0] /= cachedWorldTransform_.scale.y;
		rotateMatrix.m[1][1] /= cachedWorldTransform_.scale.y;
		rotateMatrix.m[1][2] /= cachedWorldTransform_.scale.y;
	}
	if (cachedWorldTransform_.scale.z != 0.0f) {
		rotateMatrix.m[2][0] /= cachedWorldTransform_.scale.z;
		rotateMatrix.m[2][1] /= cachedWorldTransform_.scale.z;
		rotateMatrix.m[2][2] /= cachedWorldTransform_.scale.z;
	}
	// å›è»¢è¡Œåˆ—ã‹ã‚‰ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›
	cachedWorldTransform_.rotate = Math::MatrixToQuaternion(rotateMatrix);

	/// ===ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰ä½ç½®ã‚’å–å¾—=== ///
	cachedWorldTransform_.translate = {
		worldMatrix_.m[3][0],
		worldMatrix_.m[3][1],
		worldMatrix_.m[3][2]
	};

	worldTransformCacheDirtyTag_.rotate = false; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æœ‰åŠ¹ã«ã™ã‚‹
	return cachedWorldTransform_.rotate;
}
// Scale
const Vector3& ModelCommon::GetWorldScale() const {
	// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒæœ‰åŠ¹ãªã‚‰ãã®ã¾ã¾è¿”ã™
	if (!worldTransformCacheDirtyTag_.scale) {
		return cachedWorldTransform_.scale;
	}

	// ===ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã‹ã‚‰ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å–å¾—=== ///
	cachedWorldTransform_.scale.x = std::sqrt(
		worldMatrix_.m[0][0] * worldMatrix_.m[0][0] +
		worldMatrix_.m[0][1] * worldMatrix_.m[0][1] +
		worldMatrix_.m[0][2] * worldMatrix_.m[0][2]
	);
	cachedWorldTransform_.scale.y = std::sqrt(
		worldMatrix_.m[1][0] * worldMatrix_.m[1][0] +
		worldMatrix_.m[1][1] * worldMatrix_.m[1][1] +
		worldMatrix_.m[1][2] * worldMatrix_.m[1][2]
	);
	cachedWorldTransform_.scale.z = std::sqrt(
		worldMatrix_.m[2][0] * worldMatrix_.m[2][0] +
		worldMatrix_.m[2][1] * worldMatrix_.m[2][1] +
		worldMatrix_.m[2][2] * worldMatrix_.m[2][2]
	);

	worldTransformCacheDirtyTag_.scale = false; // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æœ‰åŠ¹ã«ã™ã‚‹
	return cachedWorldTransform_.scale;
}
// Transformï¼ˆä½ç½®ã€å›è»¢ã€æ‹¡ç¸®ï¼‰ã‚’å–å¾—
const QuaternionTransform& ModelCommon::GetWorldTransform() const { 

	cachedWorldTransform_.scale = GetWorldScale();
	cachedWorldTransform_.rotate = GetWorldRotate();
	cachedWorldTransform_.translate = GetWorldTranslate();

	return cachedWorldTransform_;
}
// Color
const Vector4& ModelCommon::GetColor() const { return color_; }


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ModelCommon::Create(ID3D12Device* device, LightType type) {
	/// ===åˆæœŸåŒ–æ™‚ã®è¨­å®š=== ///
	worldTransform_ = { { 1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f, 0.0f } };
	uvTransform_ = { {1.0f, 1.0f,1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };
	color_ = { 1.0f, 1.0f, 1.0f, 1.0f };
	light_ = {
		40.0f,
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, -1.0f, 0.0f } ,1.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, 0.0f, 0.0f } , 1.0f, 0.0f, 0.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, 0.0f, 0.0f } , 0.0f, { 0.0f, 0.0f, 0.0f } , 0.0f, 0.0f, 0.0f}
	};
	environmentMapInfo_ = {
		"skyBox",
		false,
		1.0f
	};

	/// ===ç”Ÿæˆ=== ///
	vertex_ = std::make_unique<VertexBuffer3D>();
	index_ = std::make_unique<IndexBuffer3D>();
	common_ = std::make_unique<ObjectCommon>();

	/// ===vertex=== ///
	// Buffer
	vertex_->Create(device, sizeof(VertexData3D) * modelData_.vertices.size());
	vertex_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&vertexData_));
	// ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼
	std::memcpy(vertexData_, modelData_.vertices.data(), sizeof(VertexData3D) * modelData_.vertices.size());
	// view
	vertexBufferView_.BufferLocation = vertex_->GetBuffer()->GetGPUVirtualAddress();
	vertexBufferView_.SizeInBytes = UINT(sizeof(VertexData3D) * modelData_.vertices.size());
	vertexBufferView_.StrideInBytes = sizeof(VertexData3D);

	/// ===index=== ///
	index_->Create(device, sizeof(uint32_t) * modelData_.indices.size());
	index_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&indexData_));
	// ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼
	std::memcpy(indexData_, modelData_.indices.data(), sizeof(uint32_t) * modelData_.indices.size());
	// view
	indexBufferView_.BufferLocation = index_->GetBuffer()->GetGPUVirtualAddress();
	indexBufferView_.SizeInBytes = UINT(sizeof(uint32_t) * modelData_.indices.size());
	indexBufferView_.Format = DXGI_FORMAT_R32_UINT;

	/// ===Common=== ///
	common_->Initialize(device, type);
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void ModelCommon::Update() {
	/// ===ã‚«ãƒ¡ãƒ©ã®è¨­å®š=== ///
	camera_ = CameraService::GetActiveCamera().get();

	// MaterialDataã®æ›¸ãè¾¼ã¿
	MaterialDataWrite();
	// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿
	TransformDataWrite();
	// Lightã®æ›¸ãè¾¼ã¿
	LightDataWrite();
	// Cameraã®æ›¸ãè¾¼ã¿
	CameraDataWrite();
	// ç’°å¢ƒãƒãƒƒãƒ—ã®æ›¸ãè¾¼ã¿
	EnvironmentMapDataWrite();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ModelCommon::Bind(ID3D12GraphicsCommandList* commandList) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// Commonã®è¨­å®š
	common_->Bind(commandList);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
	Render::SetGraphicsRootDescriptorTable(commandList, 2, modelData_.material.textureFilePath);
	Render::SetGraphicsRootDescriptorTable(commandList, 3, environmentMapInfo_.textureName);
}

///-------------------------------------------/// 
/// MaterialDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void ModelCommon::MaterialDataWrite() {
	/// ===Matrixã®ä½œæˆ=== ///
	Matrix4x4 uvTransformMatrix = Math::MakeScaleMatrix(uvTransform_.scale);
	Matrix4x4 uvTransformMatrixMultiply = Multiply(uvTransformMatrix, Math::MakeRotateZMatrix(uvTransform_.rotate.z));
	uvTransformMatrixMultiply = Multiply(uvTransformMatrixMultiply, Math::MakeTranslateMatrix(uvTransform_.translate));

	/// ===å€¤ã®ä»£å…¥=== ///
	common_->SetMatiarlData(
		color_,
		light_.shininess,
		uvTransformMatrixMultiply
	);
}

///-------------------------------------------/// 
/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void ModelCommon::TransformDataWrite() {

	worldMatrix_ = Math::MakeAffineQuaternionMatrix(worldTransform_.scale, worldTransform_.rotate, worldTransform_.translate);
	Matrix4x4 worldViewProjectionMatrix;

	/// ===è¦ªã®ç¢ºèª=== ///
	if (parent_) {

		// è¦ªã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
		Matrix4x4 parentWorldMatrix = Math::MakeAffineQuaternionMatrix(parent_->worldTransform_.scale, parent_->worldTransform_.rotate, parent_->worldTransform_.translate);
		// ã‚ªãƒ•ã‚»ãƒƒãƒˆè¡Œåˆ—ã‚’ä½œæˆï¼ˆè¦ªã®å›è»¢ã¨æ‹¡å¤§ç¸®å°ã‚’é©ç”¨ã™ã‚‹ãŸã‚ï¼‰
		Matrix4x4 offsetMatrix = Math::MakeTranslateMatrix(parentOffset_);
		// åˆæˆ
		worldMatrix_ = Multiply(worldMatrix_, offsetMatrix);
		worldMatrix_ = Multiply(worldMatrix_, parentWorldMatrix);
	}

	// ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡åŠ¹åŒ–
	worldTransformCacheDirtyTag_.translate = true; 
	worldTransformCacheDirtyTag_.rotate = true;
	worldTransformCacheDirtyTag_.scale = true;

	/// ===Matrixã®ä½œæˆ=== ///
	const Matrix4x4& viewProjectionMatrix = camera_->GetViewProjectionMatrix();
	worldViewProjectionMatrix = Multiply(worldMatrix_, viewProjectionMatrix);

	/// ===å€¤ã®ä»£å…¥=== ///
	common_->SetTransformData(
		worldViewProjectionMatrix,
		Multiply(modelData_.rootNode.localMatrix, worldMatrix_),
		Math::Inverse4x4(worldMatrix_)
	);

}

///-------------------------------------------///  
///ã€€ãƒ©ã‚¤ãƒˆã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void ModelCommon::LightDataWrite() {
	
	// DirectionalLightã®æ›¸ãè¾¼ã¿
	common_->SetDirectionLight(
		light_.directional.color,
		light_.directional.direction,
		light_.directional.intensity
	);

	// PointLightã®æ›¸ãè¾¼ã¿
	common_->SetPointLightData(
		light_.point.color,
		light_.point.position,
		light_.point.intensity,
		light_.point.radius,
		light_.point.decay
	);

	// SpotLightã®æ›¸ãè¾¼ã¿
	common_->SetSpotLightData(
		light_.spot.color,
		light_.spot.position,
		light_.spot.direction,
		light_.spot.intensity,
		light_.spot.distance,
		light_.spot.decay,
		light_.spot.cosAngle
	);
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void ModelCommon::CameraDataWrite() {
	common_->SetCameraForGPU(camera_->GetTranslate()); // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã§å–å¾—
}

///-------------------------------------------/// 
/// ç’°å¢ƒãƒãƒƒãƒ—ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void ModelCommon::EnvironmentMapDataWrite() {
	common_->SetEnviromentMapData(environmentMapInfo_.isEnvironmentMap, environmentMapInfo_.strength);
}

============================================================
File Path: Project/Engine/Graphics/3d/Model/ModelCommon.h
============================================================
#pragma once
/// ===include=== ///
// Buffer
#include "Engine/Graphics/3d/Base/VertexBuffer3D.h"
#include "Engine/Graphics/3d/Base/IndexBuffer3D.h"
#include "Engine/Graphics/3d/Base/ObjectCommon.h"
// Data
#include "Engine/DataInfo/BlendModeData.h"
// c++
#include <memory>
#include <string>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// ãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨
///=====================================================///
class ModelCommon {
public:
	ModelCommon() = default;
	~ModelCommon();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†ã€é †æ•°ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="modelName">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«åã€‚</param>
	/// <param name="type">ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’è¡¨ã™å€¤ï¼ˆLightTypeï¼‰ã€‚</param>
	virtual void Initialize(const std::string& modelName, LightType type) = 0;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update();

	/// <summary>
	/// æç”»å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚BlendMode åˆ—æŒ™å‹ã§åˆæˆæ–¹æ³•ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	virtual void Draw(BlendMode mode) = 0;

	/// <summary>
	/// ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="device">ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã«ä½¿ç”¨ã™ã‚‹ID3D12Deviceã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</param>
	/// <param name="type">ä½œæˆã™ã‚‹ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’ç¤ºã™LightTypeã®å€¤ã€‚</param>
	void Create(ID3D12Device* device, LightType type);

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">ãƒã‚¤ãƒ³ãƒ‰ãŠã‚ˆã³æ“ä½œã«ä½¿ç”¨ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void Bind(ID3D12GraphicsCommandList* commandList);

public: /// ===è¦ªå­é–¢ä¿‚=== ///
	/// <summary>
	/// è¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	/// </summary>
	/// <param name="parent">è¦ªã¨ãªã‚‹ ModelCommon å‹ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è¨­å®šã™ã‚‹è¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã—ã¾ã™ã€‚nullptr ã®å–ã‚Šæ‰±ã„ï¼ˆè¦ªã®è§£é™¤ã‚’æ„å‘³ã™ã‚‹ã‹ã©ã†ã‹ãªã©ï¼‰ã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚</param>
	void SetParent(ModelCommon* parent);
	/// <summary>
	///  è¦ªã®è§£é™¤
	/// </summary>
	void ClearParent();
	// Offset
	void SetParentOffset(const Vector3& offset);
	const Vector3& GetParentOffset() const;

public:/// ===Setter=== ///
	// Translate
	void SetTranslate(const Vector3& position);
	// Rotate
	void SetRotate(const Quaternion& rotate);
	// Scale
	void SetScale(const Vector3& scale);
	// Color
	void SetColor(const Vector4& color);
	// Light
	void SetLightType(LightType type);
	// LightData
	void SetLightData(LightInfo light);
	// ç’°å¢ƒãƒãƒƒãƒ—
	void SetEnvironmentMapData(bool flag, float string);

public: /// ===Getter=== ///
	// Transformï¼ˆä½ç½®ã€å›è»¢ã€æ‹¡ç¸®ï¼‰ã‚’å–å¾—
	const Vector3& GetWorldTranslate() const;
	const Quaternion& GetWorldRotate() const;
	const Vector3& GetWorldScale() const;
	const QuaternionTransform& GetWorldTransform() const;
	// Colorï¼ˆè‰²ï¼‰ã‚’å–å¾—
	const Vector4& GetColor() const;

protected: /// ===ç¶™æ‰¿å…ˆã§ä½¿ç”¨ã™ã‚‹å¤‰æ•°=== ///

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼=== ///
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};
	D3D12_INDEX_BUFFER_VIEW indexBufferView_{};

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
	VertexData3D* vertexData_ = nullptr;
	uint32_t* indexData_ = nullptr;

	/// ===ãƒ¢ãƒ‡ãƒ«æƒ…å ±=== ///
	ModelData modelData_;
	EulerTransform uvTransform_;
	QuaternionTransform worldTransform_;
	Vector4 color_;

	/// ===è¦ªå­é–¢ä¿‚=== ///
	ModelCommon* parent_ = nullptr;
	Vector3 parentOffset_ = { 0.0f,0.0f,0.0f };

	/// ===Light=== ///
	LightInfo light_;

	/// ===Camera=== ///
	GameCamera* camera_ = nullptr;

	/// ===ç’°å¢ƒãƒãƒƒãƒ—=== ///
	EnvironmentMapInfo environmentMapInfo_;

private:/// ===Variables(å¤‰æ•°)=== ///

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	std::unique_ptr<VertexBuffer3D> vertex_;
	std::unique_ptr<IndexBuffer3D> index_;
	std::unique_ptr<ObjectCommon> common_;

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
	Matrix4x4 worldMatrix_;

	// Getterç”¨
	mutable QuaternionTransform cachedWorldTransform_;
	struct WorldTransformCacheDirtyTag {
		mutable bool translate = false;
		mutable bool rotate = false;
		mutable bool scale = false;
	};
	WorldTransformCacheDirtyTag worldTransformCacheDirtyTag_;

private:
	/// <summary>
	/// MaterialDataã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void MaterialDataWrite();

	/// <summary>
	/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void TransformDataWrite();

	/// <summary>
	/// LightDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void LightDataWrite();

	/// <summary>
	/// CameraDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void CameraDataWrite();

	/// <summary>
	/// EnvironmentMapDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void EnvironmentMapDataWrite();
};



============================================================
File Path: Project/Engine/Graphics/3d/Ocean/Ocean.cpp
============================================================
#include "Ocean.h"
// c++
#include <cassert>
// Service
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
#include "Engine/System/Service/DeltaTimeSevice.h"
// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"

#ifdef USE_IMGUI
#include <imgui.h>
#endif

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Ocean::~Ocean() {
    vertex_.reset();
    index_.reset();
    material_.reset();
    wvp_.reset();
    directionallight_.reset();
    camera3D_.reset();
    oceanColorBuffer_.reset();
    waveCompute_.reset();
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// æ³¢æƒ…å ±ã®è¨­å®š
void Ocean::SetWaveInfo(int waveIndex, const Vector3& direction, float amplitude, float length, float speed) {
    if (waveIndex >= 0 && waveIndex < kWaveCount_) {
        waveInfos_[waveIndex].distance = direction;
        waveInfos_[waveIndex].amplitude = amplitude;
        waveInfos_[waveIndex].length = length;
        waveInfos_[waveIndex].speed = speed;
    }
}
// è‰²æƒ…å ±ã®è¨­å®š
void Ocean::SetColorInfo(const OceanColorInfo& colorInfo) {
    colorInfo_ = colorInfo;
}
// æ³¢ç´‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
void Ocean::SetRippleSpeed(float speed) { rippleSpeed_ = speed; }
void Ocean::SetRippleDecay(float decay) { rippleDecay_ = decay; }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Ocean::Initialize(int gridSize) {
    ID3D12Device* device = GraphicsResourceGetter::GetDXDevice();

    /// ===ç”Ÿæˆ=== ///
    vertex_ = std::make_unique<BufferBase>();
    index_ = std::make_unique<BufferBase>();
    material_ = std::make_unique<Material3D>();
    wvp_ = std::make_unique<Transform3D>();
    camera3D_ = std::make_unique<BufferBase>();
    directionallight_ = std::make_unique<BufferBase>();
    oceanColorBuffer_ = std::make_unique<BufferBase>();
    waveCompute_ = std::make_unique<OceanWaveCompute>();

    /// ===ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã®è¨­å®š=== ///
    gridSize_ = gridSize;
    vertexCount_ = (gridSize_ + 1) * (gridSize_ + 1);
    indexCount_ = gridSize_ * gridSize_ * 6;

    /// ===worldTransform=== ///
    worldTransform_ = { { 0.5f, 1.0f, 0.5f }, { 0.0f, 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f, 0.0f } };
    uvTransform_ = { {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };

    /// ===WaveComputeåˆæœŸåŒ–=== ///
    waveCompute_->Initialize(device, gridSize_);

    /// ===vertex=== ///
    // Compute Shaderã®å‡ºåŠ›ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹ï¼ˆWaveVertexDataã¨åŒã˜ã‚µã‚¤ã‚ºï¼‰
    vertex_->SetBuffer(waveCompute_->GetOutputBuffer());
    vertexBufferView_.BufferLocation = vertex_->GetBuffer()->GetGPUVirtualAddress();
    vertexBufferView_.SizeInBytes = sizeof(VertexData3D) * vertexCount_;
    vertexBufferView_.StrideInBytes = sizeof(VertexData3D);
    //CreateGridMesh(); // åˆæœŸçŠ¶æ…‹ï¼ˆå¹³é¢ï¼‰ã‚’ä½œæˆ

    vertexBufferView_.BufferLocation = vertex_->GetBuffer()->GetGPUVirtualAddress();
    vertexBufferView_.SizeInBytes = sizeof(VertexData3D) * vertexCount_;
    vertexBufferView_.StrideInBytes = sizeof(VertexData3D);

    /// ===index=== ///
    index_->Create(device, sizeof(uint32_t) * indexCount_);
    index_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&indexData_));

    int idx = 0;
    for (int z = 0; z < gridSize_; ++z) {
        for (int x = 0; x < gridSize_; ++x) {
            int topLeft = z * (gridSize_ + 1) + x;
            int topRight = topLeft + 1;
            int bottomLeft = (z + 1) * (gridSize_ + 1) + x;
            int bottomRight = bottomLeft + 1;

            indexData_[idx++] = topLeft;
            indexData_[idx++] = bottomLeft;
            indexData_[idx++] = topRight;
            indexData_[idx++] = topRight;
            indexData_[idx++] = bottomLeft;
            indexData_[idx++] = bottomRight;
        }
    }

    indexBufferView_.BufferLocation = index_->GetBuffer()->GetGPUVirtualAddress();
    indexBufferView_.SizeInBytes = sizeof(uint32_t) * indexCount_;
    indexBufferView_.Format = DXGI_FORMAT_R32_UINT;

    /// ===OceanCommon=== ///
    OceanCommon::Initialize(device);

    /// ===æ³¢æƒ…å ±ã®åˆæœŸåŒ–=== ///
    InitializeWaveInfos();

    /// ===æ³¢ç´‹ãƒãƒƒãƒ•ã‚¡ã®åˆæœŸåŒ–=== ///
    for (int i = 0; i < 8; ++i) {
        ripples_[i].isActive = false;
        ripples_[i].position = { 0.0f, 0.0f };
        ripples_[i].startTime = 0.0f;
        ripples_[i].intensity = 0.0f;
        ripples_[i].duration = 3.0f;
        ripples_[i].maxRadius = 20.0f;
        ripples_[i].speed = 4.0f;
        ripples_[i].priority = 0;
    }

    rippleBuffer_.activeCount = 0;
    rippleBuffer_.currentTime = 0.0f;
    rippleBuffer_.rippleSpeed = rippleSpeed_;
    rippleBuffer_.rippleDecay = rippleDecay_;

    // æ³¢ç´‹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
    for (int i = 0; i < 8; ++i) {
        rippleBuffer_.ripples[i].position = { 0.0f, 0.0f };
        rippleBuffer_.ripples[i].startTime = 0.0f;
        rippleBuffer_.ripples[i].intensity = 0.0f;
        rippleBuffer_.ripples[i].duration = 0.0f;
        rippleBuffer_.ripples[i].maxRadius = 0.0f;
        rippleBuffer_.ripples[i].speed = 0.0f;
        rippleBuffer_.ripples[i].padding = 0.0f;
    }

    nextPriority_ = 0;

    /// ===OceanColorBuffer=== ///
    oceanColorBuffer_->Create(device, sizeof(OceanColorInfo));
    oceanColorBuffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&oceanColorData_));
    *oceanColorData_ = colorInfo_;
}

///-------------------------------------------/// 
/// æ³¢æƒ…å ±ã®åˆæœŸåŒ–ï¼ˆ12å€‹ï¼‰
///-------------------------------------------///
void Ocean::InitializeWaveInfos() {
   
    //// æœ€åˆã®3ã¤ã¯å¾“æ¥ã®æ³¢
    /*waveInfos_[0] = { { 0.53f, 0.0f, 0.77f }, 1.308f, 10.033f, 2.187f, 0.0f, 0.0f };
    waveInfos_[1] = { { 0.0f, 0.2f, 0.6f }, 0.056f, 7.369f, 2.320f, 0.0f, 0.0f };
    waveInfos_[2] = { { 0.28f, 0.03f, 0.0f }, 0.879f, 4.355f, 2.098f, 0.0f, 0.0f };*/

    // æœ€åˆã®3ã¤ã¯å¾“æ¥ã®æ³¢
    waveInfos_[0] = { { 0.0f, 0.0f, 0.0f }, 1.308f, 10.033f, 2.187f, 0.0f, 0.0f };
    waveInfos_[1] = { { 0.0f, 0.0f, 0.0f }, 0.056f, 7.369f, 2.320f, 0.0f, 0.0f };
    waveInfos_[2] = { { 0.0f, 0.0f, 0.0f }, 0.879f, 4.355f, 2.098f, 0.0f, 0.0f };
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Ocean::Update() {
    currentTime_ += DeltaTimeSevice::GetDeltaTime();

    /// ===æ™‚é–“ã®æ›´æ–°=== ///
    for (int i = 0; i < kWaveCount_; ++i) {
        waveInfos_[i].time = currentTime_;
    }

    /// ===æ³¢ç´‹ã®æ›´æ–°=== ///
    UpdateRipples();

    /// ===WorldMatrixã®æ›´æ–°=== ///
	waveCompute_->UpdateWorldMatrix(Math::MakeAffineQuaternionMatrix(worldTransform_.scale, worldTransform_.rotate, worldTransform_.translate));

    /// ===Compute Shaderã§æ³¢ã‚’è¨ˆç®—=== ///
    waveCompute_->UpdateWaveInfos(waveInfos_);
    waveCompute_->UpdateRippleBuffer(rippleBuffer_);

    /// ===ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿=== ///
    OceanCommon::Update();
    ColorDataWrite();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void Ocean::Draw(BlendMode mode) {
    ID3D12GraphicsCommandList* commandList = GraphicsResourceGetter::GetDXCommandList();

    // Compute PSOã¨Root Signatureã‚’è¨­å®š
    Render::SetPSO(commandList, PipelineType::CSOcean, BlendMode::KBlendModeNormal);
    // Compute Shaderã‚’å®Ÿè¡Œ
    waveCompute_->Dispatch(commandList);
    // UAV -> Vertex Bufferã¸ã®çŠ¶æ…‹é·ç§»
    D3D12_RESOURCE_BARRIER barrier = {};
    barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrier.Transition.pResource = vertex_->GetBuffer();
    barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
    barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_VERTEX_AND_CONSTANT_BUFFER;
    commandList->ResourceBarrier(1, &barrier);

    // Graphics PSOã‚’è¨­å®š
    Render::SetPSO(commandList, PipelineType::PrimitiveOcean, mode);

    commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
    commandList->IASetIndexBuffer(&indexBufferView_);

    // ãƒãƒƒãƒ•ã‚¡ã®è¨­å®š
    commandList->SetGraphicsRootConstantBufferView(0, material_->GetBuffer()->GetGPUVirtualAddress());
    commandList->SetGraphicsRootConstantBufferView(1, wvp_->GetBuffer()->GetGPUVirtualAddress());
    commandList->SetGraphicsRootConstantBufferView(2, directionallight_->GetBuffer()->GetGPUVirtualAddress());
    commandList->SetGraphicsRootConstantBufferView(3, camera3D_->GetBuffer()->GetGPUVirtualAddress());
    // OceanColorBufferã®è¨­å®š
    commandList->SetGraphicsRootConstantBufferView(4, oceanColorBuffer_->GetBuffer()->GetGPUVirtualAddress());

    commandList->DrawIndexedInstanced(indexCount_, 1, 0, 0, 0);
}

///-------------------------------------------/// 
/// ImGui
///-------------------------------------------///
void Ocean::ShowImGui() {
#ifdef USE_IMGUI
    ImGui::Begin("æµ·æ´‹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼");

    /// ===Transformæƒ…å ±=== ///
    if (ImGui::CollapsingHeader("Transform", ImGuiTreeNodeFlags_DefaultOpen)) {
        ImGui::DragFloat3("Translate", &worldTransform_.translate.x, 0.1f);
        ImGui::DragFloat4("Rotate", &worldTransform_.rotate.x, 0.01f);
        ImGui::DragFloat3("Scale", &worldTransform_.scale.x, 0.1f);
    }

    /// ===ã‚°ãƒªãƒƒãƒ‰æƒ…å ±=== ///
    if (ImGui::CollapsingHeader("ã‚°ãƒªãƒƒãƒ‰æƒ…å ±")) {
        ImGui::Text("ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚º : %d x %d", gridSize_, gridSize_);
        ImGui::Text("Vertexæ•° : %d", vertexCount_);
        ImGui::Text("Indexæ•° : %d", indexCount_);
        ImGui::Text("Triangleæ•° : %d", indexCount_ / 3);
    }

    /// ===æ³¢ã®æƒ…å ±=== ///
    if (ImGui::CollapsingHeader("æ³¢ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿", ImGuiTreeNodeFlags_DefaultOpen)) {
        for (int i = 0; i < kWaveCount_; ++i) {
            ImGui::PushID(i);
            if (ImGui::TreeNode("æ³¢", "æ³¢ %d", i)) {
                ImGui::Text("æ³¢ã®æ–¹å‘ : (%.2f, %.2f, %.2f)", waveInfos_[i].distance.x, waveInfos_[i].distance.y, waveInfos_[i].distance.z);
                ImGui::Text("æ³¢ã®æŒ¯å¹… : %.2f", waveInfos_[i].amplitude);
                ImGui::Text("æ³¢ã®æ³¢é•· : %.2f", waveInfos_[i].length);
                ImGui::Text("æ³¢ã®é€Ÿåº¦ : %.2f", waveInfos_[i].speed);

                ImGui::Separator();

                ImGui::DragFloat3("æ–¹å‘", &waveInfos_[i].distance.x, 0.01f, -1.0f, 1.0f);
                ImGui::SliderFloat("æŒ¯å¹…", &waveInfos_[i].amplitude, 0.0f, 2.0f);
                ImGui::SliderFloat("æ³¢é•·", &waveInfos_[i].length, 1.0f, 30.0f);
                ImGui::SliderFloat("é€Ÿåº¦", &waveInfos_[i].speed, 0.5f, 10.0f);

                ImGui::TreePop();
            }
            ImGui::PopID();
        }
    }

    /// ===æ³¢ç´‹æƒ…å ±=== ///
    if (ImGui::CollapsingHeader("æ³¢ç´‹æƒ…å ±", ImGuiTreeNodeFlags_DefaultOpen)) {
        ImGui::Text("Active Ripples: %d / 8", rippleBuffer_.activeCount);

        ImGui::Text("æ³¢ç´‹ã®é€Ÿåº¦ : %.2f", rippleSpeed_);
        ImGui::Text("æ³¢ç´‹ã®æ¸›è¡° : %.2f", rippleDecay_);

        if (ImGui::SliderFloat("é€Ÿåº¦", &rippleSpeed_, 1.0f, 10.0f)) {
            rippleBuffer_.rippleSpeed = rippleSpeed_;
        }
        if (ImGui::SliderFloat("æ¸›è¡°", &rippleDecay_, 0.1f, 3.0f)) {
            rippleBuffer_.rippleDecay = rippleDecay_;
        }
        if (ImGui::Button("å…¨ã¦ã®æ³¢ç´‹ã‚’ã‚¯ãƒªã‚¢")) {
            ClearRipples();
        }
    }

    /// ===è‰²æƒ…å ±=== ///
    if (ImGui::CollapsingHeader("è‰²")) {
        ImGui::ColorEdit3("æµ·é¢ã®åŸºæœ¬è‰²", &colorInfo_.seaBase.x);
        ImGui::ColorEdit3("æµ…ç€¬ã®è‰²", &colorInfo_.seaShallow.x);
        ImGui::ColorEdit3("ç©ºã®è‰²", &colorInfo_.sky.x);
        ImGui::ColorEdit3("æ·±æµ·ã®è‰²", &colorInfo_.deepWater.x);
        ImGui::SliderFloat("åŸºæœ¬è‰²ã®å¼·åº¦", &colorInfo_.baseStrength, 0.0f, 2.0f);
        ImGui::SliderFloat("æ°´ã®é€æ˜åº¦", &colorInfo_.waterClarity, 0.0f, 1.0f);
        ImGui::SliderFloat("æ³¡ã®é–¾å€¤", &colorInfo_.foamThreshold, 0.0f, 3.0f);
    }

    /// ===ãƒ©ã‚¤ãƒˆæƒ…å ±=== ///
    if (ImGui::CollapsingHeader("ãƒ©ã‚¤ãƒˆæƒ…å ±")) {
        ImGui::Text("å…‰æ²¢åº¦: %.2f", light_.shininess);
        ImGui::DragFloat("å…‰æ²¢åº¦", &light_.shininess, 0.1f);
        ImGui::ColorEdit4("ãƒ©ã‚¤ãƒˆã®è‰²", &light_.directional.color.x);
        ImGui::SliderFloat3("æ–¹å‘", &light_.directional.direction.x, -1.0f, 1.0f);
        ImGui::SliderFloat("å¼·åº¦", &light_.directional.intensity, 0.0f, 5.0f);
    }

    // ãƒ†ã‚¹ãƒˆæ©Ÿèƒ½
    if (ImGui::CollapsingHeader("ãƒ†ã‚¹ãƒˆ")) {
        static float testIntensity = 1.0f;
        static float testPosX = 0.0f;
        static float testPosZ = 0.0f;

        ImGui::SliderFloat("ãƒ†ã‚¹ãƒˆå¼·åº¦", &testIntensity, 0.1f, 10.0f);
        ImGui::SliderFloat("ãƒ†ã‚¹ãƒˆåº§æ¨™X", &testPosX, -50.0f, 50.0f);
        ImGui::SliderFloat("ãƒ†ã‚¹ãƒˆåº§æ¨™Z", &testPosZ, -50.0f, 50.0f);

        if (ImGui::Button("æ³¢ç´‹ã®è¿½åŠ ")) {
            AddCircularRipple({ testPosX, 0.0f, testPosZ }, 3.0f, testIntensity);
        }
        ImGui::SameLine();

        if (ImGui::Button("ãƒ©ãƒ³ãƒ€ãƒ ãªä½ç½®ã«è¿½åŠ ")) {
            float randX = static_cast<float>(rand() % 100 - 50);
            float randZ = static_cast<float>(rand() % 100 - 50);
            float randIntensity = 0.5f + (rand() % 100) / 100.0f * 1.5f;
            AddCircularRipple({ randX, 0.0f, randZ }, 3.0f, randIntensity);
        }
    }

    ImGui::End();
#endif
}

///-------------------------------------------/// 
/// ã‚°ãƒªãƒƒãƒ‰ãƒ¡ãƒƒã‚·ãƒ¥ã®ç”Ÿæˆ
///-------------------------------------------///
void Ocean::CreateGridMesh() {
    float gridWidth = 100.0f;
    float gridDepth = 100.0f;
    float step = gridWidth / gridSize_;

    int vertexIndex = 0;
    for (int i = 0; i <= gridSize_; i++) {
        for (int j = 0; j <= gridSize_; j++) {
            float x = -gridWidth * 0.5f + j * step;
            float z = -gridDepth * 0.5f + i * step;
            float u = (float)j / gridSize_;
            float v = (float)i / gridSize_;

            vertexData_[vertexIndex] = {
                {x, 0.0f, z, 1.0f},
                {u, v},
                {0.0f, 1.0f, 0.0f}
            };
            vertexIndex++;
        }
    }
}

///-------------------------------------------/// 
/// ColorDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Ocean::ColorDataWrite() {
    *oceanColorData_ = colorInfo_;
}

///-------------------------------------------/// 
/// æ³¢ç´‹ã®æ›´æ–°
///-------------------------------------------///
void Ocean::UpdateRipples() {
    int activeCount = 0;

    for (int i = 0; i < 8; ++i) {
        if (ripples_[i].isActive) {
            float elapsed = currentTime_ - ripples_[i].startTime;

            if (elapsed > ripples_[i].duration) {
                ripples_[i].isActive = false;
            } else {
                rippleBuffer_.ripples[activeCount].position = ripples_[i].position;
                rippleBuffer_.ripples[activeCount].startTime = ripples_[i].startTime;
                rippleBuffer_.ripples[activeCount].intensity = ripples_[i].intensity;
                rippleBuffer_.ripples[activeCount].duration = ripples_[i].duration;
                rippleBuffer_.ripples[activeCount].maxRadius = ripples_[i].maxRadius;
                rippleBuffer_.ripples[activeCount].speed = ripples_[i].speed;
                activeCount++;
            }
        }
    }

    rippleBuffer_.activeCount = activeCount;
    rippleBuffer_.currentTime = currentTime_;
    rippleBuffer_.rippleSpeed = rippleSpeed_;
    rippleBuffer_.rippleDecay = rippleDecay_;
}

///-------------------------------------------/// 
/// æ³¢ç´‹ã®è¿½åŠ 
///-------------------------------------------///
void Ocean::AddCircularRipple(const Vector3& center, float duration, float intensity, float maxRadius) {
    int targetSlot = -1;

    for (int i = 0; i < 8; ++i) {
        if (!ripples_[i].isActive) {
            targetSlot = i;
            break;
        }
    }

    if (targetSlot == -1) {
        int lowestPriority = ripples_[0].priority;
        targetSlot = 0;

        for (int i = 1; i < 8; ++i) {
            if (ripples_[i].priority < lowestPriority) {
                lowestPriority = ripples_[i].priority;
                targetSlot = i;
            }
        }
    }

    if (targetSlot >= 0 && targetSlot < 8) {
        ripples_[targetSlot].position = { center.x, center.z };
        ripples_[targetSlot].startTime = currentTime_;
        ripples_[targetSlot].intensity = intensity;
        ripples_[targetSlot].duration = duration;
        ripples_[targetSlot].maxRadius = maxRadius;
        ripples_[targetSlot].speed = maxRadius / duration;
        ripples_[targetSlot].priority = nextPriority_++;
        ripples_[targetSlot].isActive = true;
    }
}

///-------------------------------------------/// 
/// æ³¢ç´‹ã®ã‚¯ãƒªã‚¢
///-------------------------------------------///
void Ocean::ClearRipples() {
    for (int i = 0; i < 8; ++i) {
        ripples_[i].isActive = false;
    }
    rippleBuffer_.activeCount = 0;
    hitRecords_.clear();
}

============================================================
File Path: Project/Engine/Graphics/3d/Ocean/Ocean.h
============================================================
#pragma once
/// ===Include=== ///
// buffer
#include "Engine/Graphics/Base/BufferBase.h"
// Common
#include "OceanCommon.h"
// Wave Compute
#include "OceanWaveCompute.h"
// Pipeline
#include "Engine/DataInfo/PipelineStateObjectType.h"
// Data
#include "Engine/DataInfo/OceanData.h"
// c++
#include <vector>
#include <array>
#include <algorithm>

///=====================================================/// 
/// Ocean
///=====================================================///
class Ocean : public OceanCommon {
public:
    Ocean() = default;
    ~Ocean();

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    /// <param name="gridSize">ã‚°ãƒªãƒƒãƒ‰ã®ã‚µã‚¤ã‚ºï¼ˆç¸¦æ¨ªã®åˆ†å‰²æ•°ï¼‰</param>
    void Initialize(int gridSize);

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    /// <param name="mode">ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰</param>
    void Draw(BlendMode mode = BlendMode::KBlendModeNormal);

    /// <summary>
    /// ImGuiæƒ…å ±ã®è¡¨ç¤º
    /// </summary>
    void ShowImGui();

    /// <summary>
    /// å††çŠ¶ã«åºƒãŒã‚‹æ³¢ç´‹ã‚’è¿½åŠ 
    /// </summary>
    void AddCircularRipple(const Vector3& center, float duration = 3.0f, float intensity = 1.0f, float maxRadius = 20.0f);

    /// <summary>
    /// ã™ã¹ã¦ã®æ³¢ç´‹ã‚’ã‚¯ãƒªã‚¢
    /// </summary>
    void ClearRipples();

public: /// ===Setter=== ///
    // Ocean Wave Parametersï¼ˆ12å€‹ã®æ³¢å¯¾å¿œï¼‰
    void SetWaveInfo(int waveIndex, const Vector3& direction, float amplitude, float length, float speed);
    // Ocean Color Parameters
    void SetColorInfo(const OceanColorInfo& colorInfo);
    // Ripple Parameters
    void SetRippleSpeed(float speed);
    void SetRippleDecay(float decay);

private:
    /// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹=== ///
    std::unique_ptr<BufferBase> vertex_;
    std::unique_ptr<BufferBase> index_;
    std::unique_ptr<BufferBase> oceanColorBuffer_;    // è‰²æƒ…å ±ãƒãƒƒãƒ•ã‚¡

    /// ===Wave Compute=== ///
    std::unique_ptr<OceanWaveCompute> waveCompute_;

    /// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
    VertexData3D* vertexData_ = nullptr;
    uint32_t* indexData_ = nullptr;
    OceanColorInfo* oceanColorData_ = nullptr;

    /// ===ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼=== ///
    D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};
    D3D12_INDEX_BUFFER_VIEW indexBufferView_{};

    /// ===ã‚°ãƒªãƒƒãƒ‰æƒ…å ±=== ///
    int gridSize_ = 64;
    int vertexCount_ = 0;
    int indexCount_ = 0;

    /// ===æ³¢æƒ…å ±ï¼ˆ12å€‹ï¼‰=== ///
    std::array<OceanShaderInfo, kWaveCount_> waveInfos_;

    /// ===æ³¢ç´‹ç®¡ç†=== ///
    std::array<RippleData, 8> ripples_;
    RippleBufferForGPU rippleBuffer_;
    float currentTime_ = 0.0f;
    float rippleSpeed_ = 4.0f;
    float rippleDecay_ = 1.0f;
    int nextPriority_ = 0;

    // è¡çªæ¤œçŸ¥ç”¨
    struct HitRecord {
        int objectID;
        Vector3 lastPosition;
        bool wasHitting;
    };
    std::vector<HitRecord> hitRecords_;

    /// ===Ocean Coloræƒ…å ±=== ///
    OceanColorInfo colorInfo_ = {
        { 0.1f, 0.4f, 0.6f }, 0.0f,
        { 0.2f, 0.7f, 0.8f }, 0.0f,
        { 0.4f, 0.6f, 0.9f }, 0.0f,
        { 0.0f, 0.05f, 0.2f },
        1.2f,
        0.3f,
        0.4f,
        0.5f
    };

private: /// ===Functions=== ///
    /// <summary>
    /// ã‚°ãƒªãƒƒãƒ‰ãƒ¡ãƒƒã‚·ãƒ¥ã®ç”Ÿæˆï¼ˆåˆæœŸçŠ¶æ…‹ãƒ»å¹³é¢ï¼‰
    /// </summary>
    void CreateGridMesh();

    /// <summary>
    /// ColorDataæ›¸ãè¾¼ã¿å‡¦ç†
    /// </summary>
    void ColorDataWrite();

    /// <summary>
    /// æ³¢ç´‹ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void UpdateRipples();

    /// <summary>
    /// æ³¢æƒ…å ±ã®åˆæœŸåŒ–ï¼ˆ12å€‹ï¼‰
    /// </summary>
    void InitializeWaveInfos();
};

============================================================
File Path: Project/Engine/Graphics/3d/Ocean/OceanCommon.cpp
============================================================
#include "OceanCommon.h"
// Service
#include "Engine/System/Service/Render.h"
#include "Engine/System/Service/CameraService.h"
// camera
#include "application/Game/Camera/GameCamera.h"

// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
OceanCommon::~OceanCommon() {
	material_.reset();
	wvp_.reset();
	directionallight_.reset();
	camera3D_.reset();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
const QuaternionTransform& OceanCommon::GetWorldTransform() const { return worldTransform_; }
const Vector4& OceanCommon::GetColor() const { return color_; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void OceanCommon::SetTranslate(const Vector3& position) { worldTransform_.translate = position; }
void OceanCommon::SetRotate(const Quaternion& rotate) { worldTransform_.rotate = rotate; }
void OceanCommon::SetScale(const Vector3& scale) { worldTransform_.scale = scale; }
void OceanCommon::SetColor(const Vector4& color) { color_ = color; }
void OceanCommon::SetLightData(LightInfo light) { light_ = light; }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void OceanCommon::Initialize(ID3D12Device* device) {
	/// ===ç”Ÿæˆ=== ///
	material_ = std::make_unique<Material3D>();
	wvp_ = std::make_unique<Transform3D>();
	//  Camera
	camera3D_ = std::make_unique<BufferBase>();
	// Light
	directionallight_ = std::make_unique<BufferBase>();

	/// ===worldTransform=== ///
	worldTransform_ = { { 10.0f, 1.0f, 10.0f }, { 0.0f, 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f, 0.0f } };
	uvTransform_ = { {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };

	/// ===Material=== ///
	material_->Create(device, sizeof(MaterialData3D));
	material_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&materialData_));
	// Dataæ›¸ãè¾¼ã¿
	materialData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	materialData_->enableLighting = 1;
	materialData_->shininess = 10.0f;
	materialData_->uvTransform = Math::MakeIdentity4x4();

	/// ===wvp=== ///
	wvp_->Create(device, sizeof(TransformationMatrix3D));
	wvp_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&wvpMatrixData_));
	// Dataã®æ›¸ãè¾¼ã¿
	wvpMatrixData_->WVP = Math::MakeIdentity4x4();
	wvpMatrixData_->World = Math::MakeIdentity4x4();
	wvpMatrixData_->WorldInverseTranspose = Math::Inverse4x4(wvpMatrixData_->World);

	/// ===DirectionalLight=== ///
	directionallight_->Create(device, sizeof(DirectionalLight));
	directionallight_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&directionalLightData_));
	// Dataæ›¸ãè¾¼ã¿
	directionalLightData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	directionalLightData_->direction = { 0.0f, -1.0f, 0.0f };  // çœŸä¸Šã‹ã‚‰
	directionalLightData_->intensity = 1.5f;  // å°‘ã—æ˜ã‚‹ã

	/// ===Camera=== ///
	camera3D_->Create(device, sizeof(CameraForGPU));
	camera3D_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&cameraData_));
	// Dataæ›¸ãè¾¼ã¿
	cameraData_->worldPosition = { 0.0f, 4.0f, -10.0f };
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void OceanCommon::Update() {
	camera_ = CameraService::GetActiveCamera().get();

	MaterialDataWrite();
	TransformDataWrite();
	LightDataWrite();
	CameraDataWrite();
}

///-------------------------------------------/// 
/// æç”»æº–å‚™
///-------------------------------------------///
void OceanCommon::Bind(ID3D12GraphicsCommandList* commandList) {
	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// MaterialBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(0, material_->GetBuffer()->GetGPUVirtualAddress());
	// wvpMatrixBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(1, wvp_->GetBuffer()->GetGPUVirtualAddress());
	// DirectionlLightã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(2, directionallight_->GetBuffer()->GetGPUVirtualAddress());
	// CameraBufferã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(3, camera3D_->GetBuffer()->GetGPUVirtualAddress());
}

///-------------------------------------------/// 
/// MaterialDataã®æ›¸ãè¾¼ã¿å‡¦ç†
///-------------------------------------------///
void OceanCommon::MaterialDataWrite() {
	// UVå¤‰æ›è¡Œåˆ—ã®è¨ˆç®—
	Matrix4x4 uvTransformMatrix = Math::MakeScaleMatrix(uvTransform_.scale);
	Matrix4x4 uvTransformMatrixMultiply = Multiply(uvTransformMatrix, Math::MakeRotateZMatrix(uvTransform_.rotate.z));
	uvTransformMatrixMultiply = Multiply(uvTransformMatrixMultiply, Math::MakeTranslateMatrix(uvTransform_.translate));

	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	materialData_->color = color_;
	materialData_->shininess = light_.shininess;
	materialData_->uvTransform = uvTransformMatrixMultiply;
}

///-------------------------------------------/// 
/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿å‡¦ç†
///-------------------------------------------///
void OceanCommon::TransformDataWrite() {
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®è¨ˆç®—
	Matrix4x4 worldMatrix = Math::MakeAffineQuaternionMatrix(worldTransform_.scale, worldTransform_.rotate, worldTransform_.translate);
	Matrix4x4 worldViewProjectionMatrix;
	// ãƒ“ãƒ¥ãƒ¼å°„å½±è¡Œåˆ—ã®å–å¾—ã¨æ›ã‘ç®—
	const Matrix4x4& viewProjectionMatrix = camera_->GetViewProjectionMatrix();
	worldViewProjectionMatrix = Multiply(worldMatrix, viewProjectionMatrix);

	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	wvpMatrixData_->WVP = worldViewProjectionMatrix;
	wvpMatrixData_->World = worldMatrix;
	wvpMatrixData_->WorldInverseTranspose = Math::Inverse4x4(worldMatrix);
}

///-------------------------------------------/// 
/// LightDataæ›¸ãè¾¼ã¿å‡¦ç†
///-------------------------------------------///
void OceanCommon::LightDataWrite() {
	// å¹³è¡Œå…‰æºã®ãƒ‡ãƒ¼ã‚¿æ›¸ãè¾¼ã¿
	directionalLightData_->color = light_.directional.color;
	directionalLightData_->direction = light_.directional.direction;
	directionalLightData_->intensity = light_.directional.intensity;
}

///-------------------------------------------/// 
/// CameraDataæ›¸ãè¾¼ã¿å‡¦ç†
///-------------------------------------------///
void OceanCommon::CameraDataWrite() {
	// ã‚«ãƒ¡ãƒ©ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰ä½ç½®ã‚’æ›¸ãè¾¼ã¿
	cameraData_->worldPosition = camera_->GetTranslate();
}


============================================================
File Path: Project/Engine/Graphics/3d/Ocean/OceanCommon.h
============================================================
#pragma once
/// ===include=== ///
#include "Engine/Graphics/3d/Base/Material3D.h"
#include "Engine/Graphics/3d/Base/Transform3D.h"
#include "Engine/Graphics/Base/BufferBase.h"
// Data
#include "Engine/DataInfo/LightData.h"
// c++
#include <memory>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///-------------------------------------------/// 
/// OceanCommon
///-------------------------------------------///
class OceanCommon {
public:
	OceanCommon() = default;
	~OceanCommon();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ID3D12Deviceã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptrã§ã¯ãªã„å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»æº–å‚™å‡¦ç†
	/// </summary>
	void Bind(ID3D12GraphicsCommandList* commandList);

public: /// ===Getter=== ///
	// Transformæƒ…å ±å–å¾—
	const QuaternionTransform& GetWorldTransform() const;
	// Colorå–å¾—
	const Vector4& GetColor() const;

public: /// ===Setter=== ///
	// Transform
	void SetTranslate(const Vector3& position);
	void SetRotate(const Quaternion& rotate);
	void SetScale(const Vector3& scale);
	// Color
	void SetColor(const Vector4& color);
	// Light
	void SetLightData(LightInfo light);
protected:

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹=== ///
	std::unique_ptr<Material3D> material_;
	std::unique_ptr<Transform3D> wvp_;
	// Light
	std::unique_ptr<BufferBase> directionallight_;
	// Camera
	std::unique_ptr<BufferBase> camera3D_;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
	MaterialData3D* materialData_ = nullptr;
	TransformationMatrix3D* wvpMatrixData_ = nullptr;
	// Light
	DirectionalLight* directionalLightData_ = nullptr;
	// Camera
	CameraForGPU* cameraData_ = nullptr;

	/// ===UV=== ///
	EulerTransform uvTransform_;

	/// ===ã‚«ãƒ¡ãƒ©=== ///
	GameCamera* camera_ = nullptr;

	/// ===Transformæƒ…å ±=== ///
	QuaternionTransform worldTransform_;
	Vector4 color_ = { 1.0f, 1.0f, 1.0f, 1.0f };

	/// ===Light=== ///
	LightInfo light_ = {
		40.0f,
		{{ 1.0f, 1.0f, 1.0f, 1.0f }, { 0.0f, -1.0f, 0.0f }, 1.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f }, 1.0f, 0.0f, 0.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f }, 0.0f, { 0.0f, 0.0f, 0.0f }, 0.0f, 0.0f, 0.0f}
	};

private:

	/// <summary>
	/// MaterialDataã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void MaterialDataWrite();

	/// <summary>
	/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void TransformDataWrite();

	/// <summary>
	/// LightDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void LightDataWrite();

	/// <summary>
	/// CameraDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void CameraDataWrite();
};



============================================================
File Path: Project/Engine/Graphics/3d/Ocean/OceanWaveCompute.cpp
============================================================
#include "OceanWaveCompute.h"
// C++
#include <cassert>
// Service
#include "Engine/System/Service/ServiceLocator.h"
#include "Engine/System/Managers/SRVManager.h"
// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"


///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
OceanWaveCompute::~OceanWaveCompute() {
    waveInfoBuffer_.reset();
    rippleBuffer_.reset();
    settingsBuffer_.reset();
    outputUAV_.reset();
    outputBuffer_.Reset();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// UAVã®Indexå–å¾—
uint32_t OceanWaveCompute::GetUAVIndex() const { return uavIndex_; }
// SRVã®Indexå–å¾—
uint32_t OceanWaveCompute::GetSRVIndex() const { return srvIndex_; }
// å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
ID3D12Resource* OceanWaveCompute::GetOutputBuffer() const { return outputBuffer_.Get(); }


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void OceanWaveCompute::Initialize(ID3D12Device* device, int gridSize) {
    gridSize_ = gridSize;
    vertexCount_ = (gridSize_ + 1) * (gridSize_ + 1);

    // SRVManagerã‚’å–å¾—
    srvManager_ = ServiceLocator::GetSRVManager();

    // === æ³¢æƒ…å ±ãƒãƒƒãƒ•ã‚¡ï¼ˆ12å€‹ã®æ³¢ï¼‰StructuredBuffer === //
    waveInfoBuffer_ = std::make_unique<BufferBase>();
    waveInfoBuffer_->Create(device, sizeof(OceanShaderInfo) * 12);
	// ãƒãƒƒãƒ”ãƒ³ã‚°
    waveInfoBuffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&waveInfoData_));

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã§åˆæœŸåŒ–
    for (int i = 0; i < kWaveCount_; ++i) {
        waveInfoData_[i].distance = { 0.0f, 0.0f, 0.0f };
        waveInfoData_[i].amplitude = 0.0f;
        waveInfoData_[i].length = 10.0f;
        waveInfoData_[i].speed = 2.0f;
        waveInfoData_[i].time = 0.0f;
        waveInfoData_[i].padding = 0.0f;
    }

    // === æ³¢ç´‹ãƒãƒƒãƒ•ã‚¡ï¼ˆConstantBufferï¼‰ === //
    rippleBuffer_ = std::make_unique<BufferBase>();
    rippleBuffer_->Create(device, sizeof(RippleBufferForGPU));
	// ãƒãƒƒãƒ”ãƒ³ã‚°
    rippleBuffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&rippleBufferData_));

    // === è¨­å®šãƒãƒƒãƒ•ã‚¡ï¼ˆConstantBufferï¼‰ === //
    settingsBuffer_ = std::make_unique<BufferBase>();
    settingsBuffer_->Create(device, sizeof(WaveSettings));
	// ãƒãƒƒãƒ”ãƒ³ã‚°
    settingsBuffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&settingsData_));
	// è¨­å®šå€¤ã®åˆæœŸåŒ–
    settingsData_->gridSize = gridSize_;
    settingsData_->gridWidth = 100.0f;
    settingsData_->gridDepth = 100.0f;
    settingsData_->normalEpsilon = 0.1f;
    settingsData_->worldMatrix = Math::MakeIdentity4x4();
    settingsData_->worldOffset = { 0.0f, 0.0f, 0.0f };
    settingsData_->padding1 = 0.0f;

    // === å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ï¼ˆUAVç”¨ï¼‰=== //
	CreateUAVBuffer(device);

    // === SRVã¨UAVã®ä½œæˆ === //
    CreateViews(device, srvManager_);
}

///-------------------------------------------/// 
/// æ³¢ã®è¨ˆç®—ã‚’å®Ÿè¡Œ
///-------------------------------------------///
void OceanWaveCompute::Dispatch(ID3D12GraphicsCommandList* commandList) {

    // OceanWaveCompute::Dispatch ã‚’å‘¼ã³å‡ºã™å‰ã«è¿½åŠ 
    ID3D12DescriptorHeap* descriptorHeaps[] = {
        srvManager_->GetDescriptorHeap()  // SRVManagerã‹ã‚‰ãƒ’ãƒ¼ãƒ—ã‚’å–å¾—
    };
    commandList->SetDescriptorHeaps(1, descriptorHeaps);
        
    // COMMON -> UNORDERED_ACCESS ã¸ã®é·ç§»ãƒãƒªã‚¢
    D3D12_RESOURCE_BARRIER barrierToUAV = {};
    barrierToUAV.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrierToUAV.Transition.pResource = outputBuffer_.Get();
    barrierToUAV.Transition.StateBefore = D3D12_RESOURCE_STATE_COMMON;
    barrierToUAV.Transition.StateAfter = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
    barrierToUAV.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    commandList->ResourceBarrier(1, &barrierToUAV);

    // [0] CBV - è¨­å®šãƒãƒƒãƒ•ã‚¡ (b0)
    commandList->SetComputeRootConstantBufferView(0, settingsBuffer_->GetBuffer()->GetGPUVirtualAddress());

    // [1] CBV - æ³¢ç´‹ãƒãƒƒãƒ•ã‚¡ (b1)
    commandList->SetComputeRootConstantBufferView(1, rippleBuffer_->GetBuffer()->GetGPUVirtualAddress());

    // [2] DescriptorTable - SRV (t0: æ³¢æƒ…å ±)
    commandList->SetComputeRootDescriptorTable(2, srvManager_->GetGPUDescriptorHandle(srvIndex_));

    // [3] DescriptorTable - UAV (u0: å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡)
    commandList->SetComputeRootDescriptorTable(3, srvManager_->GetGPUDescriptorHandle(uavIndex_));

    // ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒï¼ˆ8x8ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰
    int dispatchX = (gridSize_ + 7) / 8;
    int dispatchY = (gridSize_ + 7) / 8;
    commandList->Dispatch(dispatchX, dispatchY, 1);

    // UAVãƒãƒªã‚¢ï¼ˆæ›¸ãè¾¼ã¿å®Œäº†ã‚’ä¿è¨¼ï¼‰
    D3D12_RESOURCE_BARRIER uavBarrier = {};
    uavBarrier.Type = D3D12_RESOURCE_BARRIER_TYPE_UAV;
    uavBarrier.UAV.pResource = outputBuffer_.Get();
    commandList->ResourceBarrier(1, &uavBarrier);

    // UNORDERED_ACCESS -> COMMON ã¸ã®é·ç§»ãƒãƒªã‚¢ï¼ˆæ¬¡å›ã®ä½¿ç”¨ã®ãŸã‚ï¼‰
    D3D12_RESOURCE_BARRIER barrierToCommon = {};
    barrierToCommon.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrierToCommon.Transition.pResource = outputBuffer_.Get();
    barrierToCommon.Transition.StateBefore = D3D12_RESOURCE_STATE_UNORDERED_ACCESS;
    barrierToCommon.Transition.StateAfter = D3D12_RESOURCE_STATE_COMMON;
    barrierToCommon.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    commandList->ResourceBarrier(1, &barrierToCommon);
}

///-------------------------------------------/// 
/// æ³¢æƒ…å ±ã®æ›´æ–°
///-------------------------------------------///
void OceanWaveCompute::UpdateWaveInfos(const std::array<OceanShaderInfo, kWaveCount_>& waveInfos) {
    for (int i = 0; i < kWaveCount_; ++i) {
        waveInfoData_[i] = waveInfos[i];
    }
}

///-------------------------------------------/// 
/// æ³¢ç´‹æƒ…å ±ã®æ›´æ–°
///-------------------------------------------///
void OceanWaveCompute::UpdateRippleBuffer(const RippleBufferForGPU& rippleBuffer) {*rippleBufferData_ = rippleBuffer;}

///-------------------------------------------/// 
/// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®æ›´æ–°
///-------------------------------------------///
void OceanWaveCompute::UpdateWorldMatrix(const Matrix4x4& worldMatrix) {settingsData_->worldMatrix = worldMatrix;}

///-------------------------------------------/// 
/// è¨ˆç®—çµæœã‚’é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã«ã‚³ãƒ”ãƒ¼
///-------------------------------------------///
void OceanWaveCompute::CopyResultsToVertexBuffer(ID3D12GraphicsCommandList* commandList, ID3D12Resource* vertexBuffer) {
   // UAVãƒãƒƒãƒ•ã‚¡ã®ã¿ COMMON -> COPY_SOURCE ã¸é·ç§»
    D3D12_RESOURCE_BARRIER barrierToCopySource = {};
    barrierToCopySource.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrierToCopySource.Transition.pResource = outputBuffer_.Get();
    barrierToCopySource.Transition.StateBefore = D3D12_RESOURCE_STATE_COMMON;
    barrierToCopySource.Transition.StateAfter = D3D12_RESOURCE_STATE_COPY_SOURCE;
    barrierToCopySource.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    commandList->ResourceBarrier(1, &barrierToCopySource);

    // ã‚³ãƒ”ãƒ¼å®Ÿè¡Œ
    commandList->CopyResource(vertexBuffer, outputBuffer_.Get());

    // UAVãƒãƒƒãƒ•ã‚¡ã‚’ COPY_SOURCE -> COMMON ã¸æˆ»ã™
    D3D12_RESOURCE_BARRIER barrierToCommon = {};
    barrierToCommon.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
    barrierToCommon.Transition.pResource = outputBuffer_.Get();
    barrierToCommon.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_SOURCE;
    barrierToCommon.Transition.StateAfter = D3D12_RESOURCE_STATE_COMMON;
    barrierToCommon.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
    commandList->ResourceBarrier(1, &barrierToCommon);
}

///-------------------------------------------/// 
/// UAVç”¨ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆ
///-------------------------------------------///
void OceanWaveCompute::CreateUAVBuffer(ID3D12Device* device) {
    HRESULT hr;

    D3D12_HEAP_PROPERTIES defaultHeapProps = {};
    defaultHeapProps.Type = D3D12_HEAP_TYPE_DEFAULT;

    D3D12_RESOURCE_DESC outputResourceDesc = {};
    outputResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
    outputResourceDesc.Width = sizeof(WaveVertexData) * vertexCount_;
    outputResourceDesc.Height = 1;
    outputResourceDesc.DepthOrArraySize = 1;
    outputResourceDesc.MipLevels = 1;
    outputResourceDesc.Format = DXGI_FORMAT_UNKNOWN;
    outputResourceDesc.SampleDesc.Count = 1;
    outputResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
    outputResourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;

    hr = device->CreateCommittedResource(
        &defaultHeapProps,
        D3D12_HEAP_FLAG_NONE,
        &outputResourceDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        IID_PPV_ARGS(&outputBuffer_)
    );
    assert(SUCCEEDED(hr));
}

///-------------------------------------------/// 
/// SRVã¨UAVã®ä½œæˆ
///-------------------------------------------///
void OceanWaveCompute::CreateViews(ID3D12Device* device, SRVManager* srvManger) {

    // SRVã®ä½œæˆ
    srvIndex_ = srvManger->Allocate();
    srvManger->CreateSRVForStructuredBuffer(
        srvIndex_, waveInfoBuffer_->GetBuffer(),
        kWaveCount_,
        sizeof(OceanShaderInfo)
    );

    // UAVã®ä½œæˆ
    uavIndex_ = srvManger->Allocate();
    outputUAV_ = std::make_unique<UAV>();
    outputUAV_->Create(
        device,
        outputBuffer_.Get(),
        vertexCount_,  // numElements
        sizeof(WaveVertexData),  // structureByteStride
        srvManger->GetCPUDescriptorHandle(uavIndex_)
    );
}

============================================================
File Path: Project/Engine/Graphics/3d/Ocean/OceanWaveCompute.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
#include "Engine/Graphics/Base/BufferBase.h"
#include "Engine/Graphics/Base/UAV.h"
// Data
#include "Engine/DataInfo/OceanData.h"
// c++
#include <d3d12.h>
#include <memory>
#include <array>
#include <wrl.h>

/// ===å‰æ–¹å®£è¨€=== ///
class SRVManager;

///=====================================================/// 
/// OceanWaveCompute
///=====================================================///
class OceanWaveCompute {
public:
    OceanWaveCompute() = default;
    ~OceanWaveCompute();

    /// <summary>
    /// æŒ‡å®šã—ãŸãƒ‡ãƒã‚¤ã‚¹ã¨ã‚°ãƒªãƒƒãƒ‰ã‚µã‚¤ã‚ºã‚’ç”¨ã„ã¦åˆæœŸåŒ–ã‚’è¡Œã„ã¾ã™ã€‚
    /// </summary>
    /// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚nullptr ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</param>
    /// <param name="gridSize">åˆæœŸåŒ–ã™ã‚‹ã‚°ãƒªãƒƒãƒ‰ã®ã‚µã‚¤ã‚ºã‚’è¡¨ã™æ•´æ•°ï¼ˆè¦ç´ æ•°ã‚„è§£åƒåº¦ãªã©ã‚’æŒ‡å®šï¼‰ã€‚</param>
    void Initialize(ID3D12Device* device, int gridSize);

    /// <summary>
    /// æŒ‡å®šã—ãŸã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆä¸Šã§ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒæ“ä½œã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="commandList">ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã‚’å®Ÿè¡Œã™ã‚‹å¯¾è±¡ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    void Dispatch(ID3D12GraphicsCommandList* commandList);

    /// <summary>
    /// æµ·é¢ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã§ä½¿ç”¨ã™ã‚‹æ³¢æƒ…å ±ã‚’æ›´æ–°ã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="waveInfos">12è¦ç´ ã® OceanShaderInfo ã‚’æ ¼ç´ã—ãŸ std::array ã¸ã® const å‚ç…§ã€‚å„è¦ç´ ãŒå€‹åˆ¥ã®æ³¢ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¡¨ã—ã€ã“ã‚Œã‚‰ã‚’å†…éƒ¨çŠ¶æ…‹ã«é©ç”¨ã—ã¾ã™ã€‚</param>
    void UpdateWaveInfos(const std::array<OceanShaderInfo, kWaveCount_>& waveInfos);

    /// <summary>
    /// GPU ç”¨ã®ãƒªãƒƒãƒ—ãƒ«ãƒãƒƒãƒ•ã‚¡ã®å†…å®¹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="rippleBuffer">æ›´æ–°å¯¾è±¡ã® RippleBufferForGPU å‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã® const å‚ç…§ã€‚æ›´æ–°ã«å¿…è¦ãªãƒ‡ãƒ¼ã‚¿ã‚’æä¾›ã—ã¾ã™ã€‚</param>
    void UpdateRippleBuffer(const RippleBufferForGPU& rippleBuffer);

    /// <summary>
    /// æŒ‡å®šã•ã‚ŒãŸãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã§å†…éƒ¨ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰å¤‰æ›ã‚’æ›´æ–°ã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="worldMatrix">æ›´æ–°ã«ä½¿ç”¨ã™ã‚‹èª­ã¿å–ã‚Šå°‚ç”¨ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã¸ã®å‚ç…§ã€‚</param>
    void UpdateWorldMatrix(const Matrix4x4& worldMatrix);

    /// <summary>
    /// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«å¯¾ã—ã¦çµæœã‚’é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã«ã‚³ãƒ”ãƒ¼ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="commandList">ã‚³ãƒ”ãƒ¼ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ID3D12GraphicsCommandListã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    /// <param name="vertexBuffer">ã‚³ãƒ”ãƒ¼å…ˆã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’è¡¨ã™ID3D12Resourceã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    void CopyResultsToVertexBuffer(ID3D12GraphicsCommandList* commandList, ID3D12Resource* vertexBuffer);

public: /// ===å–å¾—=== ///
	// UAVã®Indexå–å¾—
    uint32_t GetUAVIndex() const;
	// SRVã®Indexå–å¾—
    uint32_t GetSRVIndex() const;
	// å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
    ID3D12Resource* GetOutputBuffer() const;

private:
    /// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹=== ///
    std::unique_ptr<BufferBase> waveInfoBuffer_;    // 12å€‹ã®æ³¢æƒ…å ±ï¼ˆStructuredBufferï¼‰
    std::unique_ptr<BufferBase> rippleBuffer_;      // æ³¢ç´‹ãƒãƒƒãƒ•ã‚¡ï¼ˆConstantBufferï¼‰
    std::unique_ptr<BufferBase> settingsBuffer_;    // è¨­å®šãƒãƒƒãƒ•ã‚¡ï¼ˆConstantBufferï¼‰
    std::unique_ptr<UAV> outputUAV_;                // å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ç”¨UAVãƒ©ãƒƒãƒ‘ãƒ¼
	ComPtr<ID3D12Resource> outputBuffer_;           // å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	SRVManager* srvManager_ = nullptr;              // SRVç®¡ç†ã‚¯ãƒ©ã‚¹

    /// ===è¨­å®šæƒ…å ±=== ///
    struct WaveSettings {
        int gridSize;
        float gridWidth;
        float gridDepth;
        float normalEpsilon;
        Matrix4x4 worldMatrix;
        Vector3 worldOffset;
        float padding1;
    };
    WaveSettings* settingsData_ = nullptr;

    /// ===Index=== ///
    uint32_t uavIndex_ = 0;
    uint32_t srvIndex_ = 0;

    /// ===æ³¢æƒ…å ±=== ///
    OceanShaderInfo* waveInfoData_ = nullptr;
    RippleBufferForGPU* rippleBufferData_ = nullptr;

    /// ===ã‚°ãƒªãƒƒãƒ‰æƒ…å ±=== ///
    int gridSize_ = 128;
    int vertexCount_ = 0;

private:

    /// <summary>
    /// UAVï¼ˆUnordered Access Viewï¼‰ç”¨ã®ãƒãƒƒãƒ•ã‚¡ã‚’ä½œæˆã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="device">ãƒãƒƒãƒ•ã‚¡ä½œæˆã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    void CreateUAVBuffer(ID3D12Device* device);

    /// <summary>
	/// UAVã¨SRVã®ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="device">ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    void CreateViews(ID3D12Device* device, SRVManager* srvMangaer);
};

============================================================
File Path: Project/Engine/Graphics/3d/Primitive3D/Primitive3DCommon.cpp
============================================================
#include "Primitive3DCommon.h"
// Math
#include "Math/MatrixMath.h"
// Service
#include "Engine/System/Service/Render.h"
#include "Engine/System/Service/CameraService.h"
// camera
#include "application/Game/Camera/GameCamera.h"

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Primitive3DCommon::~Primitive3DCommon() {
	vertex_.reset();
	index_.reset();
	common_.reset();
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void Primitive3DCommon::SetLightType(LightType type) { common_->SetLightType(type); }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Primitive3DCommon::Create(ID3D12Device* device, LightType type) {
	/// ===åˆæœŸåŒ–æ™‚ã®è¨­å®š=== ///
	worldTransform_ = { { 1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f, 0.0f } };
	uvTransform_ = { {1.0f, 1.0f,1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };
	light_ = {
		40.0f,
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, -1.0f, 0.0f } ,1.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, 0.0f, 0.0f } , 1.0f, 0.0f, 0.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, 0.0f, 0.0f } , 0.0f, { 0.0f, 0.0f, 0.0f } , 0.0f, 0.0f, 0.0f}
	};
	environmentMapInfo_ = {
		"skyBox",
		false,
		1.0f
	};

	vertex_ = std::make_unique<VertexBuffer3D>();
	index_ = std::make_unique<IndexBuffer3D>();
	common_ = std::make_shared<ObjectCommon>();

	/// ===Common=== ///
	common_->Initialize(device, type);
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Primitive3DCommon::Update() {
	/// ===ã‚«ãƒ¡ãƒ©ã®è¨­å®š=== ///
	camera_ = CameraService::GetActiveCamera().get();

	// MaterialDataã®æ›¸ãè¾¼ã¿
	MaterialDataWrite();
	// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿
	TransformDataWrite();
	// Lightã®æ›¸ãè¾¼ã¿
	LightDataWrite();
	// Cameraã®æ›¸ãè¾¼ã¿
	CameraDataWrite();
	// ç’°å¢ƒãƒãƒƒãƒ—ã®æ›¸ãè¾¼ã¿
	EnvironmentMapDataWrite();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void Primitive3DCommon::Bind(ID3D12GraphicsCommandList* commandList) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// Commonã®è¨­å®š
	common_->Bind(commandList);
}

///-------------------------------------------/// 
/// MaterialDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Primitive3DCommon::MaterialDataWrite() {
	/// ===Matrixã®ä½œæˆ=== ///
	Matrix4x4 uvTransformMatrix = Math::MakeScaleMatrix(uvTransform_.scale);
	Matrix4x4 uvTransformMatrixMultiply = Multiply(uvTransformMatrix, Math::MakeRotateZMatrix(uvTransform_.rotate.z));
	uvTransformMatrixMultiply = Multiply(uvTransformMatrixMultiply, Math::MakeTranslateMatrix(uvTransform_.translate));

	/// ===å€¤ã®ä»£å…¥=== ///
	common_->SetMatiarlData(
		color_,
		light_.shininess,
		uvTransformMatrixMultiply
	);
}

///-------------------------------------------/// 
/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Primitive3DCommon::TransformDataWrite() {

	Matrix4x4 worldMatrix = Math::MakeAffineQuaternionMatrix(worldTransform_.scale, worldTransform_.rotate, worldTransform_.translate);
	Matrix4x4 worldViewProjectionMatrix;

	/// ===Matrixã®ä½œæˆ=== ///
	const Matrix4x4& viewProjectionMatrix = camera_->GetViewProjectionMatrix();
	worldViewProjectionMatrix = Multiply(worldMatrix, viewProjectionMatrix);

	/// ===å€¤ã®ä»£å…¥=== ///
	common_->SetTransformData(
		worldViewProjectionMatrix,
		worldMatrix,
		Math::Inverse4x4(worldMatrix)
	);

}

///-------------------------------------------///  
///ã€€ãƒ©ã‚¤ãƒˆã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Primitive3DCommon::LightDataWrite() {

	// DirectionalLightã®æ›¸ãè¾¼ã¿
	common_->SetDirectionLight(
		light_.directional.color,
		light_.directional.direction,
		light_.directional.intensity
	);

	// PointLightã®æ›¸ãè¾¼ã¿
	common_->SetPointLightData(
		light_.point.color,
		light_.point.position,
		light_.point.intensity,
		light_.point.radius,
		light_.point.decay
	);

	// SpotLightã®æ›¸ãè¾¼ã¿
	common_->SetSpotLightData(
		light_.spot.color,
		light_.spot.position,
		light_.spot.direction,
		light_.spot.intensity,
		light_.spot.distance,
		light_.spot.decay,
		light_.spot.cosAngle
	);
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Primitive3DCommon::CameraDataWrite() {
	common_->SetCameraForGPU(camera_->GetTranslate()); // ã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ç³»ã§å–å¾—
}

///-------------------------------------------/// 
/// ç’°å¢ƒãƒãƒƒãƒ—ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void Primitive3DCommon::EnvironmentMapDataWrite() {
	common_->SetEnviromentMapData(environmentMapInfo_.isEnvironmentMap, environmentMapInfo_.strength);
}

============================================================
File Path: Project/Engine/Graphics/3d/Primitive3D/Primitive3DCommon.h
============================================================
#pragma once
/// ===include=== ///
// Buffer
#include "Engine/Graphics/3d/Base/VertexBuffer3D.h"
#include "Engine/Graphics/3d/Base/IndexBuffer3D.h"
#include "Engine/Graphics/3d/Base/ObjectCommon.h"
// Data
#include "Engine/DataInfo/BlendModeData.h"
// c++
#include <memory>
#include <string>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚³ãƒ¢ãƒ³
///=====================================================///
class Primitive3DCommon {
public:
	Primitive3DCommon() = default;
	~Primitive3DCommon();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="modelName">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã®åå‰ã‚’è¡¨ã™æ–‡å­—åˆ—ï¼ˆconst std::string&ï¼‰ã€‚</param>
	/// <param name="type">ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’ç¤ºã™ LightType å‹ã®å€¤ã€‚</param>
	virtual void Initialize(const std::string& modelName, LightType type) = 0;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update();

	/// <summary>
	/// æç”»å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	virtual void Draw(BlendMode mode) = 0;

	/// <summary>
	/// ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="device">ãƒ©ã‚¤ãƒˆã‚’ä½œæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ï¼ˆDirect3D 12 ãƒ‡ãƒã‚¤ã‚¹ï¼‰ã€‚</param>
	/// <param name="type">ä½œæˆã™ã‚‹ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’ç¤ºã™å€¤ï¼ˆLightTypeï¼‰ã€‚</param>
	void Create(ID3D12Device* device, LightType type);

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">ãƒã‚¤ãƒ³ãƒ‰æ“ä½œã‚’å®Ÿè¡Œã™ã‚‹ Direct3D 12 ã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void Bind(ID3D12GraphicsCommandList* commandList);

public:/// ===Setter=== ///
	// Light
	void SetLightType(LightType type);

protected: /// ===ç¶™æ‰¿å…ˆã§ä½¿ç”¨ã™ã‚‹å¤‰æ•°=== ///

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	std::shared_ptr<VertexBuffer3D> vertex_;
	std::shared_ptr<IndexBuffer3D> index_;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼=== ///
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};
	D3D12_INDEX_BUFFER_VIEW indexBufferView_{};

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
	VertexData3D* vertexData_ = nullptr;
	uint32_t* indexData_ = nullptr;

	/// ===ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–æƒ…å ±=== ///
	EulerTransform uvTransform_;
	QuaternionTransform worldTransform_;
	Vector4 color_;

	/// ===ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹=== ///
	std::string textureFilePath_;

	/// ===Light=== ///
	LightInfo light_;

	/// ===Camera=== ///
	GameCamera* camera_ = nullptr;

	/// ===ç’°å¢ƒãƒãƒƒãƒ—=== ///
	EnvironmentMapInfo environmentMapInfo_;

private:/// ===Variables(å¤‰æ•°)=== ///

	// Common
	std::shared_ptr<ObjectCommon> common_;

private:
	/// <summary>
	/// MaterialDataã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void MaterialDataWrite();

	/// <summary>
	/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void TransformDataWrite();

	/// <summary>
	/// LightDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void LightDataWrite();

	/// <summary>
	/// CameraDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void CameraDataWrite();

	/// <summary>
	/// EnvironmentMapDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void EnvironmentMapDataWrite();
};



============================================================
File Path: Project/Engine/Graphics/3d/SkyBox/SkyBox.cpp
============================================================
#include "SkyBox.h"
// c++
#include <cassert>
#include <fstream>
// Engine
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
#include "Engine/System/Service/CameraService.h"
// camera
#include "application/Game/Camera/GameCamera.h"
// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
SkyBox::~SkyBox() {}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
/// ===ãƒ¢ãƒ‡ãƒ«=== ///
const Vector3& SkyBox::GetTranslate() const { return worldTransform_.translate; }
const Quaternion& SkyBox::GetRotate() const { return worldTransform_.rotate; }
const Vector3& SkyBox::GetScale() const { return worldTransform_.scale; }
const Vector4& SkyBox::GetColor() const { return color_; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
/// ===ãƒ¢ãƒ‡ãƒ«=== ///
void SkyBox::SetTranslate(const Vector3& position) { worldTransform_.translate = position; }
void SkyBox::SetRotate(const Quaternion& rotate) { worldTransform_.rotate = rotate; }
void SkyBox::SetScale(const Vector3& scale) { worldTransform_.scale = scale; }
void SkyBox::SetColor(const Vector4& color) { color_ = color; }
/// ===Light=== ///
void SkyBox::SetLight(LightType type) { common_->SetLightType(type); }
// LightInfo
void SkyBox::SetLightData(LightInfo light) { light_ = light; }
// ç’°å¢ƒãƒãƒƒãƒ—
void SkyBox::SetEnvironmentMapData(bool flag, float string) {
	environmentMapInfo_.isEnvironmentMap = flag;
	environmentMapInfo_.strength = string;
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void SkyBox::Initialize(const std::string& fileName, LightType type) {
	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12Device* device = GraphicsResourceGetter::GetDXDevice();

	/// ===ç”Ÿæˆ=== ///
	vertex_ = std::make_unique<VertexBuffer3D>();
	index_ = std::make_unique<IndexBuffer3D>();
	common_ = std::make_unique<ObjectCommon>();

	/// ===worldTransform=== ///
	worldTransform_ = { { 100.0f, 100.0f, 100.0f }, { 0.0f, 0.0f, 0.0f, 1.0f }, { 0.0f, 0.0f, 0.0f } };
	uvTransform_ = { {1.0f, 1.0f,1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };

	/// ===vertex=== ///
	// Buffer
	vertex_->Create(device, sizeof(VertexData3D) * kVertexCount);
	vertex_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&vertexData_));
	// é ‚ç‚¹æƒ…å ±ã®è¨­å®š
	VertexDataWrite();
	// view
	vertexBufferView_.BufferLocation = vertex_->GetBuffer()->GetGPUVirtualAddress();
	vertexBufferView_.SizeInBytes = sizeof(VertexData3D) * kVertexCount;
	vertexBufferView_.StrideInBytes = sizeof(VertexData3D);


	/// ===index=== ///
	index_->Create(device, sizeof(uint32_t) * kIndexCount);
	index_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&indexData_));
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿
	uint32_t indices[kIndexCount] = {
		0,1,2, 2,1,3,        // å³
		4,5,6, 6,5,7,        // å·¦
		8,9,10,10,9,11,      // å‰
		12,13,14,14,13,15,   // å¾Œ
		16,18,17,17,18,19,   // ä¸Šï¼ˆä¿®æ­£æ¸ˆï¼‰
		20,22,21,21,22,23    // ä¸‹ï¼ˆä¿®æ­£æ¸ˆï¼‰
	};
	std::memcpy(indexData_, indices, sizeof(indices));
	// view
	indexBufferView_.BufferLocation = index_->GetBuffer()->GetGPUVirtualAddress();
	indexBufferView_.SizeInBytes = sizeof(uint32_t) * kIndexCount;
	indexBufferView_.Format = DXGI_FORMAT_R32_UINT;

	/// ===Common=== ///
	common_->Initialize(device, type);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‘ã‚¹ä¿å­˜
	textureFilePath_ = fileName;
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void SkyBox::Update() {
	/// ===ã‚«ãƒ¡ãƒ©ã®è¨­å®š=== ///
	camera_ = CameraService::GetActiveCamera().get();

	/// ===ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿=== ///
	VertexDataWrite();
	MaterialDataWrite();
	TransformDataWrite();
	LightDataWrite();
	CameraDataWrite(); 
	EnvironmentMapDataWrite();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void SkyBox::Draw(BlendMode mode) {
	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12GraphicsCommandList* commandList = GraphicsResourceGetter::GetDXCommandList();

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// PSOã®è¨­å®š
	Render::SetPSO(commandList, PipelineType::PrimitiveSkyBox, mode);
	// Viewã®è¨­å®š
	commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
	commandList->IASetIndexBuffer(&indexBufferView_);
	// å…±é€šéƒ¨ã®è¨­å®š
	common_->Bind(commandList);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
	Render::SetGraphicsRootDescriptorTable(commandList, 2, textureFilePath_);
	// æç”»ï¼ˆDrawã‚³ãƒ¼ãƒ«ï¼‰
	commandList->DrawIndexedInstanced(kIndexCount, 1, 0, 0, 0);
}

///-------------------------------------------/// 
/// VertexDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SkyBox::VertexDataWrite() {
	// å³é¢ã€‚æç”»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯[0,1,2][2,1,3]ã§å†…å´ã‚’å‘ã
	vertexData_[0].position = { 1.0f, 1.0f, 1.0f, 1.0f };
	vertexData_[1].position = { 1.0f, 1.0f, -1.0f, 1.0f };
	vertexData_[2].position = { 1.0f, -1.0f, 1.0f, 1.0f };
	vertexData_[3].position = { 1.0f, -1.0f, -1.0f, 1.0f };
	// å·¦é¢ã€‚æç”»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯[4,5,6][6,5,7]
	vertexData_[4].position = { -1.0f, 1.0f, -1.0f, 1.0f };
	vertexData_[5].position = { -1.0f, 1.0f, 1.0f, 1.0f };
	vertexData_[6].position = { -1.0f, -1.0f, -1.0f, 1.0f };
	vertexData_[7].position = { -1.0f, -1.0f, 1.0f, 1.0f };
	// å‰é¢ã€‚æç”»ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯[8,9,10][10,9,11]
	vertexData_[8].position = { -1.0f, 1.0f, 1.0f, 1.0f };
	vertexData_[9].position = { 1.0f, 1.0f, 1.0f, 1.0f };
	vertexData_[10].position = { -1.0f, -1.0f, 1.0f, 1.0f };
	vertexData_[11].position = { 1.0f, -1.0f, 1.0f, 1.0f };
	// å¾Œé¢
	vertexData_[12].position = { 1.0f, 1.0f, -1.0f, 1.0f };
	vertexData_[13].position = { -1.0f, 1.0f, -1.0f, 1.0f };
	vertexData_[14].position = { 1.0f, -1.0f, -1.0f, 1.0f };
	vertexData_[15].position = { -1.0f, -1.0f, -1.0f, 1.0f };
	// ä¸Šé¢
	vertexData_[16].position = { -1.0f, 1.0f, -1.0f, 1.0f };
	vertexData_[17].position = { 1.0f, 1.0f, -1.0f, 1.0f };
	vertexData_[18].position = { -1.0f, 1.0f, 1.0f, 1.0f };
	vertexData_[19].position = { 1.0f, 1.0f, 1.0f, 1.0f };
	// ä¸‹é¢
	vertexData_[20].position = { -1.0f, -1.0f, 1.0f, 1.0f };
	vertexData_[21].position = { 1.0f, -1.0f, 1.0f, 1.0f };
	vertexData_[22].position = { -1.0f, -1.0f, -1.0f, 1.0f };
	vertexData_[23].position = { 1.0f, -1.0f, -1.0f, 1.0f };
}

///-------------------------------------------/// 
/// MaterialDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SkyBox::MaterialDataWrite() {
	/// ===Matrixã®ä½œæˆ=== ///
	Matrix4x4 uvTransformMatrix = Math::MakeScaleMatrix(uvTransform_.scale);
	Matrix4x4 uvTransformMatrixMultiply = Multiply(uvTransformMatrix, Math::MakeRotateZMatrix(uvTransform_.rotate.z));
	uvTransformMatrixMultiply = Multiply(uvTransformMatrixMultiply, Math::MakeTranslateMatrix(uvTransform_.translate));
	/// ===å€¤ã®ä»£å…¥=== ///
	common_->SetMatiarlData(
		color_,
		light_.shininess,
		uvTransformMatrixMultiply
	);
}

///-------------------------------------------/// 
/// WVPDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SkyBox::TransformDataWrite() {
	Matrix4x4 worldMatrix = Math::MakeAffineQuaternionMatrix(worldTransform_.scale, worldTransform_.rotate, worldTransform_.translate);
	Matrix4x4 worldViewProjectionMatrix;

	/// ===Matrixã®ä½œæˆ=== ///
	const Matrix4x4& viewProjectionMatrix = camera_->GetViewProjectionMatrix();
	worldViewProjectionMatrix = Multiply(worldMatrix, viewProjectionMatrix);

	/// ===å€¤ã®ä»£å…¥=== ///
	common_->SetTransformData(
		worldViewProjectionMatrix,
		worldMatrix,
		Math::Inverse4x4(worldMatrix)
	);
}

///-------------------------------------------/// 
/// LightDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SkyBox::LightDataWrite() {
	common_->SetDirectionLight(
		light_.directional.color,
		light_.directional.direction,
		light_.directional.intensity
	);
	common_->SetPointLightData(
		light_.point.color,
		light_.point.position,
		light_.point.intensity,
		light_.point.radius,
		light_.point.decay
	);
	common_->SetSpotLightData(
		light_.spot.color,
		light_.spot.position,
		light_.spot.direction,
		light_.spot.intensity,
		light_.spot.distance,
		light_.spot.decay,
		light_.spot.cosAngle
	);
}

///-------------------------------------------/// 
/// CameraDataã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SkyBox::CameraDataWrite() {
	common_->SetCameraForGPU(camera_->GetTranslate());
}

///-------------------------------------------/// 
/// ç’°å¢ƒãƒãƒƒãƒ—ã®æ›¸ãè¾¼ã¿
///-------------------------------------------///
void SkyBox::EnvironmentMapDataWrite() {
	common_->SetEnviromentMapData(environmentMapInfo_.isEnvironmentMap, environmentMapInfo_.strength);
}

============================================================
File Path: Project/Engine/Graphics/3d/SkyBox/SkyBox.h
============================================================
#pragma once
/// ===Include=== ///
// buffer
#include "Engine/Graphics/3d/Base/VertexBuffer3D.h"
#include "Engine/Graphics/3d/Base/IndexBuffer3D.h"
#include "Engine/Graphics/3d/Base/ObjectCommon.h"
// Pipeline
#include "Engine/DataInfo/PipelineStateObjectType.h"
// c++
#include <memory>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// SkyBox
///=====================================================///
class SkyBox {
public:

	SkyBox() = default;
	~SkyBox();
	
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="fileName">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã¾ãŸã¯ãƒ‘ã‚¹ã€‚</param>
	/// <param name="type">åˆæœŸåŒ–æ™‚ã«ä½¿ç”¨ã™ã‚‹ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’è¡¨ã™ LightType ã®å€¤ã€‚</param>
	void Initialize(const std::string& fileName, LightType type);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»æ™‚ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚çœç•¥ã—ãŸå ´åˆã¯ BlendMode::kBlendModeNoneï¼ˆãƒ–ãƒ¬ãƒ³ãƒ‰ãªã—ï¼‰ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Draw(BlendMode mode = BlendMode::kBlendModeNone);

public: /// ===Getter=== ///
	// ãƒ¢ãƒ‡ãƒ«åº§æ¨™
	const Vector3& GetTranslate() const;
	// ãƒ¢ãƒ‡ãƒ«å›è»¢
	const Quaternion& GetRotate() const;
	// ãƒ¢ãƒ‡ãƒ«æ‹¡ç¸®
	const Vector3& GetScale() const;
	// ãƒ¢ãƒ‡ãƒ«ã‚«ãƒ©ãƒ¼
	const Vector4& GetColor() const;

public: /// ===Setter=== ///
	// ãƒ¢ãƒ‡ãƒ«Transform
	void SetTranslate(const Vector3& position);
	void SetRotate(const Quaternion& rotate);
	void SetScale(const Vector3& scale);
	// ãƒ¢ãƒ‡ãƒ«ã‚«ãƒ©ãƒ¼
	void SetColor(const Vector4& color);
	// Light
	void SetLight(LightType type);
	// LightData
	void SetLightData(LightInfo light);
	// ç’°å¢ƒãƒãƒƒãƒ—
	void SetEnvironmentMapData(bool flag, float string);

private:
	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹=== ///
	std::unique_ptr<VertexBuffer3D> vertex_;
	std::unique_ptr<IndexBuffer3D> index_;
	std::unique_ptr<ObjectCommon> common_;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
	VertexData3D* vertexData_ = nullptr;
	uint32_t* indexData_ = nullptr;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼=== ///
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};
	D3D12_INDEX_BUFFER_VIEW indexBufferView_{};

	/// ===å®šæ•°=== ///
	static constexpr int kVertexCount = 24;
	static constexpr int kIndexCount = 36;

	/// ===UV=== ///
	EulerTransform uvTransform_;

	/// ===ã‚«ãƒ¡ãƒ©=== ///
	GameCamera* camera_ = nullptr;

	/// ===ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–æƒ…å ±=== ///
	QuaternionTransform worldTransform_;
	Vector4 color_ = { 1.0f, 1.0f, 1.0f, 1.0f };

	/// ===ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹=== ///
	std::string textureFilePath_;

	/// ===Light=== ///
	LightInfo light_ = {
		40.0f,
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, -1.0f, 0.0f } ,1.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, 0.0f, 0.0f } , 1.0f, 0.0f, 0.0f},
		{{ 1.0f, 1.0f, 1.0f, 1.0f } , { 0.0f, 0.0f, 0.0f } , 0.0f, { 0.0f, 0.0f, 0.0f } , 0.0f, 0.0f, 0.0f}
	};

	/// ===ç’°å¢ƒãƒãƒƒãƒ—=== ///
	EnvironmentMapInfo environmentMapInfo_;

private: /// ===Functions(é–¢æ•°)=== ///

	/// <summary>
	/// VertexDataã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void VertexDataWrite();

	/// <summary>
	/// MaterialDataã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void MaterialDataWrite();

	/// <summary>
	/// Transformæƒ…å ±ã®æ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void TransformDataWrite();

	/// <summary>
	/// LightDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void LightDataWrite();

	/// <summary>
	/// CameraDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void CameraDataWrite();

	/// <summary>
	/// EnvironmentMapDataæ›¸ãè¾¼ã¿å‡¦ç†
	/// </summary>
	void EnvironmentMapDataWrite();
};



============================================================
File Path: Project/Engine/Graphics/Base/BufferBase.cpp
============================================================
#include "BufferBase.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
BufferBase::~BufferBase() { buffer_.Reset(); }

///-------------------------------------------/// 
/// ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
///-------------------------------------------///
void BufferBase::Create(ID3D12Device* device, size_t sizeInBytes, DXGI_FORMAT format, D3D12_RESOURCE_FLAGS flags) {
	buffer_ = CreateBufferResourceComPtr(device, sizeInBytes, format, flags);
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void BufferBase::SetBuffer(ID3D12Resource* buffer) { buffer_ = buffer; }

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12Resource* BufferBase::GetBuffer() { return buffer_.Get(); }

============================================================
File Path: Project/Engine/Graphics/Base/BufferBase.h
============================================================
#pragma once
/// ===include=== ///
#include "Engine/DataInfo/FunctionData.h"

///=====================================================/// 
/// Light
///=====================================================///
class BufferBase {
public:
	BufferBase() = default;
	~BufferBase();

	/// <summary>
	/// ãƒã‚¤ãƒˆå˜ä½ã§æŒ‡å®šã—ãŸã‚µã‚¤ã‚ºã®ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="device">ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="sizeInBytes">ä½œæˆã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆå˜ä½ï¼‰ã€‚</param>
	void Create(ID3D12Device* device, size_t sizeInBytes, DXGI_FORMAT format = DXGI_FORMAT_UNKNOWN, D3D12_RESOURCE_FLAGS flags = D3D12_RESOURCE_FLAG_NONE);

public: /// ===è¨­å®š=== ///

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
	void SetBuffer(ID3D12Resource* buffer);

public: /// ===å–å¾—=== ///

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	ID3D12Resource* GetBuffer();

private:/// ===Variables(å¤‰æ•°)=== ///

	ComPtr<ID3D12Resource> buffer_;
};


============================================================
File Path: Project/Engine/Graphics/Base/UAV.cpp
============================================================
#include "UAV.h"

///-------------------------------------------/// 
/// UAVã®ç”Ÿæˆå‡¦ç†
///-------------------------------------------///
void UAV::Create(ID3D12Device* device, ID3D12Resource* targetResource, UINT numElements, UINT structureByteStride, D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle) {

	// ãƒªã‚½ãƒ¼ã‚¹ã‚’ä¿å­˜
	resource_ = targetResource;

	// ãƒ‡ã‚¹ã‚¯ã®è¨­å®š
	desc_.Format = DXGI_FORMAT_UNKNOWN;
	desc_.ViewDimension = D3D12_UAV_DIMENSION_BUFFER;
	desc_.Buffer.FirstElement = 0;
	desc_.Buffer.NumElements = numElements;
	desc_.Buffer.CounterOffsetInBytes = 0;
	desc_.Buffer.Flags = D3D12_BUFFER_UAV_FLAG_NONE;
	desc_.Buffer.StructureByteStride = structureByteStride;

	device->CreateUnorderedAccessView(resource_, nullptr, &desc_, cpuHandle);
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
D3D12_UNORDERED_ACCESS_VIEW_DESC UAV::GetUAVDesc() const { return desc_; }
ID3D12Resource* UAV::GetResource() const { return resource_; }


============================================================
File Path: Project/Engine/Graphics/Base/UAV.h
============================================================
/// ===Include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
// directX
#include <d3d12.h>

///=====================================================/// 
/// UAV
///=====================================================///
class UAV {
public:
	UAV() = default;
	~UAV() = default;

	/// <summary>
	/// UAVï¼ˆUnordered Access Viewï¼‰ã‚’ä½œæˆã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="dxCommon">DirectXå…±é€šç®¡ç†ã‚¯ãƒ©ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="targetResource">UAVã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ï¼ˆæ—¢ã«ä½œæˆæ¸ˆã¿ï¼‰</param>
	/// <param name="numElements">ãƒãƒƒãƒ•ã‚¡ã®è¦ç´ æ•°</param>
	/// <param name="structureByteStride">1è¦ç´ ã‚ãŸã‚Šã®ãƒã‚¤ãƒˆã‚µã‚¤ã‚º</param>
	/// <param name="cpuHandle">DescriptorHeapã®CPUãƒãƒ³ãƒ‰ãƒ«ï¼ˆUAVã‚’ç™»éŒ²ã™ã‚‹å ´æ‰€ï¼‰</param>
	void Create(ID3D12Device* device, ID3D12Resource* targetResorce, UINT numElements, UINT structureByteStride, D3D12_CPU_DESCRIPTOR_HANDLE cpuHandle);

	/// <summary>
	/// UAVã®å–å¾—
	/// </summary>
	/// <returns></returns>
	D3D12_UNORDERED_ACCESS_VIEW_DESC GetUAVDesc() const;

	/// <summary>
	/// å†…éƒ¨ã§ä¿æŒã—ã¦ã„ã‚‹ ID3D12Resource ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚
	/// </summary>
	/// <returns>ç®¡ç†ä¸‹ã«ã‚ã‚‹ ID3D12Resource ã¸ã®ç”Ÿãƒã‚¤ãƒ³ã‚¿ã€‚æ‰€æœ‰æ¨©ã¯ç§»å‹•ã—ã¾ã›ã‚“ã€‚ãƒªã‚½ãƒ¼ã‚¹ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ nullptr ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	ID3D12Resource* GetResource() const;

private:
	// resource
	ID3D12Resource* resource_ = nullptr;
	// Desc
	D3D12_UNORDERED_ACCESS_VIEW_DESC desc_{};
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/BoxFilter3x3Effect.cpp
============================================================
#include "BoxFilter3x3Effect.h"
// Service
#include "Engine/System/Service/Render.h"

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void BoxFilter3x3Effect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// Deviceã®åˆæœŸåŒ–
	ID3D12Device* devicePtr = device;
	devicePtr;
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void BoxFilter3x3Effect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// ImGuiã®æç”»
///-------------------------------------------///
void BoxFilter3x3Effect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ã‚³ãƒ”ãƒ¼ã‚¤ãƒ¡ãƒ¼ã‚¸
	Render::SetPSO(commandList, PipelineType::BoxFilter3x3, BlendMode::kBlendModeNone);

	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void BoxFilter3x3Effect::ImGuiInfo() {

}

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/BoxFilter3x3Effect.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/OffScreen/RenderPass.h"

///=====================================================/// 
/// BoxFilter3x3Effect
///=====================================================///
class BoxFilter3x3Effect : public RenderPass {
public:
	BoxFilter3x3Effect() = default;
	~BoxFilter3x3Effect() = default;
	
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/BoxFilter5x5Effect.cpp
============================================================
#include "BoxFilter5x5Effect.h"
// Service
#include "Engine/System/Service/Render.h"

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void BoxFilter5x5Effect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// Deviceã®åˆæœŸåŒ–
	ID3D12Device* devicePtr = device;
	devicePtr;
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void BoxFilter5x5Effect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// ImGuiã®æç”»
///-------------------------------------------///
void BoxFilter5x5Effect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ã‚³ãƒ”ãƒ¼ã‚¤ãƒ¡ãƒ¼ã‚¸
	Render::SetPSO(commandList, PipelineType::BoxFilter5x5, BlendMode::kBlendModeNone);

	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void BoxFilter5x5Effect::ImGuiInfo() {

}

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/BoxFilter5x5Effect.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/OffScreen/RenderPass.h"

///=====================================================/// 
///	BoxFilter5x5Effect
///=====================================================///
class BoxFilter5x5Effect : public RenderPass {
public:
	BoxFilter5x5Effect() = default;
	~BoxFilter5x5Effect() = default;
	
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/CopyImageEffect.cpp
============================================================

#include "CopyImageEffect.h"
// Service
#include "Engine/System/Service/Render.h"

///-------------------------------------------/// 
/// åˆæœŸåŒ–ã€€
///-------------------------------------------///
void CopyImageEffect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// Deviceã®åˆæœŸåŒ–
	ID3D12Device* devicePtr = device;
	devicePtr;
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void CopyImageEffect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void CopyImageEffect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ã‚³ãƒ”ãƒ¼ã‚¤ãƒ¡ãƒ¼ã‚¸
	Render::SetPSO(commandList, PipelineType::OffScreen, BlendMode::kBlendModeNone);

	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}


///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void CopyImageEffect::ImGuiInfo() {

}

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/CopyImageEffect.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/OffScreen/RenderPass.h"

///=====================================================/// 
/// CopyImageEffect
///=====================================================///
class CopyImageEffect : public RenderPass {
public:
	CopyImageEffect() = default;
	~CopyImageEffect() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/DissolveEffect.cpp
============================================================
#include "DissolveEffect.h"
// Service
#include "Engine/System/Service/Render.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif

///-------------------------------------------/// 
/// åˆæœŸåŒ–ã€€
///-------------------------------------------///
void DissolveEffect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åã‚’è¨­å®š
	textureKeyName_ = "noise0";
	
	// bufferã®ä½œæˆ
	buffer_ = std::make_unique<BufferBase>();
	buffer_->Create(device, sizeof(DissolveData));
	buffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&data_));

	// Dissolveã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
	data_->edgeColor = { 1.0f, 0.4f, 0.3f }; // ã‚¨ãƒƒã‚¸è‰²ã‚’ç™½ã«è¨­å®š
	data_->threshold = 0.5f; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®é–¾å€¤
	data_->edgeStart = 0.5f; // ã‚¨ãƒƒã‚¸ã®é–‹å§‹ä½ç½®
	data_->edgeEnd = 0.53f; // ã‚¨ãƒƒã‚¸ã®çµ‚äº†ä½ç½®
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void DissolveEffect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void DissolveEffect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	Render::SetPSO(commandList, PipelineType::Dissolve, BlendMode::kBlendModeNone);

	// dataã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(2, buffer_->GetBuffer()->GetGPUVirtualAddress());

	// Textureã®è¨­å®š
	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	Render::SetGraphicsRootDescriptorTable(commandList, 1, textureKeyName_);

	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void DissolveEffect::ImGuiInfo() {
#ifdef USE_IMGUI
	// ImGuiã®æç”»
	ImGui::Text("Dissolve Effect");
	ImGui::SliderFloat("Threshold", &data_->threshold, 0.0f, 1.0f);
	ImGui::SliderFloat("Edge Start", &data_->edgeStart, 0.0f, 1.0f);
	ImGui::SliderFloat("Edge End", &data_->edgeEnd, 0.0f, 1.0f);
	ImGui::ColorEdit3("Edge Color", &data_->edgeColor.x);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šæ›¿ãˆ
	static const char* textureOptions[] = { "noise0", "noise1" };
	static int currentTextureIndex = 0;

	// ç¾åœ¨ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£åã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—ï¼ˆåˆå›ã ã‘ï¼‰
	if (textureKeyName_ == "noise1") currentTextureIndex = 1;

	if (ImGui::Combo("Dissolve Mask", &currentTextureIndex, textureOptions, IM_ARRAYSIZE(textureOptions))) {
		// é¸æŠãŒå¤‰ã‚ã£ãŸã¨ãã®ã¿ SetTexture ã‚’å‘¼ã¶
		std::string selectedTexture = textureOptions[currentTextureIndex];
		SetTexture(selectedTexture);
	}
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void DissolveEffect::SetData(DissolveData data) {
	data_->threshold = data.threshold;
	data_->edgeStart = data.edgeStart;
	data_->edgeEnd = data.edgeEnd;
	data_->edgeColor = data.edgeColor;
}
void DissolveEffect::SetTexture(std::string& textureKeyName) {
	textureKeyName_ = textureKeyName;
}


============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/DissolveEffect.h
============================================================
#pragma once
/// ===Include=== ///
// BufferBase
#include "Engine/Graphics/Base/BufferBase.h"
// RenderPass
#include "Engine/Graphics/OffScreen/RenderPass.h"
// c++
#include <string>
// Math
#include "Math/Vector3.h"

/// ===Dissolveã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ === ///
struct DissolveData {
	float threshold; // discardã®é–¾å€¤
	float edgeStart; // smoothstepé–‹å§‹
	float edgeEnd; // smoothstepçµ‚äº†
	Vector3 edgeColor; // ã‚¨ãƒƒã‚¸è‰²
	float padding; // floatã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
};

///=====================================================/// 
/// CopyImageEffect
///=====================================================///
class DissolveEffect : public RenderPass {
public:
	DissolveEffect() = default;
	~DissolveEffect() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;

public: /// ===Setter=== ///
	// ãƒ‡ãƒ¼ã‚¿
	void SetData(DissolveData data);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
	void SetTexture(std::string& texuteKeyName);

private:

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å
	std::string textureKeyName_ = "Dissolve";

	// Buffer
	std::unique_ptr<BufferBase> buffer_;

	// Data
	DissolveData* data_ = nullptr;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/GrayScaleEffect.cpp
============================================================
#include "GrayscaleEffect.h"
// Service
#include "Engine/System/Service/Render.h"

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void GrayscaleEffect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// Deviceã®åˆæœŸåŒ–
	ID3D12Device* devicePtr = device;
	devicePtr;
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void GrayscaleEffect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// ImGuiã®æç”»
///-------------------------------------------///
void GrayscaleEffect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ã‚³ãƒ”ãƒ¼ã‚¤ãƒ¡ãƒ¼ã‚¸
	Render::SetPSO(commandList, PipelineType::Grayscale, BlendMode::kBlendModeNone);

	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void GrayscaleEffect::ImGuiInfo() {

}

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/GrayScaleEffect.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/OffScreen/RenderPass.h"

///=====================================================/// 
/// GrayscaleEffect
///=====================================================///
class GrayscaleEffect : public RenderPass {
public:
	GrayscaleEffect() = default;
	~GrayscaleEffect() = default;
	
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/OutLineEffect.cpp
============================================================
#include "OutLineEffect.h"
// Service
#include "Engine/System/Service/Render.h"

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void OutLineEffect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;
	// Deviceã®åˆæœŸåŒ–
	ID3D12Device* devicePtr = device;
	devicePtr;
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void OutLineEffect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// ImGuiã®æç”»
///-------------------------------------------///
void OutLineEffect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ã‚³ãƒ”ãƒ¼ã‚¤ãƒ¡ãƒ¼ã‚¸
	Render::SetPSO(commandList, PipelineType::OutLine, BlendMode::kBlendModeNone);

	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void OutLineEffect::ImGuiInfo() {

}

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/OutLineEffect.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/OffScreen/RenderPass.h"

///=====================================================/// 
/// OutLineEffect
///=====================================================///
class OutLineEffect : public RenderPass {
public:
	OutLineEffect() = default;
	~OutLineEffect() = default;
	
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;
	
	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;
	
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;
	
	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/RadiusBlurEffect.cpp
============================================================
#include "RadiusBlurEffect.h"
// Service
#include "Engine/System/Service/Render.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void RadiusBlurEffect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// bufferã®ä½œæˆ
	buffer_ = std::make_unique<BufferBase>();
	buffer_->Create(device, sizeof(RadiusBlurData));
	buffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&data_));
	// RadiusBlurã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–7
	data_->center = { 0.5f, 0.5f }; // ä¸­å¿ƒåº§æ¨™ã‚’ç”»é¢ä¸­å¤®ã«è¨­å®š
	data_->numSamples = 16; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ•°
	data_->blurWidth = 0.01f; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ–ãƒ©ãƒ¼å¹…
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void RadiusBlurEffect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// ImGuiã®æç”»
///-------------------------------------------///
void RadiusBlurEffect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ã‚³ãƒ”ãƒ¼ã‚¤ãƒ¡ãƒ¼ã‚¸
	Render::SetPSO(commandList, PipelineType::RadiusBlur, BlendMode::kBlendModeNone);

	// dataã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(1, buffer_->GetBuffer()->GetGPUVirtualAddress());

	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void RadiusBlurEffect::ImGuiInfo() {
#ifdef USE_IMGUI
	// ImGuiã®æç”»
	ImGui::Text("RadiusBlur Effect");
	ImGui::DragFloat2("center", &data_->center.x, 0.1f);
	ImGui::SliderInt("numSamples", &data_->numSamples, 1, 100);
	ImGui::SliderFloat("blurWidth", &data_->blurWidth, 0.0f, 1.0f);
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void RadiusBlurEffect::SetData(RadiusBlurData data) {
	data_->center = data.center;
	data_->numSamples = data.numSamples;
	data_->blurWidth = data.blurWidth;
}


============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/RadiusBlurEffect.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/OffScreen/RenderPass.h"
// BufferBase
#include "Engine/Graphics/Base/BufferBase.h"
// Math
#include "Math/Vector2.h"

/// ===Dissolveã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ === ///
struct RadiusBlurData {
	Vector2 center;  // ãƒ–ãƒ©ãƒ¼ã®ä¸­å¿ƒåº§æ¨™
	int numSamples;  // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ•°
	float blurWidth; // ãƒ–ãƒ©ãƒ¼ã®å¹…
	float padding;   // floatã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
};

///=====================================================/// 
/// RadiusBlurEffect
///=====================================================///
class RadiusBlurEffect : public RenderPass {
public:
	RadiusBlurEffect() = default;
	~RadiusBlurEffect() = default;
	
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;
	
	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;
	
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;
	
	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;

public: /// ===Setter=== ///
	// ãƒ‡ãƒ¼ã‚¿
	void SetData(RadiusBlurData data);

private:

	// Buffer
	std::unique_ptr<BufferBase> buffer_;

	// Data
	RadiusBlurData* data_ = nullptr;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/ShatterGlassEffect.cpp
============================================================
#include "ShatterGlassEffect.h"
// Service
#include "Engine/System/Service/Render.h"
#include <cstdlib>
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif

///-------------------------------------------/// 
/// åˆæœŸåŒ–ã€€
///-------------------------------------------///
void ShatterGlassEffect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åã‚’è¨­å®š
	textureKeyName_ = "White";

	// Bufferã®ä½œæˆ
	buffer_ = std::make_unique<BufferBase>();
	buffer_->Create(device, sizeof(ShatterGlassData));
	buffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&data_));

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
	data_->progress = 0.0f;
	data_->impactX = 0.5f;
	data_->impactY = 0.5f;
	data_->crackDensity = 15.0f;
	data_->dispersion = 1.0f;
	data_->rotation = 1.0f;
	data_->fadeOut = 0.0f;
	data_->randomSeed = 0.0f;
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void ShatterGlassEffect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ShatterGlassEffect::Draw(ID3D12GraphicsCommandList* commandList) {

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	Render::SetPSO(commandList, PipelineType::ShatterGlass, BlendMode::kBlendModeNone);

	commandList->SetGraphicsRootConstantBufferView(2, buffer_->GetBuffer()->GetGPUVirtualAddress());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆ
	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	Render::SetGraphicsRootDescriptorTable(commandList, 1, textureKeyName_);

	// é ‚ç‚¹3ã¤ã‚’æç”»ï¼ˆãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸‰è§’å½¢ï¼‰
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void ShatterGlassEffect::ImGuiInfo() {
#ifdef USE_IMGUI
	if (ImGui::TreeNode("Shatter Glass Parameters")) {
		ImGui::SliderFloat("Progress", &data_->progress, 0.0f, 1.0f);
		ImGui::SliderFloat("Impact X", &data_->impactX, 0.0f, 1.0f);
		ImGui::SliderFloat("Impact Y", &data_->impactY, 0.0f, 1.0f);
		ImGui::SliderFloat("Crack Density", &data_->crackDensity, 5.0f, 50.0f);
		ImGui::SliderFloat("Dispersion", &data_->dispersion, 0.0f, 3.0f);
		ImGui::SliderFloat("Rotation", &data_->rotation, 0.0f, 5.0f);
		ImGui::SliderFloat("Fade Out", &data_->fadeOut, 0.0f, 1.0f);

		if (ImGui::Button("Reset")) {
			data_->progress = 0.0f;
			data_->impactX = 0.5f;
			data_->impactY = 0.5f;
			data_->crackDensity = 15.0f;
			data_->dispersion = 1.0f;
			data_->rotation = 1.0f;
			data_->fadeOut = 0.0f;
		}

		ImGui::TreePop();
	}
#endif
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void ShatterGlassEffect::SetData(ShatterGlassData data) {
	data_->progress = data.progress;
	data_->impactX = data.impactX;
	data_->impactY = data.impactY;
	data_->crackDensity = data.crackDensity;
	data_->dispersion = data.dispersion;
	data_->rotation = data.rotation;
	data_->fadeOut = data.fadeOut;
}

///-------------------------------------------/// 
/// æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
///-------------------------------------------///
void ShatterGlassEffect::GenerateNewPattern() {
	// 0.0 ~ 1000.0 ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ ãªã‚·ãƒ¼ãƒ‰å€¤ã‚’ç”Ÿæˆ
	data_->randomSeed = static_cast<float>(rand() % 10000) / 10.0f;
}

///-------------------------------------------/// 
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
///-------------------------------------------///
void ShatterGlassEffect::SetGlassTexture(const std::string& textureName) { textureKeyName_ = textureName; }


============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/ShatterGlassEffect.h
============================================================
#pragma once
/// ===Include=== ///
// BufferBase
#include "Engine/Graphics/Base/BufferBase.h"
// RenderPass
#include "Engine/Graphics/OffScreen/RenderPass.h"

/// ===ShatterGlassã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ === ///
struct ShatterGlassData {
	float progress;      // å‰²ã‚Œã‚‹é€²è¡Œåº¦ (0.0 ~ 1.0)
	float impactX;       // è¡æ’ƒç‚¹ã®Xåº§æ¨™ (0.0 ~ 1.0)
	float impactY;       // è¡æ’ƒç‚¹ã®Yåº§æ¨™ (0.0 ~ 1.0)
	float crackDensity;  // ã²ã³å‰²ã‚Œã®å¯†åº¦
	float dispersion;    // ç ´ç‰‡ã®é£›æ•£åº¦
	float rotation;      // ç ´ç‰‡ã®å›è»¢é‡
	float fadeOut;       // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆåŠ¹æœ
	float randomSeed;	 // ãƒ©ãƒ³ãƒ€ãƒ ãƒŠã‚·ãƒ¼ãƒ‰å€¤
	float padding;       // ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
};

///=====================================================/// 
/// ShatterGlassEffect
///=====================================================///
class ShatterGlassEffect : public RenderPass {
public:
	ShatterGlassEffect() = default;
	~ShatterGlassEffect() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;

public: /// ===Setter=== ///
	// ãƒ‡ãƒ¼ã‚¿
	void SetData(ShatterGlassData data);

	// æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
	void GenerateNewPattern();

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
	void SetGlassTexture(const std::string& textureName);

private:
	// Buffer
	std::unique_ptr<BufferBase> buffer_;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å
	std::string textureKeyName_;

	// Data
	ShatterGlassData* data_ = nullptr;
};

============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/VignetteEffect.cpp
============================================================

#include "VignetteEffect.h"
// Service
#include "Engine/System/Service/Render.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void VignetteEffect::Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) {
	// RenderTextureã‚’å–å¾—
	outputTexture_ = RenderTexture;

	// bufferã®ä½œæˆ
	buffer_ = std::make_unique<BufferBase>();
	buffer_->Create(device, sizeof(VignetteData));
	buffer_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&data_));
	// Vignetteã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
	data_->scale = 16.0f; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¹ã‚±ãƒ¼ãƒ«
	data_->pawer = 0.8f; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ‘ãƒ¯ãƒ¼
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void VignetteEffect::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	RenderPass::PreDraw(commandList, dsvHandle);
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void VignetteEffect::Draw(ID3D12GraphicsCommandList* commandList) {
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	Render::SetPSO(commandList, PipelineType::Vignette, BlendMode::kBlendModeNone);

	// dataã®è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(1, buffer_->GetBuffer()->GetGPUVirtualAddress());

	commandList->SetGraphicsRootDescriptorTable(0, inputTexture_->GetSRVHandle());
	// é ‚ç‚¹3ã¤ã‚’æç”»
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±
///-------------------------------------------///
void VignetteEffect::ImGuiInfo() {
#ifdef USE_IMGUI
	// ImGuiã®æç”»
	ImGui::Text("Vignette Effect");
	ImGui::SliderFloat("Scale", &data_->scale, 0.1f, 100.0f);
	ImGui::SliderFloat("Pawer", &data_->pawer, 0.0f, 50.0f);
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void VignetteEffect::SetData(VignetteData data) {
	data_->scale = data.scale;
	data_->pawer = data.pawer;
}


============================================================
File Path: Project/Engine/Graphics/OffScreen/Effect/VignetteEffect.h
============================================================

#pragma once
/// ===Include=== ///
#include "Engine/Graphics/OffScreen/RenderPass.h"
// BufferBase
#include "Engine/Graphics/Base/BufferBase.h"

/// ===Dissolveã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ === ///
struct VignetteData {
	float scale; // discardã®é–¾å€¤
	float pawer; // smoothstepé–‹å§‹
	Vector2 padding; // floatã®å€æ•°ã«ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ‡ã‚£ãƒ³ã‚°
};

///=====================================================/// 
/// VignetteEffect
///=====================================================///
class VignetteEffect : public RenderPass {
public:
	VignetteEffect() = default;
	~VignetteEffect() = default;
	
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ D3D12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚GPU ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–ã§ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã® std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã®å‡ºåŠ›å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> RenderTexture) override;
	
	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚GPU ã‚³ãƒãƒ³ãƒ‰ã®ç™ºè¡Œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚æç”»å‰ã« DSV ã‚’ãƒã‚¤ãƒ³ãƒ‰ã¾ãŸã¯è¨­å®šã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) override;
	
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã•ãªã„ã§ãã ã•ã„ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList) override;
	
	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ImGuiInfo() override;

public: /// ===Setter=== ///
	// ãƒ‡ãƒ¼ã‚¿
	void SetData(VignetteData data);

private:

	// Buffer
	std::unique_ptr<BufferBase> buffer_;

	// Data
	VignetteData* data_ = nullptr;
};


============================================================
File Path: Project/Engine/Graphics/OffScreen/OffScreenRenderer.cpp
============================================================
#include "OffScreenRenderer.h"
// Service
#include "Engine/System/Service/Render.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
OffScreenRenderer::~OffScreenRenderer() {
	copyImage_.reset();
	grayscale_.reset();
	vignette_.reset();
	boxFilter3x3_.reset();
	boxFilter5x5_.reset();
	radiusBlur_.reset();
	outLine_.reset();
	dissolve_.reset();
	shatterGlass_.reset();
	sceneTexture_.reset();
	effectTexture_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void OffScreenRenderer::Initialize(
	ID3D12Device* device,
	SRVManager* srv, RTVManager* rtv,
	uint32_t width, uint32_t height, const Vector4& clearColor) {

	// ã‚·ãƒ¼ãƒ³æç”»ç”¨ã®RenderTextureã‚’åˆæœŸåŒ–
	sceneTexture_ = std::make_shared<RenderTexture>();
	sceneTexture_->Initialize(srv, rtv, width, height, clearColor, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB);
	sceneTexture_->CreateRenderTexture(device);

	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé©ç”¨å¾Œã®RenderTextureã‚’åˆæœŸåŒ–
	effectTexture_ = std::make_shared<RenderTexture>();
	effectTexture_->Initialize(srv, rtv, width, height, clearColor, DXGI_FORMAT_R8G8B8A8_UNORM_SRGB);
	effectTexture_->CreateRenderTexture(device);

	/// ===RenderPassã®ç™»éŒ²=== ///
	// SceneRenderPass
	copyImage_ = std::make_shared<CopyImageEffect>();
	copyImage_->Initialize(device,effectTexture_);
	copyImage_->SetInputTexture(sceneTexture_);

	// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹
	grayscale_ = std::make_shared<GrayscaleEffect>();
	grayscale_->Initialize(device, effectTexture_);
	grayscale_->SetInputTexture(sceneTexture_);

	// ãƒ“ãƒãƒƒãƒˆãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹
	vignette_ = std::make_shared<VignetteEffect>();
	vignette_->Initialize(device, effectTexture_);
	vignette_->SetInputTexture(sceneTexture_);

	// Dissolveã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	dissolve_ = std::make_shared<DissolveEffect>();
	dissolve_->Initialize(device, effectTexture_);
	dissolve_->SetInputTexture(sceneTexture_);

	// 3x3ãƒœãƒƒã‚¯ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹
	boxFilter3x3_ = std::make_shared<BoxFilter3x3Effect>();
	boxFilter3x3_->Initialize(device, effectTexture_);
	boxFilter3x3_->SetInputTexture(sceneTexture_);

	// 5x5ãƒœãƒƒã‚¯ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ‘ã‚¹
	boxFilter5x5_ = std::make_shared<BoxFilter5x5Effect>();
	boxFilter5x5_->Initialize(device, effectTexture_);
	boxFilter5x5_->SetInputTexture(sceneTexture_);

	// åŠå¾„ãƒ–ãƒ©ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	radiusBlur_ = std::make_shared<RadiusBlurEffect>();
	radiusBlur_->Initialize(device, effectTexture_);
	radiusBlur_->SetInputTexture(sceneTexture_);

	// OutLineã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	outLine_ = std::make_shared<OutLineEffect>();
	outLine_->Initialize(device, effectTexture_);
	outLine_->SetInputTexture(sceneTexture_);

	// ShatterGlassã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	shatterGlass_ = std::make_shared<ShatterGlassEffect>();
	shatterGlass_->Initialize(device, effectTexture_);
	shatterGlass_->SetInputTexture(sceneTexture_);
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void OffScreenRenderer::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {
	
	// ã‚·ãƒ¼ãƒ³æç”»ã¯sceneTexture_ã¸
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandel = sceneTexture_->GetRTVHandle();
	commandList->OMSetRenderTargets(1, &rtvHandel, false, &dsvHandle);
	// RenderTextureã®ã‚¯ãƒªã‚¢
	sceneTexture_->Clear(commandList);
	
	/*switch (type_) {
	case OffScreenType::CopyImage:
		copyImage_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::Grayscale:
		grayscale_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::Vignette:
		vignette_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::BoxFilter3x3:
		boxFilter3x3_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::BoxFilter5x5:
		boxFilter5x5_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::RadiusBlur:
		radiusBlur_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::OutLine:
		outLine_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::Dissolve:
		dissolve_->PreDraw(commandList, dsvHandle);
		break;
	case OffScreenType::ShatterGlass:
		shatterGlass_->PreDraw(commandList, dsvHandle);
		break;
	}*/
}

///-------------------------------------------/// 
/// æç”»å‡¦ç†
///-------------------------------------------///
void OffScreenRenderer::Draw(ID3D12GraphicsCommandList* commandList) {
	// effectTexture_ ã¸ã®æç”»å…ˆã‚’è¨­å®š
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle = effectTexture_->GetRTVHandle();
	commandList->OMSetRenderTargets(1, &rtvHandle, false, nullptr);

	// effectTexture_ ã‚’ã‚¯ãƒªã‚¢
	effectTexture_->Clear(commandList);

	switch (type_) {
	case OffScreenType::CopyImage:
		copyImage_->Draw(commandList);
		break;
	case OffScreenType::Grayscale:
		grayscale_->Draw(commandList);
		break;
	case OffScreenType::Vignette:
		vignette_->Draw(commandList);
		break;
	case OffScreenType::BoxFilter3x3:
		boxFilter3x3_->Draw(commandList);
		break;
	case OffScreenType::BoxFilter5x5:
		boxFilter5x5_->Draw(commandList);
		break;
	case OffScreenType::RadiusBlur:
		radiusBlur_->Draw(commandList);
		break;
	case OffScreenType::OutLine:
		outLine_->Draw(commandList);
		break;
	case OffScreenType::Dissolve:
		dissolve_->Draw(commandList);
		break;
	case OffScreenType::ShatterGlass:
		shatterGlass_->Draw(commandList);
		break;
	}
}

///-------------------------------------------/// 
/// æç”»å¾Œå‡¦ç†
///-------------------------------------------///
void OffScreenRenderer::PostDraw(ID3D12GraphicsCommandList* commandList) {
	commandList;
}

///-------------------------------------------/// 
/// effectTexture ã‚’ SwapChain ã«ã‚³ãƒ”ãƒ¼
///-------------------------------------------///
void OffScreenRenderer::CopyToSwapChain(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE swapChainRTV) {
	// SwapChain ã® RTV ã‚’æç”»å…ˆã¨ã—ã¦è¨­å®š
	commandList->OMSetRenderTargets(1, &swapChainRTV, false, nullptr);

	// CopyImage ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä½¿ç”¨ã—ã¦ effectTexture_ ã‚’ SwapChain ã«ã‚³ãƒ”ãƒ¼
	Render::SetPSO(commandList, PipelineType::OffScreen, BlendMode::kBlendModeNone);
	commandList->SetGraphicsRootDescriptorTable(0, effectTexture_->GetSRVHandle());
	commandList->DrawInstanced(3, 1, 0, 0);
}

///-------------------------------------------/// 
/// ImGuiã®æç”»
///-------------------------------------------///
#ifdef USE_IMGUI
void OffScreenRenderer::DrawImGui() {
	const char* typeNames[] = {
		"CopyImage",
		"Grayscale",
		"Vignette",
		"BoxFilter3x3",
		"BoxFilter5x5",
		"RadiusBlur",
		"OutLine",
		"Dissolve",
		"ShatterGlass",
	};

	int current = static_cast<int>(type_);
	if (ImGui::Begin("OffScreen Effect")) {
		ImGui::Text("Current Effect: %s", typeNames[current]);  // â† â˜… ã“ã“ã§åå‰è¡¨ç¤º

		if (ImGui::Combo("Effect Type", &current, typeNames, IM_ARRAYSIZE(typeNames))) {
			type_ = static_cast<OffScreenType>(current);
		}
	}

	switch (type_) {
	case OffScreenType::CopyImage:
		copyImage_->ImGuiInfo();
		break;
	case OffScreenType::Grayscale:
		grayscale_->ImGuiInfo();
		break;
	case OffScreenType::Vignette:
		vignette_->ImGuiInfo();
		break;
	case OffScreenType::BoxFilter3x3:
		boxFilter3x3_->ImGuiInfo();
		break;
	case OffScreenType::BoxFilter5x5:
		boxFilter5x5_->ImGuiInfo();
		break;
	case OffScreenType::RadiusBlur:
		radiusBlur_->ImGuiInfo();
		break;
	case OffScreenType::OutLine:
		outLine_->ImGuiInfo();
		break;
	case OffScreenType::Dissolve:
		dissolve_->ImGuiInfo();
		break;
	case OffScreenType::ShatterGlass:
		shatterGlass_->ImGuiInfo();
		break;
	}

	ImGui::End();
}
#endif // USE_IMGUI

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// RTV
D3D12_CPU_DESCRIPTOR_HANDLE OffScreenRenderer::GetResultRTV() const { return effectTexture_->GetRTVHandle(); }
// SRV
D3D12_GPU_DESCRIPTOR_HANDLE OffScreenRenderer::GetResultSRV() const { return effectTexture_->GetSRVHandle(); }
// RTVIndex
uint32_t OffScreenRenderer::GetRTVHandleIndex() const { return effectTexture_->GetRTVHandleIndex(); }
// SRVIndex
uint32_t OffScreenRenderer::GetSRVHandleIndex() const { return effectTexture_->GetSRVHandleIndex(); }
// Reosurce
ID3D12Resource* OffScreenRenderer::GetSceneBuffer() const { return sceneTexture_->GetBuffer(); }
ID3D12Resource* OffScreenRenderer::GetEffectBuffer() const { return effectTexture_->GetBuffer(); }

/// ===Effect=== ///
CopyImageEffect* OffScreenRenderer::GetCopyImage() { return copyImage_.get(); }
GrayscaleEffect* OffScreenRenderer::GetGrayscale() { return grayscale_.get(); }
VignetteEffect* OffScreenRenderer::GetVignette() { return vignette_.get();}
OutLineEffect* OffScreenRenderer::GetOutLine() { return outLine_.get(); }
BoxFilter3x3Effect* OffScreenRenderer::GetBoxFilter3x3() { return boxFilter3x3_.get(); }
BoxFilter5x5Effect* OffScreenRenderer::GetBoxFilter5x5() { return boxFilter5x5_.get(); }
RadiusBlurEffect* OffScreenRenderer::GetRadiusBlur() { return radiusBlur_.get(); }
DissolveEffect* OffScreenRenderer::GetDissolve() { return dissolve_.get(); }
ShatterGlassEffect* OffScreenRenderer::GetShatterGlass() { return shatterGlass_.get(); }

/// ===Type=== ///
OffScreenType OffScreenRenderer::GetType() { return type_; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Typeã®è¨­å®š
void OffScreenRenderer::SetType(OffScreenType type) { type_ = type; }


============================================================
File Path: Project/Engine/Graphics/OffScreen/OffScreenRenderer.h
============================================================
#pragma once
/// ===Include=== ///
// c++
#include <vector>
// Offscreen
#include "RenderTexture.h"
// Effect
#include "Effect/CopyImageEffect.h"
#include "Effect/GrayscaleEffect.h"
#include "Effect/VignetteEffect.h"
#include "Effect/OutLineEffect.h"
#include "Effect/BoxFilter3x3Effect.h"
#include "Effect/BoxFilter5x5Effect.h"
#include "Effect/RadiusBlurEffect.h"
#include "Effect/DissolveEffect.h"
#include "Effect/ShatterGlassEffect.h"

// Data
#include "Engine/DataInfo/OffScreenData.h"

///=====================================================/// 
/// OffScreenRenderer
///=====================================================///
class OffScreenRenderer {
public:
	OffScreenRenderer() = default;
	~OffScreenRenderer();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">ãƒªã‚½ãƒ¼ã‚¹ä½œæˆã‚„ã‚³ãƒãƒ³ãƒ‰å®Ÿè¡Œã«ä½¿ç”¨ã•ã‚Œã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="srv">ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ (SRV) ã‚’ç®¡ç†ã™ã‚‹ SRVManager ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="rtv">ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ (RTV) ã‚’ç®¡ç†ã™ã‚‹ RTVManager ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="width">åˆæœŸåŒ–ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚</param>
	/// <param name="height">åˆæœŸåŒ–ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®é«˜ã•ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚</param>
	/// <param name="clearColor">ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢ã™ã‚‹éš›ã«ä½¿ç”¨ã™ã‚‹è‰²ï¼ˆVector4ã€é€šå¸¸ã¯ RGBAï¼‰ã€‚</param>
	void Initialize(ID3D12Device* device, SRVManager* srv, RTVManager* rtv, uint32_t width, uint32_t height, const Vector4& clearColor);

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚æ“ä½œå¯¾è±¡ã®æœ‰åŠ¹ãªã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	/// <param name="dsvHandle">ãƒã‚¤ãƒ³ãƒ‰ã™ã‚‹æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã‚’æŒ‡ã™ D3D12_CPU_DESCRIPTOR_HANDLEã€‚</param>
	void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle);

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ãƒ»ç™ºè¡Œã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚å‘¼ã³å‡ºã™å‰ã«ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆãŒé©åˆ‡ã«åˆæœŸåŒ–ãŠã‚ˆã³è¨­å®šã•ã‚Œã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚</param>
	void Draw(ID3D12GraphicsCommandList* commandList);

	/// <summary>
	/// æç”»å¾Œå‡¦ç†
	/// </summary>
	/// <param name="commandList">å¾Œå‡¦ç†ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void PostDraw(ID3D12GraphicsCommandList* commandList);

	/// <summary>
	/// effectTexture ã‚’ SwapChain ã«ã‚³ãƒ”ãƒ¼
	/// </summary>
	/// <param name="commandList">ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	/// <param name="swapChainRTV">SwapChain ã® RTV ãƒãƒ³ãƒ‰ãƒ«</param>
	void CopyToSwapChain(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE swapChainRTV);

#ifdef USE_IMGUI
	void DrawImGui();
#endif

public: /// ===Getter=== ///
	// RTVHandleã®å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE GetResultRTV() const;
	// SRVã®å–å¾—
	D3D12_GPU_DESCRIPTOR_HANDLE GetResultSRV() const;
	// RTVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã®å–å¾—
	uint32_t GetRTVHandleIndex() const;
	// SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã®å–å¾—
	uint32_t GetSRVHandleIndex() const;
	// Resourceã®å–å¾—
	ID3D12Resource* GetSceneBuffer() const;
	ID3D12Resource* GetEffectBuffer() const;

public: /// ===Getter=== ///
	// ã‚³ãƒ”ãƒ¼ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	CopyImageEffect* GetCopyImage();
	// ã‚°ãƒ¬ãƒ¼ã‚¹ã‚±ãƒ¼ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	GrayscaleEffect* GetGrayscale();
	// ãƒ“ãƒãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	VignetteEffect* GetVignette();
	// ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	OutLineEffect* GetOutLine();
	// 3x3ãƒœãƒƒã‚¯ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	BoxFilter3x3Effect* GetBoxFilter3x3();
	// 5x5ãƒœãƒƒã‚¯ã‚¹ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	BoxFilter5x5Effect* GetBoxFilter5x5();
	// åŠå¾„ã¼ã‹ã—ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	RadiusBlurEffect* GetRadiusBlur();
	// ãƒ‡ã‚£ã‚¾ãƒ«ãƒ–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	DissolveEffect* GetDissolve();
	// ç ´ç‰‡ã‚¬ãƒ©ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®å–å¾—
	ShatterGlassEffect* GetShatterGlass();
	// Piplineã®ã‚¿ã‚¤ãƒ—ã®å–å¾—
	OffScreenType GetType();

public: /// ===Setter=== ///
	// Typeã®è¨­å®š
	void SetType(OffScreenType type);

private:
	std::shared_ptr<RenderTexture> sceneTexture_;
	std::shared_ptr<RenderTexture> effectTexture_;

	// å„ãƒ‘ã‚¹ï¼ˆã‚ã‚‰ã‹ã˜ã‚ç”Ÿæˆæ¸ˆã¿ï¼‰
	std::shared_ptr<CopyImageEffect> copyImage_;
	std::shared_ptr<GrayscaleEffect> grayscale_;
	std::shared_ptr<VignetteEffect> vignette_;
	std::shared_ptr<OutLineEffect> outLine_;
	std::shared_ptr<BoxFilter3x3Effect> boxFilter3x3_;
	std::shared_ptr<BoxFilter5x5Effect> boxFilter5x5_;
	std::shared_ptr<RadiusBlurEffect> radiusBlur_;
	std::shared_ptr<DissolveEffect> dissolve_;
	std::shared_ptr<ShatterGlassEffect> shatterGlass_;

	// Piplineã®ã‚¿ã‚¤ãƒ—
	OffScreenType type_ = OffScreenType::CopyImage;
};



============================================================
File Path: Project/Engine/Graphics/OffScreen/RenderPass.cpp
============================================================
#include "RenderPass.h"

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void RenderPass::PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle) {

	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandel = outputTexture_->GetRTVHandle();
	commandList->OMSetRenderTargets(1, &rtvHandel, false, &dsvHandle);

	// RenderTextureã®ã‚¯ãƒªã‚¢
	outputTexture_->Clear(commandList);
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void RenderPass::SetInputTexture(std::shared_ptr<RenderTexture> inputTexture) { inputTexture_ = inputTexture; }


============================================================
File Path: Project/Engine/Graphics/OffScreen/RenderPass.h
============================================================
#pragma once
#include "Engine/Graphics/OffScreen/RenderTexture.h"
#include <memory>

///=====================================================/// 
/// RenderPass 
///=====================================================///
class RenderPass {
public:
	RenderPass() = default;
	virtual ~RenderPass() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ Direct3D 12 ãƒ‡ãƒã‚¤ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆID3D12Device*ï¼‰ã€‚</param>
	/// <param name="RenderTexture">åˆæœŸåŒ–å¯¾è±¡ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æŒ‡ã™ std::shared_ptrã€‚ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å…ˆã‚„é–¢é€£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	virtual void Initialize(ID3D12Device* device, std::shared_ptr<RenderTexture> outputTexture) = 0;

	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	/// <param name="commandList">æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="dsvHandle">æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ (DSV) ã® CPU å´ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã€‚æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«è¨­å®šã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	virtual void PreDraw(ID3D12GraphicsCommandList* commandList, D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle);

	/// <summary>
	/// æç”»å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="commandList">Direct3D 12 ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’ã“ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨˜éŒ²ã—ã¾ã™ã€‚</param>
	virtual void Draw(ID3D12GraphicsCommandList* commandList) = 0;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	virtual void ImGuiInfo() = 0;

public:

	/// <summary>
	/// å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®šã—ã¾ã™ã€‚æ¸¡ã•ã‚ŒãŸstd::shared_ptr<RenderTexture>ã‚’å—ã‘å–ã‚Šã€å†…éƒ¨ã®å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ›´æ–°ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="inputTexture">è¨­å®šã™ã‚‹å…¥åŠ›ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¸ã®std::shared_ptr<RenderTexture>ã€‚æ‰€æœ‰æ¨©ã¯å…±æœ‰ã•ã‚Œã€å‚ç…§ã‚«ã‚¦ãƒ³ãƒˆãŒå¢—åŠ ã—ã¾ã™ã€‚</param>
	void SetInputTexture(std::shared_ptr<RenderTexture> inputTexture);

protected:
	std::shared_ptr<RenderTexture> inputTexture_;
	std::shared_ptr<RenderTexture> outputTexture_;
};

 

============================================================
File Path: Project/Engine/Graphics/OffScreen/RenderTexture.cpp
============================================================
#include "RenderTexture.h"
// Engine
#include "Engine/System/Managers/RTVManager.h"
#include "Engine/System/Managers/DSVManager.h"
#include "Engine/System/Managers/SRVManager.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
RenderTexture::~RenderTexture() {
	buffer_.Reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void RenderTexture::Initialize(
	SRVManager* srv, RTVManager* rtv,
	uint32_t width, uint32_t height, const Vector4& clearColor, DXGI_FORMAT format) {

	// Managerã®å–å¾—
	rtvManager_ = rtv;
	srvManager_ = srv;

	// å€¤ã®ä»£å…¥
	width_ = width;
	height_ = height;
	format_ = format;
	clearColor_ = clearColor;
}

///-------------------------------------------///  
/// RenderTextureã®ç”Ÿæˆ
///-------------------------------------------///
void RenderTexture::CreateRenderTexture(ID3D12Device* device) {
	/// ===Resource=== ///
	// DESCã®è¨­å®š
	D3D12_RESOURCE_DESC textureDesc{};
	textureDesc.Width = width_;
	textureDesc.Height = height_;
	textureDesc.DepthOrArraySize = 1;
	textureDesc.MipLevels = 1;
	textureDesc.Format = format_;
	textureDesc.SampleDesc.Count = 1;
	textureDesc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
	textureDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	textureDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET; // RenderTextureã¨ã—ã¦åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
	// HEAPã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT; // å½“ç„¶VRAMçŠ¶ã«ä½œã‚‹
	// ClearValueã®è¨­å®š
	D3D12_CLEAR_VALUE clearValue{};
	clearValue.Format = format_; // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	clearValue.Color[0] = clearColor_.x; // RGBAã®å€¤
	clearValue.Color[1] = clearColor_.y;
	clearValue.Color[2] = clearColor_.z;
	clearValue.Color[3] = clearColor_.w;
	// Resourceã®ç”Ÿæˆ
	device->CreateCommittedResource(
		&heapProperties,			// Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE,		// Heapã®ãƒ•ãƒ©ã‚°
		&textureDesc,				// Resourceã®DESC
		D3D12_RESOURCE_STATE_RENDER_TARGET, // Resourceã®çŠ¶æ…‹
		&clearValue,				// ClearValueã®è¨­å®š
		IID_PPV_ARGS(&buffer_));	// Resourceã®ãƒã‚¤ãƒ³ã‚¿


	/// ===RTV=== ///
	// DESCã®è¨­å®š
	D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
	rtvDesc.Format = format_; // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D; // 2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
	// RTVã®ä½œæˆ
	rtvHandleIndex_ = rtvManager_->Allocate(); // RTVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç¢ºä¿
	rtvManager_->CreateRenderTargetView(rtvHandleIndex_, buffer_.Get(), rtvDesc);

	/// ===SRV=== ///
	// DESCã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = format_; // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Texture2D.MipLevels = 1;
	// SRVã®ä½œæˆ
	srvHandleIndex_ = srvManager_->Allocate(); // SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ç¢ºä¿
	srvManager_->CreateShaderResourceView(srvHandleIndex_, buffer_.Get(), srvDesc);
}

///-------------------------------------------/// 
/// ã‚¯ãƒªã‚¢
///-------------------------------------------///
void RenderTexture::Clear(ID3D12GraphicsCommandList* commandList) {
	// RTVã®ã‚¯ãƒªã‚¢
	const float clearColor[4] = { clearColor_.x, clearColor_.y, clearColor_.z, clearColor_.w };
	rtvManager_->ClearRenderTargetView(commandList, rtvHandleIndex_, clearColor);
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// RenderTextureã®å–å¾—
ID3D12Resource* RenderTexture::GetBuffer() { return buffer_.Get(); }
// RTVHandleã®å–å¾—
D3D12_CPU_DESCRIPTOR_HANDLE RenderTexture::GetRTVHandle() { return rtvManager_->GetCPUDescriptorHandle(rtvHandleIndex_); }
// SRVHandleã®å–å¾—
D3D12_GPU_DESCRIPTOR_HANDLE RenderTexture::GetSRVHandle() { return srvManager_->GetGPUDescriptorHandle(srvHandleIndex_); }
// RTVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã®å–å¾—
uint32_t RenderTexture::GetRTVHandleIndex() const { return rtvHandleIndex_; }
// SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã®å–å¾—
uint32_t RenderTexture::GetSRVHandleIndex() const { return srvHandleIndex_; }


============================================================
File Path: Project/Engine/Graphics/OffScreen/RenderTexture.h
============================================================
#pragma once
// ComPtr
#include "Engine/Core/ComPtr.h"
// Vector4
#include "Math/Vector4.h"
// DirectX
#include <d3d12.h>
// uint32_t
#include <cstdint>

/// ===å‰æ–¹å®£è¨€=== ///
class SRVManager;
class RTVManager;

///=====================================================/// 
/// RenderTexture
///=====================================================///
class RenderTexture {
public:

	RenderTexture() = default;
	~RenderTexture();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="srv">SRVManager ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ï¼ˆSRVï¼‰ã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</param>
	/// <param name="rtv">RTVManager ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ï¼ˆRTVï¼‰ã‚’ç®¡ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</param>
	/// <param name="width">åˆæœŸåŒ–ã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚</param>
	/// <param name="height">åˆæœŸåŒ–ã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®é«˜ã•ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚</param>
	/// <param name="clearColor">ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢ã™ã‚‹éš›ã«ä½¿ç”¨ã™ã‚‹è‰²ã€‚Vector4 ã§ RGBA ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <param name="format">ä½¿ç”¨ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ç¤ºã™ DXGI_FORMAT å€¤ã€‚</param>
	void Initialize(SRVManager* srv, RTVManager* rtv, uint32_t width, uint32_t height, const Vector4& clearColor, DXGI_FORMAT format);

	/// <summary>
	/// RenderTextureã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="device">ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ä½œæˆã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</param>
	void CreateRenderTexture(ID3D12Device* device);

	/// <summary>
	/// RenderTextureã®ã‚¯ãƒªã‚¢
	/// </summary>
	/// <param name="commandList">ã‚¯ãƒªã‚¢æ“ä½œã‚’è¨˜éŒ²ã™ã‚‹ãŸã‚ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚æœ‰åŠ¹ãªï¼ˆnullptr ã§ãªã„ï¼‰ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æ¸¡ã—ã¦ãã ã•ã„ã€‚</param>
	void Clear(ID3D12GraphicsCommandList* commandList);

public: /// ===Getter=== ///

	// RenderTextureã®å–å¾—
	ID3D12Resource* GetBuffer();
	// RTVHandleã®å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE GetRTVHandle();
	// SRVHandleã®å–å¾—
	D3D12_GPU_DESCRIPTOR_HANDLE GetSRVHandle();
	// RTVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã®å–å¾—
	uint32_t GetRTVHandleIndex() const;
	// SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç•ªå·ã®å–å¾—
	uint32_t GetSRVHandleIndex() const;

private:
	// Manager
	RTVManager* rtvManager_ = nullptr;
	SRVManager* srvManager_ = nullptr;

	// Info
	uint32_t width_;
	uint32_t height_;
	DXGI_FORMAT format_;
	Vector4 clearColor_;

	// Resource
	ComPtr<ID3D12Resource> buffer_;
	uint32_t rtvHandleIndex_ = 0;
	uint32_t srvHandleIndex_ = 0;
};



============================================================
File Path: Project/Engine/Graphics/Particle/ParticleCommon.cpp
============================================================
#include "ParticleCommon.h"
// c++
#include <cassert>
// Math
#include "Math/MatrixMath.h"


///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ParticleCommon::ParticleCommon() = default;
ParticleCommon::~ParticleCommon() { 
	material_.reset(); 
	instancing_.Reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ParticleCommon::Initlize(ID3D12Device* device, const uint32_t kNumMaxInstance) {

	/// ===mateial=== ///
	// ç”Ÿæˆ
	material_ = std::make_unique<Material3D>();
	// buffer
	material_->Create(device, sizeof(MaterialData3D));
	material_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&materialData_));
	materialData_->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	materialData_->enableLighting = false;
	materialData_->uvTransform = Math::MakeIdentity4x4();

	/// ===Instancing=== ///
	// ç”Ÿæˆ
	Create(device, sizeof(ParticleForGPU) * kNumMaxInstance);
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	instancing_->Map(0, nullptr, reinterpret_cast<void**>(&instancingData_));
	
	// Dataã®æ›¸ãè¾¼ã¿
	for (uint32_t index = 0; index < kNumMaxInstance; ++index) {
		instancingData_[index].WVP = Math::MakeIdentity4x4();
		instancingData_[index].World = Math::MakeIdentity4x4();
		instancingData_[index].color = { 1.0f, 1.0f, 1.0f, 1.0f };
	}
}

///-------------------------------------------/// 
/// æç”»æº–å‚™
///-------------------------------------------///
void ParticleCommon::Bind(ID3D12GraphicsCommandList* commandList) {
	// ãƒãƒ†ãƒªã‚¢ãƒ«CBufferã®å ´æ‰€è¨­å®š
	commandList->SetGraphicsRootConstantBufferView(0, material_->GetBuffer()->GetGPUVirtualAddress());
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// Instancing
ID3D12Resource* ParticleCommon::GetInstancing() { return instancing_.Get(); }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// material
void ParticleCommon::SetMatiarlData(const Vector4& color, const Matrix4x4& uvTransform) {
	materialData_->color = color;
	materialData_->uvTransform = uvTransform;

}
// Instancing
void ParticleCommon::SetInstancingData(size_t index, const Vector4& color, const Matrix4x4& WVP, const Matrix4x4& World) {
	instancingData_[index].color = color;
	instancingData_[index].WVP = WVP;
	instancingData_[index].World = World;
}

///-------------------------------------------/// 
/// Bufferã®ç”Ÿæˆ
///-------------------------------------------///
void ParticleCommon::Create(ID3D12Device* device, size_t sizeInBytes) {
	HRESULT hr;

	// ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—ã®è¨­å®š
	D3D12_HEAP_PROPERTIES uploadHeapProperties{};
	uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;  // UploadHeapã‚’ä½¿ã†

	// ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
	D3D12_RESOURCE_DESC ResourceDesc{};

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã€‚ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å ´åˆã¯ã¾ãŸåˆ¥ã®è¨­å®šã‚’ã™ã‚‹
	ResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	ResourceDesc.Width = sizeInBytes; // ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã€‚ä»Šå›ã¯Vector4ã‚’3é ‚ç‚¹åˆ†

	// ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã‚‰ã¯1ã«ã™ã‚‹æ±ºã¾ã‚Š
	ResourceDesc.Height = 1;
	ResourceDesc.DepthOrArraySize = 1;
	ResourceDesc.MipLevels = 1;
	ResourceDesc.SampleDesc.Count = 1;

	// ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã¯ã“ã‚Œã«ã™ã‚‹æ±ºã¾ã‚Š
	ResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	// å®Ÿéš›ã«é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œã‚‹
	hr = device->CreateCommittedResource(&uploadHeapProperties, D3D12_HEAP_FLAG_NONE, &ResourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(&instancing_));
	assert(SUCCEEDED(hr));
}


============================================================
File Path: Project/Engine/Graphics/Particle/ParticleCommon.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/DataInfo/CData.h"
#include "Engine/DataInfo/ParticleData.h"
#include "Engine/Core/ComPtr.h"
#include "Engine/Graphics/3d/base/Material3D.h"
// c++
#include <memory>
#include <list>

/// ===å‰æ–¹å®£è¨€=== ///
class SRVManager;

///=====================================================/// 
/// ParticleSetUp
///=====================================================///
class ParticleCommon {
public:

	ParticleCommon();
	~ParticleCommon();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="device">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="kNumMaxInstance">åˆæœŸåŒ–æ™‚ã«ç¢ºä¿ã¾ãŸã¯è¨±å®¹ã™ã‚‹æœ€å¤§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ï¼ˆuint32_tï¼‰ã€‚</param>
	void Initlize(ID3D12Device* device, const uint32_t kNumMaxInstance);

	/// <summary>
	/// æç”»æº–å‚™å‡¦ç†
	/// </summary>
	/// <param name="commandList">ãƒã‚¤ãƒ³ãƒ‰å…ˆã®ID3D12GraphicsCommandListã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚ã‚³ãƒãƒ³ãƒ‰ã®è¨˜éŒ²ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Bind(ID3D12GraphicsCommandList* commandList);

public: /// ===Geter=== ///

	// Instancingã®å–å¾—
	ID3D12Resource* GetInstancing();

public: /// ===Setter=== ///

	// Material
	void SetMatiarlData(const Vector4& color, const Matrix4x4& uvTransform);
	// Instancing
	void SetInstancingData(size_t index, const Vector4& color, const Matrix4x4& WVP, const Matrix4x4& World);

private:

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹=== ///
	std::unique_ptr<Material3D> material_;
	ComPtr<ID3D12Resource> instancing_;
	
	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
	MaterialData3D* materialData_ = nullptr;
	ParticleForGPU* instancingData_ = nullptr;

private:

	/// <summary>
	/// Bufferã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="device">ãƒªã‚½ãƒ¼ã‚¹ä½œæˆã«ä½¿ç”¨ã™ã‚‹ ID3D12Device ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="sizeInBytes">ä½œæˆã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºï¼ˆãƒã‚¤ãƒˆå˜ä½ï¼‰ã€‚</param>
	void Create(ID3D12Device* device, size_t sizeInBytes);
};



============================================================
File Path: Project/Engine/Graphics/Particle/ParticleDefinition.cpp
============================================================
#include "ParticleDefinition.h"

///-------------------------------------------/// 
/// JSONå¤‰æ›: ToJson
///-------------------------------------------///
nlohmann::json ParticleDefinition::ToJson() const {
	nlohmann::json j;

	// åŸºæœ¬è¨­å®š
	j["name"] = name;
	j["modelName"] = modelName;
	j["shape"] = shape;
	j["maxInstance"] = maxInstance;

	// ç‰©ç†è¨­å®š
	j["physics"] = {
		{"velocityMin", Vector3ToJson(physics.velocityMin)},
		{"velocityMax", Vector3ToJson(physics.velocityMax)},
		{"acceleration", Vector3ToJson(physics.acceleration)},
		{"gravity", physics.gravity},
		{"explosionRange", Vector3ToJson(physics.explosionRange)},
		{"upwardForce", physics.upwardForce},
		{"useRandomVelocity", physics.useRandomVelocity}
	};

	// è¦‹ãŸç›®è¨­å®š
	j["appearance"] = {
		{"startColor", Vector4ToJson(appearance.startColor)},
		{"endColor", Vector4ToJson(appearance.endColor)},
		{"startScaleMin", Vector3ToJson(appearance.startScaleMin)},
		{"startScaleMax", Vector3ToJson(appearance.startScaleMax)},
		{"endScale", Vector3ToJson(appearance.endScale)},
		{"texturePath", appearance.texturePath},
		{"useColorGradient", appearance.useColorGradient},
		{"useScaleAnimation", appearance.useScaleAnimation}
	};

	// å›è»¢è¨­å®š
	j["rotation"] = {
		{"initialRotationMin", Vector3ToJson(rotation.initialRotationMin)},
		{"initialRotationMax", Vector3ToJson(rotation.initialRotationMax)},
		{"rotationSpeedMin", Vector3ToJson(rotation.rotationSpeedMin)},
		{"rotationSpeedMax", Vector3ToJson(rotation.rotationSpeedMax)},
		{"randomRotation", rotation.randomRotation},
		{"enableRotation", rotation.enableRotation},
		{"randomInitialRotation", rotation.randomInitialRotation}
	};

	// ç™ºç”Ÿè¨­å®š
	j["emission"] = {
		{"lifetimeMin", emission.lifetimeMin},
		{"lifetimeMax", emission.lifetimeMax},
		{"emissionRate", emission.emissionRate},
		{"burstCount", emission.burstCount},
		{"frequency", emission.frequency},
		{"isBurst", emission.isBurst}
	};

	// é«˜åº¦è¨­å®š
	j["advanced"] = {
		{"motion", MotionSettingsToJson(advanced.motion)},
		{"emissionPattern", EmissionPatternToJson(advanced.emissionPattern)},
		{"colorGradient", ColorGradientToJson(advanced.colorGradient)},
		{"scaleAnimation", ScaleAnimationToJson(advanced.scaleAnimation)},
		{"isTrajectoryParticle", advanced.isTrajectoryParticle},
		{"trailSpacing", advanced.trailSpacing},
		{"clearOnStop", advanced.clearOnStop}
	};

	return j;
}

///-------------------------------------------/// 
/// JSONå¤‰æ›: FromJson
///-------------------------------------------///
ParticleDefinition ParticleDefinition::FromJson(const nlohmann::json& json) {
	ParticleDefinition def;

	// åŸºæœ¬è¨­å®š
	if (json.contains("name")) def.name = json["name"];
	if (json.contains("modelName")) def.modelName = json["modelName"];
	if (json.contains("shape")) def.shape = json["shape"];
	if (json.contains("maxInstance")) def.maxInstance = json["maxInstance"];

	// ç‰©ç†è¨­å®š
	if (json.contains("physics")) {
		const auto& p = json["physics"];
		if (p.contains("velocityMin")) def.physics.velocityMin = JsonToVector3(p["velocityMin"]);
		if (p.contains("velocityMax")) def.physics.velocityMax = JsonToVector3(p["velocityMax"]);
		if (p.contains("acceleration")) def.physics.acceleration = JsonToVector3(p["acceleration"]);
		if (p.contains("gravity")) def.physics.gravity = p["gravity"];
		if (p.contains("explosionRange")) {
			def.physics.explosionRange = JsonToVector3(p["explosionRange"]);
		} else if (p.contains("explosionRadius")) {
			// å¤ã„å½¢å¼ï¼ˆfloatï¼‰ã®å ´åˆã¯å…¨è»¸ã«åŒã˜å€¤ã‚’è¨­å®š
			float radius = p["explosionRadius"];
			def.physics.explosionRange = { radius, radius, radius };
		}
		if (p.contains("upwardForce")) def.physics.upwardForce = p["upwardForce"];
		if (p.contains("useRandomVelocity")) def.physics.useRandomVelocity = p["useRandomVelocity"];
	}

	// è¦‹ãŸç›®è¨­å®š
	if (json.contains("appearance")) {
		const auto& a = json["appearance"];
		if (a.contains("startColor")) def.appearance.startColor = JsonToVector4(a["startColor"]);
		if (a.contains("endColor")) def.appearance.endColor = JsonToVector4(a["endColor"]);
		if (a.contains("startScaleMin")) def.appearance.startScaleMin = JsonToVector3(a["startScaleMin"]);
		if (a.contains("startScaleMax")) def.appearance.startScaleMax = JsonToVector3(a["startScaleMax"]);
		if (a.contains("endScale")) def.appearance.endScale = JsonToVector3(a["endScale"]);
		if (a.contains("texturePath")) def.appearance.texturePath = a["texturePath"];
		if (a.contains("useColorGradient")) def.appearance.useColorGradient = a["useColorGradient"];
		if (a.contains("useScaleAnimation")) def.appearance.useScaleAnimation = a["useScaleAnimation"];
	}

	// å›è»¢è¨­å®š
	if (json.contains("rotation")) {
		const auto& r = json["rotation"];
		if (r.contains("initialRotationMin")) def.rotation.initialRotationMin = JsonToVector3(r["initialRotationMin"]);
		if (r.contains("initialRotationMax")) def.rotation.initialRotationMax = JsonToVector3(r["initialRotationMax"]);
		if (r.contains("rotationSpeedMin")) def.rotation.rotationSpeedMin = JsonToVector3(r["rotationSpeedMin"]);
		if (r.contains("rotationSpeedMax")) def.rotation.rotationSpeedMax = JsonToVector3(r["rotationSpeedMax"]);
		if (r.contains("randomRotation")) def.rotation.randomRotation = r["randomRotation"];
		if (r.contains("enableRotation")) def.rotation.enableRotation = r["enableRotation"];
		if (r.contains("randomInitialRotation")) def.rotation.randomInitialRotation = r["randomInitialRotation"];
	}

	// ç™ºç”Ÿè¨­å®š
	if (json.contains("emission")) {
		const auto& e = json["emission"];
		if (e.contains("lifetimeMin")) def.emission.lifetimeMin = e["lifetimeMin"];
		if (e.contains("lifetimeMax")) def.emission.lifetimeMax = e["lifetimeMax"];
		if (e.contains("emissionRate")) def.emission.emissionRate = e["emissionRate"];
		if (e.contains("burstCount")) def.emission.burstCount = e["burstCount"];
		if (e.contains("frequency")) def.emission.frequency = e["frequency"];
		if (e.contains("isBurst")) def.emission.isBurst = e["isBurst"];
	}

	// é«˜åº¦è¨­å®š
	if (json.contains("advanced")) {
		const auto& adv = json["advanced"];
		if (adv.contains("motion")) def.advanced.motion = JsonToMotionSettings(adv["motion"]);
		if (adv.contains("emissionPattern")) def.advanced.emissionPattern = JsonToEmissionPattern(adv["emissionPattern"]);
		if (adv.contains("colorGradient")) def.advanced.colorGradient = JsonToColorGradient(adv["colorGradient"]);
		if (adv.contains("scaleAnimation")) def.advanced.scaleAnimation = JsonToScaleAnimation(adv["scaleAnimation"]);
		if (adv.contains("isTrajectoryParticle")) def.advanced.isTrajectoryParticle = adv["isTrajectoryParticle"];
		if (adv.contains("trailSpacing")) def.advanced.trailSpacing = adv["trailSpacing"];
		if (adv.contains("clearOnStop")) def.advanced.clearOnStop = adv["clearOnStop"];
	}

	return def;
}

///-------------------------------------------/// 
/// Vector3ã®JSONå¤‰æ›
///-------------------------------------------///
nlohmann::json ParticleDefinition::Vector3ToJson(const Vector3& vec) {
	return nlohmann::json::array({ vec.x, vec.y, vec.z });
}
Vector3 ParticleDefinition::JsonToVector3(const nlohmann::json& json) {
	if (json.is_array() && json.size() >= 3) {
		return Vector3{ json[0], json[1], json[2] };
	}
	return Vector3{ 0.0f, 0.0f, 0.0f };
}

///-------------------------------------------/// 
/// Vector4ã®JSONå¤‰æ›
///-------------------------------------------///
nlohmann::json ParticleDefinition::Vector4ToJson(const Vector4& vec) {
	return nlohmann::json::array({ vec.x, vec.y, vec.z, vec.w });
}
Vector4 ParticleDefinition::JsonToVector4(const nlohmann::json& json) {
	if (json.is_array() && json.size() >= 4) {
		return Vector4{ json[0], json[1], json[2], json[3] };
	}
	return Vector4{ 1.0f, 1.0f, 1.0f, 1.0f };
}

///-------------------------------------------/// 
/// MotionSettingsã®Jsonå¤‰æ›
///-------------------------------------------///
nlohmann::json ParticleDefinition::MotionSettingsToJson(const ParticleMotionSettings& motion) {
	return {
		{"enableSwirling", motion.enableSwirling},
		{"swirlingSpeed", motion.swirlingSpeed},
		{"expansionRate", motion.expansionRate},
		{"followEmitter", motion.followEmitter},
		{"followStrength", motion.followStrength},
		{"useRotationInfluence", motion.useRotationInfluence},
		{"rotationInfluence", motion.rotationInfluence},
		{"velocityDamping", motion.velocityDamping},
		{"enableBillboardRotation", motion.enableBillboardRotation},
		{"billboardRotationSpeed", motion.billboardRotationSpeed}
	};
}
ParticleMotionSettings ParticleDefinition::JsonToMotionSettings(const nlohmann::json& json) {
	ParticleMotionSettings motion;
	if (json.contains("enableSwirling")) motion.enableSwirling = json["enableSwirling"];
	if (json.contains("swirlingSpeed")) motion.swirlingSpeed = json["swirlingSpeed"];
	if (json.contains("expansionRate")) motion.expansionRate = json["expansionRate"];
	if (json.contains("followEmitter")) motion.followEmitter = json["followEmitter"];
	if (json.contains("followStrength")) motion.followStrength = json["followStrength"];
	if (json.contains("useRotationInfluence")) motion.useRotationInfluence = json["useRotationInfluence"];
	if (json.contains("rotationInfluence")) motion.rotationInfluence = json["rotationInfluence"];
	if (json.contains("velocityDamping")) motion.velocityDamping = json["velocityDamping"];
	if (json.contains("enableBillboardRotation")) motion.enableBillboardRotation = json["enableBillboardRotation"];
	if (json.contains("billboardRotationSpeed")) motion.billboardRotationSpeed = json["billboardRotationSpeed"];
	return motion;
}

///-------------------------------------------/// 
/// EmissionPatternã®Jsonå¤‰æ›
///-------------------------------------------///
nlohmann::json ParticleDefinition::EmissionPatternToJson(const ParticleEmissionPattern& pattern) {
	return {
	   {"pattern", pattern.pattern},
	   {"patternRadius", pattern.patternRadius},
	   {"patternAngle", pattern.patternAngle},
	   {"particlesPerEmit", pattern.particlesPerEmit}
	};
}
ParticleEmissionPattern ParticleDefinition::JsonToEmissionPattern(const nlohmann::json& json) {
	ParticleEmissionPattern pattern;
	if (json.contains("pattern")) pattern.pattern = json["pattern"];
	if (json.contains("patternRadius")) pattern.patternRadius = json["patternRadius"];
	if (json.contains("patternAngle")) pattern.patternAngle = json["patternAngle"];
	if (json.contains("particlesPerEmit")) pattern.particlesPerEmit = json["particlesPerEmit"];
	return pattern;
}

///-------------------------------------------/// 
/// ColorGradientã®Jsonå¤‰æ›
///-------------------------------------------///
nlohmann::json ParticleDefinition::ColorGradientToJson(const ParticleColorGradient& gradient) {
	return {
		{"useGradient", gradient.useGradient},
		{"primaryColor", Vector4ToJson(gradient.primaryColor)},
		{"secondaryColor", Vector4ToJson(gradient.secondaryColor)},
		{"colorBlendCurve", gradient.colorBlendCurve},
		{"oscillateColor", gradient.oscillateColor}
	};
}
ParticleColorGradient ParticleDefinition::JsonToColorGradient(const nlohmann::json& json) {
	ParticleColorGradient gradient;
	if (json.contains("useGradient")) gradient.useGradient = json["useGradient"];
	if (json.contains("primaryColor")) gradient.primaryColor = JsonToVector4(json["primaryColor"]);
	if (json.contains("secondaryColor")) gradient.secondaryColor = JsonToVector4(json["secondaryColor"]);
	if (json.contains("colorBlendCurve")) gradient.colorBlendCurve = json["colorBlendCurve"];
	if (json.contains("oscillateColor")) gradient.oscillateColor = json["oscillateColor"];
	return gradient;
}

///-------------------------------------------/// 
/// ScaleAnimationã®Jsonå¤‰æ›
///-------------------------------------------///
nlohmann::json ParticleDefinition::ScaleAnimationToJson(const ParticleScaleAnimation animation) {
	return {
		{"type", animation.type},
		{"startScale", animation.startScale},
		{"maxScale", animation.maxScale},
		{"endScale", animation.endScale}
	};
}
ParticleScaleAnimation ParticleDefinition::JsonToScaleAnimation(const nlohmann::json& json) {
	ParticleScaleAnimation animation;
	if (json.contains("type")) animation.type = json["type"];
	if (json.contains("startScale")) animation.startScale = json["startScale"];
	if (json.contains("maxScale")) animation.maxScale = json["maxScale"];
	if (json.contains("endScale")) animation.endScale = json["endScale"];
	return animation;
}


============================================================
File Path: Project/Engine/Graphics/Particle/ParticleDefinition.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/DataInfo/CData.h"
#include "Engine/DataInfo/ParticleData.h"
// c++
#include <string>
// JSON
#include <json.hpp>

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ãƒ‡ãƒ¼ã‚¿
///=====================================================///
struct ParticleDefinition {
public:
    /// ===åŸºæœ¬è¨­å®š=== ///
    std::string name = "NewParticle";
    std::string modelName = "plane";
    shapeType shape = shapeType::kNone;
    uint32_t maxInstance = 100;

    /// ===è¨­å®šã‚°ãƒ«ãƒ¼ãƒ—=== ///
    ParticlePhysicsSettings physics;       // ç‰©ç†è¨­å®š
    ParticleAppearanceSettings appearance; // è¦‹ãŸç›®è¨­å®š
    ParticleRotationSettings rotation;     // å›è»¢è¨­å®š
    ParticleEmissionSettings emission;     // ç™ºç”Ÿè¨­å®š
	ParticleAdvancedSettings advanced;     // é«˜åº¦è¨­å®š


    /// ===JSONå¤‰æ›=== ///
    /// <summary>
    /// ParticleDefinitionã‚’JSONå½¢å¼ã«å¤‰æ›
    /// </summary>
    /// <returns>å¤‰æ›ã•ã‚ŒãŸJSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</returns>
    nlohmann::json ToJson() const;

    /// <summary>
    /// JSONã‹ã‚‰ParticleDefinitionã‚’ç”Ÿæˆ
    /// </summary>
    /// <param name="json">èª­ã¿è¾¼ã‚€JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ</param>
    /// <returns>ç”Ÿæˆã•ã‚ŒãŸParticleDefinition</returns>
    static ParticleDefinition FromJson(const nlohmann::json& json);

private:
    /// ===JSONãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°=== ///
    // Vector3ã®JSONå¤‰æ›
    static nlohmann::json Vector3ToJson(const Vector3& vec);
    static Vector3 JsonToVector3(const nlohmann::json& json);
    // Vector4ã®JSONå¤‰æ›
    static nlohmann::json Vector4ToJson(const Vector4& vec);
    static Vector4 JsonToVector4(const nlohmann::json& json);

    // é«˜åº¦è¨­å®šç”¨ã®Jsonå¤‰æ›
	static nlohmann::json MotionSettingsToJson(const ParticleMotionSettings& motion);
    static ParticleMotionSettings JsonToMotionSettings(const nlohmann::json& json);
	static nlohmann::json EmissionPatternToJson(const ParticleEmissionPattern& pattern);
    static ParticleEmissionPattern JsonToEmissionPattern(const nlohmann::json& json);
    static nlohmann::json ColorGradientToJson(const ParticleColorGradient& gradient);
	static ParticleColorGradient JsonToColorGradient(const nlohmann::json& json);
    static nlohmann::json ScaleAnimationToJson(const ParticleScaleAnimation animation);
    static ParticleScaleAnimation JsonToScaleAnimation(const nlohmann::json& json);
};

///=====================================================/// 
/// shapeTypeã®JSONå¤‰æ›ãƒ˜ãƒ«ãƒ‘ãƒ¼
///=====================================================///
namespace nlohmann {
    template <>
    struct adl_serializer<shapeType> {
        static void to_json(json& j, const shapeType& type) {
            switch (type) {
            case shapeType::kCircle:   j = "Circle"; break;
            case shapeType::kCylinder: j = "Cylinder"; break;
            case shapeType::kNone:     j = "None"; break;
            default:                   j = "None"; break;
            }
        }

        static void from_json(const json& j, shapeType& type) {
            std::string str = j.get<std::string>();
            if (str == "Circle") type = shapeType::kCircle;
            else if (str == "Cylinder") type = shapeType::kCylinder;
            else type = shapeType::kNone;
        }
    };

    // EmissionPatternã®JSONå¤‰æ›
    template <>
    struct adl_serializer<ParticleEmissionPattern::Pattern> {
        static void to_json(json& j, const ParticleEmissionPattern::Pattern& pattern) {
            switch (pattern) {
            case ParticleEmissionPattern::Pattern::Point:  j = "Point"; break;
            case ParticleEmissionPattern::Pattern::Sphere: j = "Sphere"; break;
            case ParticleEmissionPattern::Pattern::Cone:   j = "Cone"; break;
            case ParticleEmissionPattern::Pattern::Trail:  j = "Trail"; break;
            case ParticleEmissionPattern::Pattern::Ring:   j = "Ring"; break;
            case ParticleEmissionPattern::Pattern::Burst:  j = "Burst"; break;
            default: j = "Point"; break;
            }
        }

        static void from_json(const json& j, ParticleEmissionPattern::Pattern& pattern) {
            std::string str = j.get<std::string>();
            if (str == "Point") pattern = ParticleEmissionPattern::Pattern::Point;
            else if (str == "Sphere") pattern = ParticleEmissionPattern::Pattern::Sphere;
            else if (str == "Cone") pattern = ParticleEmissionPattern::Pattern::Cone;
            else if (str == "Trail") pattern = ParticleEmissionPattern::Pattern::Trail;
            else if (str == "Ring") pattern = ParticleEmissionPattern::Pattern::Ring;
            else if (str == "Burst") pattern = ParticleEmissionPattern::Pattern::Burst;
            else pattern = ParticleEmissionPattern::Pattern::Point;
        }
    };

    // ScaleAnimationTypeã®JSONå¤‰æ›
    template <>
    struct adl_serializer<ParticleScaleAnimation::AnimationType> {
        static void to_json(json& j, const ParticleScaleAnimation::AnimationType& type) {
            switch (type) {
            case ParticleScaleAnimation::AnimationType::None:   j = "None"; break;
            case ParticleScaleAnimation::AnimationType::Linear: j = "Linear"; break;
            case ParticleScaleAnimation::AnimationType::EaseIn: j = "EaseIn"; break;
            case ParticleScaleAnimation::AnimationType::EaseOut: j = "EaseOut"; break;
            case ParticleScaleAnimation::AnimationType::Bounce: j = "Bounce"; break;
            case ParticleScaleAnimation::AnimationType::Pulse:  j = "Pulse"; break;
            default: j = "None"; break;
            }
        }

        static void from_json(const json& j, ParticleScaleAnimation::AnimationType& type) {
            std::string str = j.get<std::string>();
            if (str == "None") type = ParticleScaleAnimation::AnimationType::None;
            else if (str == "Linear") type = ParticleScaleAnimation::AnimationType::Linear;
            else if (str == "EaseIn") type = ParticleScaleAnimation::AnimationType::EaseIn;
            else if (str == "EaseOut") type = ParticleScaleAnimation::AnimationType::EaseOut;
            else if (str == "Bounce") type = ParticleScaleAnimation::AnimationType::Bounce;
            else if (str == "Pulse") type = ParticleScaleAnimation::AnimationType::Pulse;
            else type = ParticleScaleAnimation::AnimationType::None;
        }
    };
}

============================================================
File Path: Project/Engine/Graphics/Particle/ParticleFactory.cpp
============================================================
#include "ParticleFactory.h"
// Math
#include "Math/sMath.h"
// c++
#include <numbers>

///-------------------------------------------/// 
/// å˜ä¸€ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
///-------------------------------------------///
ParticleData ParticleFactory::CreateParticle(
    const ParticleDefinition& definition,
    std::mt19937& randomEngine,
    const Vector3& position) {

    ParticleData particle;

    // ã‚¹ã‚±ãƒ¼ãƒ«ã®è¨­å®š
    particle.transform.scale = GenerateRandomScale(definition, randomEngine);

    // å›è»¢ã®åˆæœŸåŒ–
    if (definition.rotation.randomInitialRotation) {
        particle.transform.rotate = GenerateRandomInitialRotation(definition, randomEngine);
    } else {
        particle.transform.rotate = definition.rotation.initialRotationMin;
    }

    // ä½ç½®ã®è¨­å®šï¼ˆçˆ†ç™ºç¯„å›²ã‚’è€ƒæ…®ï¼‰
    Vector3 offset = { 0.0f, 0.0f, 0.0f };
    if (definition.physics.explosionRange.x > 0.0f ||
        definition.physics.explosionRange.y > 0.0f ||
        definition.physics.explosionRange.z > 0.0f) {

        std::uniform_real_distribution<float> distX(-definition.physics.explosionRange.x, definition.physics.explosionRange.x);
        std::uniform_real_distribution<float> distY(-definition.physics.explosionRange.y, definition.physics.explosionRange.y);
        std::uniform_real_distribution<float> distZ(-definition.physics.explosionRange.z, definition.physics.explosionRange.z);

        offset = {
            distX(randomEngine),
            distY(randomEngine),
            distZ(randomEngine)
        };
    }
    particle.transform.translate = position + offset;

    // é€Ÿåº¦ã®è¨­å®š
    particle.velocity = GenerateRandomVelocity(definition, randomEngine, offset);

    // è‰²ã®è¨­å®š
    particle.color = definition.appearance.startColor;

    // å¯¿å‘½ã®è¨­å®š
    particle.lifeTime = GenerateRandomLifetime(definition, randomEngine);
    particle.currentTime = 0.0f;

    // å›è»¢é€Ÿåº¦ã®ä¿å­˜ï¼ˆã‚«ã‚¹ã‚¿ãƒ ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ï¼‰
    // æ³¨: ParticleDataã« rotationSpeed ãƒ¡ãƒ³ãƒãƒ¼ãŒãªã„å ´åˆã¯è¿½åŠ ãŒå¿…è¦

    return particle;
}

///-------------------------------------------/// 
/// ãƒãƒ¼ã‚¹ãƒˆç”Ÿæˆ
///-------------------------------------------///
std::list<ParticleData> ParticleFactory::CreateParticleBurst(
    const ParticleDefinition& definition,
    std::mt19937& randomEngine,
    const Vector3& position,
    uint32_t count) {

    std::list<ParticleData> particles;

    for (uint32_t i = 0; i < count; ++i) {
        particles.push_back(CreateParticle(definition, randomEngine, position));
    }

    return particles;
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
///-------------------------------------------///
void ParticleFactory::UpdateParticle(
    ParticleData& particle,
    const ParticleDefinition& definition,
    float deltaTime,
    std::mt19937& randomEngine) {

    // é‡åŠ›ã®é©ç”¨
    if (definition.physics.gravity != 0.0f) {
        particle.velocity.y += definition.physics.gravity * deltaTime;
    }

    // åŠ é€Ÿåº¦ã®é©ç”¨
    particle.velocity += definition.physics.acceleration * deltaTime;

    // ä½ç½®ã®æ›´æ–°
    particle.transform.translate += particle.velocity * deltaTime;

    // å›è»¢ã®æ›´æ–°
    if (definition.rotation.enableRotation) {
        Vector3 rotationSpeed = GenerateRandomRotationSpeed(definition, randomEngine);
        if (definition.rotation.randomRotation) {
            particle.transform.rotate += rotationSpeed * deltaTime;
        } else {
            // å›ºå®šé€Ÿåº¦ã§å›è»¢
            particle.transform.rotate += definition.rotation.rotationSpeedMin * deltaTime;
        }
    }

    // æ™‚é–“ã®æ›´æ–°
    particle.currentTime += deltaTime;

    // å¯¿å‘½ã«åŸºã¥ãè£œé–“ç‡
    float t = particle.currentTime / particle.lifeTime;

    // è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (definition.appearance.useColorGradient) {
        particle.color = LerpColor(
            definition.appearance.startColor,
            definition.appearance.endColor,
            t);
    }

    // ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
    if (definition.appearance.useScaleAnimation) {
        Vector3 startScale = (definition.appearance.startScaleMin + definition.appearance.startScaleMax) * 0.5f;
        particle.transform.scale = LerpScale(
            startScale,
            definition.appearance.endScale,
            t);
    }
}

///-------------------------------------------/// 
/// ãƒ©ãƒ³ãƒ€ãƒ é€Ÿåº¦ç”Ÿæˆ
///-------------------------------------------///
Vector3 ParticleFactory::GenerateRandomVelocity(
    const ParticleDefinition& definition,
    std::mt19937& randomEngine,
    const Vector3& position) {

    Vector3 velocity;

    if (definition.physics.useRandomVelocity) {
        // ãƒ©ãƒ³ãƒ€ãƒ ç¯„å›²å†…ã§é€Ÿåº¦ã‚’ç”Ÿæˆ
        std::uniform_real_distribution<float> distX(
            definition.physics.velocityMin.x,
            definition.physics.velocityMax.x);
        std::uniform_real_distribution<float> distY(
            definition.physics.velocityMin.y,
            definition.physics.velocityMax.y);
        std::uniform_real_distribution<float> distZ(
            definition.physics.velocityMin.z,
            definition.physics.velocityMax.z);

        velocity = {
            distX(randomEngine),
            distY(randomEngine),
            distZ(randomEngine)
        };
    } else {
        // çˆ†ç™ºæ–¹å‘ã«åŸºã¥ãé€Ÿåº¦
        float rangeSum = definition.physics.explosionRange.x +
            definition.physics.explosionRange.y +
            definition.physics.explosionRange.z;

        if (rangeSum > 0.0f) {
            // æ­£è¦åŒ–ã•ã‚ŒãŸã‚ªãƒ•ã‚»ãƒƒãƒˆä½ç½®ã‹ã‚‰æ”¾å°„çŠ¶ã®é€Ÿåº¦ã‚’è¨ˆç®—
            Vector3 normalizedOffset = Normalize(position);

            // é€Ÿåº¦ã®æœ€å¤§å€¤ã®å¹³å‡ã‚’ä½¿ç”¨
            float averageMaxVelocity = (definition.physics.velocityMax.x +
                definition.physics.velocityMax.y +
                definition.physics.velocityMax.z) / 3.0f;

            velocity = normalizedOffset * averageMaxVelocity;
        } else {
            velocity = definition.physics.velocityMin;
        }
    }

    // ä¸Šæ–¹å‘ã®åŠ›ã‚’è¿½åŠ 
    velocity.y += definition.physics.upwardForce;

    return velocity;
}

///-------------------------------------------/// 
/// ãƒ©ãƒ³ãƒ€ãƒ åˆæœŸå›è»¢ç”Ÿæˆ
///-------------------------------------------///
Vector3 ParticleFactory::GenerateRandomInitialRotation(
    const ParticleDefinition& definition, 
    std::mt19937& randomEngine) {

    std::uniform_real_distribution<float> distX(
        definition.rotation.initialRotationMin.x,
        definition.rotation.initialRotationMax.x);
    std::uniform_real_distribution<float> distY(
        definition.rotation.initialRotationMin.y,
        definition.rotation.initialRotationMax.y);
    std::uniform_real_distribution<float> distZ(
        definition.rotation.initialRotationMin.z,
        definition.rotation.initialRotationMax.z);

    return {
        distX(randomEngine),
        distY(randomEngine),
        distZ(randomEngine)
    };
}

///-------------------------------------------/// 
/// ãƒ©ãƒ³ãƒ€ãƒ ã‚¹ã‚±ãƒ¼ãƒ«ç”Ÿæˆ
///-------------------------------------------///
Vector3 ParticleFactory::GenerateRandomScale(
    const ParticleDefinition& definition,
    std::mt19937& randomEngine) {

    std::uniform_real_distribution<float> distX(
        definition.appearance.startScaleMin.x,
        definition.appearance.startScaleMax.x);
    std::uniform_real_distribution<float> distY(
        definition.appearance.startScaleMin.y,
        definition.appearance.startScaleMax.y);
    std::uniform_real_distribution<float> distZ(
        definition.appearance.startScaleMin.z,
        definition.appearance.startScaleMax.z);

    return {
        distX(randomEngine),
        distY(randomEngine),
        distZ(randomEngine)
    };
}

///-------------------------------------------/// 
/// ãƒ©ãƒ³ãƒ€ãƒ å›è»¢é€Ÿåº¦ç”Ÿæˆ
///-------------------------------------------///
Vector3 ParticleFactory::GenerateRandomRotationSpeed(
    const ParticleDefinition& definition,
    std::mt19937& randomEngine) {

    std::uniform_real_distribution<float> distX(
        definition.rotation.rotationSpeedMin.x,
        definition.rotation.rotationSpeedMax.x);
    std::uniform_real_distribution<float> distY(
        definition.rotation.rotationSpeedMin.y,
        definition.rotation.rotationSpeedMax.y);
    std::uniform_real_distribution<float> distZ(
        definition.rotation.rotationSpeedMin.z,
        definition.rotation.rotationSpeedMax.z);

    return {
        distX(randomEngine),
        distY(randomEngine),
        distZ(randomEngine)
    };
}

///-------------------------------------------/// 
/// ãƒ©ãƒ³ãƒ€ãƒ å¯¿å‘½ç”Ÿæˆ
///-------------------------------------------///
float ParticleFactory::GenerateRandomLifetime(
    const ParticleDefinition& definition,
    std::mt19937& randomEngine) {

    std::uniform_real_distribution<float> dist(
        definition.emission.lifetimeMin,
        definition.emission.lifetimeMax);

    return dist(randomEngine);
}

///-------------------------------------------/// 
/// è‰²ã®è£œé–“
///-------------------------------------------///
Vector4 ParticleFactory::LerpColor(const Vector4& start, const Vector4& end, float t) {
    t = std::clamp(t, 0.0f, 1.0f);
    return {
        start.x + (end.x - start.x) * t,
        start.y + (end.y - start.y) * t,
        start.z + (end.z - start.z) * t,
        start.w + (end.w - start.w) * t
    };
}

///-------------------------------------------/// 
/// ã‚¹ã‚±ãƒ¼ãƒ«ã®è£œé–“
///-------------------------------------------///
Vector3 ParticleFactory::LerpScale(const Vector3& start, const Vector3& end, float t) {
    t = std::clamp(t, 0.0f, 1.0f);
    return {
        start.x + (end.x - start.x) * t,
        start.y + (end.y - start.y) * t,
        start.z + (end.z - start.z) * t
    };
}

============================================================
File Path: Project/Engine/Graphics/Particle/ParticleFactory.h
============================================================
#pragma once
/// ===Include=== ///
#include "ParticleDefinition.h"
#include "Engine/DataInfo/ParticleData.h"
// c++
#include <random>
#include <list>

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
/// ParticleDefinitionã‹ã‚‰å‹•çš„ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ
///=====================================================///
class ParticleFactory {
public:

    /// <summary>
    /// å˜ä¸€ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
    /// </summary>
    /// <param name="definition">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å®šç¾©ãƒ‡ãƒ¼ã‚¿</param>
    /// <param name="randomEngine">ä¹±æ•°ç”Ÿæˆå™¨</param>
    /// <param name="position">ç™ºç”Ÿä½ç½®</param>
    /// <returns>ç”Ÿæˆã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‡ãƒ¼ã‚¿</returns>
    static ParticleData CreateParticle(
        const ParticleDefinition& definition,
        std::mt19937& randomEngine,
        const Vector3& position);

    /// <summary>
    /// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒãƒƒãƒç”Ÿæˆï¼ˆãƒãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
    /// </summary>
    /// <param name="definition">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å®šç¾©ãƒ‡ãƒ¼ã‚¿</param>
    /// <param name="randomEngine">ä¹±æ•°ç”Ÿæˆå™¨</param>
    /// <param name="position">ç™ºç”Ÿä½ç½®</param>
    /// <param name="count">ç”Ÿæˆæ•°</param>
    /// <returns>ç”Ÿæˆã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ</returns>
    static std::list<ParticleData> CreateParticleBurst(
        const ParticleDefinition& definition,
        std::mt19937& randomEngine,
        const Vector3& position,
        uint32_t count);

    /// <summary>
    /// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°å‡¦ç†ï¼ˆæ±ç”¨ãƒ­ã‚¸ãƒƒã‚¯ï¼‰
    /// </summary>
    /// <param name="particle">æ›´æ–°ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‡ãƒ¼ã‚¿</param>
    /// <param name="definition">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å®šç¾©ãƒ‡ãƒ¼ã‚¿</param>
    /// <param name="deltaTime">ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ </param>
    /// <param name="randomEngine">ä¹±æ•°ç”Ÿæˆå™¨ï¼ˆå›è»¢ç”¨ï¼‰</param>
    static void UpdateParticle(
        ParticleData& particle,
        const ParticleDefinition& definition,
        float deltaTime,
        std::mt19937& randomEngine);

private:

    /// <summary>
    /// ãƒ©ãƒ³ãƒ€ãƒ ãªé€Ÿåº¦ã‚’ç”Ÿæˆ
    /// </summary>
    static Vector3 GenerateRandomVelocity(
        const ParticleDefinition& definition,
        std::mt19937& randomEngine,
        const Vector3& position);
    
    /// <summary>
    /// ãƒ©ãƒ³ãƒ€ãƒ ãªåˆæœŸå›è»¢ã‚’ç”Ÿæˆ
    /// </summary>
    static Vector3 GenerateRandomInitialRotation(
        const ParticleDefinition& definition,
        std::mt19937& randomEngine);

    /// <summary>
    /// ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¹ã‚±ãƒ¼ãƒ«ã‚’ç”Ÿæˆ
    /// </summary>
    static Vector3 GenerateRandomScale(
        const ParticleDefinition& definition,
        std::mt19937& randomEngine);

    /// <summary>
    /// ãƒ©ãƒ³ãƒ€ãƒ ãªå›è»¢é€Ÿåº¦ã‚’ç”Ÿæˆ
    /// </summary>
    static Vector3 GenerateRandomRotationSpeed(
        const ParticleDefinition& definition,
        std::mt19937& randomEngine);

    /// <summary>
    /// ãƒ©ãƒ³ãƒ€ãƒ ãªå¯¿å‘½ã‚’ç”Ÿæˆ
    /// </summary>
    static float GenerateRandomLifetime(
        const ParticleDefinition& definition,
        std::mt19937& randomEngine);

    /// <summary>
    /// æ™‚é–“çµŒéã«ã‚ˆã‚‹è‰²ã®è£œé–“
    /// </summary>
    static Vector4 LerpColor(
        const Vector4& start,
        const Vector4& end,
        float t);

    /// <summary>
    /// æ™‚é–“çµŒéã«ã‚ˆã‚‹ã‚¹ã‚±ãƒ¼ãƒ«ã®è£œé–“
    /// </summary>
    static Vector3 LerpScale(
        const Vector3& start,
        const Vector3& end,
        float t);
};

============================================================
File Path: Project/Engine/Graphics/Particle/ParticleGroup.cpp
============================================================
#include "ParticleGroup.h"
#include "ParticleFactory.h"
// Camera
#include "application/Game/Camera/GameCamera.h"
// Service
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/CameraService.h"
#include "Engine/System/Service/DeltaTimeSevice.h"
// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"
// c++
#include <numbers>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ParticleGroup::~ParticleGroup() {
    group_.particles.clear();
    group_.particle.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–ï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é§†å‹•å‹ï¼‰
///-------------------------------------------///
void ParticleGroup::Initialze(const Vector3& translate, const ParticleDefinition& definition) {
    /// ===å®šç¾©ã‚’ä¿å­˜=== ///
    definition_ = definition;

    /// ===ä¹±æ•°ç”Ÿæˆå™¨ã®åˆæœŸåŒ–=== ///
    std::random_device seedGenerator;
    randomEngine_.seed(seedGenerator());

    /// ===æœ€å¤§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã®è¨­å®š=== ///
    group_.maxInstance = definition_.maxInstance;
    group_.numInstance = 0;

    /// ===ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®åˆæœŸåŒ–=== ///
    group_.transform = { {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, translate };
    group_.cameraTransform = {
       {1.0f, 1.0f, 1.0f},
       {std::numbers::pi_v<float> / 3.0f, std::numbers::pi_v<float>, 0.0f},
       {0.0f, 23.0f, 10.0f}
    };

    /// è»Œè·¡ç”¨ã®åˆæœŸåŒ–
    group_.previouseEmitterPosition = translate;
    group_.previouseEmitterRotation = { 0.0f, 0.0f, 0.0f };
    group_.trajectoryTimer = 0.0f;

    /// ===ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®åˆæœŸåŒ–=== ///
    InstancingInit(definition_.modelName, translate, group_.maxInstance, definition_.shape);

    /// ===Cameraã®è¨­å®š=== ///
    group_.camera = CameraService::GetActiveCamera().get();

    /// ===ç™ºç”Ÿã‚¿ã‚¤ãƒãƒ¼ã®åˆæœŸåŒ–=== ///
    group_.frequencyTimer = 0.0f;
    group_.hasEmitted = false;

    // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã®å–å¾—
    kDeltaTime_ = DeltaTimeSevice::GetDeltaTime();

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
    if (!definition_.appearance.texturePath.empty()) {
        SetTexture(definition_.appearance.texturePath);
    }

    // 
    Update();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void ParticleGroup::Update() {
    // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã®å–å¾—
    kDeltaTime_ = DeltaTimeSevice::GetDeltaTime();

    // åœæ­¢ä¸­ã®å ´åˆã¯æ–°è¦ç™ºç”Ÿã‚’æ­¢ã‚ã¦ã€æ—¢å­˜ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½ã‚’çŸ­ç¸®
    if (isStopped_) {
        // æ—¢å­˜ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½ã‚’å¼·åˆ¶çµ‚äº†
        for (auto& particle : group_.particles) {
            particle.currentTime = particle.lifeTime;  // å³åº§ã«å¯¿å‘½ã‚’çµ‚äº†ã•ã›ã‚‹
        }
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°ã®ã¿å®Ÿè¡Œï¼ˆç™ºç”Ÿå‡¦ç†ã¯ã‚¹ã‚­ãƒƒãƒ—ï¼‰
        UpdateParticles();
        return;
    }

    // é€šå¸¸æ™‚ã®å‡¦ç†
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿå‡¦ç†
    Emit();

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°å‡¦ç†
    UpdateParticles();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ParticleGroup::Draw(BlendMode mode) {
    if (group_.numInstance > 0) {
        group_.particle->Draw(group_.numInstance, mode);
    }
}

///-------------------------------------------/// 
/// åœæ­¢å‡¦ç†
///-------------------------------------------///
void ParticleGroup::Stop() { isStopped_ = true; }

///-------------------------------------------/// 
/// çµ‚äº†åˆ¤å®š
///-------------------------------------------///
bool ParticleGroup::IsFinish() const {
    // åœæ­¢ã•ã‚Œã¦ã„ã‚‹å ´åˆã€å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒæ¶ˆãˆãŸã‚‰çµ‚äº†
    if (isStopped_) {
        return group_.particles.empty();
    }

    // ãƒãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãŒæ¶ˆãˆãŸã‚‰true
    if (definition_.emission.isBurst) {
        return group_.particles.empty() && group_.hasEmitted;
    }

    // é€£ç¶šç™ºç”Ÿãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã¯å¸¸ã«falseï¼ˆæ‰‹å‹•ã§åœæ­¢ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰
    return false;
}

///-------------------------------------------/// 
/// åœæ­¢åˆ¤å®š
///-------------------------------------------///
bool ParticleGroup::IsStopped() const { return isStopped_; }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®š
void ParticleGroup::SetTexture(const std::string& fileName) {
    if (group_.particle) {
        group_.particle->SetTexture(fileName);
    }
}
// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©è¨­å®š
void ParticleGroup::SetDefinition(const ParticleDefinition& definition) {
    definition_ = definition;

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚‚æ›´æ–°
    if (!definition_.appearance.texturePath.empty()) {
        SetTexture(definition_.appearance.texturePath);
    }
}
// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼å¤‰æ›´
void ParticleGroup::SetParameter(ParticleParameter param, float value) {
    // å®Ÿè¡Œæ™‚ã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å¤‰æ›´
    switch (param) {
        // ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::Gravity:
        definition_.physics.gravity = value;
        break;
    case ParticleParameter::ExplosionRadiusX:
        definition_.physics.explosionRange.x = value;
        break;
    case ParticleParameter::ExplosionRadiusY:
        definition_.physics.explosionRange.y = value;
        break;
    case ParticleParameter::ExplosionRadiusZ:
        definition_.physics.explosionRange.z = value;
        break;
    case ParticleParameter::UpwardForce:
        definition_.physics.upwardForce = value;
        break;
    case ParticleParameter::AccelerationX:
        definition_.physics.acceleration.x = value;
        break;
    case ParticleParameter::AccelerationY:
        definition_.physics.acceleration.y = value;
        break;
    case ParticleParameter::AccelerationZ:
        definition_.physics.acceleration.z = value;
        break;

        // ç™ºç”Ÿãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::EmissionRate:
        definition_.emission.emissionRate = value;
        break;
    case ParticleParameter::Frequency:
        definition_.emission.frequency = value;
        break;
    case ParticleParameter::LifetimeMin:
        definition_.emission.lifetimeMin = value;
        break;
    case ParticleParameter::LifetimeMax:
        definition_.emission.lifetimeMax = value;
        break;
    case ParticleParameter::BurstCount:
        definition_.emission.burstCount = static_cast<uint32_t>(value);
        break;

        // è¦‹ãŸç›®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::StartColorR:
        definition_.appearance.startColor.x = value;
        break;
    case ParticleParameter::StartColorG:
        definition_.appearance.startColor.y = value;
        break;
    case ParticleParameter::StartColorB:
        definition_.appearance.startColor.z = value;
        break;
    case ParticleParameter::StartColorA:
        definition_.appearance.startColor.w = value;
        break;
    case ParticleParameter::EndColorR:
        definition_.appearance.endColor.x = value;
        break;
    case ParticleParameter::EndColorG:
        definition_.appearance.endColor.y = value;
        break;
    case ParticleParameter::EndColorB:
        definition_.appearance.endColor.z = value;
        break;
    case ParticleParameter::EndColorA:
        definition_.appearance.endColor.w = value;
        break;

        // å›è»¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::RotationSpeedX:
        definition_.rotation.rotationSpeedMin.x = value;
        break;
    case ParticleParameter::RotationSpeedY:
        definition_.rotation.rotationSpeedMin.y = value;
        break;
    case ParticleParameter::RotationSpeedZ:
        definition_.rotation.rotationSpeedMin.z = value;
        break;

        // é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::VelocityMinX:
        definition_.physics.velocityMin.x = value;
        break;
    case ParticleParameter::VelocityMinY:
        definition_.physics.velocityMin.y = value;
        break;
    case ParticleParameter::VelocityMinZ:
        definition_.physics.velocityMin.z = value;
        break;
    case ParticleParameter::VelocityMaxX:
        definition_.physics.velocityMax.x = value;
        break;
    case ParticleParameter::VelocityMaxY:
        definition_.physics.velocityMax.y = value;
        break;
    case ParticleParameter::VelocityMaxZ:
        definition_.physics.velocityMax.z = value;
        break;
    }
}
// ã‚¨ãƒŸãƒƒã‚¿ä½ç½®è¨­å®š
void ParticleGroup::SetEmitterPosition(const Vector3& position) { 
    group_.previouseEmitterPosition = group_.transform.translate;
    group_.transform.translate = position; 
}
// 
void ParticleGroup::MoveEmitterPosition(const Vector3& offset) { group_.transform.translate += offset; }
// ã‚¨ãƒŸãƒƒã‚¿å›è»¢è¨­å®š
void ParticleGroup::SetEmitterRotate(const Vector3& rotate) { 
    group_.previouseEmitterRotation = group_.transform.rotate;
    group_.transform.rotate = rotate;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
const ParticleDefinition& ParticleGroup::GetDefinition() const {return definition_;}
uint32_t ParticleGroup::GetActiveParticleCount() const {return static_cast<uint32_t>(group_.particles.size());}
const Vector3& ParticleGroup::GetEmitterPosition() const {return group_.transform.translate;}

///-------------------------------------------/// 
/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°åˆæœŸåŒ–
///-------------------------------------------///
void ParticleGroup::InstancingInit(const std::string& modelName, const Vector3& translate, const uint32_t maxInstance, shapeType type) {
    /// ===ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®åˆæœŸåŒ–=== ///
    group_.particle = std::make_unique<ParticleSetUp>();
    group_.particle->Initialize(modelName, maxInstance, type);
    translate;
}

///-------------------------------------------/// 
/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°æ›´æ–°
///-------------------------------------------///
void ParticleGroup::InstancingUpdate(std::list<ParticleData>::iterator it) {
    // ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã¨WVPè¡Œåˆ—ã®è¨ˆç®—
    Matrix4x4 worldMatrix = Math::MakeAffineEulerMatrix(
        it->transform.scale,
        it->transform.rotate,
        it->transform.translate);
    Matrix4x4 wvpMatrix;

    // ã‚«ãƒ¡ãƒ©ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯WVPè¡Œåˆ—ã‚’è¨ˆç®—
    if (group_.camera) {
        const Matrix4x4& viewProjectionMatrix = group_.camera->GetViewProjectionMatrix();
        wvpMatrix = Multiply(worldMatrix, viewProjectionMatrix);
    } else {
        Matrix4x4 viewMatrix = Math::Inverse4x4(
            Math::MakeAffineEulerMatrix(
                group_.cameraTransform.scale,
                group_.cameraTransform.rotate,
                group_.cameraTransform.translate));
        Matrix4x4 projectionMatrix = Math::MakePerspectiveFovMatrix(
            0.45f,
            static_cast<float>(GraphicsResourceGetter::GetWindowWidth()) /
            static_cast<float>(GraphicsResourceGetter::GetWindowHeight()),
            0.1f, 100.0f);
        wvpMatrix = Multiply(worldMatrix, Multiply(viewMatrix, projectionMatrix));
    }

    // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®š
    group_.particle->SetInstancingData(group_.numInstance, it->color, wvpMatrix, worldMatrix);
    ++group_.numInstance;
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é§†å‹•å‹ï¼‰
///-------------------------------------------///
ParticleData ParticleGroup::MakeParticle(const Vector3& translate) {
    // åŸºæœ¬ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆ
    ParticleData particle = ParticleFactory::CreateParticle(definition_, randomEngine_, translate);

    // è»Œè·¡ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆã€ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢ã‚’è€ƒæ…®
    if (definition_.advanced.isTrajectoryParticle) {
        // ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›
        Quaternion emitterQuat = Math::QuaternionFromVector(group_.transform.rotate);

        // ç™ºç”Ÿä½ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢ç©ºé–“ã§é©ç”¨
        Vector3 localOffset = particle.transform.translate - translate;
        Vector3 worldOffset = Math::RotateVector(localOffset, emitterQuat);
        particle.transform.translate = translate + worldOffset;

        // åˆé€Ÿåº¦ã‚‚ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢ã‚’é©ç”¨
        particle.velocity = Math::RotateVector(particle.velocity, emitterQuat);

        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è‡ªä½“ã®åˆæœŸå›è»¢ã‚‚ã‚¨ãƒŸãƒƒã‚¿ã«åˆã‚ã›ã‚‹
        if (definition_.rotation.enableRotation) {
            Quaternion particleRot = Math::QuaternionFromVector(particle.transform.rotate);
            Quaternion finalRot = Multiply(emitterQuat, particleRot);
            particle.transform.rotate = Math::QuaternionToEuler(finalRot);
        }
    }

    return particle;
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿå‡¦ç†
///-------------------------------------------///
void ParticleGroup::Emit() {
    // è»Œè·¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ¢ãƒ¼ãƒ‰
    if (definition_.advanced.isTrajectoryParticle) {
        group_.trajectoryTimer += kDeltaTime_;

        if (group_.trajectoryTimer >= definition_.advanced.trailSpacing) {
            // ã‚¨ãƒŸãƒƒã‚¿ãŒç§»å‹•ã—ã¦ã„ã‚‹å ´åˆã®ã¿ç™ºç”Ÿ
            Vector3 movementDelta = group_.transform.translate - group_.previouseEmitterPosition;
            float distanceMoved = std::sqrt(
                movementDelta.x * movementDelta.x +
                movementDelta.y * movementDelta.y +
                movementDelta.z * movementDelta.z
            );

            if (distanceMoved > 0.01f) {
                // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆæ•°
                uint32_t particlesPerEmit = definition_.advanced.emissionPattern.particlesPerEmit;

                for (uint32_t i = 0; i < particlesPerEmit; ++i) {
                    if (group_.particles.size() < group_.maxInstance) {
                        group_.particles.push_back(MakeParticle(group_.transform.translate));
                    }
                }
            }

            group_.trajectoryTimer = 0.0f;
        }
        return;
    }

    // ãƒãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰
    if (definition_.emission.isBurst) {
        if (!group_.hasEmitted) {
            std::list<ParticleData> burstParticles = ParticleFactory::CreateParticleBurst(
                definition_,
                randomEngine_,
                group_.transform.translate,
                definition_.emission.burstCount);

            group_.particles.splice(group_.particles.end(), burstParticles);
            group_.hasEmitted = true;
        }
        return;
    }

    // é€£ç¶šç™ºç”Ÿãƒ¢ãƒ¼ãƒ‰
    group_.frequencyTimer += kDeltaTime_;

    if (group_.frequencyTimer >= definition_.emission.frequency) {
        uint32_t emitCount = static_cast<uint32_t>(
            definition_.emission.emissionRate * definition_.emission.frequency);

        for (uint32_t i = 0; i < emitCount; ++i) {
            if (group_.particles.size() < group_.maxInstance) {
                group_.particles.push_back(MakeParticle(group_.transform.translate));
            }
        }

        group_.frequencyTimer = 0.0f;
    }
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°å‡¦ç†
///-------------------------------------------///
void ParticleGroup::UpdateParticles() {
    group_.numInstance = 0;

    // ã‚¨ãƒŸãƒƒã‚¿ã®ç§»å‹•é‡è¨ˆç®—
    Vector3 emitterDelta = group_.transform.translate - group_.previouseEmitterPosition;

    for (auto it = group_.particles.begin(); it != group_.particles.end();) {
        // å¯¿å‘½ãƒã‚§ãƒƒã‚¯
        if (it->currentTime >= it->lifeTime) {
            it = group_.particles.erase(it);
            continue;
        }

        // åŸºæœ¬æ›´æ–°ï¼ˆParticleFactoryä½¿ç”¨ï¼‰
        ParticleFactory::UpdateParticle(*it, definition_, kDeltaTime_, randomEngine_);

        // é€²è¡Œåº¦ã®è¨ˆç®—
        float progress = it->currentTime / it->lifeTime;

        // ã‚¨ãƒŸãƒƒã‚¿è¿½å¾“
        if (definition_.advanced.motion.followEmitter) {
            Vector3 followOffset = emitterDelta * definition_.advanced.motion.followStrength;
            it->transform.translate += followOffset;
        }

        // é€Ÿåº¦æ¸›è¡°
        if (definition_.advanced.motion.velocityDamping < 1.0f) {
            it->velocity = it->velocity * definition_.advanced.motion.velocityDamping;
        }

        // æ¸¦å·»ãé‹å‹•
        if (definition_.advanced.motion.enableSwirling) {
            ApplySwirlMotion(*it, progress);
        }

        // å›è»¢å½±éŸ¿
        if (definition_.advanced.motion.useRotationInfluence) {
            ApplyRotationInfluence(*it, progress);
        }

        // ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰å›è»¢
        if (definition_.advanced.motion.enableBillboardRotation) {
            float rotationSpeed = definition_.advanced.motion.billboardRotationSpeed;
			it->transform.rotate.z += rotationSpeed * kDeltaTime_;
        }

        // ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°æ›´æ–°
        InstancingUpdate(it);
        ++it;
    }

    // å‰å›ã®çŠ¶æ…‹ã‚’ä¿å­˜
    group_.previouseEmitterPosition = group_.transform.translate;
    group_.previouseEmitterRotation = group_.transform.rotate;
}

///-------------------------------------------/// 
/// æ¸¦å·»ãé‹å‹•ã®é©ç”¨
///-------------------------------------------///
void ParticleGroup::ApplySwirlMotion(ParticleData& particle, float progress) {
    float swirl = particle.currentTime * definition_.advanced.motion.swirlingSpeed;

    // ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢ã‚’è€ƒæ…®ã—ãŸãƒ­ãƒ¼ã‚«ãƒ«ç©ºé–“ã§ã®æ¸¦å·»ã
    Vector3 localSwirlingOffset = {
        std::cos(swirl) * definition_.advanced.motion.expansionRate * progress,
        std::sin(swirl * 1.3f) * definition_.advanced.motion.expansionRate * progress * 0.5f,
        std::sin(swirl) * definition_.advanced.motion.expansionRate * progress
    };

    // ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›
    Quaternion emitterRotation = Math::QuaternionFromVector(group_.transform.rotate);

    // ãƒ¯ãƒ¼ãƒ«ãƒ‰ç©ºé–“ã«å¤‰æ›ã—ã¦é©ç”¨
    Vector3 worldSwirlingOffset = Math::RotateVector(localSwirlingOffset, emitterRotation);
    particle.transform.translate += worldSwirlingOffset * kDeltaTime_;
}

///-------------------------------------------/// 
/// å›è»¢å½±éŸ¿ã®é©ç”¨
///-------------------------------------------///
void ParticleGroup::ApplyRotationInfluence(ParticleData& particle, float progress) {
    progress;
    // ç¾åœ¨ã¨å‰å›ã®ã‚¨ãƒŸãƒƒã‚¿å›è»¢ã‚’æ¯”è¼ƒ
    Quaternion currentRot = Math::QuaternionFromVector(group_.transform.rotate);
    Quaternion previousRot = Math::QuaternionFromVector(group_.previouseEmitterRotation);
    Quaternion rotationDelta = Multiply(currentRot, Math::Conjugate(previousRot));

    // å›è»¢ã«ã‚ˆã‚‹é å¿ƒåŠ›çš„ãªé€Ÿåº¦ã‚’è¿½åŠ 
    Vector3 rotationalVelocity = Math::RotateVector(
        particle.velocity * definition_.advanced.motion.rotationInfluence,
        rotationDelta
    );

    particle.transform.translate += rotationalVelocity * kDeltaTime_ * 0.3f;
}


============================================================
File Path: Project/Engine/Graphics/Particle/ParticleGroup.h
============================================================
#pragma once
/// ===Include=== ///
#include "ParticleSetUp.h"
#include "ParticleDefinition.h"
#include "ParticleParameter.h"
#include "Engine/DataInfo/ParticleData.h"
// c++
#include <list>
#include <random>
#include <memory>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚°ãƒ«ãƒ¼ãƒ—
///=====================================================///
class ParticleGroup {
public:

	ParticleGroup() = default;
	~ParticleGroup();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="translate">ç™ºç”Ÿä½ç½®</param>
	/// <param name="definition">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©</param>
	void Initialze(const Vector3& translate, const ParticleDefinition& definition);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»æ™‚ã®åˆæˆï¼ˆãƒ–ãƒ¬ãƒ³ãƒ‰ï¼‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Draw(BlendMode mode);

	/// <summary>
	/// åœæ­¢å‡¦ç†
	/// </summary>
	void Stop();

	/// <summary>
	/// ç”Ÿå­˜ã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®šã™ã‚‹é–¢æ•°
	/// </summary>
	/// <returns>å‡¦ç†ãŒå®Œäº†ã—ã¦ã„ã‚‹å ´åˆã¯ trueã€ãã†ã§ãªã„å ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool IsFinish() const;

	/// <summary>
	/// åœæ­¢ä¸­ã‹ã©ã†ã‹
	/// </summary>
	/// <returns></returns>
	bool IsStopped() const;

public: /// ===Setter=== ///

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®š
	/// </summary>
	void SetTexture(const std::string& fileName);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã‚’è¨­å®šï¼ˆå®Ÿè¡Œæ™‚å¤‰æ›´ç”¨ï¼‰
	/// </summary>
	void SetDefinition(const ParticleDefinition& definition);

	/// <summary>
	/// å®Ÿè¡Œæ™‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´ï¼ˆå‹å®‰å…¨ç‰ˆï¼‰
	/// </summary>
	/// <param name="param">å¤‰æ›´ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</param>
	/// <param name="value">è¨­å®šã™ã‚‹å€¤</param>
	void SetParameter(ParticleParameter param, float value);

	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ã®ä½ç½®ã‚’è¨­å®š
	/// </summary>
	/// <param name="position">æ–°ã—ã„ä½ç½®</param>
	void SetEmitterPosition(const Vector3& position);

	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ã®ä½ç½®ã‚’ç§»å‹•(ç›¸å¯¾ç§»å‹•)
	/// </summary>
	/// <param name="offset">ç§»å‹•é‡</param>
	void MoveEmitterPosition(const Vector3& offset);

	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ã®å›è»¢ã‚’è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="rotate">è¨­å®šã™ã‚‹å›è»¢ãƒ™ã‚¯ãƒˆãƒ«ã€‚const Vector3& ã§å‚ç…§æ¸¡ã—ã•ã‚Œã¾ã™ã€‚</param>
	void SetEmitterRotate(const Vector3& rotate);

public: /// ===Getter=== ///

	/// <summary>
	/// ç¾åœ¨ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã‚’å–å¾—
	/// </summary>
	const ParticleDefinition& GetDefinition() const;

	/// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’å–å¾—
	/// </summary>
	uint32_t GetActiveParticleCount() const;

	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ã®ç¾åœ¨ä½ç½®ã‚’å–å¾—
	/// </summary>
	const Vector3& GetEmitterPosition() const;

private:

	/// ===å†…éƒ¨æ§‹é€ ä½“=== ///
	struct Group {
		std::unique_ptr<ParticleSetUp> particle;     // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æç”»ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
		std::list<ParticleData> particles;           // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ
		EulerTransform transform;                    // ã‚¨ãƒŸãƒƒã‚¿ã®Transform
		EulerTransform cameraTransform;              // ã‚«ãƒ¡ãƒ©ã®Transformï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
		uint32_t maxInstance;                        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æœ€å¤§æ•°
		uint32_t numInstance;                        // ç¾åœ¨ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°
		float frequencyTimer;                        // ç™ºç”Ÿé »åº¦ã‚¿ã‚¤ãƒãƒ¼
		GameCamera* camera = nullptr;
		bool hasEmitted;                             // åˆå›ç™ºç”Ÿæ¸ˆã¿ãƒ•ãƒ©ã‚°ï¼ˆãƒãƒ¼ã‚¹ãƒˆç”¨ï¼‰

		// è»Œè·¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”¨
		float trajectoryTimer = 0.0f;                // è»Œè·¡ã‚¿ã‚¤ãƒãƒ¼
		Vector3 previouseEmitterPosition = { 0.0f, 0.0f, 0.0f }; // å‰å›ã®ã‚¨ãƒŸãƒƒã‚¿ä½ç½®
		Vector3 previouseEmitterRotation = { 0.0f, 0.0f, 0.0f }; // å‰å›ã®ã‚¨ãƒŸãƒƒã‚¿å›è»¢
	};

	Group group_{};
	ParticleDefinition definition_;     // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©
	float kDeltaTime_ = 1.0f / 60.0f;   // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	std::mt19937 randomEngine_;         // ä¹±æ•°ç”Ÿæˆå™¨

	bool isStopped_ = false;		// åœæ­¢ãƒ•ãƒ©ã‚°

private:

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ã«å¯¾ã™ã‚‹åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void InstancingInit(const std::string& modelName, const Vector3& translate, const uint32_t maxInstance, shapeType type);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ã«å¯¾ã™ã‚‹æ›´æ–°å‡¦ç†
	/// </summary>
	void InstancingUpdate(std::list<ParticleData>::iterator it);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆï¼ˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é§†å‹•å‹ï¼‰
	/// </summary>
	ParticleData MakeParticle(const Vector3& translate);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿå‡¦ç†
	/// </summary>
	void Emit();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateParticles();

	/// <summary>
    /// æ¸¦å·»ãé‹å‹•ã‚’é©ç”¨
    /// </summary>
    void ApplySwirlMotion(ParticleData& particle, float progress);

    /// <summary>
    /// ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢å½±éŸ¿ã‚’é©ç”¨
    /// </summary>
    void ApplyRotationInfluence(ParticleData& particle, float progress);
};

============================================================
File Path: Project/Engine/Graphics/Particle/ParticleParameter.cpp
============================================================
#include "ParticleParameter.h"
#include <unordered_map>

///-------------------------------------------/// 
/// enum classã‚’æ–‡å­—åˆ—ã«å¤‰æ›
///-------------------------------------------///
std::string ParticleParameterUtils::ToString(ParticleParameter param) {
    switch (param) {
        // ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::Gravity:           return "gravity";
    case ParticleParameter::ExplosionRadiusX:  return "explosionRadiusX";
    case ParticleParameter::ExplosionRadiusY:  return "explosionRadiusY";
    case ParticleParameter::ExplosionRadiusZ:  return "explosionRadiusZ";
    case ParticleParameter::UpwardForce:       return "upwardForce";
    case ParticleParameter::AccelerationX:     return "accelerationX";
    case ParticleParameter::AccelerationY:     return "accelerationY";
    case ParticleParameter::AccelerationZ:     return "accelerationZ";

        // ç™ºç”Ÿãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::EmissionRate:      return "emissionRate";
    case ParticleParameter::Frequency:         return "frequency";
    case ParticleParameter::LifetimeMin:       return "lifetimeMin";
    case ParticleParameter::LifetimeMax:       return "lifetimeMax";
    case ParticleParameter::BurstCount:        return "burstCount";

        // è¦‹ãŸç›®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::StartColorR:       return "startColorR";
    case ParticleParameter::StartColorG:       return "startColorG";
    case ParticleParameter::StartColorB:       return "startColorB";
    case ParticleParameter::StartColorA:       return "startColorA";
    case ParticleParameter::EndColorR:         return "endColorR";
    case ParticleParameter::EndColorG:         return "endColorG";
    case ParticleParameter::EndColorB:         return "endColorB";
    case ParticleParameter::EndColorA:         return "endColorA";

        // å›è»¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::RotationSpeedX:    return "rotationSpeedX";
    case ParticleParameter::RotationSpeedY:    return "rotationSpeedY";
    case ParticleParameter::RotationSpeedZ:    return "rotationSpeedZ";

        // é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::VelocityMinX:      return "velocityMinX";
    case ParticleParameter::VelocityMinY:      return "velocityMinY";
    case ParticleParameter::VelocityMinZ:      return "velocityMinZ";
    case ParticleParameter::VelocityMaxX:      return "velocityMaxX";
    case ParticleParameter::VelocityMaxY:      return "velocityMaxY";
    case ParticleParameter::VelocityMaxZ:      return "velocityMaxZ";

    default: return "unknown";
    }
}

///-------------------------------------------/// 
/// æ–‡å­—åˆ—ã‹ã‚‰enum classã«å¤‰æ›
///-------------------------------------------///
bool ParticleParameterUtils::FromString(const std::string& str, ParticleParameter& outParam) {
    static const std::unordered_map<std::string, ParticleParameter> stringToEnum = {
        // ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        {"gravity", ParticleParameter::Gravity},
        {"explosionRadiuX", ParticleParameter::ExplosionRadiusX},
        {"explosionRadiuY", ParticleParameter::ExplosionRadiusY},
        {"explosionRadiuZ", ParticleParameter::ExplosionRadiusZ},
        {"upwardForce", ParticleParameter::UpwardForce},
        {"accelerationX", ParticleParameter::AccelerationX},
        {"accelerationY", ParticleParameter::AccelerationY},
        {"accelerationZ", ParticleParameter::AccelerationZ},

        // ç™ºç”Ÿãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        {"emissionRate", ParticleParameter::EmissionRate},
        {"frequency", ParticleParameter::Frequency},
        {"lifetimeMin", ParticleParameter::LifetimeMin},
        {"lifetimeMax", ParticleParameter::LifetimeMax},
        {"burstCount", ParticleParameter::BurstCount},

        // è¦‹ãŸç›®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        {"startColorR", ParticleParameter::StartColorR},
        {"startColorG", ParticleParameter::StartColorG},
        {"startColorB", ParticleParameter::StartColorB},
        {"startColorA", ParticleParameter::StartColorA},
        {"endColorR", ParticleParameter::EndColorR},
        {"endColorG", ParticleParameter::EndColorG},
        {"endColorB", ParticleParameter::EndColorB},
        {"endColorA", ParticleParameter::EndColorA},

        // å›è»¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        {"rotationSpeedX", ParticleParameter::RotationSpeedX},
        {"rotationSpeedY", ParticleParameter::RotationSpeedY},
        {"rotationSpeedZ", ParticleParameter::RotationSpeedZ},

        // é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        {"velocityMinX", ParticleParameter::VelocityMinX},
        {"velocityMinY", ParticleParameter::VelocityMinY},
        {"velocityMinZ", ParticleParameter::VelocityMinZ},
        {"velocityMaxX", ParticleParameter::VelocityMaxX},
        {"velocityMaxY", ParticleParameter::VelocityMaxY},
        {"velocityMaxZ", ParticleParameter::VelocityMaxZ},
    };

    auto it = stringToEnum.find(str);
    if (it != stringToEnum.end()) {
        outParam = it->second;
        return true;
    }
    return false;
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®èª¬æ˜ã‚’å–å¾—
///-------------------------------------------///
std::string ParticleParameterUtils::GetDescription(ParticleParameter param) {
    switch (param) {
        // ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::Gravity:           return "é‡åŠ›åŠ é€Ÿåº¦";
    case ParticleParameter::ExplosionRadiusX:  return "Xè»¸ã®ç™ºç”ŸåŠå¾„";
    case ParticleParameter::ExplosionRadiusY:  return "Yè»¸ã®ç™ºç”ŸåŠå¾„";
    case ParticleParameter::ExplosionRadiusZ:  return "Zè»¸ã®ç™ºç”ŸåŠå¾„";
    case ParticleParameter::UpwardForce:       return "ä¸Šæ–¹å‘ã®åˆæœŸåŠ é€Ÿ";
    case ParticleParameter::AccelerationX:     return "Xè»¸åŠ é€Ÿåº¦";
    case ParticleParameter::AccelerationY:     return "Yè»¸åŠ é€Ÿåº¦";
    case ParticleParameter::AccelerationZ:     return "Zè»¸åŠ é€Ÿåº¦";

        // ç™ºç”Ÿãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::EmissionRate:      return "ç™ºç”Ÿãƒ¬ãƒ¼ãƒˆï¼ˆå€‹/ç§’ï¼‰";
    case ParticleParameter::Frequency:         return "ç™ºç”Ÿé »åº¦ï¼ˆç§’ï¼‰";
    case ParticleParameter::LifetimeMin:       return "æœ€å°å¯¿å‘½ï¼ˆç§’ï¼‰";
    case ParticleParameter::LifetimeMax:       return "æœ€å¤§å¯¿å‘½ï¼ˆç§’ï¼‰";
    case ParticleParameter::BurstCount:        return "ãƒãƒ¼ã‚¹ãƒˆæ•°";

        // è¦‹ãŸç›®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::StartColorR:       return "é–‹å§‹è‰²ï¼ˆèµ¤ï¼‰";
    case ParticleParameter::StartColorG:       return "é–‹å§‹è‰²ï¼ˆç·‘ï¼‰";
    case ParticleParameter::StartColorB:       return "é–‹å§‹è‰²ï¼ˆé’ï¼‰";
    case ParticleParameter::StartColorA:       return "é–‹å§‹è‰²ï¼ˆé€æ˜åº¦ï¼‰";
    case ParticleParameter::EndColorR:         return "çµ‚äº†è‰²ï¼ˆèµ¤ï¼‰";
    case ParticleParameter::EndColorG:         return "çµ‚äº†è‰²ï¼ˆç·‘ï¼‰";
    case ParticleParameter::EndColorB:         return "çµ‚äº†è‰²ï¼ˆé’ï¼‰";
    case ParticleParameter::EndColorA:         return "çµ‚äº†è‰²ï¼ˆé€æ˜åº¦ï¼‰";

        // å›è»¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::RotationSpeedX:    return "Xè»¸å›è»¢é€Ÿåº¦";
    case ParticleParameter::RotationSpeedY:    return "Yè»¸å›è»¢é€Ÿåº¦";
    case ParticleParameter::RotationSpeedZ:    return "Zè»¸å›è»¢é€Ÿåº¦";

        // é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    case ParticleParameter::VelocityMinX:      return "æœ€å°é€Ÿåº¦X";
    case ParticleParameter::VelocityMinY:      return "æœ€å°é€Ÿåº¦Y";
    case ParticleParameter::VelocityMinZ:      return "æœ€å°é€Ÿåº¦Z";
    case ParticleParameter::VelocityMaxX:      return "æœ€å¤§é€Ÿåº¦X";
    case ParticleParameter::VelocityMaxY:      return "æœ€å¤§é€Ÿåº¦Y";
    case ParticleParameter::VelocityMaxZ:      return "æœ€å¤§é€Ÿåº¦Z";

    default: return "ä¸æ˜ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿";
    }
}

============================================================
File Path: Project/Engine/Graphics/Particle/ParticleParameter.h
============================================================
#pragma once
#include <string>

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åˆ—æŒ™å‹
/// SetParameterç”¨ã®å‹å®‰å…¨ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æŒ‡å®š
///=====================================================///
enum class ParticleParameter {
    // ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    Gravity,               // é‡åŠ›
    ExplosionRadiusX,      // ç™ºç”Ÿç¯„å›²
    ExplosionRadiusY,      // ç™ºç”Ÿç¯„å›²
    ExplosionRadiusZ,      // ç™ºç”Ÿç¯„å›²
    UpwardForce,           // ä¸Šæ–¹å‘ã®åŠ›
    AccelerationX,         // åŠ é€Ÿåº¦X
    AccelerationY,         // åŠ é€Ÿåº¦Y
    AccelerationZ,         // åŠ é€Ÿåº¦Z

    // ç™ºç”Ÿãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    EmissionRate,          // ç™ºç”Ÿãƒ¬ãƒ¼ãƒˆ
    Frequency,             // ç™ºç”Ÿé »åº¦
    LifetimeMin,           // æœ€å°å¯¿å‘½
    LifetimeMax,           // æœ€å¤§å¯¿å‘½
    BurstCount,            // ãƒãƒ¼ã‚¹ãƒˆæ•°

    // è¦‹ãŸç›®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    StartColorR,           // é–‹å§‹è‰²R
    StartColorG,           // é–‹å§‹è‰²G
    StartColorB,           // é–‹å§‹è‰²B
    StartColorA,           // é–‹å§‹è‰²A
    EndColorR,             // çµ‚äº†è‰²R
    EndColorG,             // çµ‚äº†è‰²G
    EndColorB,             // çµ‚äº†è‰²B
    EndColorA,             // çµ‚äº†è‰²A

    // å›è»¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    RotationSpeedX,        // å›è»¢é€Ÿåº¦X
    RotationSpeedY,        // å›è»¢é€Ÿåº¦Y
    RotationSpeedZ,        // å›è»¢é€Ÿåº¦Z

    // é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    VelocityMinX,          // æœ€å°é€Ÿåº¦X
    VelocityMinY,          // æœ€å°é€Ÿåº¦Y
    VelocityMinZ,          // æœ€å°é€Ÿåº¦Z
    VelocityMaxX,          // æœ€å¤§é€Ÿåº¦X
    VelocityMaxY,          // æœ€å¤§é€Ÿåº¦Y
    VelocityMaxZ,          // æœ€å¤§é€Ÿåº¦Z
};

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
///=====================================================///
class ParticleParameterUtils {
public:

    /// <summary>
    /// enum classã‚’æ–‡å­—åˆ—ã«å¤‰æ›ï¼ˆå†…éƒ¨å‡¦ç†ç”¨ï¼‰
    /// </summary>
    /// <param name="param">å¤‰æ›ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</param>
    /// <returns>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åã®æ–‡å­—åˆ—</returns>
    static std::string ToString(ParticleParameter param);

    /// <summary>
    /// æ–‡å­—åˆ—ã‹ã‚‰enum classã«å¤‰æ›ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    /// </summary>
    /// <param name="str">å¤‰æ›ã™ã‚‹æ–‡å­—åˆ—</param>
    /// <param name="outParam">å¤‰æ›çµæœã®å‡ºåŠ›å…ˆ</param>
    /// <returns>å¤‰æ›ã«æˆåŠŸã—ãŸå ´åˆã¯true</returns>
    static bool FromString(const std::string& str, ParticleParameter& outParam);

    /// <summary>
    /// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®èª¬æ˜ã‚’å–å¾—ï¼ˆUIè¡¨ç¤ºç”¨ï¼‰
    /// </summary>
    /// <param name="param">èª¬æ˜ã‚’å–å¾—ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</param>
    /// <returns>ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®èª¬æ˜æ–‡</returns>
    static std::string GetDescription(ParticleParameter param);
};

============================================================
File Path: Project/Engine/Graphics/Particle/ParticleSetUp.cpp
============================================================
#include "ParticleSetUp.h"
// c++
#include <cassert>
#include <fstream>
#include <numbers>
// Service
#include "Engine/System/Service/ServiceLocator.h"
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
// Managers
#include "Engine/System/Managers/SRVManager.h"
// camera
#include "application/Game/Camera/GameCamera.h"
// Math
#include "Math/sMath.h"


///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ParticleSetUp::~ParticleSetUp() { 
	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è§£æ”¾
	if (srvData_.srvManager_ != nullptr) {
		srvData_.srvManager_->Free(srvData_.srvIndex);
	}
	vertex_.reset();
	index_.reset();
	common_.reset();
}


///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Texture
void ParticleSetUp::SetTexture(const std::string& fileName) { modelData_.material.textureFilePath = fileName; }
// Material
void ParticleSetUp::SetMaterialData(const Vector4& color, const Matrix4x4& uvTransform) { common_->SetMatiarlData(color, uvTransform); }
// instancing
void ParticleSetUp::SetInstancingData(size_t index, const Vector4& color, const Matrix4x4& WVP, const Matrix4x4& World) { common_->SetInstancingData(index, color, WVP, World); }


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ParticleSetUp::Initialize(const std::string& filename, const uint32_t kNumMaxInstance, shapeType type) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12Device* device = GraphicsResourceGetter::GetDXDevice();

	// å¼•æ•°ã®å€¤ã‚’ä»£å…¥
	kNumMaxInstance_ = kNumMaxInstance;

	/// ===ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿=== ///
	modelData_ = GraphicsResourceGetter::GetModelData(filename); // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹

	/// ===ç”Ÿæˆ=== ///
	vertex_ = std::make_unique<VertexBuffer3D>();
	index_ = std::make_unique<IndexBuffer3D>();
	common_ = std::make_unique<ParticleCommon>();

	// å††å½¢ã®å ´åˆã¯å¿…è¦ãªé ‚ç‚¹æ•°ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ•°ã‚’è¨ˆç®—
	size_t vertexCount = modelData_.vertices.size();  
	size_t indexCount = modelData_.indices.size();

	if (type == shapeType::kCircle) {
		const uint32_t kRingDivide = 32;
		vertexCount = static_cast<size_t>(kRingDivide) * 4;  // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ4é ‚ç‚¹
		indexCount = static_cast<size_t>(kRingDivide) * 6;   // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ6ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	} else if (type == shapeType::kCylinder) {
		const uint32_t kCylinderDivide = 32;
		vertexCount = static_cast<size_t>(kCylinderDivide) * 6;  // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ6é ‚ç‚¹
		indexCount = static_cast<size_t>(kCylinderDivide) * 6;   // å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ6ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	}

	/// ===vertex=== ///
	// Buffer
	vertex_->Create(device, sizeof(VertexData3D) * vertexCount);
	vertex_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&vertexData_));
	// ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼
	std::memcpy(vertexData_, modelData_.vertices.data(), sizeof(VertexData3D) * modelData_.vertices.size());
	// view
	vertexBufferView_.BufferLocation = vertex_->GetBuffer()->GetGPUVirtualAddress();
	vertexBufferView_.SizeInBytes = UINT(sizeof(VertexData3D) * vertexCount);
	vertexBufferView_.StrideInBytes = sizeof(VertexData3D);

	/// ===index=== ///
	index_->Create(device, sizeof(uint32_t) * indexCount);
	index_->GetBuffer()->Map(0, nullptr, reinterpret_cast<void**>(&indexData_));
	// ãƒ¡ãƒ¢ãƒªã‚³ãƒ”ãƒ¼
	std::memcpy(indexData_, modelData_.indices.data(), sizeof(uint32_t) * modelData_.indices.size());
	// view
	indexBufferView_.BufferLocation = index_->GetBuffer()->GetGPUVirtualAddress();
	indexBufferView_.SizeInBytes = UINT(sizeof(uint32_t) * indexCount);
	indexBufferView_.Format = DXGI_FORMAT_R32_UINT;

	// ã‚¿ã‚¤ãƒ—æ¬¡ç¬¬ã§VertexBufferã‚’å¤‰æ›´ã™ã‚‹
	if (type == shapeType::kCircle) {
		// å††
		SetVertexBufferCircle();
	} else if (type == shapeType::kCylinder) {
		// cylinder
		SetVertexBufferCylinder();
	}

	// é ‚ç‚¹æ•°ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ•°ã‚’ä¿å­˜
	modelData_.vertices.resize(vertexCount);
	modelData_.indices.resize(indexCount);

	/// ===SetUp=== ///
	common_->Initlize(device, kNumMaxInstance_);

	/// ===SRV=== ///
	srvData_.srvManager_ = ServiceLocator::GetSRVManager(); // SRVManagerã®å–å¾—
	// SRVã‚’ä½œæˆã™ã‚‹DescriptorHeapã®å ´æ‰€è¨­å®š
	srvData_.srvIndex = srvData_.srvManager_->Allocate();
	srvData_.srvHandleCPU = srvData_.srvManager_->GetCPUDescriptorHandle(srvData_.srvIndex);
	srvData_.srvHandleGPU = srvData_.srvManager_->GetGPUDescriptorHandle(srvData_.srvIndex);
	// SRVã®ç”Ÿæˆ
	srvData_.srvManager_->CreateSRVForStructuredBuffer(
		srvData_.srvIndex, common_->GetInstancing(), kNumMaxInstance_, sizeof(ParticleForGPU));
}


///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ParticleSetUp::Draw(const uint32_t instance, BlendMode mode) {

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒã‚¤ãƒ³ã‚¿ã®å–å¾—=== ///
	ID3D12GraphicsCommandList* commandList = GraphicsResourceGetter::GetDXCommandList();

	/// ===ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨­å®š=== ///
	// PSOã®è¨­å®š
	Render::SetPSO(commandList, PipelineType::Particle, mode);
	// VertexBufferViewã®è¨­å®š
	commandList->IASetVertexBuffers(0, 1, &vertexBufferView_);
	// IndexBufferViewã®è¨­å®š
	commandList->IASetIndexBuffer(&indexBufferView_);
	// materialã®è¨­å®š
	common_->Bind(commandList);
	// Instancingã®è¨­å®š
	commandList->SetGraphicsRootDescriptorTable(1, srvData_.srvHandleGPU);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
	Render::SetGraphicsRootDescriptorTable(commandList, 2, modelData_.material.textureFilePath);
	// æç”»ï¼ˆDrawã‚³ãƒ¼ãƒ«ï¼‰
	commandList->DrawIndexedInstanced(UINT(modelData_.indices.size()), instance, 0, 0, 0);
}

///-------------------------------------------/// 
/// VertexBufferã®è¨­å®š
///-------------------------------------------///
// å††
void ParticleSetUp::SetVertexBufferCircle() {
	// å¤‰æ•°ã®å®£è¨€
	const uint32_t kRingDivide = 32;  // å††ã®åˆ†å‰²æ•°
	const float kOuterRadius = 4.5f;  // å¤–åŠå¾„
	const float kInnerRadius = 1.0f;  // å†…åŠå¾„ï¼ˆ0ã«ã™ã‚‹ã¨å††ç›¤ã€å€¤ãŒã‚ã‚‹ã¨ãƒ‰ãƒ¼ãƒŠãƒ„ï¼‰
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kRingDivide);

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	for (uint32_t index = 0; index < kRingDivide; ++index) {
		float currentAngle = index * radianPerDivide;
		float nextAngle = (index + 1) * radianPerDivide;

		float sin = std::sin(currentAngle);
		float cos = std::cos(currentAngle);
		float sinNext = std::sin(nextAngle);
		float cosNext = std::cos(nextAngle);

		float u = static_cast<float>(index) / float(kRingDivide);
		float uNext = static_cast<float>(index + 1) / float(kRingDivide);

		// â˜…é‡è¦ï¼šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ­£ã—ãè¨ˆç®—
		uint32_t baseIndex = index * 4;

		// å¤–å´ã®é ‚ç‚¹1
		vertexData_[baseIndex + 0].position = { cos * kOuterRadius, 0.0f, sin * kOuterRadius, 1.0f };
		vertexData_[baseIndex + 0].texcoord = { u, 0.0f };
		vertexData_[baseIndex + 0].normal = { 0.0f, 1.0f, 0.0f };  // ä¸Šå‘ã

		// å¤–å´ã®é ‚ç‚¹2
		vertexData_[baseIndex + 1].position = { cosNext * kOuterRadius, 0.0f, sinNext * kOuterRadius, 1.0f };
		vertexData_[baseIndex + 1].texcoord = { uNext, 0.0f };
		vertexData_[baseIndex + 1].normal = { 0.0f, 1.0f, 0.0f };

		// å†…å´ã®é ‚ç‚¹1
		vertexData_[baseIndex + 2].position = { cos * kInnerRadius, 0.0f, sin * kInnerRadius, 1.0f };
		vertexData_[baseIndex + 2].texcoord = { u, 1.0f };
		vertexData_[baseIndex + 2].normal = { 0.0f, 1.0f, 0.0f };

		// å†…å´ã®é ‚ç‚¹2
		vertexData_[baseIndex + 3].position = { cosNext * kInnerRadius, 0.0f, sinNext * kInnerRadius, 1.0f };
		vertexData_[baseIndex + 3].texcoord = { uNext, 1.0f };
		vertexData_[baseIndex + 3].normal = { 0.0f, 1.0f, 0.0f };
	}

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	for (uint32_t index = 0; index < kRingDivide; ++index) {
		uint32_t baseVertex = index * 4;
		uint32_t baseIndex = index * 6;

		// ä¸‰è§’å½¢1:  (0, 1, 2)
		indexData_[baseIndex + 0] = baseVertex + 0;
		indexData_[baseIndex + 1] = baseVertex + 1;
		indexData_[baseIndex + 2] = baseVertex + 2;

		// ä¸‰è§’å½¢2: (2, 1, 3)
		indexData_[baseIndex + 3] = baseVertex + 2;
		indexData_[baseIndex + 4] = baseVertex + 1;
		indexData_[baseIndex + 5] = baseVertex + 3;
	}
}

// Cylinder
void ParticleSetUp::SetVertexBufferCylinder() {
	// å¤‰æ•°ã®å®£è¨€
	const uint32_t kCylinderDivide = 32;   // å††æŸ±ã®åˆ†å‰²æ•°
	const float kTopRadius = 0.5f;         // ä¸Šéƒ¨ã®åŠå¾„
	const float kBottomRadius = 0.5f;      // ä¸‹éƒ¨ã®åŠå¾„
	const float kHeight = 3.0f;            // é«˜ã•
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kCylinderDivide);

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	for (uint32_t index = 0; index < kCylinderDivide; ++index) {
		float currentAngle = index * radianPerDivide;
		float nextAngle = (index + 1) * radianPerDivide;

		float sin = std::sin(currentAngle);
		float cos = std::cos(currentAngle);
		float sinNext = std::sin(nextAngle);
		float cosNext = std::cos(nextAngle);

		float u = static_cast<float>(index) / static_cast<float>(kCylinderDivide);
		float uNext = static_cast<float>(index + 1) / static_cast<float>(kCylinderDivide);

		// â˜…é‡è¦ï¼šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’æ­£ã—ãè¨ˆç®—ï¼ˆå„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆ6é ‚ç‚¹ï¼‰
		uint32_t baseIndex = index * 6;

		// ä¸Šéƒ¨ã®é ‚ç‚¹1
		vertexData_[baseIndex + 0].position = { cos * kTopRadius, kHeight, sin * kTopRadius, 1.0f };
		vertexData_[baseIndex + 0].texcoord = { u, 0.0f };
		vertexData_[baseIndex + 0].normal = { cos, 0.0f, sin };

		// ä¸Šéƒ¨ã®é ‚ç‚¹2
		vertexData_[baseIndex + 1].position = { cosNext * kTopRadius, kHeight, sinNext * kTopRadius, 1.0f };
		vertexData_[baseIndex + 1].texcoord = { uNext, 0.0f };
		vertexData_[baseIndex + 1].normal = { cosNext, 0.0f, sinNext };

		// ä¸‹éƒ¨ã®é ‚ç‚¹1
		vertexData_[baseIndex + 2].position = { cos * kBottomRadius, 0.0f, sin * kBottomRadius, 1.0f };
		vertexData_[baseIndex + 2].texcoord = { u, 1.0f };
		vertexData_[baseIndex + 2].normal = { cos, 0.0f, sin };

		// ä¸‹éƒ¨ã®é ‚ç‚¹1ï¼ˆé‡è¤‡ - ä¸‰è§’å½¢2ç”¨ï¼‰
		vertexData_[baseIndex + 3].position = { cos * kBottomRadius, 0.0f, sin * kBottomRadius, 1.0f };
		vertexData_[baseIndex + 3].texcoord = { u, 1.0f };
		vertexData_[baseIndex + 3].normal = { cos, 0.0f, sin };

		// ä¸Šéƒ¨ã®é ‚ç‚¹2ï¼ˆé‡è¤‡ - ä¸‰è§’å½¢2ç”¨ï¼‰
		vertexData_[baseIndex + 4].position = { cosNext * kTopRadius, kHeight, sinNext * kTopRadius, 1.0f };
		vertexData_[baseIndex + 4].texcoord = { uNext, 0.0f };
		vertexData_[baseIndex + 4].normal = { cosNext, 0.0f, sinNext };

		// ä¸‹éƒ¨ã®é ‚ç‚¹2
		vertexData_[baseIndex + 5].position = { cosNext * kBottomRadius, 0.0f, sinNext * kBottomRadius, 1.0f };
		vertexData_[baseIndex + 5].texcoord = { uNext, 1.0f };
		vertexData_[baseIndex + 5].normal = { cosNext, 0.0f, sinNext };
	}

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	for (uint32_t index = 0; index < kCylinderDivide; ++index) {
		uint32_t baseVertex = index * 6;
		uint32_t baseIndex = index * 6;

		// ä¸‰è§’å½¢1:  (0, 1, 2)
		indexData_[baseIndex + 0] = baseVertex + 0;
		indexData_[baseIndex + 1] = baseVertex + 1;
		indexData_[baseIndex + 2] = baseVertex + 2;

		// ä¸‰è§’å½¢2: (3, 4, 5)
		indexData_[baseIndex + 3] = baseVertex + 3;
		indexData_[baseIndex + 4] = baseVertex + 4;
		indexData_[baseIndex + 5] = baseVertex + 5;
	}
}


============================================================
File Path: Project/Engine/Graphics/Particle/ParticleSetUp.h
============================================================
#pragma once
/// ===Include=== ///
// Buffer
#include "Engine/Graphics/3d/Base/VertexBuffer3D.h"
#include "Engine/Graphics/3d/Base/IndexBuffer3D.h"
#include "ParticleCommon.h"
// Pipeline
#include "Engine/DataInfo/PipelineStateObjectType.h"
// c++
#include <memory>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;
class SRVManager;

///=====================================================/// 
/// Particleå…±é€šæç”»è¨­å®š
///=====================================================///
class ParticleSetUp {
public:

	ParticleSetUp() = default;
	~ParticleSetUp();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="filename">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯åå‰ï¼ˆconst std::string&ï¼‰ã€‚</param>
	/// <param name="kNumMaxInstance">è¨±å¯ã•ã‚Œã‚‹æœ€å¤§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ï¼ˆconst uint32_tï¼‰ã€‚</param>
	/// <param name="type">åˆæœŸåŒ–å¯¾è±¡ã®å½¢çŠ¶ã®ç¨®é¡ã‚’ç¤ºã™ shapeType å€¤ã€‚</param>
	void Initialize(const std::string& filename, const uint32_t kNumMaxInstance, shapeType type);

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="instance">æç”»å¯¾è±¡ã‚’ç¤ºã™ uint32_t å‹ã®è­˜åˆ¥å­ã€‚é–¢æ•°å†…ã§å¤‰æ›´ã•ã‚Œãªã„ï¼ˆconstï¼‰ã€‚</param>
	/// <param name="mode">æç”»æ™‚ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã™ã‚‹ï¼ˆBlendMode å‹ã®å€¤ï¼‰ã€‚</param>
	void Draw(const uint32_t instance, BlendMode mode);

public: /// ===Setter=== ///

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£
	void SetTexture(const std::string& fileName);
	// Material
	void SetMaterialData(const Vector4& color, const Matrix4x4& uvTransform);
	// Instancing
	void SetInstancingData(size_t index, const Vector4& color, const Matrix4x4& WVP, const Matrix4x4& World);

private:
	/// ===SRV=== ///
	struct ParticleSRV {
		SRVManager* srvManager_ = nullptr;
		uint32_t srvIndex;
		D3D12_CPU_DESCRIPTOR_HANDLE srvHandleCPU;
		D3D12_GPU_DESCRIPTOR_HANDLE srvHandleGPU;
	};
	ParticleSRV srvData_;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹=== ///
	std::unique_ptr<VertexBuffer3D> vertex_;
	std::unique_ptr<IndexBuffer3D> index_;
	std::unique_ptr<ParticleCommon> common_;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿=== ///
	VertexData3D* vertexData_ = nullptr;
	uint32_t* indexData_ = nullptr;

	/// ===ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼=== ///
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView_{};
	D3D12_INDEX_BUFFER_VIEW indexBufferView_{};
	
	/// ===ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿=== ///
	ModelData modelData_;

	/// ===ãƒ¢ãƒ‡ãƒ«æƒ…å ±=== ///
	uint32_t kNumMaxInstance_;

private:
	
	/// <summary>
	/// å††å½¢ã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
	/// </summary>
	void SetVertexBufferCircle();

	/// <summary>
	/// å††æŸ±ã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
	/// </summary>
	void SetVertexBufferCylinder();
};



============================================================
File Path: Project/Engine/Graphics/Pipeline/CS/CSPSOCommon.cpp
============================================================
#include "CSPSOCommon.h"
// Compiler
#include "Engine/Graphics/Pipeline/Compiler.h"
// Engine
#include "Engine/Core/DXCommon.h"
// c++
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
CSPSOCommon::~CSPSOCommon() {
	rootSignature_.reset();
	computePipelineState_.Reset();
}

///-------------------------------------------/// 
/// PSOã®ä½œæˆ
///-------------------------------------------///
void CSPSOCommon::Create(DXCommon* dxCommon, Compiler* compiler, PipelineType Type) {
	// RootSignatureã®ç”Ÿæˆ
	rootSignature_ = std::make_unique<CSRootSignature>();
	rootSignature_->Create(dxCommon, Type);
	compiler_ = compiler;
	// PipelineState
	CreatePipelineState(dxCommon, Type);
}

///-------------------------------------------/// 
/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
///-------------------------------------------///
void CSPSOCommon::SetPSO(ID3D12GraphicsCommandList* commandList) {
	// assertã§ãƒã‚§ãƒƒã‚¯
	assert(rootSignature_);
	assert(computePipelineState_);

	// RootSignatureã®è¨­å®š
	commandList->SetComputeRootSignature(rootSignature_->GetRootSignature());
	// PSOã®è¨­å®š
	commandList->SetPipelineState(computePipelineState_.Get());
}

///-------------------------------------------/// 
/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ä½œæˆ
///-------------------------------------------///
void CSPSOCommon::CreatePipelineState(DXCommon* dxCommon, PipelineType type) {
	HRESULT hr;
	type;

	// ComputePipelineStateDescã®è¨­å®š
	computePipelineStateDesc_.CS = {
		.pShaderBytecode = compiler_->GetObjCS()->GetBufferPointer(),
		.BytecodeLength = compiler_->GetObjCS()->GetBufferSize()
	};
	// RootSignatureã®è¨­å®š
	computePipelineStateDesc_.pRootSignature = rootSignature_->GetRootSignature();
	// å®Ÿéš›ã«ç”Ÿæˆ
	hr = dxCommon->GetDevice()->CreateComputePipelineState(&computePipelineStateDesc_, IID_PPV_ARGS(&computePipelineState_));
	assert(SUCCEEDED(hr));
}

============================================================
File Path: Project/Engine/Graphics/Pipeline/CS/CSPSOCommon.h
============================================================
#pragma once
/// ===Include=== ///
#include "CSRootSignature.h"
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"
// c++
#include <memory>
#include <array>
#include <cassert>
// directX
#include <d3d12.h>
#include <dxgidebug.h>
#include <dxgi1_6.h>
#include <dxcapi.h>

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;
class Compiler;

///=====================================================/// 
/// ComputePipelineStateObjectCommon
///=====================================================///
class CSPSOCommon {
public:

	CSPSOCommon() = default;
	~CSPSOCommon();

	/// <summary>
	/// PSOã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="DXCommon">DirectX ã«é–¢é€£ã™ã‚‹å…±é€šãƒªã‚½ãƒ¼ã‚¹ã€ãƒ‡ãƒã‚¤ã‚¹ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆã«å¿…è¦ãªç’°å¢ƒæƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚</param>
	/// <param name="compiler">ã‚·ã‚§ãƒ¼ãƒ€ã‚„ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ãŸã‚ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="Type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã™ã‚‹åˆ—æŒ™å‹ï¼ˆPipelineTypeï¼‰ã®å€¤ã€‚</param>
	void Create(DXCommon* dxcommon, Compiler* compiler, PipelineType Type);

	/// <summary>
	/// PSOã®è¨­å®šå‡¦ç†
	/// </summary>
	/// <param name="commandList">PSO ã‚’è¨­å®šã™ã‚‹å¯¾è±¡ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚æœ‰åŠ¹ãªã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æ¸¡ã—ã¦ãã ã•ã„ã€‚</param>
	void SetPSO(ID3D12GraphicsCommandList* commandList);

private: /// ===å¤‰æ•°=== ///

	/// ===PSOã«å¿…è¦ãªæƒ…å ±=== ///
	std::unique_ptr<CSRootSignature> rootSignature_;    // RootSignature
	Compiler* compiler_;                                // Compiler

	ComPtr<ID3D12PipelineState> computePipelineState_;
	D3D12_COMPUTE_PIPELINE_STATE_DESC computePipelineStateDesc_{};

private: /// ===é–¢æ•°=== ///

	/// <summary>
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="dxCommon">DirectX ã®å…±é€šãƒªã‚½ãƒ¼ã‚¹ã‚„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã™ã‚‹ DXCommon ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™ PipelineType ã®å€¤ã€‚</param>
	void CreatePipelineState(DXCommon* dxCommon, PipelineType type);
};



============================================================
File Path: Project/Engine/Graphics/Pipeline/CS/CSRootSignature.cpp
============================================================
#include "CSRootSignature.h"
// Engine
#include "Engine/Core/Logger.h"
#include "Engine/Core/DXCommon.h"
// c++
#include <algorithm>
#include <cassert>
#include <thread>
#include <timeapi.h>
#include <vector>
#include <format>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
CSRootSignature::~CSRootSignature() {
	rootSignature_.Reset();
}

///-------------------------------------------/// 
/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
///-------------------------------------------///
namespace {

	/// ===CSOcean=== ///
	ComPtr<ID3D12RootSignature> TypeCSOcean(ID3D12Device* device) {
		// SRVç”¨ã®DescriptorRange (t0: æ³¢æƒ…å ±)
		D3D12_DESCRIPTOR_RANGE srvRange = {};
		srvRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
		srvRange.NumDescriptors = 1; // t0:WaveInfos
		srvRange.BaseShaderRegister = 0;
		srvRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

		// UAVç”¨ã®DescriptorRange (u0: å‡ºåŠ›é ‚ç‚¹)
		D3D12_DESCRIPTOR_RANGE uavRange = {};
		uavRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_UAV;
		uavRange.NumDescriptors = 1; // u0:OutputVertices
		uavRange.BaseShaderRegister = 0;
		uavRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;

		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[4] = {};

		// [0] CBV - è¨­å®šãƒãƒƒãƒ•ã‚¡ (b0:WaveSettings)
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
		rootParameters[0].Descriptor.ShaderRegister = 0;

		// [1] CBV - æ³¢ç´‹ãƒãƒƒãƒ•ã‚¡ (b1:RippleBuffer)
		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
		rootParameters[1].Descriptor.ShaderRegister = 1;

		// [2] SRV - æ³¢æƒ…å ± (t0:WaveInfos)
		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
		rootParameters[2].DescriptorTable.pDescriptorRanges = &srvRange;
		rootParameters[2].DescriptorTable.NumDescriptorRanges = 1;

		// [3] UAV - å‡ºåŠ›ãƒãƒƒãƒ•ã‚¡ (u0:OutputVertices)
		rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
		rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_ALL;
		rootParameters[3].DescriptorTable.pDescriptorRanges = &uavRange;
		rootParameters[3].DescriptorTable.NumDescriptorRanges = 1;

		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_NONE;
		desc.pParameters = rootParameters;
		desc.NumParameters = _countof(rootParameters);
		desc.pStaticSamplers = nullptr;
		desc.NumStaticSamplers = 0;

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===ãƒãƒƒãƒ—ã«ç™»éŒ²=== ///
	using RootSigGenerator = std::function<ComPtr<ID3D12RootSignature>(ID3D12Device*)>;

	// IsComputePipelineé–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ã€Computeç”¨ã®ã¿ã‚’ç™»éŒ²
	std::unordered_map<PipelineType, RootSigGenerator> CreateCSRootSignatureTable() {
		std::unordered_map<PipelineType, RootSigGenerator> table;

		// å…¨ã¦ã®PipelineTypeã‚’ãƒã‚§ãƒƒã‚¯
		for (PipelineType type : AllPipelineTypes()) {
			// Computeãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã¿ç™»éŒ²
			if (IsComputePipeline(type)) {
				switch (type) {
				case PipelineType::CSOcean:
					table[type] = TypeCSOcean;
					break;
				default:
					// Computeã¨åˆ¤å®šã•ã‚ŒãŸãŒã€å¯¾å¿œã™ã‚‹é–¢æ•°ãŒãªã„å ´åˆ
					assert(false && "CS RootSignature not implemented for this type");
					break;
				}
			}
		}

		return table;
	}

	const std::unordered_map<PipelineType, RootSigGenerator> kCSRootSignatureTable_ = CreateCSRootSignatureTable();
}

///-------------------------------------------/// 
/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£ã®ç”Ÿæˆ
///-------------------------------------------///
void CSRootSignature::Create(DXCommon* dxCommon, PipelineType Type) {
	// Computeãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‹ãƒã‚§ãƒƒã‚¯
	assert(IsComputePipeline(Type) && "CSRootSignature can only be used for Compute Pipelines");

	auto it = kCSRootSignatureTable_.find(Type);
	if (it != kCSRootSignatureTable_.end()) {
		// ç›´æ¥ RootSignature ã‚’ä½œã£ã¦è¿”ã™æ§‹æˆã«å¤‰æ›´
		rootSignature_ = it->second(dxCommon->GetDevice());
	} else {
		assert(false && "Unknown Compute PipelineType in CSRootSignature");
	}
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12RootSignature* CSRootSignature::GetRootSignature() const { return rootSignature_.Get(); }

============================================================
File Path: Project/Engine/Graphics/Pipeline/CS/CSRootSignature.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Core/ComPtr.h"
// Type
#include "Engine/DataInfo/PipelineStateObjectType.h"
// c++
#include <d3d12.h>
#include <unordered_map>
#include <functional>

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;

///=====================================================/// 
/// ComputeShaderç”¨RootSignature
///=====================================================///
class CSRootSignature {
public:
	CSRootSignature() = default;
	~CSRootSignature();

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="dxCommon">DXCommon ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒ‡ãƒã‚¤ã‚¹ã‚„ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ãªã©ã®å…±é€š DirectX ãƒªã‚½ãƒ¼ã‚¹ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚</param>
	/// <param name="Type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã™ã‚‹ PipelineType å€¤ï¼ˆä¾‹: ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆï¼‰ã€‚</param>
	void Create(DXCommon* dxCommon, PipelineType Type);

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12RootSignature* GetRootSignature()const;

private:

	ComPtr<ID3D12RootSignature> rootSignature_; // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£
};



============================================================
File Path: Project/Engine/Graphics/Pipeline/Compiler.cpp
============================================================
#include "Compiler.h"

#include "Engine/Core/Logger.h"
#include "Engine/Core/DXCommon.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Compiler::~Compiler() {
	objVSBlob_.Reset();
	objPSBlob_.Reset();
	objCSBlob_.Reset();
}

///-------------------------------------------/// 
/// Shaderãƒ‡ãƒ¼ãƒ–ãƒ«ã®å®šç¾©
///-------------------------------------------///
namespace {
	// æƒ…å ±
	struct ShaderInfo {
		std::wstring vsPath;
		std::wstring psPath;
		std::wstring csPath;
	};

	// ãƒ†ãƒ¼ãƒ–ãƒ«æœ¬ä½“
	const std::unordered_map<PipelineType, ShaderInfo> kShaderTable_ = {
	{ PipelineType::ForGround2D,	 { L"2D/Obj2D.VS.hlsl",				 L"2D/Obj2D.PS.hlsl",						 L""}},
	{ PipelineType::BackGround2D,	 { L"2D/Obj2D.VS.hlsl",				 L"2D/Obj2D.PS.hlsl",		 				 L""}},
	{ PipelineType::CircularGauge2D, { L"2D/Obj2D.VS.hlsl",				 L"2D/CircularGauge.PS.hlsl",		 		 L""}},
	{ PipelineType::Obj3D,			 { L"3D/Obj3D.VS.hlsl",				 L"3D/Obj3D.PS.hlsl",						 L""}},
	{ PipelineType::PrimitiveSkyBox, { L"3D/SkyBox.VS.hlsl",             L"3D/SkyBox.PS.hlsl",						 L""}},
	{ PipelineType::PrimitiveOcean,  { L"3D/Ocean.VS.hlsl",              L"3D/Ocean.PS.hlsl",						 L""}},
	{ PipelineType::Skinning3D,		 { L"3D/SkinningObj3D.VS.hlsl",      L"3D/SkinningObj3D.PS.hlsl",				 L""}},
	{ PipelineType::Line3D,			 { L"3D/Line3D.VS.hlsl",             L"3D/Line3D.PS.hlsl",						 L""}},
	{ PipelineType::Particle,		 { L"Particle/Particle.VS.hlsl",     L"Particle/Particle.PS.hlsl",				 L""}},
	{ PipelineType::OffScreen,		 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/CopyImage.PS.hlsl",			 L""}},
	{ PipelineType::Grayscale,		 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/Grayscale.PS.hlsl",			 L""}},
	{ PipelineType::Vignette ,		 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/Vignette.PS.hlsl",				 L""}},
	{ PipelineType::Dissolve,		 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/Dissolve.PS.hlsl",				 L""}},
	{ PipelineType::BoxFilter3x3,	 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/BoxFilter3x3.PS.hlsl",			 L""}},
	{ PipelineType::BoxFilter5x5,	 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/BoxFilter5x5.PS.hlsl",			 L""}},
	{ PipelineType::RadiusBlur,		 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/RadialBlur.PS.hlsl",			 L""}},
	{ PipelineType::OutLine,		 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/LuminanceBasedOutline.PS.hlsl", L""}},
	{ PipelineType::ShatterGlass,	 { L"OffScreen/Fullscreen.VS.hlsl",  L"OffScreen/ShatterGlass.PS.hlsl",			 L""}},
	/// ===CS=== ///
	{ PipelineType::CSOcean,		 { L"", L"", L"3D/Ocean.CS.hlsl"}},
	};
}

///-------------------------------------------/// 
/// shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
///-------------------------------------------///
void Compiler::Initialize(DXCommon* dxCommon, PipelineType type) {
	// å¯¾å¿œã™ã‚‹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®æ¤œç´¢
	const auto& it = kShaderTable_.find(type);
	assert(it != kShaderTable_.end() && "Unknown PipelineType");

	// å¯¾å¿œã™ã‚‹æƒ…å ±ã‚’å–å¾—
	const ShaderInfo& info = it->second;

	// VSã‚·ã‚§ãƒ¼ãƒ€ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	if (!info.vsPath.empty()) {
		objVSBlob_ = CompileShader(info.vsPath, L"vs_6_0",
			dxCommon->GetDxcUtils(), dxCommon->GetDxcCompiler(), dxCommon->GetIncludeHandler());
		assert(objVSBlob_ && "Vertex Shader Compile Failed");
	}
	// PSã‚·ã‚§ãƒ¼ãƒ€ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	if (!info.psPath.empty()) {
		objPSBlob_ = CompileShader(info.psPath, L"ps_6_0",
			dxCommon->GetDxcUtils(), dxCommon->GetDxcCompiler(), dxCommon->GetIncludeHandler());
		assert(objPSBlob_ && "Pixel Shader Compile Failed");
	}
	// CSã‚·ã‚§ãƒ¼ãƒ€ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	if (!info.csPath.empty()) {
		objCSBlob_ = CompileShader(info.csPath, L"cs_6_0",
			dxCommon->GetDxcUtils(), dxCommon->GetDxcCompiler(), dxCommon->GetIncludeHandler());
		assert(objCSBlob_ && "Compute Shader Compile Failed");
	}
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// ObjectVertexShaderBlobã®å–å¾—
IDxcBlob* Compiler::GetObjVS() { return objVSBlob_.Get(); }
// ObjectPixelShaderBlobã®å–å¾—
IDxcBlob* Compiler::GetObjPS() { return objPSBlob_.Get(); }
// ObjectComputeShaderBlobã®å–å¾—
IDxcBlob* Compiler::GetObjCS() { return objCSBlob_.Get(); }

///-------------------------------------------/// 
/// CompileShaderé–¢æ•°
///-------------------------------------------///
ComPtr<IDxcBlob> Compiler::CompileShader(
	const std::wstring& filePath, const wchar_t* profile, IDxcUtils* dxcUtils, IDxcCompiler3* dxcCompiler, IDxcIncludeHandler* includeHandler) {

	HRESULT hr;

	// ãƒ™ãƒ¼ã‚¹ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¨­å®š
	const std::wstring& baseShaderPath = L"Resource/Shaders";
	const std::wstring& shaderFileName = baseShaderPath + L"/" + filePath;

	/// ===1. hlslãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€=== ///
	// ã“ã‚Œã‹ã‚‰ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ—¨ã‚’ãƒ­ã‚°ã«å‡ºã™
	Log(ConvertString(std::format(L"Begin CompileShader, path:{}, profile:{}\n", shaderFileName, profile)));

	// hlslãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚€
	ComPtr<IDxcBlobEncoding> shaderSource = nullptr;
	hr = dxcUtils->LoadFile(shaderFileName.c_str(), nullptr, &shaderSource);

	// èª­ã‚ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
	assert(SUCCEEDED(hr));

	// èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’è¨­å®šã™ã‚‹
	DxcBuffer shaderSourceBuffer;
	shaderSourceBuffer.Ptr = shaderSource->GetBufferPointer();
	shaderSourceBuffer.Size = shaderSource->GetBufferSize();
	shaderSourceBuffer.Encoding = DXC_CP_UTF8; // UTF8ã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’é€šçŸ¥

	/// ===2. Compileã™ã‚‹ === ///
#ifdef _DEBUG
	LPCWSTR arguments[] = {
		shaderFileName.c_str(),
		L"-E", L"main",
		L"-T", profile,
		L"-Zi", L"-Qembed_debug",   // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚ã‚Š
		L"-Od",                     // æœ€é©åŒ–ã‚ªãƒ•
		L"-Zpr",
		L"-D", L"_DEBUG",           // _DEBUGãƒã‚¯ãƒ­ã‚’å®šç¾©
	};
#else
	LPCWSTR arguments[] = {
		shaderFileName.c_str(),
		L"-E", L"main",
		L"-T", profile,
		// ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã¯ãªã—
		L"-O2",                     // é«˜é€ŸåŒ–ã®ãŸã‚ã®æœ€é©åŒ–
		L"-Zpr",
		L"-D", L"NDEBUG",           // NDEBUGãƒã‚¯ãƒ­ã‚’å®šç¾©ï¼ˆå¿…è¦ãªã‚‰ï¼‰
	};
#endif

	// å®Ÿéš›ã«Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	ComPtr<IDxcResult> shaderResult = nullptr;
	hr = dxcCompiler->Compile(
		&shaderSourceBuffer,          // èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«
		arguments,                    // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³
		_countof(arguments),          // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•°
		includeHandler,               // includeãŒå«ã¾ã‚ŒãŸè«¸ã€…
		IID_PPV_ARGS(&shaderResult)   // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœ
	);

	// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã§ã¯ãªãDxcãŒèµ·å‹•ã§ããªã„ãªã©è‡´å‘½çš„ãªçŠ¶æ³
	assert(SUCCEEDED(hr));

	/// ===3. è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ã„ãªã„ã‹ã‚’ç¢ºèªã™ã‚‹=== ///
	// è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ãŸã‚‰ãƒ­ã‚°ã‚’å‡ºã—ã¦æ­¢ã‚ã‚‹
	ComPtr<IDxcBlobUtf8> shaderError = nullptr;
	shaderResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&shaderError), nullptr);
	if (shaderError != nullptr && shaderError->GetStringLength() != 0) {
		Log(shaderError->GetStringPointer());

		// è­¦å‘Šãƒ»ã‚¨ãƒ©ãƒ¼ãƒ€ãƒ¡ã‚¼ãƒƒã‚¿ã‚¤
		assert(false);
	}

	/// ===4. Compileçµæœã‚’å—ã‘å–ã£ã¦ã¾ã™=== ///
	// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‹ã‚‰å®Ÿè¡Œç”¨ã®ãƒã‚¤ãƒŠãƒªéƒ¨åˆ†ã‚’å–å¾—
	ComPtr<IDxcBlob> shaderBlob = nullptr;
	hr = shaderResult->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shaderBlob), nullptr);
	assert(SUCCEEDED(hr));

	// æˆåŠŸã—ãŸãƒ­ã‚°ã‚’å‡ºã™
	Log(ConvertString(std::format(L"Compile Succeeded, path:{}, profile:{}\n", shaderFileName, profile)));

	// å®Ÿè¡Œç”¨ã®ãƒã‚¤ãƒŠãƒªã‚’è¿”å´
	return shaderBlob;
}


============================================================
File Path: Project/Engine/Graphics/Pipeline/Compiler.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"
// directX
#include <d3d12.h>
#include <dxcapi.h>
// c++
#include <string>
#include <unordered_map>

#pragma comment(lib, "dxcompiler.lib")

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;

///=====================================================/// 
/// Compiler
///=====================================================///
class Compiler {
public:

	Compiler() = default;
	~Compiler();

	/// <summary>
	///shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹å‡¦ç†
	/// </summary>
	/// <param name="dxCommon">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ DXCommon ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚DirectX ã«é–¢é€£ã™ã‚‹å…±æœ‰ãƒªã‚½ãƒ¼ã‚¹ã‚„çŠ¶æ…‹ã‚’æä¾›ã™ã‚‹ã€‚</param>
	/// <param name="Type">åˆæœŸåŒ–å¯¾è±¡ã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™å€¤ï¼ˆPipelineTypeï¼‰ã€‚</param>
	void Initialize(DXCommon* dxCommon, PipelineType Type);

	/// ===ShaderBlobã®å–å¾—=== ///
	// VertexShader
	IDxcBlob* GetObjVS();
	// PixelShader
	IDxcBlob* GetObjPS();
	// ComputeShader
	IDxcBlob* GetObjCS();

private:

	//ã€€ObjectShader
	ComPtr<IDxcBlob> objVSBlob_;
	ComPtr<IDxcBlob> objPSBlob_;
	ComPtr<IDxcBlob> objCSBlob_;

private:
	/// <summary>
	/// CompileShaderé–¢æ•°
	/// </summary>
	/// <param name="filePath">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¯¾è±¡ã®ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ï¼ˆstd::wstringï¼‰ã€‚</param>
	/// <param name="profile">ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã«ä½¿ç”¨ã™ã‚‹ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æ–‡å­—åˆ—ï¼ˆä¾‹: L"vs_6_0"ã€L"ps_6_0"ï¼‰ã€‚</param>
	/// <param name="dxcUtils">åˆæœŸåŒ–æ¸ˆã¿ã®IDxcUtilsã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã€‚ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã‚„ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£æ“ä½œã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="dxcCompiler">åˆæœŸåŒ–æ¸ˆã¿ã®IDxcCompiler3ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã€‚å®Ÿéš›ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚</param>
	/// <param name="includeHandler">åˆæœŸåŒ–æ¸ˆã¿ã®IDxcIncludeHandlerã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ã€‚#includeã®è§£æ±ºã‚’æ‹…å½“ã—ã¾ã™ã€‚</param>
	/// <returns>ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’ä¿æŒã™ã‚‹ComPtr<IDxcBlob>ã€‚ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æˆåŠŸæ™‚ã¯ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒã‚¤ãƒŠãƒªãŒæ ¼ç´ã•ã‚Œã€å¤±æ•—æ™‚ã¯ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å«ã‚€BlobãŒè¿”ã•ã‚Œã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</returns>
	ComPtr<IDxcBlob> CompileShader(
		// Compilerã™ã‚‹Shaderãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹
		const std::wstring& filePath,

		// Compilerã«ä½¿ç”¨ã™ã‚‹Profile
		const wchar_t* profile,

		// åˆæœŸåŒ–ã§ç”Ÿæˆã—ãŸã‚‚ã®ã‚’3ã¤
		IDxcUtils* dxcUtils,
		IDxcCompiler3* dxcCompiler,
		IDxcIncludeHandler* includeHandler);

};

============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/BlendState.cpp
============================================================
#include "BlendState.h"

///-------------------------------------------/// 
/// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
///-------------------------------------------///
void BlendState::Create(BlendMode mode) {
	// BlendStateã®è¨­å®š
	// ã™ã¹ã¦ã®è‰²è¦ç´ ã‚’æ›¸ãè¾¼ã‚€
	blendDesc_.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;

	if (mode == BlendMode::kBlendModeAdd) {
		blendDesc_.RenderTarget[0].BlendEnable = TRUE;

		// åŠ ç®—åˆæˆ
		blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
		blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;

		// aå€¤ã®è¨­å®š
		blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ZERO;
		blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ONE;
	} else if (mode == BlendMode::kBlendModeSubtract) {
		blendDesc_.RenderTarget[0].BlendEnable = TRUE;

		// æ¸›ç®—åˆæˆ
		blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
		blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
		blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;

		// aå€¤ã®è¨­å®š
		blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ZERO;
		blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ONE;
	} else if (mode == BlendMode::kBlendModeMultily) {
		blendDesc_.RenderTarget[0].BlendEnable = TRUE;

		// ä¹—ç®—åˆæˆ
		blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_ZERO;
		blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_SRC_COLOR;

		// aå€¤ã®è¨­å®š
		blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ZERO;
		blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ONE;
	} else if (mode == BlendMode::kBlendModeScreen) {
		blendDesc_.RenderTarget[0].BlendEnable = TRUE;

		// ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åˆæˆ
		blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_INV_DEST_COLOR;
		blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;

		// aå€¤ã®è¨­å®š
		blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ZERO;
		blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ONE;
	} else if (mode == BlendMode::KBlendModeNormal) {
		blendDesc_.RenderTarget[0].BlendEnable = TRUE;

		// Normal
		blendDesc_.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
		blendDesc_.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;

		// aå€¤ã®è¨­å®š
		blendDesc_.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ZERO;
		blendDesc_.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
		blendDesc_.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ONE;
	}
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
D3D12_BLEND_DESC BlendState::GetBlendDesc() { return blendDesc_; }

============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/BlendState.h
============================================================

#pragma once
/// ===Include=== ///
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"

// c++
#include <d3d12.h>

///=====================================================/// 
/// BlendState
///=====================================================///
class BlendState {
public:

	BlendState() = default;
	~BlendState() = default;

	/// <summary>
	///  ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
	/// </summary>
	/// <param name="mode">ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ï¼ˆåˆæˆï¼‰ãƒ¢ãƒ¼ãƒ‰ã€‚BlendMode åˆ—æŒ™å‹ã®å€¤ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Create(BlendMode mode);

	/// <summary>
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®å–å¾—
	/// </summary>
	/// <returns></returns>
	D3D12_BLEND_DESC GetBlendDesc();

private:

	D3D12_BLEND_DESC blendDesc_{}; // BlendState
};


============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/DepthStencil.cpp
============================================================
#include "DepthStencil.h"

namespace {
	D3D12_DEPTH_STENCIL_DESC CreateDepthDesc(bool enable, D3D12_DEPTH_WRITE_MASK writeMask = D3D12_DEPTH_WRITE_MASK_ZERO, D3D12_COMPARISON_FUNC func = D3D12_COMPARISON_FUNC_ALWAYS, bool stencilEnable = false) {
		D3D12_DEPTH_STENCIL_DESC desc{};
		desc.DepthEnable = enable;
		desc.DepthWriteMask = writeMask;
		desc.DepthFunc = func;
		desc.StencilEnable = stencilEnable;
		return desc;
	}

	/// ===ãƒ†ãƒ¼ãƒ–ãƒ«ã«ç™»éŒ²=== ///
	const std::unordered_map<PipelineType, D3D12_DEPTH_STENCIL_DESC> kDepthStencilTable_ = {
		// 2D: å‰æ™¯ï¼ˆæ·±åº¦æœ‰åŠ¹, æ›¸ãè¾¼ã¿ã‚ã‚Š, æ¯”è¼ƒå¸¸ã«OKï¼‰
		{ PipelineType::ForGround2D,  CreateDepthDesc(true, D3D12_DEPTH_WRITE_MASK_ALL, D3D12_COMPARISON_FUNC_ALWAYS) },

		// 2D: èƒŒæ™¯ï¼ˆæ·±åº¦ç„¡åŠ¹, æ›¸ãè¾¼ã¿ãªã—, æ¯”è¼ƒLessEqual, ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ç„¡åŠ¹ï¼‰
		{ PipelineType::BackGround2D, CreateDepthDesc(false, D3D12_DEPTH_WRITE_MASK_ZERO, D3D12_COMPARISON_FUNC_LESS_EQUAL, false) },

		// 2D: CircularGaugeï¼ˆæ·±åº¦ç„¡åŠ¹, æ›¸ãè¾¼ã¿ãªã—, æ¯”è¼ƒLessEqualï¼‰
		{ PipelineType::CircularGauge2D, CreateDepthDesc(false, D3D12_DEPTH_WRITE_MASK_ALL, D3D12_COMPARISON_FUNC_ALWAYS) },

		// 3D Objectï¼ˆæ·±åº¦æœ‰åŠ¹, æ›¸ãè¾¼ã¿ã‚ã‚Š, æ¯”è¼ƒLessEqualï¼‰
		{ PipelineType::Obj3D, CreateDepthDesc(true, D3D12_DEPTH_WRITE_MASK_ALL, D3D12_COMPARISON_FUNC_LESS_EQUAL) },

		// SkyBoxï¼ˆæ·±åº¦æœ‰åŠ¹, æ›¸ãè¾¼ã¿ãªã—, æ¯”è¼ƒLessEqualï¼‰
		{ PipelineType::PrimitiveSkyBox, CreateDepthDesc(true,  D3D12_DEPTH_WRITE_MASK_ZERO, D3D12_COMPARISON_FUNC_LESS_EQUAL) },

		// Ocean (æ·±åº¦æœ‰åŠ¹ã€æ›¸ãè¾¼ã¿ç„¡ã—ã€æ¯”è¼ƒLessEqual)
		{ PipelineType::PrimitiveOcean, CreateDepthDesc(true, D3D12_DEPTH_WRITE_MASK_ALL, D3D12_COMPARISON_FUNC_LESS_EQUAL)},

		// Particleï¼ˆæ·±åº¦æœ‰åŠ¹, æ›¸ãè¾¼ã¿ãªã—, æ¯”è¼ƒLessEqualï¼‰
		{ PipelineType::Particle, CreateDepthDesc(true, D3D12_DEPTH_WRITE_MASK_ZERO, D3D12_COMPARISON_FUNC_LESS_EQUAL) },

		// Skinning 3Dï¼ˆæ·±åº¦æœ‰åŠ¹, æ›¸ãè¾¼ã¿ã‚ã‚Š, æ¯”è¼ƒLessEqualï¼‰
		{ PipelineType::Skinning3D, CreateDepthDesc(true, D3D12_DEPTH_WRITE_MASK_ALL, D3D12_COMPARISON_FUNC_LESS_EQUAL) },

		// Line3D ï¼ˆæ·±åº¦æœ‰åŠ¹, æ›¸ãè¾¼ã¿ãªã—, æ¯”è¼ƒLessEqualï¼‰
		{ PipelineType::Line3D, CreateDepthDesc(true, D3D12_DEPTH_WRITE_MASK_ZERO, D3D12_COMPARISON_FUNC_LESS_EQUAL) },

		// PostEffect ç³»ï¼ˆæ·±åº¦ç„¡åŠ¹ï¼‰
		{ PipelineType::OffScreen,    CreateDepthDesc(false) },
		{ PipelineType::Grayscale,    CreateDepthDesc(false) },
		{ PipelineType::Vignette,     CreateDepthDesc(false) },
		{ PipelineType::Dissolve,     CreateDepthDesc(false) },
		{ PipelineType::BoxFilter3x3, CreateDepthDesc(false) },
		{ PipelineType::BoxFilter5x5, CreateDepthDesc(false) },
		{ PipelineType::RadiusBlur,   CreateDepthDesc(false) },
		{ PipelineType::OutLine,	  CreateDepthDesc(false) },
		{ PipelineType::ShatterGlass, CreateDepthDesc(false) },
	};
}



///-------------------------------------------/// 
/// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã®ç”Ÿæˆ
///-------------------------------------------///
void DepthStencil::Create(PipelineType Type) {
	auto it = kDepthStencilTable_.find(Type);
	if (it != kDepthStencilTable_.end()) {
		depthStencilDesc_ = it->second;
	} else {
		depthStencilDesc_ = {}; // fallback to default
	}
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
D3D12_DEPTH_STENCIL_DESC DepthStencil::GetDepthStencilDesc() const { return depthStencilDesc_; }

============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/DepthStencil.h
============================================================
#pragma once
/// ===Include=== ///
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"
// directX
#include <d3d12.h>
#include <unordered_map>

///=====================================================/// 
/// DepthStencil
///=====================================================///
class DepthStencil {
public:

	DepthStencil() = default;
	~DepthStencil() = default;

	/// <summary>
	/// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="Type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã™ã‚‹ PipelineType å‹ã®å€¤ã€‚</param>
	void Create(PipelineType Type);

	/// <summary>
	/// ãƒ‡ãƒ—ã‚¹ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	D3D12_DEPTH_STENCIL_DESC GetDepthStencilDesc() const;

private:

	D3D12_DEPTH_STENCIL_DESC depthStencilDesc_{}; // DepthStencil
};

============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/GSPSOCommon.cpp
============================================================
#include "GSPSOCommon.h"
// Compiler
#include "Engine/Graphics/Pipeline/Compiler.h"
// Engine
#include "Engine/Core/DXCommon.h"
// c++
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
GSPSOCommon::~GSPSOCommon() {

	rootSignature_.reset();
	inputLayout_.reset();
	blendState_.reset();
	rasterizerState_.reset();
	depthStencil_.reset();
	graphicsPipelineState_.Reset();
}

///-------------------------------------------/// 
/// PSOã®ä½œæˆ
///-------------------------------------------///
void GSPSOCommon::Create(DXCommon* dxCommon, Compiler* compiler, PipelineType Type, BlendMode Mode) {

	// RootSignatureã®ç”Ÿæˆ
	rootSignature_ = std::make_unique<GSRootSignature>();
	rootSignature_->Create(dxCommon, Type);

	// InputLayoutã®ç”Ÿæˆ
	inputLayout_ = std::make_unique<InputLayout>();
	inputLayout_->Create(Type);

	// BlendStateã®ç”Ÿæˆ
	blendState_ = std::make_unique<BlendState>();
	blendState_->Create(Mode);

	// RasterizerStateã®ç”Ÿæˆ
	rasterizerState_ = std::make_unique<RasterizerState>();
	rasterizerState_->Create(Type);

	// DepthStencilã®ç”Ÿæˆ
	depthStencil_ = std::make_unique<DepthStencil>();
	depthStencil_->Create(Type);

	// Compilerã®åˆæœŸåŒ–
	compiler_ = compiler;

	// PipelineState
	CreatePipelineState(dxCommon, Type);
}

///-------------------------------------------/// 
/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
///-------------------------------------------///
void GSPSOCommon::SetPSO(ID3D12GraphicsCommandList* commandList) {

	// assertãƒã‚§ãƒƒã‚¯
	assert(rootSignature_);
	assert(graphicsPipelineState_);

	// RootSignatureã®è¨­å®š
	commandList->SetGraphicsRootSignature(rootSignature_->GetRootSignature());
	// PSOã®è¨­å®š
	commandList->SetPipelineState(graphicsPipelineState_.Get());
}


///-------------------------------------------/// 
/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä½œæˆ
///-------------------------------------------///
void GSPSOCommon::CreatePipelineState(DXCommon* dxCommon, PipelineType type) {
	HRESULT hr;

	// PSOã®å–å¾—
	graphicsPipelineStateDesc_.pRootSignature = rootSignature_->GetRootSignature(); // RootSignature
	graphicsPipelineStateDesc_.InputLayout = inputLayout_->GetInputLayout(); // InputLayout
	graphicsPipelineStateDesc_.VS = {
		compiler_->GetObjVS()->GetBufferPointer(), compiler_->GetObjVS()->GetBufferSize() }; // VertexShader
	graphicsPipelineStateDesc_.PS = {
		compiler_->GetObjPS()->GetBufferPointer(), compiler_->GetObjPS()->GetBufferSize() }; // PixlShader
	graphicsPipelineStateDesc_.BlendState = blendState_->GetBlendDesc(); // BlendState
	graphicsPipelineStateDesc_.RasterizerState = rasterizerState_->GetRasterizerState(); // RasterizerState
	graphicsPipelineStateDesc_.DepthStencilState = depthStencil_->GetDepthStencilDesc(); // DepthStencil

	// æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc_.NumRenderTargets = 1;
	graphicsPipelineStateDesc_.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;

	// æ›¸ãè¾¼ã‚€DSVã®æƒ…å ±
	graphicsPipelineStateDesc_.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;

	// åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸(å½¢çŠ¶)ã®ã‚¿ã‚¤ãƒ—ã€‚ä¸‰è§’å½¢
	if (type == PipelineType::Line3D) {
		graphicsPipelineStateDesc_.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_LINE;
	} else {
		graphicsPipelineStateDesc_.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;

	}
	

	// ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã‹ã®è¨­å®š(æ°—ã«ã—ãªãã¦è‰¯ã„)
	graphicsPipelineStateDesc_.SampleDesc.Count = 1;
	graphicsPipelineStateDesc_.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;

	// å®Ÿéš›ã«ç”Ÿæˆ
	hr = dxCommon->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc_, IID_PPV_ARGS(&graphicsPipelineState_));
	assert(SUCCEEDED(hr));
}

============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/GSPSOCommon.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "GSRootSignature.h"
#include "InputLayout.h"
#include "BlendState.h"
#include "DepthStencil.h"
#include "RasterizerState.h"
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"
// c++
#include <memory>
#include <array>
#include <cassert>
// directX
#include <d3d12.h>
#include <dxgidebug.h>
#include <dxgi1_6.h>
#include <dxcapi.h>

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;
class Compiler;

///=====================================================/// 
/// GraphicsPipelineStateObjectCommon
///=====================================================///
class GSPSOCommon {
public:

	GSPSOCommon() = default;
	~GSPSOCommon();

	/// <summary>
	/// PSOã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="DXCommon">DirectX ã«é–¢é€£ã™ã‚‹å…±é€šãƒªã‚½ãƒ¼ã‚¹ã€ãƒ‡ãƒã‚¤ã‚¹ã€ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¿æŒã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ä½œæˆã«å¿…è¦ãªç’°å¢ƒæƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚</param>
	/// <param name="compiler">ã‚·ã‚§ãƒ¼ãƒ€ã‚„ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹ãŸã‚ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="Type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã™ã‚‹åˆ—æŒ™å‹ï¼ˆPipelineTypeï¼‰ã®å€¤ã€‚</param>
	/// <param name="Mode">ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰å‹•ä½œã‚’æŒ‡å®šã™ã‚‹åˆ—æŒ™å‹ï¼ˆBlendModeï¼‰ã®å€¤ã€‚</param>
	void Create(DXCommon* dxcommon, Compiler* compiler, PipelineType Type, BlendMode Mode);

	/// <summary>
	/// PSOã®è¨­å®šå‡¦ç†
	/// </summary>
	/// <param name="commandList">PSO ã‚’è¨­å®šã™ã‚‹å¯¾è±¡ã® ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚æœ‰åŠ¹ãªã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æ¸¡ã—ã¦ãã ã•ã„ã€‚</param>
	void SetPSO(ID3D12GraphicsCommandList* commandList);

private:/// ===å¤‰æ•°=== ///

	/// ===PSOã«å¿…è¦ãªæƒ…å ±=== ///
	std::unique_ptr<GSRootSignature> rootSignature_;     // RootSignature
	std::unique_ptr<InputLayout> inputLayout_;         // InputLayout
	std::unique_ptr<BlendState> blendState_;           // BlendState
	std::unique_ptr<RasterizerState> rasterizerState_; // RasterizerState
	std::unique_ptr<DepthStencil> depthStencil_;       // DepthStencil
	Compiler* compiler_;                               // Compiler

	ComPtr<ID3D12PipelineState> graphicsPipelineState_;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc_{};

private:/// ===é–¢æ•°=== ///

	/// <summary>
	/// PipelineStateã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="dxCommon">DirectX ã®ãƒ‡ãƒã‚¤ã‚¹ã‚„ãƒªã‚½ãƒ¼ã‚¹æƒ…å ±ã‚’ä¿æŒã™ã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆä½œæˆæ™‚ã«å¿…è¦ãªæƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚</param>
	/// <param name="type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™å€¤ï¼ˆä¾‹: ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆãªã©ï¼‰ã€‚</param>
	void CreatePipelineState(DXCommon* dxCommon, PipelineType type);
};

============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/GSRootSignature.cpp
============================================================
#include "GSRootSignature.h"
// Engine
#include "Engine/Core/Logger.h"
#include "Engine/Core/DXCommon.h"
// c++
#include <algorithm>
#include <cassert>
#include <thread>
#include <timeapi.h>
#include <vector>
#include <format>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
GSRootSignature::~GSRootSignature() {
	rootSignature_.Reset();
}

///-------------------------------------------/// 
/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
///-------------------------------------------///
namespace {

	/// ===2D=== ///
	ComPtr<ID3D12RootSignature> Type2D(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ
		D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
		descriptorRange[0].BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã‚ã‚‹
		descriptorRange[0].NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—


		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[3] = {};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ã†
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[0].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ã®æŒ‡å®š

		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ã†
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX; // VertexShaderã§ä½¿ã†
		rootParameters[1].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ã®æŒ‡å®š

		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange); // Tableã§åˆ©ç”¨ã™ã‚‹æ•°


		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0;
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;


		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é•·ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===Line3D=== ///
	ComPtr<ID3D12RootSignature> TypeLine3D(ID3D12Device* device) {
		D3D12_ROOT_PARAMETER rootParameters[1] = {};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
		rootParameters[0].Descriptor.ShaderRegister = 0;

		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters;
		desc.NumParameters = _countof(rootParameters);
		desc.pStaticSamplers = nullptr;
		desc.NumStaticSamplers = 0;

		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));
		return rootSignature;
	}

	/// ===3D=== ///
	ComPtr<ID3D12RootSignature> Type3D(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ				
		// t0ç”¨
		D3D12_DESCRIPTOR_RANGE descriptorRange0 = {};
		descriptorRange0.BaseShaderRegister = 0; // t0
		descriptorRange0.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange0.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange0.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—
		// t1ç”¨
		D3D12_DESCRIPTOR_RANGE descriptorRange1 = {};
		descriptorRange1.BaseShaderRegister = 1; // t0
		descriptorRange1.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange1.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange1.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—


		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[9] = {};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ç”¨
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ç”¨
		rootParameters[0].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX; // VertexShaderã§ä½¿ç”¨
		rootParameters[1].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ç”¨
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[2].DescriptorTable.pDescriptorRanges = &descriptorRange0; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[2].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
		rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[3].DescriptorTable.pDescriptorRanges = &descriptorRange1; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[3].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		rootParameters[4].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[4].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[4].Descriptor.ShaderRegister = 1; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·1ã‚’ä½¿ç”¨

		rootParameters[5].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[5].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[5].Descriptor.ShaderRegister = 2; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·2ã‚’ä½¿ç”¨

		rootParameters[6].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[6].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[6].Descriptor.ShaderRegister = 3; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·3ã‚’ä½¿ç”¨

		rootParameters[7].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[7].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[7].Descriptor.ShaderRegister = 4; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·4ã‚’ä½¿ç”¨

		rootParameters[8].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[8].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[8].Descriptor.ShaderRegister = 5; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·5ã‚’ä½¿ç”¨


		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0; // S0
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;


		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é«˜ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===Particle=== ///
	ComPtr<ID3D12RootSignature> TypeParticle(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ
		D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
		descriptorRange[0].BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã‚ã‚‹
		descriptorRange[0].NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—


		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[3] = {};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ã†
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[0].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†

		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX; // VertexShaderã§ä½¿ã†
		rootParameters[1].DescriptorTable.pDescriptorRanges = descriptorRange; // ãƒ†ãƒ¼ãƒ–ãƒ«ã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[1].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange); // ãƒ†ãƒ¼ãƒ–ãƒ«ã§åˆ©ç”¨å¯èƒ½

		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange); // Tableã§åˆ©ç”¨ã™ã‚‹æ•°


		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0;
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;


		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é«˜ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===Skinning3D=== ///
	ComPtr<ID3D12RootSignature> TypeSkinning3D(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ
		// t0ç”¨
		D3D12_DESCRIPTOR_RANGE descriptorRange0 = {};
		descriptorRange0.BaseShaderRegister = 0; // t0
		descriptorRange0.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange0.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange0.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—
		// t1ç”¨
		D3D12_DESCRIPTOR_RANGE descriptorRange1 = {};
		descriptorRange1.BaseShaderRegister = 1; // t0
		descriptorRange1.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange1.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange1.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[10] = {};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ç”¨
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ç”¨
		rootParameters[0].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX; // VertexShaderã§ä½¿ç”¨
		rootParameters[1].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ç”¨
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[2].DescriptorTable.pDescriptorRanges = &descriptorRange0; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[2].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
		rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[3].DescriptorTable.pDescriptorRanges = &descriptorRange1; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[3].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		rootParameters[4].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[4].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[4].Descriptor.ShaderRegister = 1; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·1ã‚’ä½¿ç”¨

		rootParameters[5].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[5].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[5].Descriptor.ShaderRegister = 2; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·2ã‚’ä½¿ç”¨

		rootParameters[6].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[6].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[6].Descriptor.ShaderRegister = 3; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·3ã‚’ä½¿ç”¨

		rootParameters[7].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[7].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[7].Descriptor.ShaderRegister = 4; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·4ã‚’ä½¿ç”¨

		rootParameters[8].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[8].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[8].Descriptor.ShaderRegister = 5; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·5ã‚’ä½¿ç”¨

		rootParameters[9].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[9].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
		rootParameters[9].DescriptorTable.pDescriptorRanges = &descriptorRange0; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[9].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°


		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0;
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;


		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é«˜ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===OffScreen=== ///
	ComPtr<ID3D12RootSignature> TypeOffScreen(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ
		D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
		descriptorRange[0].BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã‚ã‚‹
		descriptorRange[0].NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[1]{};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[0].DescriptorTable.pDescriptorRanges = descriptorRange; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[0].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange); // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1]{};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0;
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é•·ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===OffScreen(Vignette)=== ///
	ComPtr<ID3D12RootSignature> TypeOffScreenOneBuffer(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ
		D3D12_DESCRIPTOR_RANGE descriptorRange = {};
		descriptorRange.BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã‚ã‚‹
		descriptorRange.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—
		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[2]{};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[0].DescriptorTable.pDescriptorRanges = &descriptorRange; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[0].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ç”¨
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ç”¨
		rootParameters[1].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1]{};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0;
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é•·ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===OffScreen(Dissolve)=== ///
	ComPtr<ID3D12RootSignature> TypeOffScreenDissolve(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ
		D3D12_DESCRIPTOR_RANGE descriptorRange0 = {};
		descriptorRange0.BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã‚ã‚‹
		descriptorRange0.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange0.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange0.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—
		// t1ç”¨
		D3D12_DESCRIPTOR_RANGE descriptorRange1 = {};
		descriptorRange1.BaseShaderRegister = 1; // t0
		descriptorRange1.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange1.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange1.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—


		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[3]{};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[0].DescriptorTable.pDescriptorRanges = &descriptorRange0; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[0].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[1].DescriptorTable.pDescriptorRanges = &descriptorRange1; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[1].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ç”¨
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ç”¨
		rootParameters[2].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1]{};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0;
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é•·ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===OffScreen(ShatterGlass)=== ///
	ComPtr<ID3D12RootSignature> TypeOffScreenShatterGlass(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ
		D3D12_DESCRIPTOR_RANGE descriptorRange0 = {};
		descriptorRange0.BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã‚ã‚‹
		descriptorRange0.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange0.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange0.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—
		// t1ç”¨
		D3D12_DESCRIPTOR_RANGE descriptorRange1 = {};
		descriptorRange1.BaseShaderRegister = 1; // t0
		descriptorRange1.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange1.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange1.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—


		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[3]{}; // 2ã¤ã«å¢—ã‚„ã™

		// [0] SRV (ãƒ†ã‚¯ã‚¹ãƒãƒ£)
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[0].DescriptorTable.pDescriptorRanges = &descriptorRange0; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[0].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		// [1] SRV (ãƒ†ã‚¯ã‚¹ãƒãƒ£)
		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ã†
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[1].DescriptorTable.pDescriptorRanges = &descriptorRange1; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[1].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		// [2] CBV (å®šæ•°ãƒãƒƒãƒ•ã‚¡)
		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ç›´æ¥æŒ‡å®š
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
		rootParameters[2].Descriptor.ShaderRegister = 0; // b0
		rootParameters[2].Descriptor.RegisterSpace = 0; // space0

		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1]{};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0; // s0
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é•·ã• (2ã«å¤‰æ›´)
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===SkyBox=== ///
	ComPtr<ID3D12RootSignature> TypeSkyBox(ID3D12Device* device) {
		// DescriptorRangeã®ç”Ÿæˆ				
		// t0ç”¨
		D3D12_DESCRIPTOR_RANGE descriptorRange0 = {};
		descriptorRange0.BaseShaderRegister = 0; // t0
		descriptorRange0.NumDescriptors = 1; // æ•°ã¯1ã¤
		descriptorRange0.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRVã‚’ä½¿ã†
		descriptorRange0.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

		// RootParameterã®ç”Ÿæˆ
		D3D12_ROOT_PARAMETER rootParameters[9] = {};
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV; // CBVã‚’ä½¿ç”¨
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ç”¨
		rootParameters[0].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX; // VertexShaderã§ä½¿ç”¨
		rootParameters[1].Descriptor.ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ç”¨

		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE; // DescriptorTableã‚’ä½¿ç”¨
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[2].DescriptorTable.pDescriptorRanges = &descriptorRange0; // Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
		rootParameters[2].DescriptorTable.NumDescriptorRanges = 1; // Tableã§åˆ©ç”¨ã™ã‚‹æ•°

		// Samplerã®è¨­å®š
		D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
		staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
		staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
		staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
		staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
		staticSamplers[0].ShaderRegister = 0; // S0
		staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;


		// RootSignatureã®ç”Ÿæˆ
		D3D12_ROOT_SIGNATURE_DESC desc{};
		desc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
		desc.pParameters = rootParameters; // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
		desc.NumParameters = _countof(rootParameters); // é…åˆ—ã®é«˜ã•
		desc.pStaticSamplers = staticSamplers;
		desc.NumStaticSamplers = _countof(staticSamplers);

		// --- ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚º & ä½œæˆ ---
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(&desc, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
		if (FAILED(hr)) {
			if (errorBlob) {
				OutputDebugStringA((char*)errorBlob->GetBufferPointer());
			}
			assert(false);
			return nullptr;
		}

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature));
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===Ocean=== ///
	ComPtr<ID3D12RootSignature> TypeOcean(ID3D12Device* device) {
		// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
		D3D12_ROOT_PARAMETER rootParameters[5] = {};

		// b0: Material (ObjectCommon)
		rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[0].Descriptor.ShaderRegister = 0;

		// b1: Transform (ObjectCommon) & OceanShaderInfo0
		rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
		rootParameters[1].Descriptor.ShaderRegister = 1;

		// b2: DirectionalLight (ObjectCommon)
		rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[2].Descriptor.ShaderRegister = 2;

		// b3: Camera (ObjectCommon)
		rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[3].Descriptor.ShaderRegister = 3;

		// b10: OceanColor
		rootParameters[4].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
		rootParameters[4].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
		rootParameters[4].Descriptor.ShaderRegister = 4;

		// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®è¨˜è¿°
		D3D12_ROOT_SIGNATURE_DESC rootSignatureDesc = {};
		rootSignatureDesc.NumParameters = _countof(rootParameters);
		rootSignatureDesc.pParameters = rootParameters;
		rootSignatureDesc.Flags = D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

		// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ä½œæˆ
		ComPtr<ID3DBlob> signatureBlob;
		ComPtr<ID3DBlob> errorBlob;
		HRESULT hr = D3D12SerializeRootSignature(
			&rootSignatureDesc,
			D3D_ROOT_SIGNATURE_VERSION_1,
			&signatureBlob,
			&errorBlob
		);
		assert(SUCCEEDED(hr));

		ComPtr<ID3D12RootSignature> rootSignature;
		hr = device->CreateRootSignature(
			0,
			signatureBlob->GetBufferPointer(),
			signatureBlob->GetBufferSize(),
			IID_PPV_ARGS(&rootSignature)
		);
		assert(SUCCEEDED(hr));

		return rootSignature;
	}

	/// ===ãƒãƒƒãƒ—ã«ç™»éŒ²=== ///
	using RootSigGenerator = std::function<ComPtr<ID3D12RootSignature>(ID3D12Device*)>;
	const std::unordered_map<PipelineType, RootSigGenerator> kRootSignatureTable_ = {
		{ PipelineType::ForGround2D,		Type2D },
		{ PipelineType::BackGround2D,		Type2D },
		{ PipelineType::CircularGauge2D,	Type2D },
		{ PipelineType::Obj3D,				Type3D },
		{ PipelineType::PrimitiveSkyBox,	Type3D },
		{ PipelineType::PrimitiveOcean,     TypeOcean },
		{ PipelineType::Particle,			TypeParticle },
		{ PipelineType::Skinning3D,			TypeSkinning3D  },
		{ PipelineType::Line3D,				TypeLine3D },
		{ PipelineType::OffScreen,			TypeOffScreen },
		{ PipelineType::Grayscale,			TypeOffScreen },
		{ PipelineType::Vignette ,			TypeOffScreenOneBuffer },
		{ PipelineType::Dissolve,           TypeOffScreenDissolve },
		{ PipelineType::BoxFilter3x3,		TypeOffScreen },
		{ PipelineType::BoxFilter5x5,		TypeOffScreen },
		{ PipelineType::RadiusBlur,			TypeOffScreenOneBuffer },
		{ PipelineType::OutLine,			TypeOffScreen },
		{ PipelineType::ShatterGlass,       TypeOffScreenShatterGlass },
	};
}

///-------------------------------------------/// 
/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£ã®ç”Ÿæˆ
///-------------------------------------------///
void GSRootSignature::Create(DXCommon* dxCommon, PipelineType Type) {
	auto it = kRootSignatureTable_.find(Type);
	if (it != kRootSignatureTable_.end()) {
		// ç›´æ¥ RootSignature ã‚’ä½œã£ã¦è¿”ã™æ§‹æˆã«å¤‰æ›´
		rootSignature_ = it->second(dxCommon->GetDevice());
	} else {
		assert(false && "Unknown PipelineType in RootSignature");
	}
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ID3D12RootSignature* GSRootSignature::GetRootSignature() const { return rootSignature_.Get(); }



============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/GSRootSignature.h
============================================================
#pragma once
/// ===include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"
// c++
#include <d3d12.h>
#include <unordered_map>
#include <functional>

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;

///=====================================================/// 
/// Graphicsç”¨ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£
///=====================================================///
class GSRootSignature {
public:

	GSRootSignature() = default;
	~GSRootSignature();

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="dxCommon">DXCommon ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ãƒ‡ãƒã‚¤ã‚¹ã‚„ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ãªã©ã®å…±é€š DirectX ãƒªã‚½ãƒ¼ã‚¹ã¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’æä¾›ã—ã¾ã™ã€‚</param>
	/// <param name="Type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã™ã‚‹ PipelineType å€¤ï¼ˆä¾‹: ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆï¼‰ã€‚</param>
	void Create(DXCommon* dxCommon, PipelineType Type);

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	ID3D12RootSignature* GetRootSignature()const;

private:

	ComPtr<ID3D12RootSignature> rootSignature_; // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒã‚¤ãƒãƒ£
};


============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/InputLayout.cpp
============================================================
#include "InputLayout.h"

///-------------------------------------------/// 
/// ãƒ†ãƒ¼ãƒ–ãƒ«ã§ä½¿ç”¨ã™ã‚‹Descã‚’ä½œæˆã—è¨­å®š
///-------------------------------------------///
namespace {
	/// ===é…åˆ—ãŒï¼’ã¤=== ///
	static D3D12_INPUT_ELEMENT_DESC inputElementDescs2[2] = {};
	// ãƒ‡ã‚¹ã‚¯ã«å¯¾å¿œã—ãŸè¨­å®š
	void InitLayout2Array() {
		inputElementDescs2[0].SemanticName = "POSITION";
		inputElementDescs2[0].SemanticIndex = 0;
		inputElementDescs2[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		inputElementDescs2[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

		inputElementDescs2[1].SemanticName = "TEXCOORD";
		inputElementDescs2[1].SemanticIndex = 0;
		inputElementDescs2[1].Format = DXGI_FORMAT_R32G32_FLOAT;
		inputElementDescs2[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	}

	/// ====== ///

	/// ===Line3Dç”¨=== ///
	static D3D12_INPUT_ELEMENT_DESC inputElementDescsLine[2] = {};
	// ãƒ‡ã‚¹ã‚¯ã«å¯¾å¿œã—ãŸè¨­å®š
	void InitLayoutLine3D() {
		inputElementDescsLine[0].SemanticName = "POSITION";
		inputElementDescsLine[0].SemanticIndex = 0;
		inputElementDescsLine[0].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		inputElementDescsLine[0].InputSlot = 0;
		inputElementDescsLine[0].AlignedByteOffset = 0;
		inputElementDescsLine[0].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		inputElementDescsLine[0].InstanceDataStepRate = 0;

		inputElementDescsLine[1].SemanticName = "COLOR";
		inputElementDescsLine[1].SemanticIndex = 0;
		inputElementDescsLine[1].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		inputElementDescsLine[1].InputSlot = 0;
		inputElementDescsLine[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		inputElementDescsLine[1].InputSlotClass = D3D12_INPUT_CLASSIFICATION_PER_VERTEX_DATA;
		inputElementDescsLine[1].InstanceDataStepRate = 0;
	}

	/// ===é…åˆ—ãŒ3ã¤=== ///
	static D3D12_INPUT_ELEMENT_DESC inputElementDescs3[3] = {};
	void InitLayout3Array() {
		inputElementDescs3[0].SemanticName = "POSITION";
		inputElementDescs3[0].SemanticIndex = 0;
		inputElementDescs3[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		inputElementDescs3[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

		inputElementDescs3[1].SemanticName = "TEXCOORD";
		inputElementDescs3[1].SemanticIndex = 0;
		inputElementDescs3[1].Format = DXGI_FORMAT_R32G32_FLOAT;
		inputElementDescs3[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

		inputElementDescs3[2].SemanticName = "NORMAL";
		inputElementDescs3[2].SemanticIndex = 0;
		inputElementDescs3[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		inputElementDescs3[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
		inputElementDescs3[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	}

	/// ===é…åˆ—ãŒ5ã¤=== ///
	static D3D12_INPUT_ELEMENT_DESC inputElementDescs5[5] = {};
	void InitLayout5Array() {
		inputElementDescs5[0].SemanticName = "POSITION";
		inputElementDescs5[0].SemanticIndex = 0;
		inputElementDescs5[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
		inputElementDescs5[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

		inputElementDescs5[1].SemanticName = "TEXCOORD";
		inputElementDescs5[1].SemanticIndex = 0;
		inputElementDescs5[1].Format = DXGI_FORMAT_R32G32_FLOAT;
		inputElementDescs5[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

		inputElementDescs5[2].SemanticName = "NORMAL";
		inputElementDescs5[2].SemanticIndex = 0;
		inputElementDescs5[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
		inputElementDescs5[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

		inputElementDescs5[3].SemanticName = "WEIGHT";
		inputElementDescs5[3].SemanticIndex = 0;
		inputElementDescs5[3].Format = DXGI_FORMAT_R32G32B32A32_FLOAT; // float4
		inputElementDescs5[3].InputSlot = 1; // ä¸€ç•ªç›®ã®slotã®VBVã®ã“ã¨ã ã¨ä¼ãˆã‚‹
		inputElementDescs5[3].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

		inputElementDescs5[4].SemanticName = "INDEX";
		inputElementDescs5[4].SemanticIndex = 0;
		inputElementDescs5[4].Format = DXGI_FORMAT_R32G32B32A32_SINT; // int4
		inputElementDescs5[4].InputSlot = 1; // ä¸€ç•ªç›®ã®slotã®VBVã®ã“ã¨ã ã¨ä¼ãˆã‚‹
		inputElementDescs5[4].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	}

	// æƒ…å ±
	struct LayoutInfo {
		const D3D12_INPUT_ELEMENT_DESC* elements;
		UINT numElements;
	};

	// ãƒ†ãƒ¼ãƒ–ãƒ«
	const std::unordered_map<PipelineType, LayoutInfo> kLayoutTable_ = [] {
		InitLayout2Array();
		InitLayoutLine3D();
		InitLayout3Array();
		InitLayout5Array();
		// ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦è¨­å®š
		return std::unordered_map<PipelineType, LayoutInfo>{
			{ PipelineType::ForGround2D,  { inputElementDescs2,      _countof(inputElementDescs2)}},
			{ PipelineType::BackGround2D, { inputElementDescs2,      _countof(inputElementDescs2)}},
			{ PipelineType::CircularGauge2D,  { inputElementDescs2,      _countof(inputElementDescs2)}},
			{ PipelineType::Obj3D,        { inputElementDescs3,      _countof(inputElementDescs3)}},
			{ PipelineType::PrimitiveSkyBox,  { inputElementDescs3,      _countof(inputElementDescs3) }},
			{ PipelineType::PrimitiveOcean,   { inputElementDescs3,      _countof(inputElementDescs3) }},
			{ PipelineType::Particle,     { inputElementDescs3,      _countof(inputElementDescs3) }},
			{ PipelineType::Skinning3D,   { inputElementDescs5,		 _countof(inputElementDescs5) }},
			{ PipelineType::Line3D,       { inputElementDescsLine,   _countof(inputElementDescsLine)}},
			{ PipelineType::OffScreen,    { nullptr,                  0 }},
			{ PipelineType::Grayscale,    { nullptr,                  0 }},
			{ PipelineType::Vignette,     { nullptr,                  0 }},
			{ PipelineType::Dissolve,     { nullptr,                  0 }},
			{ PipelineType::BoxFilter3x3, { nullptr,                  0 }},
			{ PipelineType::BoxFilter5x5, { nullptr,                  0 }},
			{ PipelineType::RadiusBlur,   { nullptr,                  0 }},
			{ PipelineType::OutLine,      { nullptr,                  0 }},
			{ PipelineType::ShatterGlass, { nullptr,                  0 }},
		};
	}();
}



///-------------------------------------------/// 
/// InputLayoutã®ç”Ÿæˆ
///-------------------------------------------///
void InputLayout::Create(PipelineType Type) {

	auto it = kLayoutTable_.find(Type);
	if (it != kLayoutTable_.end()) {
		inputLayoutDesc_.pInputElementDescs = it->second.elements;
		inputLayoutDesc_.NumElements = it->second.numElements;
	} else {
		inputLayoutDesc_.pInputElementDescs = nullptr;
		inputLayoutDesc_.NumElements = 0;
	}
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
D3D12_INPUT_LAYOUT_DESC InputLayout::GetInputLayout() const { return inputLayoutDesc_; }


============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/InputLayout.h
============================================================
#pragma once
/// ===Include=== ///
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"

// c++
#include <d3d12.h>
#include <unordered_map>

///=====================================================/// 
/// InputLayout
///=====================================================///
class InputLayout {
public:

	InputLayout() = default;
	~InputLayout() = default;

	/// <summary>
	/// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="Type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Create(PipelineType Type);

	/// <summary>
	/// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å–å¾—
	/// </summary>
	/// <returns></returns>
	D3D12_INPUT_LAYOUT_DESC GetInputLayout()const;

private:

	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc_{}; // InputLayout
};


============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/RasterizerState.cpp
============================================================
#include "RasterizerState.h"

///-------------------------------------------/// 
/// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
///-------------------------------------------///
namespace {
	const std::unordered_map<PipelineType, D3D12_CULL_MODE> kCullModeTable_ = {
	{ PipelineType::ForGround2D,		D3D12_CULL_MODE_NONE },
	{ PipelineType::BackGround2D,		D3D12_CULL_MODE_NONE },
	{ PipelineType::BackGround2D,		D3D12_CULL_MODE_NONE },
	{ PipelineType::Obj3D,				D3D12_CULL_MODE_BACK },
	{ PipelineType::PrimitiveSkyBox,    D3D12_CULL_MODE_NONE },
	{ PipelineType::PrimitiveOcean,     D3D12_CULL_MODE_BACK },
	{ PipelineType::Particle,			D3D12_CULL_MODE_NONE },
	{ PipelineType::Skinning3D,			D3D12_CULL_MODE_BACK },
	{ PipelineType::Line3D,				D3D12_CULL_MODE_NONE },
	{ PipelineType::OffScreen,			D3D12_CULL_MODE_NONE },
	{ PipelineType::Grayscale,			D3D12_CULL_MODE_NONE },
	{ PipelineType::Vignette,			D3D12_CULL_MODE_NONE },
	{ PipelineType::Dissolve,			D3D12_CULL_MODE_NONE },
	{ PipelineType::BoxFilter3x3,		D3D12_CULL_MODE_NONE },
	{ PipelineType::BoxFilter5x5,		D3D12_CULL_MODE_NONE },
	{ PipelineType::RadiusBlur,			D3D12_CULL_MODE_NONE },
	{ PipelineType::OutLine,			D3D12_CULL_MODE_NONE },
	{ PipelineType::ShatterGlass,		D3D12_CULL_MODE_NONE },
	};
}

///-------------------------------------------/// 
/// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆ
///-------------------------------------------///
void RasterizerState::Create(PipelineType Type) {
	// CullModeã‚’ãƒ†ãƒ¼ãƒ–ãƒ«ã‹ã‚‰å–å¾—
	auto it = kCullModeTable_.find(Type);
	if (it != kCullModeTable_.end()) {
		rasterizerDesc_.CullMode = it->second;
	} else {
		rasterizerDesc_.CullMode = D3D12_CULL_MODE_NONE; // fallback
	}
	
	// ä¸‰è§’å½¢ã®ä¸­ã‚’å¡—ã‚Šã¤ã¶ã™
	rasterizerDesc_.FillMode = D3D12_FILL_MODE_SOLID; // å…¨ã¦å…±é€šã®è¨­å®š
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
D3D12_RASTERIZER_DESC RasterizerState::GetRasterizerState()const { return rasterizerDesc_; }

============================================================
File Path: Project/Engine/Graphics/Pipeline/GS/RasterizerState.h
============================================================
#pragma once
/// ===Include=== ///
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"
// directX
#include <d3d12.h>
#include <unordered_map>

///=====================================================/// 
/// RasterizerState
///=====================================================///
class RasterizerState {
public:

	RasterizerState() = default;
	~RasterizerState() = default;

	/// <summary>
	/// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="Type">ä½œæˆã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Create(PipelineType Type);

	/// <summary>
	/// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã‚¹ãƒ†ãƒ¼ãƒˆã®å–å¾—
	/// </summary>
	/// <returns></returns>
	D3D12_RASTERIZER_DESC GetRasterizerState()const;

private:
	// RasterizerState
	D3D12_RASTERIZER_DESC rasterizerDesc_{}; 
};


============================================================
File Path: Project/Engine/Graphics/Pipeline/PSOBase.cpp
============================================================
#include "PSOBase.h"


============================================================
File Path: Project/Engine/Graphics/Pipeline/PSOBase.h
============================================================
#pragma once
/// ===include=== ///
// PipelineType
#include "Engine/DataInfo/PipelineStateObjectType.h"
// c++
#include <memory>
#include <array>
#include <cassert>
// directX
#include <d3d12.h>
#include <dxgidebug.h>
#include <dxgi1_6.h>
#include <dxcapi.h>

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;
class Compiler;

///=====================================================/// 
/// PipelineStateObjectBase
///=====================================================///
class PSOBase {
public:
	
	virtual ~PSOBase() = default;


};



============================================================
File Path: Project/Engine/Scene/AbstractSceneFactory.cpp
============================================================
#include "AbstractSceneFactory.h"


============================================================
File Path: Project/Engine/Scene/AbstractSceneFactory.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/IScene.h"
#include "Engine/DataInfo/SceneType.h"
#include <memory>
#include <string>

///=====================================================/// 
/// ã‚·ãƒ¼ãƒ³å·¥å ´ï¼ˆæ¦‚å¿µï¼‰
///=====================================================///
class AbstractSceneFactory {
public:
	
	virtual ~AbstractSceneFactory() = default;
	
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆå‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="type">ã‚·ãƒ¼ãƒ³ã®ç¨®é¡</param>
	/// <returns>ISceneã‚’è¿”ã™</returns>
	virtual std::unique_ptr<IScene> CreateScene(SceneType type) = 0;
};



============================================================
File Path: Project/Engine/Scene/Debug/ParticleEditorScene.cpp
============================================================
#include "ParticleEditorScene.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"
// Service
#include "Engine/System/Service/ParticleService.h"
#include "Engine/System/Service/DeltaTimeSevice.h"
#ifdef USE_IMGUI
// ImGui
#include <imgui.h>
#endif // USE_IMGUI

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ParticleEditorScene::~ParticleEditorScene() {
	particleEditor_.reset();
	// ISceneã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	IScene::~IScene();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ParticleEditorScene::Initialize() {
	// ISceneã®åˆæœŸåŒ–(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã¨ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£)
	IScene::Initialize();

	/// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®åˆæœŸåŒ–=== ///
	particleEditor_ = std::make_unique<ParticleEditor>();
	particleEditor_->Initialize();
	particleEditor_->SetVisible(true);

	/// ===Line=== ///
	line_ = std::make_unique<Line>();

	/// ===ã‚«ãƒ¡ãƒ©ã®åˆæœŸè¨­å®š=== ///
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’è¨­å®š
	// camera_->SetTranslate(cameraPosition_);
	// camera_->SetRotate(cameraRotation_);
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void ParticleEditorScene::Update() {
	/// ===ã‚«ãƒ¡ãƒ©ã®æ›´æ–°=== ///
	//UpdateCamera();

	/// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®æ›´æ–°=== ///
	if (particleEditor_) {
		particleEditor_->Update();
	}

	/// ===ImGuiæç”»=== ///
#ifdef USE_IMGUI
	//RenderMenuBar();
	defaultCamera_->ImGuiUpdate();

	// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
	particleEditor_->Render();

	// ã‚µãƒ–ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
	/*if (showHelp_) {
		RenderHelpWindow();
	}
	if (showStats_) {
		RenderStatsWindow();
	}*/

	//RenderCameraControl();
#endif // USE_IMGUI

	/// ===ISceneã®æ›´æ–°=== ///
	IScene::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ParticleEditorScene::Draw() {
	/// ===ã‚°ãƒªãƒƒãƒ‰ã®æç”»=== ///
	line_->DrawGrid({ 0.0f, 0.0f, 0.0f }, { 500.0f, 0.0f, 500.0f }, 100, { 1.0f, 1.0f, 1.0f, 1.0f });

	/// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®æç”»=== ///
	if (particleEditor_) {
		particleEditor_->DrawPreview();
	}

	/// ===ISceneã®æç”»=== ///
	IScene::Draw();
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
///-------------------------------------------///
void ParticleEditorScene::RenderMenuBar() {
#ifdef USE_IMGUI
	if (ImGui::BeginMainMenuBar()) {
		if (ImGui::BeginMenu("ãƒ•ã‚¡ã‚¤ãƒ«")) {
			if (ImGui::MenuItem("æ–°è¦ä½œæˆ", "Ctrl+N")) {
				// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®æ–°è¦ä½œæˆæ©Ÿèƒ½ã‚’å‘¼ã³å‡ºã—
			}
			if (ImGui::MenuItem("é–‹ã", "Ctrl+O")) {
				// é–‹ãå‡¦ç†
			}
			if (ImGui::MenuItem("ä¿å­˜", "Ctrl+S")) {
				// ä¿å­˜å‡¦ç†
			}
			ImGui::Separator();
			if (ImGui::MenuItem("çµ‚äº†", "Alt+F4")) {
				// ã‚·ãƒ¼ãƒ³é·ç§»ãªã©ã®çµ‚äº†å‡¦ç†
			}
			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu("è¡¨ç¤º")) {
			bool editorVisible = particleEditor_ ? particleEditor_->IsVisible() : false;
			if (ImGui::MenuItem("ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼", nullptr, &editorVisible)) {
				if (particleEditor_) {
					particleEditor_->SetVisible(editorVisible);
				}
			}
			ImGui::MenuItem("çµ±è¨ˆæƒ…å ±", nullptr, &showStats_);
			ImGui::MenuItem("ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«", nullptr, nullptr);
			ImGui::MenuItem("ã‚°ãƒªãƒƒãƒ‰", nullptr, &showGrid_);
			ImGui::EndMenu();
		}

		if (ImGui::BeginMenu("ãƒ˜ãƒ«ãƒ—")) {
			if (ImGui::MenuItem("ä½¿ã„æ–¹")) {
				showHelp_ = true;
			}
			ImGui::Separator();
			if (ImGui::MenuItem("ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±")) {
				// ãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±è¡¨ç¤º
			}
			ImGui::EndMenu();
		}

		ImGui::EndMainMenuBar();
	}
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ˜ãƒ«ãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
///-------------------------------------------///
void ParticleEditorScene::RenderHelpWindow() {
#ifdef USE_IMGUI
	ImGui::Begin("ä½¿ã„æ–¹", &showHelp_);

	ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®ä½¿ã„æ–¹");
	ImGui::Separator();

	ImGui::Text("â–  åŸºæœ¬æ“ä½œ");
	ImGui::BulletText("å·¦å´ã®ã‚¿ãƒ–ã§å„ç¨®è¨­å®šã‚’èª¿æ•´ã§ãã¾ã™");
	ImGui::BulletText("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒœã‚¿ãƒ³ã§åŠ¹æœã‚’ç¢ºèªã§ãã¾ã™");
	ImGui::BulletText("ä¿å­˜ãƒœã‚¿ãƒ³ã§JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã•ã‚Œã¾ã™");

	ImGui::Spacing();
	ImGui::Text("â–  ã‚¿ãƒ–ã®èª¬æ˜");
	ImGui::BulletText("åŸºæœ¬è¨­å®š: åå‰ã€ãƒ¢ãƒ‡ãƒ«ã€å½¢çŠ¶ãªã©ã®åŸºæœ¬ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿");
	ImGui::BulletText("ç‰©ç†è¨­å®š: é‡åŠ›ã€é€Ÿåº¦ã€çˆ†ç™ºåŠå¾„ãªã©ã®ç‰©ç†æŒ™å‹•");
	ImGui::BulletText("è¦‹ãŸç›®è¨­å®š: è‰²ã€ã‚¹ã‚±ãƒ¼ãƒ«ã€ãƒ†ã‚¯ã‚¹ãƒãƒ£ãªã©ã®è¦–è¦šåŠ¹æœ");
	ImGui::BulletText("å›è»¢è¨­å®š: ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å›è»¢ã«é–¢ã™ã‚‹è¨­å®š");
	ImGui::BulletText("ç™ºç”Ÿè¨­å®š: å¯¿å‘½ã€ç™ºç”Ÿãƒ¬ãƒ¼ãƒˆã€ãƒãƒ¼ã‚¹ãƒˆãªã©ã®ç™ºç”Ÿãƒ‘ã‚¿ãƒ¼ãƒ³");

	ImGui::Spacing();
	ImGui::Text("â–  ã‚«ãƒ¡ãƒ©æ“ä½œ");
	ImGui::BulletText("WASDã‚­ãƒ¼: ã‚«ãƒ¡ãƒ©ã®ç§»å‹•");
	ImGui::BulletText("çŸ¢å°ã‚­ãƒ¼: ã‚«ãƒ¡ãƒ©ã®å›è»¢");
	ImGui::BulletText("ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§è©³ç´°è¨­å®šå¯èƒ½");

	ImGui::Spacing();
	ImGui::Text("â–  ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ");
	ImGui::BulletText("Ctrl+N: æ–°è¦ä½œæˆ");
	ImGui::BulletText("Ctrl+S: ä¿å­˜");
	ImGui::BulletText("Ctrl+O: é–‹ã");
	ImGui::BulletText("Space: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿ/åœæ­¢");

	ImGui::Spacing();
	ImGui::Separator();
	if (ImGui::Button("é–‰ã˜ã‚‹", ImVec2(120, 30))) {
		showHelp_ = false;
	}

	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// çµ±è¨ˆæƒ…å ±ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
///-------------------------------------------///
void ParticleEditorScene::RenderStatsWindow() {
#ifdef USE_IMGUI
	ImGui::Begin("çµ±è¨ˆæƒ…å ±", &showStats_);

	// FPSè¡¨ç¤º
	float deltaTime = DeltaTimeSevice::GetDeltaTime();
	float fps = 1.0f / deltaTime;
	ImGui::Text("FPS: %.1f", fps);
	ImGui::Text("ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ : %.3f ms", deltaTime * 1000.0f);

	ImGui::Separator();

	// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ä¸€è¦§
	ImGui::Text("ç™»éŒ²æ¸ˆã¿ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«:");
	std::vector<std::string> names = ParticleService::GetDefinitionNames();
	if (names.empty()) {
		ImGui::TextDisabled("ï¼ˆãªã—ï¼‰");
	} else {
		for (const auto& name : names) {
			ImGui::BulletText("%s", name.c_str());
			ImGui::Indent();

			// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚°ãƒ«ãƒ¼ãƒ—æ•°ã¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°
			size_t groupCount = ParticleService::GetActiveGroupCount(name);
			uint32_t particleCount = ParticleService::GetActiveParticleCount(name);

			ImGui::Text("ã‚°ãƒ«ãƒ¼ãƒ—æ•°: %zu", groupCount);
			ImGui::Text("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°: %u", particleCount);

			ImGui::Unindent();
		}
	}

	ImGui::Separator();

	// ã‚«ãƒ¡ãƒ©æƒ…å ±
	ImGui::Text("ã‚«ãƒ¡ãƒ©ä½ç½®:");
	ImGui::Text("  X: %.2f, Y: %.2f, Z: %.2f",
		cameraPosition_.x, cameraPosition_.y, cameraPosition_.z);
	ImGui::Text("ã‚«ãƒ¡ãƒ©å›è»¢:");
	ImGui::Text("  X: %.2f, Y: %.2f, Z: %.2f",
		cameraRotation_.x, cameraRotation_.y, cameraRotation_.z);

	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
///-------------------------------------------///
void ParticleEditorScene::RenderCameraControl() {
#ifdef USE_IMGUI
	ImGui::Begin("ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«");

	ImGui::Text("ã‚«ãƒ¡ãƒ©è¨­å®š");
	ImGui::Separator();

	// ä½ç½®
	if (ImGui::DragFloat3("ä½ç½®", &cameraPosition_.x, 0.1f)) {
		// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’æ›´æ–°
		// camera_->SetTranslate(cameraPosition_);
	}

	// å›è»¢
	if (ImGui::DragFloat3("å›è»¢", &cameraRotation_.x, 0.01f)) {
		// ã‚«ãƒ¡ãƒ©å›è»¢ã‚’æ›´æ–°
		// camera_->SetRotate(cameraRotation_);
	}

	ImGui::Spacing();

	// é€Ÿåº¦è¨­å®š
	ImGui::DragFloat("ç§»å‹•é€Ÿåº¦", &cameraSpeed_, 0.01f, 0.01f, 1.0f);
	ImGui::DragFloat("å›è»¢é€Ÿåº¦", &cameraRotationSpeed_, 0.001f, 0.001f, 0.1f);

	ImGui::Spacing();
	ImGui::Separator();

	// ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
	if (ImGui::Button("ã‚«ãƒ¡ãƒ©ã‚’ãƒªã‚»ãƒƒãƒˆ", ImVec2(150, 30))) {
		cameraPosition_ = { 0.0f, 5.0f, -10.0f };
		cameraRotation_ = { 0.3f, 0.0f, 0.0f };
		// camera_->SetTranslate(cameraPosition_);
		// camera_->SetRotate(cameraRotation_);
	}

	ImGui::Spacing();
	ImGui::TextDisabled("WASDã‚­ãƒ¼: ç§»å‹•");
	ImGui::TextDisabled("çŸ¢å°ã‚­ãƒ¼: å›è»¢");
	ImGui::TextDisabled("QE: ä¸Šä¸‹ç§»å‹•");

	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
///-------------------------------------------///
void ParticleEditorScene::UpdateCamera() {
	// TODO: å…¥åŠ›å‡¦ç†ã®å®Ÿè£…
	// Input::IsPress()ãªã©ã‚’ä½¿ç”¨ã—ã¦ã‚«ãƒ¡ãƒ©ã‚’æ“ä½œ

	/*
	// WASDç§»å‹•
	if (Input::IsPress(Key::W)) {
		cameraPosition_.z += cameraSpeed_;
	}
	if (Input::IsPress(Key::S)) {
		cameraPosition_.z -= cameraSpeed_;
	}
	if (Input::IsPress(Key::A)) {
		cameraPosition_.x -= cameraSpeed_;
	}
	if (Input::IsPress(Key::D)) {
		cameraPosition_.x += cameraSpeed_;
	}

	// QEä¸Šä¸‹ç§»å‹•
	if (Input::IsPress(Key::Q)) {
		cameraPosition_.y -= cameraSpeed_;
	}
	if (Input::IsPress(Key::E)) {
		cameraPosition_.y += cameraSpeed_;
	}

	// çŸ¢å°ã‚­ãƒ¼ã§å›è»¢
	if (Input::IsPress(Key::Up)) {
		cameraRotation_.x += cameraRotationSpeed_;
	}
	if (Input::IsPress(Key::Down)) {
		cameraRotation_.x -= cameraRotationSpeed_;
	}
	if (Input::IsPress(Key::Left)) {
		cameraRotation_.y -= cameraRotationSpeed_;
	}
	if (Input::IsPress(Key::Right)) {
		cameraRotation_.y += cameraRotationSpeed_;
	}

	// ã‚«ãƒ¡ãƒ©ã«åæ˜ 
	camera_->SetTranslate(cameraPosition_);
	camera_->SetRotate(cameraRotation_);
	*/
}

============================================================
File Path: Project/Engine/Scene/Debug/ParticleEditorScene.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/IScene.h"
// Editor
#include "Engine/System/Editor/ParticleEditor.h"
// Line
#include "application/Drawing/3d/Line.h"
// c++
#include <memory>

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚·ãƒ¼ãƒ³
///=====================================================///
class ParticleEditorScene : public IScene {
public:

	ParticleEditorScene() = default;
	~ParticleEditorScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw() override;

private:
	/// ===Line=== ///
	std::unique_ptr<Line> line_;
	/// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼=== ///
	std::unique_ptr<ParticleEditor> particleEditor_;

	/// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼è¨­å®š=== ///
	bool showHelp_ = false;              // ãƒ˜ãƒ«ãƒ—è¡¨ç¤ºãƒ•ãƒ©ã‚°
	bool showStats_ = true;              // çµ±è¨ˆæƒ…å ±è¡¨ç¤ºãƒ•ãƒ©ã‚°
	bool showGrid_ = true;               // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºãƒ•ãƒ©ã‚°

	/// ===ã‚«ãƒ¡ãƒ©åˆ¶å¾¡=== ///
	Vector3 cameraPosition_ = { 0.0f, 5.0f, -10.0f };
	Vector3 cameraRotation_ = { 0.3f, 0.0f, 0.0f };
	float cameraSpeed_ = 0.1f;
	float cameraRotationSpeed_ = 0.02f;

private:

	/// <summary>
	/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
	/// </summary>
	void RenderMenuBar();

	/// <summary>
	/// ãƒ˜ãƒ«ãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
	/// </summary>
	void RenderHelpWindow();

	/// <summary>
	/// çµ±è¨ˆæƒ…å ±ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
	/// </summary>
	void RenderStatsWindow();

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
	/// </summary>
	void RenderCameraControl();

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	/// </summary>
	void UpdateCamera();
};

============================================================
File Path: Project/Engine/Scene/Framework.cpp
============================================================
#include "Framework.h"
// Service
#include "Engine/System/Service/ServiceLocator.h"

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Framework::Initialize(const wchar_t* title) {
	/// ===åˆæœŸåŒ–=== ///
	// MiiEngine
	MiiEngine_ = std::make_unique<Mii>();
	MiiEngine_->Initialize(title, 1280, 720);
	// CameraManager
	cameraManager_ = std::make_unique<CameraManager>();
	// ParticleManager
	particleManager_ = std::make_unique<ParticleManager>();
	// ColliderManager
	colliderManager_ = std::make_unique<ColliderManager>();
	colliderManager_->Initialize();
	// DeltaTime
	deltaTime_ = std::make_unique<DeltaTime>();

	// ServiceLocator
	ServiceLocator::ProvideAll({
		MiiEngine_->GetWinApp(),
		MiiEngine_->GetDXCommon(),
		MiiEngine_->GetSRVManager(),
		MiiEngine_->GetRTVManager(),
		MiiEngine_->GetDSVManager(),
		MiiEngine_->GetPipelineManager(),
		MiiEngine_->GetTextureManager(),
		MiiEngine_->GetModelManager(),
		MiiEngine_->GetAnimationManager(),
		MiiEngine_->GetOffScreenRenderer(),
		MiiEngine_->GetAudioManager(),
		MiiEngine_->GetCSVManager(),
		MiiEngine_->GetLevelManager(),
		MiiEngine_->GetLineObject3D(),
		MiiEngine_->GetKeyboard(),
		MiiEngine_->GetMouse(),
		MiiEngine_->GetController(),
		cameraManager_.get(),
		particleManager_.get(),
		colliderManager_.get(),
		deltaTime_.get()
		}
	);
}

///-------------------------------------------/// 
/// çµ‚äº†
///-------------------------------------------///
void Framework::Finalize() {
	/// ===çµ‚äº†å‡¦ç†=== ///
	// ã‚µãƒ¼ãƒ“ã‚¹ãƒ­ã‚±ãƒ¼ã‚¿
	ServiceLocator::Finalize();
	// CameraManager
	cameraManager_.reset();
	// ParticleManager
	particleManager_.reset();
	// ColliderManager
	colliderManager_.reset();
	// MiiEngine
	MiiEngine_->Finalize();
	MiiEngine_.reset();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Framework::Update() {
	/// ===ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°å‡¦ç†=== ///
	// MiiEngine
	MiiEngine_->Update();
	// ParticleManager
	particleManager_->Update();
	// CameraManager
	cameraManager_->UpdateAllCameras();
	// ColliderManager
	colliderManager_->CheckAllCollisions();
}

///-------------------------------------------/// 
/// çµ‚äº†ãƒã‚§ãƒƒã‚¯
///-------------------------------------------///
bool Framework::IsEndRequest() { return endRequest_; }

///-------------------------------------------/// 
/// å®Ÿè¡Œ
///-------------------------------------------///
void Framework::Run(const wchar_t* title) {
	/// ===ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–=== ///
	Initialize(title);
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®xãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã‚‹ã¾ã§ãƒ«ãƒ¼ãƒ—
	while (MiiEngine_->ProcessMessage() == 0) {
		/// ===æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°=== ///
		Update();
		/// ===çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒæ¥ãŸã‚‰æŠœã‘ã‚‹=== ///
		if (IsEndRequest()) { break; }
		/// ===æç”»=== ///
		Draw();
	}
	/// ===ã‚²ãƒ¼ãƒ çµ‚äº†=== ///
	Finalize();
}

///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void Framework::PreDraw() {
	// ãƒ•ãƒ¬ãƒ¼ãƒ ã®é–‹å§‹
	MiiEngine_->BeginFrame();
}

///-------------------------------------------/// 
/// æç”»å¾Œå‡¦ç†
///-------------------------------------------///
void Framework::PostDraw() {
	// ParticleManager
	particleManager_->Draw(BlendMode::kBlendModeAdd);

	// ãƒ•ãƒ¬ãƒ¼ãƒ ã®çµ‚äº†
	MiiEngine_->EndFrame();
}


============================================================
File Path: Project/Engine/Scene/Framework.h
============================================================
#pragma once
/// ===Include=== ///
// MiiEngine
#include "Engine/Core/Mii.h"
// SceneFactory
#include "Engine/Scene/AbstractSceneFactory.h"
// CameraManager
#include "Engine/System/Managers/CameraManager.h"
// ParticleManager
#include "Engine/System/Managers/ParticleManager.h"
// ColliderManager
#include "Engine/System/Managers/ColliderManager.h"
// DeltaTime
#include "Engine/System/DeltraTime/DeltaTime.h"
// ï½ƒ++
#include <memory>

///=====================================================/// 
/// ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
///=====================================================///
class Framework {
public:/// ====== ///

	Framework() = default;
	virtual ~Framework() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="title">ã‚¿ã‚¤ãƒˆãƒ«ã®åå‰</param>
	virtual void Initialize(const wchar_t* title);
	
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	virtual void Finalize();

	/// <summary>
	/// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°
	/// </summary>
	virtual void Update();

	/// <summary>
	/// æç”»å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	virtual void Draw() = 0;
	// çµ‚äº†ãƒ•ãƒ©ã‚°ã®ãƒã‚§ãƒƒã‚¯
	virtual bool IsEndRequest();

public:/// ===ãƒ¡ãƒ³ãƒé–¢æ•°=== ///
	/// <summary>
	/// å®Ÿè¡Œå‡¦ç†
	/// </summary>
	/// <param name="title">ã‚¿ã‚¤ãƒˆãƒ«ã®åå‰</param>
	void Run(const wchar_t* title);
	
	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	void PreDraw();
	
	/// <summary>
	/// æç”»å¾Œå‡¦ç†
	/// </summary>
	void PostDraw();

private:
	// MiiEngine
	std::unique_ptr<Mii> MiiEngine_;
	// CameraManager
	std::unique_ptr<CameraManager> cameraManager_;
	// ParticleManager
	std::unique_ptr<ParticleManager> particleManager_;
	// ColliderManager
	std::unique_ptr<ColliderManager> colliderManager_;
	// DeltaTime
	std::unique_ptr<DeltaTime> deltaTime_;
protected:
	// ã‚²ãƒ¼ãƒ çµ‚äº†ãƒ•ãƒ©ã‚°
	bool endRequest_ = false;
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	std::unique_ptr<AbstractSceneFactory> sceneFactory_;
};



============================================================
File Path: Project/Engine/Scene/IScene.cpp
============================================================
#include "IScene.h"
// Service
#include "Engine/System/Service/ServiceLocator.h"
#include "Engine/System/Service/CameraService.h"
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Loader.h"
// Object3d
#include "Engine/Graphics/3d/Model/Model.h"
// Line
#include "Engine/Graphics/3d/Line/LineObject3D.h"
// Math
#include "Math/sMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
IScene::~IScene() {
	defaultCamera_.reset();
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void IScene::SetSceneManager(SceneManager* sceneManager) { sceneManager_ = sceneManager; }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void IScene::Initialize() {

	/// ===ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®ç”Ÿæˆ=== ///
	defaultCamera_ = std::make_shared<GameCamera>();
	defaultCamera_->Init(CameraType::Normal);
	defaultCamera_->SetTranslate({ 0.0f, 0.0f, -50.0f });
	defaultCamera_->SetRotate({ 0.0f, 0.0f, 0.0f });

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®è¨­å®š
	CameraService::AddCamera("Default", defaultCamera_);
	CameraService::SetActiveCamera("Default");
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void IScene::Update() {

	// Lineæ›´æ–°
	ServiceLocator::GetLineObject3D()->Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void IScene::Draw() {

	// Lineã®æç”»
	ServiceLocator::GetLineObject3D()->Draw();
}





============================================================
File Path: Project/Engine/Scene/IScene.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Game/Camera/GameCamera.h"
#include "Engine/DataInfo/LevelData.h"
#include "Engine/DataInfo/BlendModeData.h"

#include <vector>

/// ===å‰æ–¹å®£è¨€=== ///
class SceneManager;
class Model;

///=====================================================/// 
/// ã‚·ãƒ¼ãƒ³ã®åŸºåº•ã‚¯ãƒ©ã‚¹
///=====================================================///
class IScene {
public:

	IScene() = default;
	virtual ~IScene();

	virtual void Initialize();
	virtual void Update();
	virtual void Draw();

public:/// ===Setter=== ///
	// SceneManager
	void SetSceneManager(SceneManager* sceneManager);

protected:

	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£
	SceneManager* sceneManager_ = nullptr;
	// Camera
	std::shared_ptr<GameCamera> defaultCamera_;
};



============================================================
File Path: Project/Engine/Scene/MyGame.cpp
============================================================
#include "MyGame.h"
// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
#include "Engine/Scene/SceneFactory.h"
// Service
#include "Engine/System/Service/Loader.h"
#include "Engine/System/Service/ParticleService.h"
// Logger
#include "Engine/Core/Logger.h"
// c++
#include <iostream>
#include <thread>
#include <chrono>

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
MyGame::MyGame() = default;
MyGame::~MyGame() {
	sceneFactory_.reset();
	sceneManager_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void MyGame::Initialize(const wchar_t* title) {
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®åˆæœŸåŒ–
	Framework::Initialize(title);
	
	/// ===æ™‚é–“è¨ˆæ¸¬=== ///
	auto start = std::chrono::high_resolution_clock::now();

	/// ===èª­ã¿è¾¼ã¿å‡¦ç†=== ///
	// å„èª­ã¿è¾¼ã¿å‡¦ç†ç”¨ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ç”Ÿæˆ
	LoadTexture(); // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿ã¯ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ¬ãƒƒãƒ‰ã§å®Ÿè¡Œ
	std::vector<std::thread> loadingThreads;
	loadingThreads.emplace_back([this] { LoadAudio(); });     // Soundã®èª­ã¿è¾¼ã¿
	loadingThreads.emplace_back([this] { LoadModel(); });	  // ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿
	loadingThreads.emplace_back([this] { LoadAnimation(); }); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®èª­ã¿è¾¼ã¿
	loadingThreads.emplace_back([this] { LoadJson(); });	  // Jsonãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	// ã™ã¹ã¦ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã®çµ‚äº†ã‚’å¾…æ©Ÿ
	for (auto& thread : loadingThreads) {
		thread.join();
	}

	// å‡¦ç†æ™‚é–“ã‚’è¨ˆæ¸¬ï¼ˆendï¼‰
	auto end = std::chrono::high_resolution_clock::now();
	// çµŒéæ™‚é–“ã‚’ãƒŸãƒªç§’å˜ä½ã§å‡ºåŠ›
	auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
	Log("time: " + std::to_string(duration.count()) + " ms\n");

	/// ===ã‚·ãƒ¼ãƒ³ã®ä½œæˆ=== ///
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ
	sceneFactory_ = std::make_unique<SceneFactory>();
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
	sceneManager_ = std::make_unique<SceneManager>();
	sceneManager_->Initialize(sceneFactory_.get());
	sceneManager_->ChangeScene(SceneType::Title);   //ã€€ã‚¹ã‚¿ãƒ¼ãƒˆã‚·ãƒ¼ãƒ³ã®è¨­å®š
}
 
///-------------------------------------------/// 
/// çµ‚äº†å‡¦ç†
///-------------------------------------------///
void MyGame::Finalize() {
	// ã‚·ãƒ¼ãƒ³ã®è§£æ”¾å‡¦ç†
	sceneManager_.reset();
	sceneFactory_.reset();
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®çµ‚äº†å‡¦ç†
	Framework::Finalize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void MyGame::Update() {
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã®æ›´æ–°å‡¦ç†
	Framework::Update();
	// ã‚·ãƒ¼ãƒ³ã®æ›´æ–°
	sceneManager_->Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void MyGame::Draw() {
	// æç”»å‰å‡¦ç†
	Framework::PreDraw();
	// ã‚·ãƒ¼ãƒ³ã®æç”»
	sceneManager_->Draw();
	// æç”»å¾Œå‡¦ç†
	Framework::PostDraw();
}


///-------------------------------------------/// 
/// Soundã®èª­ã¿è¾¼ã¿é–¢æ•°
///-------------------------------------------///
void MyGame::LoadAudio() {
#pragma region Wave
	Loader::LoadWave("fanfare", "fanfare.wav");
#pragma endregion
#pragma region MP3
	Loader::LoadMP3("clear", "clear.mp3");
#pragma endregion
}

///-------------------------------------------/// 
///	ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿å‡¦ç†
///-------------------------------------------///
void MyGame::LoadTexture() {
	/// ===Engine=== ///
	Loader::LoadTexture("uvChecker", "uvChecker.png");
	Loader::LoadTexture("monsterBall", "monsterBall.png");
	Loader::LoadTexture("White", "WhiteTexture.png");
	// Particle
	Loader::LoadTexture("circle", "Particle/circle.png");
	Loader::LoadTexture("circle2", "Particle/circle2.png");
	Loader::LoadTexture("gradationLine", "Particle/gradationLine.png");
	Loader::LoadTexture("Spark", "Particle/Spark.png");
	Loader::LoadTexture("FlameEye", "Particle/FlameEye.png");
	Loader::LoadTexture("Fire", "Particle/Fire.png");
	// OffScreen
	Loader::LoadTexture("noise0", "OffScreen/noise0.png");
	Loader::LoadTexture("noise1", "OffScreen/noise1.png");
	// DDS
	Loader::LoadTexture("skyBox", "DDS/rostock_laage_airport_4k.dds");

	/// ===Game=== ///
	// TitleUI
	Loader::LoadTexture("TitleBG", "TitleUI/SkyBG.png");
	Loader::LoadTexture("TitleBGKiri", "TitleUI/BGsecond.png");
	Loader::LoadTexture("Title", "TitleUI/Title.png");
	Loader::LoadTexture("Start", "TitleUI/Start.png");
	Loader::LoadTexture("Option", "TitleUI/Option.png");
	Loader::LoadTexture("Exit", "TitleUI/Exit.png");
	Loader::LoadTexture("OverLay", "TitleUI/OverLay.png");
	// GameUI
	Loader::LoadTexture("MoveUI", "GameUI/MoveUI.png");
	Loader::LoadTexture("CameraUI", "GameUI/CameraUI.png");
	Loader::LoadTexture("AttackUI", "GameUI/AttackUI.png");
	Loader::LoadTexture("AvoidanceUI", "GameUI/AvoidanceUI.png");
	Loader::LoadTexture("xButton", "GameUI/xbox_button_color_x.png");
	Loader::LoadTexture("aButton", "GameUI/xbox_button_color_a.png");
	Loader::LoadTexture("leftStick", "GameUI/xbox_stick_l.png");
	Loader::LoadTexture("rightStick", "GameUI/xbox_stick_r.png");
	// GameAnimation
	Loader::LoadTexture("GameOverAnimation", "Animation/GameOverAnimation.png");
}

///-------------------------------------------/// 
/// ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
///-------------------------------------------///
void MyGame::LoadModel() {
	/// ===Engine=== ///
	Loader::LoadModel("MonsterBall", "MonsterBall/MonsterBall.obj");
	Loader::LoadModel("terrain", "terrain/terrain.obj");
	// Particle
	Loader::LoadModel("plane", "Particle/Plane/ParticlePlane.gltf");
	Loader::LoadModel("sphere", "Particle/Sphere/ParticleSphere.obj");
	Loader::LoadModel("cube", "Particle/Cube/ParticleCube.obj");
	Loader::LoadModel("triangle", "Particle/Triangle/ParticleTriangle.obj");
	
	/// ===Game=== ///
	Loader::LoadModel("player", "player/player.gltf");
	Loader::LoadModel("Ground", "Ground/Ground.obj");
	Loader::LoadModel("Object1", "Object1/Object1.obj");
	Loader::LoadModel("Object2", "Object2/Object2.obj");
	Loader::LoadModel("PlayerWeapon", "PlayerWeapon/PlayerWeapon.obj");
}

///-------------------------------------------/// 
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
///-------------------------------------------///
void MyGame::LoadAnimation() {
	/// ===Engine=== ///
	Loader::LoadAnimation("simpleSkin", "simpleSkin/simpleSkin.gltf");
	Loader::LoadAnimation("human", "human/sneakWalk.gltf");
}

///-------------------------------------------/// 
/// Jsonãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿å‡¦ç†
///-------------------------------------------///
void MyGame::LoadJson() {
	/// ===Game=== ///
	Loader::LoadLevelJson("Level/StageData.json");
	Loader::LoadLevelJson("Level/EntityData.json");
}


============================================================
File Path: Project/Engine/Scene/MyGame.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/Scene/Framework.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"

///=====================================================/// 
/// ã‚²ãƒ¼ãƒ å…¨ä½“
///=====================================================///
class MyGame : public Framework {
public:

	MyGame();
	~MyGame();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="title">ã‚¿ã‚¤ãƒˆãƒ«ã®åå‰</param>
	void Initialize(const wchar_t* title) override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;

	/// <summary>
	/// æ¯ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw() override;

private:/// ====== ///

	/// ===ã‚·ãƒ¼ãƒ³=== ///
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£
	std::unique_ptr<SceneManager> sceneManager_;
private:
	/// ===Load=== ///
	
	/// <summary>
	/// Audioã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	void LoadAudio();

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	void LoadTexture();

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	void LoadModel();

	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	void LoadAnimation();

	/// <summary>
	/// Jsonãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	void LoadJson();
};



============================================================
File Path: Project/Engine/Scene/SceneFactory.cpp
============================================================
#include "SceneFactory.h"

// å„ã‚·ãƒ¼ãƒ³
#include "application/Scene/TitleScene.h"
#include "application/Scene/SelectScene.h"
#include "application/Scene/GameScene.h"
#include "application/Scene/ClearScene.h"
#include "application/Scene/GameOverScene.h"
#include "Engine/Scene/Debug/ParticleEditorScene.h"
#include "application/Scene/Debug/AttackEditorScene.h"

///-------------------------------------------/// 
/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
///-------------------------------------------///
std::unique_ptr<IScene> SceneFactory::CreateScene(SceneType type) {
	/// ===ã‚·ãƒ¼ãƒ³ã®åˆ¤æ–­=== ///
	if (type == SceneType::Title) {
		// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³
		return std::make_unique<TitleScene>();
	} else if (type == SceneType::Select) {
		// ã‚»ãƒ¬ã‚¯ãƒˆã‚·ãƒ¼ãƒ³
		return std::make_unique<SelectScene>();
	} else if (type == SceneType::Game) {
		//ã€€ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³
		return std::make_unique<GameScene>();
	} else if (type == SceneType::Clear) {
		//ã€€ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³
		return std::make_unique<ClearScene>();
	} else if (type == SceneType::GameOver) {
		//ã€€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
		return std::make_unique<GameOverScene>();
	} else if (type == SceneType::ParticleEditor) {
		// ç²’å­ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚·ãƒ¼ãƒ³
		return std::make_unique<ParticleEditorScene>();
	} else if (type == SceneType::AttackEditor) {
		// æ”»æ’ƒã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚·ãƒ¼ãƒ³
		return std::make_unique<AttackEditorScene>();
	}
	return nullptr;
}


============================================================
File Path: Project/Engine/Scene/SceneFactory.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/AbstractSceneFactory.h"

///=====================================================/// 
/// ã‚·ãƒ¼ãƒ³å·¥å ´
///=====================================================///
class SceneFactory : public AbstractSceneFactory {
public:
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="type">ã‚·ãƒ¼ãƒ³ã‚¿ã‚¤ãƒ—</param>
	/// <returns>ISceneã‚’è¿”ã™</returns>
	std::unique_ptr<IScene> CreateScene(SceneType type) override;
};



============================================================
File Path: Project/Engine/Scene/Transition/Base/SceneTransitionBase.cpp
============================================================
#include "SceneTransitionBase.h"
#include "Engine/System/Service/DeltaTimeSevice.h"

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
bool SceneTransitionBase::IsFading() const { return animation_.isPlaying; }
bool SceneTransitionBase::IsFinished() const { return animation_.isFinished; }
FadeState SceneTransitionBase::GetState() const { return currentState_; }

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹å‡¦ç†
///-------------------------------------------///
void SceneTransitionBase::StartFadeIn(float duration) {
	// è¨­å®š
	animation_.isPlaying = true;
	animation_.isFinished = false;
	animation_.currentTime = 0.0f;
	animation_.duration = duration;
	currentState_ = FadeState::FadeIn;
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹å‡¦ç†
///-------------------------------------------///
void SceneTransitionBase::StartFadeOut(float duration) {

	// è¨­å®š
	animation_.isPlaying = true;
	animation_.isFinished = false;
	animation_.currentTime = 0.0f;
	animation_.duration = duration;
	currentState_ = FadeState::FadeOut;
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void SceneTransitionBase::FadeInUpdate() {
	// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (!animation_.isPlaying || animation_.isFinished || currentState_ != FadeState::FadeIn) {
		return;
	}

	// çµŒéæ™‚é–“ã‚’åŠ ç®—
	animation_.currentTime += DeltaTimeSevice::GetDeltaTime();

	/// ===ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã®æ›´æ–°å‡¦ç†=== ///
	OnFadeInUpdate();
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void SceneTransitionBase::FadeOutUpdate() {
	// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (!animation_.isPlaying || animation_.isFinished || currentState_ != FadeState::FadeOut) {
		return;
	}

	// çµŒéæ™‚é–“ã‚’åŠ ç®—
	animation_.currentTime += DeltaTimeSevice::GetDeltaTime();

	/// ===ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®æ›´æ–°å‡¦ç†=== ///
	OnFadeOutUpdate();
}

///-------------------------------------------/// 
/// æç”»å‡¦ç†
///-------------------------------------------///
void SceneTransitionBase::Draw() {
	// åŸºåº•ã‚¯ãƒ©ã‚¹ã§ã¯ä½•ã‚‚ã—ãªã„
}

///-------------------------------------------/// 
/// ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void SceneTransitionBase::Reset() {
	animation_.isPlaying = false;
	animation_.isFinished = false;
	animation_.currentTime = 0.0f;
	animation_.duration = 1.2f;
	currentState_ = FadeState::None;
}


============================================================
File Path: Project/Engine/Scene/Transition/Base/SceneTransitionBase.h
============================================================
#pragma once
/// ===Include=== ///

/// ===å‰æ–¹å®£è¨€=== ///
enum class FadeState {
	None,
	FadeIn,
	FadeOut,
};

///=====================================================/// 
/// ã‚·ãƒ¼ãƒ³ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³åŸºåº•ã‚¯ãƒ©ã‚¹
///=====================================================///
class SceneTransitionBase {
public:

	virtual ~SceneTransitionBase() = default;

	/// <summary>
	/// æŒ‡å®šã—ãŸæ™‚é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’é–‹å§‹ã™ã‚‹
	/// </summary>
	/// <param name="duration">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰ã€‚</param>
	virtual void StartFadeIn(const float duration);

	/// <summary>
	/// æŒ‡å®šã—ãŸç¶™ç¶šæ™‚é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚’é–‹å§‹ã™ã‚‹
	/// </summary>
	/// <param name="duration">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰ã€‚</param>
	virtual void StartFadeOut(const float duration);

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã®æ›´æ–°å‡¦ç†ã‚’è¡Œã†ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	void FadeInUpdate();

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®æ›´æ–°å‡¦ç†ã‚’è¡Œã†ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	void FadeOutUpdate();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	virtual void Draw();

public: /// ===Getter=== ///

	// ãƒ•ã‚§ãƒ¼ãƒ‰ä¸­ã‹
	bool IsFading() const;
	// å®Œäº†ã—ãŸã‹
	bool IsFinished() const;
	// ç¾åœ¨ã®çŠ¶æ…‹
	FadeState GetState() const;

public:
	// ãƒªã‚»ãƒƒãƒˆ
	void Reset();

protected:

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡ç”¨æ§‹é€ ä½“
	struct TransitionData {
		bool isPlaying = false;
		bool isFinished = false;
		float currentTime = 0.0f;
		float duration = 1.2f;  // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç·æ™‚é–“
	};
	TransitionData animation_;

	// ãƒ•ã‚§ãƒ¼ãƒ‰
	FadeState currentState_ = FadeState::None;

protected:

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã®æ›´æ–°æ™‚ã«å‘¼ã³å‡ºã•ã‚Œã‚‹å‡¦ç†ã‚’è¡Œã†é–¢æ•°ã€‚
	/// </summary>
	virtual void OnFadeInUpdate() {};

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®é€²è¡Œã«å¿œã˜ãŸæ›´æ–°å‡¦ç†ã‚’è¡Œã„ã¾ã™ã€‚
	/// </summary>
	virtual void OnFadeOutUpdate() {};
};



============================================================
File Path: Project/Engine/Scene/Transition/SceneTransitionManager.cpp
============================================================
#include "SceneTransitionManager.h"
// Transition
#include "Engine/Scene/Transition/ShatterGlassTransition.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
SceneTransitionManager::~SceneTransitionManager() {
	currentTransition_.reset();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
bool SceneTransitionManager::IsFading() const {return currentTransition_->IsFading();}
bool SceneTransitionManager::IsFinished() const {return currentTransition_->IsFinished();}
TransitionType SceneTransitionManager::GetType() const { return currentType_; }
FadeState SceneTransitionManager::GetState() const {return currentTransition_->GetState();}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void SceneTransitionManager::Initialize() {
	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã®åˆæœŸåŒ–
	currentType_ = TransitionType::None;

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã®ä½œæˆ
	currentTransition_ = std::move(std::make_unique<SceneTransitionBase>());
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void SceneTransitionManager::Update() {
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³æ›´æ–°
	currentTransition_->FadeInUpdate();
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæ›´æ–°
	currentTransition_->FadeOutUpdate();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void SceneTransitionManager::Draw() {
	// æç”»
	currentTransition_->Draw();
}

///-------------------------------------------/// 
/// ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void SceneTransitionManager::Reset() {
	currentTransition_->Reset();
}

///-------------------------------------------/// 
/// NewMake
///-------------------------------------------///
void SceneTransitionManager::NewMake() {
	// æ—¢å­˜ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’ç ´æ£„
	currentTransition_.reset();
	// æ–°ã—ãä½œæˆ
	currentType_ = TransitionType::None;
	currentTransition_ = std::make_unique<SceneTransitionBase>();
}

///-------------------------------------------/// 
/// é·ç§»ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’é–‹å§‹
///-------------------------------------------///
void SceneTransitionManager::StartFadeIn(TransitionType type, const float duration) {
	// æ—¢å­˜ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’å¤‰æ›´
	CreateTransition(type);
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
	currentTransition_->StartFadeIn(duration);
}

///-------------------------------------------/// 
/// é·ç§»ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚’é–‹å§‹
///-------------------------------------------///
void SceneTransitionManager::StartFadeOut(TransitionType type, const float duration) {
	// æ—¢å­˜ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’å¤‰æ›´
	CreateTransition(type);
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
	currentTransition_->StartFadeOut(duration);
}

///-------------------------------------------/// 
/// æŒ‡å®šã—ãŸç¨®é¡ã®ã‚·ãƒ¼ãƒ³é·ç§»ã‚’ä½œæˆ
///-------------------------------------------///
void SceneTransitionManager::CreateTransition(TransitionType type) {
	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ãŒç•°ãªã‚‹å ´åˆã®ã¿ä½œæˆ
	if (currentType_ != type) {
		switch (type) {
		case TransitionType::ShatterGlass:
			// æ—¢å­˜ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’ç ´æ£„
			currentTransition_.reset();
			// æ–°ã—ã„ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚’ä½œæˆ
			currentTransition_ = std::move(std::make_unique<ShatterGlassTransition>());
			// ç¾åœ¨ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—ã‚’æ›´æ–°
			currentType_ = type;
			break;
		default:
			break;
		}
	}
}

============================================================
File Path: Project/Engine/Scene/Transition/SceneTransitionManager.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/Transition/Base/SceneTransitionBase.h"
// C++
#include <memory>
#include <functional>

/// ===ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—=== ///
enum class TransitionType {
	None,
	ShatterGlass,
};

///=====================================================/// 
/// ã‚·ãƒ¼ãƒ³ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£
///=====================================================///
class SceneTransitionManager {
public:

	SceneTransitionManager() = default;
	~SceneTransitionManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

	/// <summary>
	/// é·ç§»ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ï¼‰ã‚’é–‹å§‹ã™ã‚‹é–¢æ•°
	/// </summary>
	/// <param name="type">é–‹å§‹ã™ã‚‹é·ç§»ã®ç¨®é¡ã‚’ç¤ºã™å€¤ï¼ˆTransitionTypeï¼‰ã€‚</param>
	/// <param name="duration">é·ç§»ã«ã‹ã‹ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰ã€‚float å‹ã§æŒ‡å®šã™ã‚‹ã€‚</param>
	void StartFadeIn(TransitionType type, const float duration);

	/// <summary>
	/// æŒ‡å®šã—ãŸç¶™ç¶šæ™‚é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚’é–‹å§‹ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="duration">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰</param>
	void StartFadeOut(TransitionType type, const float duration);

public: /// ===Getter=== ///

	// ãƒ•ã‚§ãƒ¼ãƒ‰ä¸­ã‹
	bool IsFading() const;
	// å®Œäº†ã—ãŸã‹
	bool IsFinished() const;
	// ç¾åœ¨ã®ã‚¿ã‚¤ãƒ—
	TransitionType GetType() const;
	// ç¾åœ¨ã®çŠ¶æ…‹
	FadeState GetState() const;

public: /// ===Setter=== ///
	// ãƒªã‚»ãƒƒãƒˆ
	void Reset();
	// NewMake
	void NewMake();

private:

	// ç¾åœ¨ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã‚¿ã‚¤ãƒ—
	TransitionType currentType_ = TransitionType::None;

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
	std::unique_ptr<SceneTransitionBase> currentTransition_;

private:

	/// <summary>
	/// æŒ‡å®šã—ãŸç¨®é¡ã®ã‚·ãƒ¼ãƒ³é·ç§»ï¼ˆSceneTransitionBase æ´¾ç”Ÿï¼‰ã‚’ç”Ÿæˆã—ã€ãã®æ‰€æœ‰æ¨©ã‚’æŒã¤ std::unique_ptr ã‚’è¿”ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="type">ç”Ÿæˆã™ã‚‹ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™å€¤ï¼ˆTransitionTypeï¼‰ã€‚</param>
	void CreateTransition(TransitionType type);
};



============================================================
File Path: Project/Engine/Scene/Transition/ShatterGlassTransition.cpp
============================================================
#include "ShatterGlassTransition.h"
#include <algorithm>
// Service
#include "Engine/System/Service/OffScreenService.h"
#include "Engine/System/Service/GraphicsResourceGetter.h"
// Math
#include "Math/EasingMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ShatterGlassTransition::~ShatterGlassTransition() {
	OffScreenService::SetOffScreenType(OffScreenType::CopyImage);
	if (sprite_) {
		sprite_.reset();
	}
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹å‡¦ç†
///-------------------------------------------///
void ShatterGlassTransition::StartFadeIn(float duration) {
	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã®è¨­å®š
	OffScreenService::SetOffScreenType(OffScreenType::ShatterGlass);
	// Spriteã®è‰²ã‚’ãƒªã‚»ãƒƒãƒˆ
	if (sprite_) {
		sprite_->SetColor({ 1.0f, 1.0f, 1.0f, 0.0f }); // é€æ˜ã§åˆæœŸåŒ–
	}

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
	data_.progress = 0.0f;
	data_.impactX = 0.5f;
	data_.impactY = 0.5f;
	data_.crackDensity = 15.0f;
	data_.dispersion = 1.2f;
	data_.rotation = 1.5f;
	data_.fadeOut = 0.5f;  // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚’æœ‰åŠ¹ã«

	// æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
	data_.randomSeed = static_cast<float>(rand() % 10000) / 10.0f;

	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
	SceneTransitionBase::StartFadeIn(duration);
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹å‡¦ç†
///-------------------------------------------///
void ShatterGlassTransition::StartFadeOut(float duration) {
	// Sprite
	sprite_ = std::make_unique<Sprite>();
	sprite_->Initialize("White");
	sprite_->SetSize({ static_cast<float>(GraphicsResourceGetter::GetWindowWidth()), static_cast<float>(GraphicsResourceGetter::GetWindowHeight()) });
	sprite_->SetColor({ 1.0f, 1.0f, 1.0f, 0.0f }); // é€æ˜ã§åˆæœŸåŒ–
	sprite_->Update();

	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
	SceneTransitionBase::StartFadeOut(duration);
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ShatterGlassTransition::Draw() {
	if (sprite_) {
		sprite_->Draw(GroundType::Front, BlendMode::KBlendModeNormal);
	}
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å›ºæœ‰ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void ShatterGlassTransition::OnFadeInUpdate() {
	// é€²è¡Œåº¦ã‚’è¨ˆç®—ï¼ˆ0.0 ~ 1.0ï¼‰
	float normalizedTime = (std::min)(animation_.currentTime / animation_.duration, 1.0f);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨ï¼ˆæœ€åˆã¯é€Ÿãã€å¾Œã§ã‚†ã£ãã‚Šï¼‰
	float easedTime = Easing::EaseOutCubic(normalizedTime);

	if (data_.progress < 0.5f) {
		// å„ãƒ•ã‚§ãƒ¼ã‚ºã§ã®å‹•ãã‚’èª¿æ•´
		if (normalizedTime < 0.5f) {
			// Phase 1: ã²ã³å‰²ã‚ŒãŒåºƒãŒã‚‹ï¼ˆ0.0 ~ 0.15ç§’ï¼‰
			data_.crackDensity = 15.0f;
			data_.progress = easedTime * 0.3f;
		} else {
			// Phase 3: ç ´ç‰‡ãŒé£›æ•£ã—ã¦æ¶ˆãˆã‚‹ï¼ˆ0.5 ~ 1.0ç§’ï¼‰
			data_.crackDensity = 15.0f;
			data_.dispersion = 4.0f;
			float phaseTime = (normalizedTime - 0.5f) / 0.5f;
			data_.progress = 0.25f + Easing::EaseOutCubic(phaseTime) * 0.3f;
		}
	} else {
		OffScreenService::SetOffScreenType(OffScreenType::CopyImage);
		data_.progress = 1.0f;
		// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçµ‚äº†åˆ¤å®š
		animation_.isPlaying = false;
		animation_.isFinished = true;
	}

	// è¨­å®š
	OffScreenService::SetShatterGlassData(data_);
	if (sprite_) {
		sprite_->Update();
	}
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå›ºæœ‰ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void ShatterGlassTransition::OnFadeOutUpdate() {
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®è‰²ï¼ˆã‚¢ãƒ«ãƒ•ã‚¡å€¤ã®ã¿æ›´æ–°ï¼‰
	Vector4 color = sprite_->GetColor();
	color.w += 0.01f; // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚’æ›´æ–°

	// é€æ˜åº¦ãŒ1.0ã«åˆ°é”ã—ãŸã‚‰çµ‚äº†
	if (color.w >= 1.0f) {
		animation_.isPlaying = false;
		animation_.isFinished = true;
	}

	sprite_->SetColor(color);
	sprite_->Update();
}


============================================================
File Path: Project/Engine/Scene/Transition/ShatterGlassTransition.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/Transition/Base/SceneTransitionBase.h"
#include "Engine/Graphics/OffScreen/Effect/ShatterGlassEffect.h"
#include "application/Drawing/2d/Sprite.h"

///=====================================================/// 
/// ShatterGlassTransition
///=====================================================///
class ShatterGlassTransition : public SceneTransitionBase {
public: 

    ShatterGlassTransition() = default;
    ~ShatterGlassTransition();

    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹å‡¦ç†
    /// </summary>
    /// <param name="duration">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã«ã‹ã‹ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰ã€‚çœç•¥æ™‚ã¯1.2ç§’ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
    void StartFadeIn(float duration = 1.0f) override;

    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹å‡¦ç†
    /// </summary>
    /// <param name="duration">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®ç¶™ç¶šæ™‚é–“ï¼ˆç§’ï¼‰ã€‚çœç•¥ã—ãŸå ´åˆã®æ—¢å®šå€¤ã¯1.0ç§’ã§ã™ã€‚</param>
    void StartFadeOut(float duration = 1.2f) override;  

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;

private: 
    // Sprite
	std::unique_ptr<Sprite> sprite_;
    // Data
    ShatterGlassData data_;

protected:
    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³å›ºæœ‰ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void OnFadeInUpdate() override;

    /// <summary>
    /// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå›ºæœ‰ã®æ›´æ–°å‡¦ç†
    /// </summary>
    void OnFadeOutUpdate() override;


};



============================================================
File Path: Project/Engine/System/DeltraTime/DeltaTime.cpp
============================================================
#include "DeltaTime.h"

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
const float& DeltaTime::GetDeltaTime() const {return deltaTime_;}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void DeltaTime::SetDeltaTime(const float& deltaTime) { deltaTime_ = deltaTime; }

============================================================
File Path: Project/Engine/System/DeltraTime/DeltaTime.h
============================================================
#pragma once
/// ===Include=== ///

///=====================================================/// 
/// DeltaTime
///=====================================================///
class DeltaTime {
public:
	DeltaTime() = default;
	~DeltaTime() = default;

public: /// ===Getter=== ///
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã®å–å¾—
	const float& GetDeltaTime() const;

public: /// ===Setter=== ///
	// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã®è¨­å®š
	void SetDeltaTime(const float& deltaTime);

private:

	// DeltaTime
	float deltaTime_ = 1.0f / 60.0f;
};



============================================================
File Path: Project/Engine/System/Editor/ParticleEditor.cpp
============================================================
#include "ParticleEditor.h"
#include "Engine/Graphics/Particle/ParticleFactory.h"
#include "Engine/Graphics/Particle/ParticleGroup.h"
#include "Engine/System/Service/DeltaTimeSevice.h"

#ifdef USE_IMGUI
// ImGui
#include <imgui.h>
#endif // USE_IMGUI
// c++
#include <fstream>
#include <filesystem>

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ParticleEditor::ParticleEditor() {
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¨­å®š
    strcpy_s(filePathBuffer_, kDefaultSavePath);
}

ParticleEditor::~ParticleEditor() {
    previewParticle_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ParticleEditor::Initialize() {
    // åˆ©ç”¨å¯èƒ½ãªãƒªã‚½ãƒ¼ã‚¹ã‚’æ›´æ–°
    UpdateAvailableModels();
    UpdateAvailableTextures();
    UpdateAvailablePresets();

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å®šç¾©ã‚’è¨­å®š
    currentDefinition_ = ParticleDefinition();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void ParticleEditor::Update() {
    if (!isVisible_) return;

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
    if (isPlaying_ && previewParticle_) {
        // è»Œè·¡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã®å ´åˆ
        if (trajectoryPreviewMode_ && currentDefinition_.advanced.isTrajectoryParticle) {
            UpdateTrajectoryPreview();
        }

        previewParticle_->Update();

        // çµ‚äº†ã—ãŸã‚‰è‡ªå‹•ãƒªãƒ—ãƒ¬ã‚¤
        if (autoReplay_ && previewParticle_->IsFinish()) {
            ResetPreview();
            PlayPreview();
        }
    }
}

///-------------------------------------------/// 
/// ImGuiæç”»
///-------------------------------------------///
void ParticleEditor::Render() {
#ifdef USE_IMGUI
    if (!isVisible_) return;

    ImGui::Begin("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼", &isVisible_, ImGuiWindowFlags_MenuBar);

    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼
    RenderMenuBar();

    // ã‚¿ãƒ–ã§åˆ†å‰²
    if (ImGui::BeginTabBar("ParticleEditorTabs")) {

        // åŸºæœ¬è¨­å®šã‚¿ãƒ–
        if (ImGui::BeginTabItem("åŸºæœ¬è¨­å®š")) {
            RenderBasicSettings();
            ImGui::EndTabItem();
        }

        // ç‰©ç†è¨­å®šã‚¿ãƒ–
        if (ImGui::BeginTabItem("ç‰©ç†è¨­å®š")) {
            RenderPhysicsSettings();
            ImGui::EndTabItem();
        }

        // è¦‹ãŸç›®è¨­å®šã‚¿ãƒ–
        if (ImGui::BeginTabItem("è¦‹ãŸç›®è¨­å®š")) {
            RenderAppearanceSettings();
            ImGui::EndTabItem();
        }

        // å›è»¢è¨­å®šã‚¿ãƒ–
        if (ImGui::BeginTabItem("å›è»¢è¨­å®š")) {
            RenderRotationSettings();
            ImGui::EndTabItem();
        }

        // ç™ºç”Ÿè¨­å®šã‚¿ãƒ–
        if (ImGui::BeginTabItem("ç™ºç”Ÿè¨­å®š")) {
            RenderEmissionSettings();
            ImGui::EndTabItem();
        }

        // é«˜åº¦è¨­å®šã‚¿ãƒ–
        if (ImGui::BeginTabItem("å‹•ä½œè¨­å®š")) {
            RenderAdvancedSettings();
            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    ImGui::Separator();

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
    RenderPreviewControls();

    // ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ
    RenderFileOperations();

    ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»
///-------------------------------------------///
void ParticleEditor::DrawPreview() {
#ifdef USE_IMGUI
    if (isPlaying_ && previewParticle_) {
        previewParticle_->Draw(previewBlendMode_);
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
///-------------------------------------------///
void ParticleEditor::ToggleVisibility() {
    isVisible_ = !isVisible_;
}

void ParticleEditor::SetVisible(bool visible) {
    isVisible_ = visible;
}

bool ParticleEditor::IsVisible() const {
    return isVisible_;
}

///-------------------------------------------/// 
/// JSONä¿å­˜
///-------------------------------------------///
void ParticleEditor::SaveToJson() {
#ifdef USE_IMGUI
    try {
        // ç·¨é›†ä¸­ã®å®šç¾©ã‚’ä¿å­˜
        nlohmann::json j = currentDefinition_.ToJson();

        std::string filepath = filePathBuffer_;
        if (filepath.find(kFileExtension) == std::string::npos) {
            filepath += kFileExtension;
        }

        std::ofstream file(filepath);
        file << j.dump(4); // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ4ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        file.close();

        currentFilePath_ = filepath;

        // ãƒ—ãƒªã‚»ãƒƒãƒˆä¸€è¦§ã‚’æ›´æ–°
        UpdateAvailablePresets();

    } catch (const std::exception& e) {
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«å‡ºåŠ›ãªã©ï¼‰
        e;
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// JSONèª­ã¿è¾¼ã¿
///-------------------------------------------///
void ParticleEditor::LoadFromJson() {
#ifdef USE_IMGUI
    try {
        std::string filepath = filePathBuffer_;
        if (filepath.find(kFileExtension) == std::string::npos) {
            filepath += kFileExtension;
        }

        std::ifstream file(filepath);
        nlohmann::json j;
        file >> j;
        file.close();

        currentDefinition_ = ParticleDefinition::FromJson(j);
        currentFilePath_ = filepath;

        // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°
        if (isPlaying_) {
            ResetPreview();
            CreatePreviewParticle();
            PlayPreview();
        }

    } catch (const std::exception& e) {
        // ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        e;
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// æ–°è¦ä½œæˆ
///-------------------------------------------///
void ParticleEditor::CreateNew() {
#ifdef USE_IMGUI
    currentDefinition_ = ParticleDefinition();
    currentFilePath_.clear();
    strcpy_s(filePathBuffer_, kDefaultSavePath);

    if (isPlaying_) {
        StopPreview();
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿ
///-------------------------------------------///
void ParticleEditor::PlayPreview() {
#ifdef USE_IMGUI
    if (!previewParticle_) {
        CreatePreviewParticle();
    }
    isPlaying_ = true;
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åœæ­¢
///-------------------------------------------///
void ParticleEditor::StopPreview() {
#ifdef USE_IMGUI
    isPlaying_ = false;
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void ParticleEditor::ResetPreview() {
#ifdef USE_IMGUI
    previewParticle_.reset();
    isPlaying_ = false;
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
///-------------------------------------------///
void ParticleEditor::CreatePreviewParticle() {
#ifdef USE_IMGUI
    // ParticleGroupã‚’ç”Ÿæˆã—ã¦Definitionã‚’é©ç”¨
    previewParticle_ = std::make_unique<ParticleGroup>();
    previewParticle_->Initialze(previewPosition_, currentDefinition_);

    // â˜…ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚Œã°æ˜ç¤ºçš„ã«è¨­å®šï¼ˆäºŒé‡é©ç”¨ã«ãªã‚‹ãŒå®‰å…¨ã®ãŸã‚ï¼‰
    if (!currentDefinition_.appearance.texturePath.empty()) {
        previewParticle_->SetTexture(currentDefinition_.appearance.texturePath);
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼æç”»
///-------------------------------------------///
void ParticleEditor::RenderMenuBar() {
#ifdef USE_IMGUI
    if (ImGui::BeginMenuBar()) {
        if (ImGui::BeginMenu("ãƒ•ã‚¡ã‚¤ãƒ«")) {
            if (ImGui::MenuItem("æ–°è¦ä½œæˆ", "Ctrl+N")) {
                CreateNew();
            }
            if (ImGui::MenuItem("é–‹ã", "Ctrl+O")) {
                showLoadDialog_ = true;
            }
            if (ImGui::MenuItem("ä¿å­˜", "Ctrl+S")) {
                SaveToJson();
            }
            if (ImGui::MenuItem("åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜...")) {
                showSaveDialog_ = true;
            }
            ImGui::Separator();
            if (ImGui::MenuItem("é–‰ã˜ã‚‹")) {
                isVisible_ = false;
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("ãƒ˜ãƒ«ãƒ—")) {
            if (ImGui::MenuItem("ä½¿ã„æ–¹")) {
                // TODO: ãƒ˜ãƒ«ãƒ—ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤º
            }
            ImGui::EndMenu();
        }

        ImGui::EndMenuBar();
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// åŸºæœ¬è¨­å®šUI
///-------------------------------------------///
void ParticleEditor::RenderBasicSettings() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("åŸºæœ¬è¨­å®š");

    /// ===åå‰=== ///
    char nameBuffer[256];
    strcpy_s(nameBuffer, currentDefinition_.name.c_str());
    if (ImGui::InputText("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«", nameBuffer, sizeof(nameBuffer))) {
        currentDefinition_.name = nameBuffer;
    }
    ImGui::TextDisabled("ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ç™»éŒ²æ™‚ã«ä½¿ç”¨ã™ã‚‹è­˜åˆ¥å");
    ImGui::Spacing();

    /// ===ãƒ¢ãƒ‡ãƒ«é¸æŠ=== ///
    if (!availableModels_.empty()) {
        if (ImGui::Combo("ãƒ¢ãƒ‡ãƒ«", &selectedModelIndex_,
            [](void* data, int idx, const char** out_text) {
                auto& models = *static_cast<std::vector<std::string>*>(data);
                *out_text = models[idx].c_str();
                return true;
            }, &availableModels_, static_cast<int>(availableModels_.size()))) {
            currentDefinition_.modelName = availableModels_[selectedModelIndex_];

            // ãƒ¢ãƒ‡ãƒ«å¤‰æ›´æ™‚ã¯ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å†ç”Ÿæˆ
            if (isPlaying_) {
                ResetPreview();
                CreatePreviewParticle();
                PlayPreview();
            }
        }
    } else {
        char modelBuffer[256];
        strcpy_s(modelBuffer, currentDefinition_.modelName.c_str());
        if (ImGui::InputText("ãƒ¢ãƒ‡ãƒ«å", modelBuffer, sizeof(modelBuffer))) {
            currentDefinition_.modelName = modelBuffer;
        }
    }

    /// ===å½¢çŠ¶é¸æŠ=== ///
    const char* shapes[] = { "å††", "å††æŸ±", "ãªã—" };
    int currentShape = static_cast<int>(currentDefinition_.shape);
    if (ImGui::Combo("å½¢çŠ¶ã‚¿ã‚¤ãƒ—", &currentShape, shapes, IM_ARRAYSIZE(shapes))) {
        currentDefinition_.shape = static_cast<shapeType>(currentShape);
    }
    ImGui::TextDisabled("ã‚«ã‚¹ã‚¿ãƒ é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ç”¨ã™ã‚‹å½¢çŠ¶");
    ImGui::Spacing();

    /// ===æœ€å¤§ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°=== ///
    int maxInstance = static_cast<int>(currentDefinition_.maxInstance);
    if (ImGui::DragInt("æœ€å¤§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°", &maxInstance, 1, 1, 10000)) {
        currentDefinition_.maxInstance = static_cast<uint32_t>(maxInstance);

        // æœ€å¤§æ•°å¤‰æ›´æ™‚ã‚‚ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å†ç”Ÿæˆ
        if (isPlaying_) {
            ResetPreview();
            CreatePreviewParticle();
            PlayPreview();
        }
    }
    ImGui::TextDisabled("åŒæ™‚ã«è¡¨ç¤ºã§ãã‚‹æœ€å¤§æ•°");
    ImGui::Spacing();
    ImGui::Separator();

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä½ç½®è¨­å®š=== ///
    ImGui::SeparatorText("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®š");

    bool positionChanged = false;

    /// ===XYZå€‹åˆ¥ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼=== ///
    positionChanged |= ImGui::DragFloat("ç™ºç”Ÿä½ç½® X", &previewPosition_.x, 0.1f, -100.0f, 100.0f);
    positionChanged |= ImGui::DragFloat("ç™ºç”Ÿä½ç½® Y", &previewPosition_.y, 0.1f, -100.0f, 100.0f);
    positionChanged |= ImGui::DragFloat("ç™ºç”Ÿä½ç½® Z", &previewPosition_.z, 0.1f, -100.0f, 100.0f);

    /// ===ã¾ã¨ã‚ã¦ãƒªã‚»ãƒƒãƒˆ=== ///
    if (ImGui::Button("ä½ç½®ã‚’ãƒªã‚»ãƒƒãƒˆ", ImVec2(150, 25))) {
        previewPosition_ = { 0.0f, 0.0f, 0.0f };
        positionChanged = true;
    }
    ImGui::SameLine();

    // ä½ç½®å¤‰æ›´æ™‚ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®ã‚‚æ›´æ–°
    if (positionChanged && previewParticle_) {
        previewParticle_->SetEmitterPosition(previewPosition_);
    }

    ImGui::Spacing();
    ImGui::TextDisabled("Tips: ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿä¸­ã§ã‚‚ä½ç½®ã‚’å¤‰æ›´ã§ãã¾ã™");
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ç‰©ç†è¨­å®šUI
///-------------------------------------------///
void ParticleEditor::RenderPhysicsSettings() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("ç‰©ç†è¨­å®š");

	/// ===é€Ÿåº¦è¨­å®š=== ///
    if (ImGui::Checkbox("ãƒ©ãƒ³ãƒ€ãƒ é€Ÿåº¦ã‚’ä½¿ç”¨", &currentDefinition_.physics.useRandomVelocity)) {
        // ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¤‰æ›´æ™‚ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«é©ç”¨
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }
    ImGui::TextDisabled("ã‚ªãƒ•ã®å ´åˆã¯ãƒ©ãƒ³ãƒ€ãƒ é€Ÿåº¦ã«ãªã‚Šã¾ã™");
    ImGui::Spacing();

    bool velocityChanged = false;

	/// ===é€Ÿåº¦ã®è¨­å®š=== ///
    if (currentDefinition_.physics.useRandomVelocity) {
        ImGui::Text("é€Ÿåº¦ç¯„å›²");
        velocityChanged |= ImGui::DragFloat3("æœ€å°é€Ÿåº¦", &currentDefinition_.physics.velocityMin.x, 0.1f, -100.0f, 100.0f);
        velocityChanged |= ImGui::DragFloat3("æœ€å¤§é€Ÿåº¦", &currentDefinition_.physics.velocityMax.x, 0.1f, -100.0f, 100.0f);
    } else {
        velocityChanged |= ImGui::DragFloat3("åˆæœŸé€Ÿåº¦", &currentDefinition_.physics.velocityMin.x, 0.1f, -100.0f, 100.0f);
    }

    // é€Ÿåº¦å¤‰æ›´æ™‚ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã«é©ç”¨
    if (velocityChanged && previewParticle_) {
        previewParticle_->SetParameter(ParticleParameter::VelocityMinX, currentDefinition_.physics.velocityMin.x);
        previewParticle_->SetParameter(ParticleParameter::VelocityMinY, currentDefinition_.physics.velocityMin.y);
        previewParticle_->SetParameter(ParticleParameter::VelocityMinZ, currentDefinition_.physics.velocityMin.z);
        previewParticle_->SetParameter(ParticleParameter::VelocityMaxX, currentDefinition_.physics.velocityMax.x);
        previewParticle_->SetParameter(ParticleParameter::VelocityMaxY, currentDefinition_.physics.velocityMax.y);
        previewParticle_->SetParameter(ParticleParameter::VelocityMaxZ, currentDefinition_.physics.velocityMax.z);
    }
    ImGui::Spacing();
    ImGui::Separator();

    /// ===åŠ é€Ÿåº¦ã®è¨­å®š=== ///
    ImGui::Text("åŠ é€Ÿåº¦");
    if (ImGui::DragFloat3("åŠ é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«", &currentDefinition_.physics.acceleration.x, 0.1f, -50.0f, 50.0f)) {
        if (previewParticle_) {
            previewParticle_->SetParameter(ParticleParameter::AccelerationX, currentDefinition_.physics.acceleration.x);
            previewParticle_->SetParameter(ParticleParameter::AccelerationY, currentDefinition_.physics.acceleration.y);
            previewParticle_->SetParameter(ParticleParameter::AccelerationZ, currentDefinition_.physics.acceleration.z);
        }
    }
    ImGui::TextDisabled("æ¯ãƒ•ãƒ¬ãƒ¼ãƒ é€Ÿåº¦ã«åŠ ç®—ã•ã‚Œã‚‹é‡");
    ImGui::Spacing();

    /// ===é‡åŠ›ã®è¨­å®š=== ///
    if (ImGui::DragFloat("é‡åŠ›", &currentDefinition_.physics.gravity, 0.1f, -50.0f, 50.0f)) {
        if (previewParticle_) {
            previewParticle_->SetParameter(ParticleParameter::Gravity, currentDefinition_.physics.gravity);
        }
    }
    ImGui::TextDisabled("Yè»¸æ–¹å‘ã®åŠ é€Ÿåº¦");

    if (ImGui::DragFloat("ä¸Šæ–¹å‘ã®åˆæœŸåŠ é€Ÿ", &currentDefinition_.physics.upwardForce, 0.1f, 0.0f, 50.0f)) {
        if (previewParticle_) {
            previewParticle_->SetParameter(ParticleParameter::UpwardForce, currentDefinition_.physics.upwardForce);
        }
    }
    ImGui::TextDisabled("ç™ºç”Ÿæ™‚ã«Yè»¸é€Ÿåº¦ã«åŠ ç®—ã•ã‚Œã‚‹å€¤");
    ImGui::Spacing();
    ImGui::Separator();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¦‹ãŸç›®è¨­å®šUI
///-------------------------------------------///
void ParticleEditor::RenderAppearanceSettings() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("è¦‹ãŸç›®è¨­å®š");

    /// ===è‰²è¨­å®š=== ///
    ImGui::Text("è‰²è¨­å®š");
    if (ImGui::Checkbox("è‰²ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³", &currentDefinition_.appearance.useColorGradient)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }
    if (ImGui::ColorEdit4("é–‹å§‹è‰²", &currentDefinition_.appearance.startColor.x)) {
        if (previewParticle_) {
            previewParticle_->SetParameter(ParticleParameter::StartColorR, currentDefinition_.appearance.startColor.x);
            previewParticle_->SetParameter(ParticleParameter::StartColorG, currentDefinition_.appearance.startColor.y);
            previewParticle_->SetParameter(ParticleParameter::StartColorB, currentDefinition_.appearance.startColor.z);
            previewParticle_->SetParameter(ParticleParameter::StartColorA, currentDefinition_.appearance.startColor.w);
        }
    }
    if (currentDefinition_.appearance.useColorGradient) {
        if (ImGui::ColorEdit4("çµ‚äº†è‰²", &currentDefinition_.appearance.endColor.x)) {
            if (previewParticle_) {
                previewParticle_->SetParameter(ParticleParameter::EndColorR, currentDefinition_.appearance.endColor.x);
                previewParticle_->SetParameter(ParticleParameter::EndColorG, currentDefinition_.appearance.endColor.y);
                previewParticle_->SetParameter(ParticleParameter::EndColorB, currentDefinition_.appearance.endColor.z);
                previewParticle_->SetParameter(ParticleParameter::EndColorA, currentDefinition_.appearance.endColor.w);
            }
        }
        ImGui::TextDisabled("å¯¿å‘½ã«å¿œã˜ã¦é–‹å§‹è‰²â†’çµ‚äº†è‰²ã¸å¤‰åŒ–");
    }
    ImGui::Spacing();
    ImGui::Separator();

    /// ===ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š=== ///
    ImGui::Text("ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®š");
    if (ImGui::Checkbox("ã‚¹ã‚±ãƒ¼ãƒ«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³", &currentDefinition_.appearance.useScaleAnimation)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }

    ImGui::Text("é–‹å§‹ã‚¹ã‚±ãƒ¼ãƒ«ç¯„å›²");
    bool scaleChanged = false;
    scaleChanged |= ImGui::DragFloat3("æœ€å°ã‚¹ã‚±ãƒ¼ãƒ«", &currentDefinition_.appearance.startScaleMin.x, 0.01f, 0.0f, 10.0f);
    scaleChanged |= ImGui::DragFloat3("æœ€å¤§ã‚¹ã‚±ãƒ¼ãƒ«", &currentDefinition_.appearance.startScaleMax.x, 0.01f, 0.0f, 10.0f);
    if (currentDefinition_.appearance.useScaleAnimation) {
        scaleChanged |= ImGui::DragFloat3("çµ‚äº†ã‚¹ã‚±ãƒ¼ãƒ«", &currentDefinition_.appearance.endScale.x, 0.01f, 0.0f, 10.0f);
        ImGui::TextDisabled("å¯¿å‘½ã«å¿œã˜ã¦ç¸®å°ãƒ»æ‹¡å¤§ã—ã¾ã™");
    }
    if (scaleChanged && previewParticle_) {
        previewParticle_->SetDefinition(currentDefinition_);
    }
    ImGui::Spacing();
    ImGui::Separator();

    /// ===ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®š=== ///
    ImGui::Text("ãƒ†ã‚¯ã‚¹ãƒãƒ£");
    if (!availableTextures_.empty()) {
        if (ImGui::Combo("ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«", &selectedTextureIndex_,
            [](void* data, int idx, const char** out_text) {
                auto& textures = *static_cast<std::vector<std::string>*>(data);
                *out_text = textures[idx].c_str();
                return true;
            }, &availableTextures_, static_cast<int>(availableTextures_.size()))) {
            currentDefinition_.appearance.texturePath = availableTextures_[selectedTextureIndex_];

            if (previewParticle_) {
                previewParticle_->SetTexture(currentDefinition_.appearance.texturePath);
            }
        }
    } else {
        char textureBuffer[256];
        strcpy_s(textureBuffer, currentDefinition_.appearance.texturePath.c_str());
        if (ImGui::InputText("ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‘ã‚¹", textureBuffer, sizeof(textureBuffer))) {
            currentDefinition_.appearance.texturePath = textureBuffer;

            if (previewParticle_) {
                previewParticle_->SetTexture(currentDefinition_.appearance.texturePath);
            }
        }
    }

    if (!currentDefinition_.appearance.texturePath.empty()) {
        ImGui::TextDisabled("ç¾åœ¨: %s", currentDefinition_.appearance.texturePath.c_str());
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// å›è»¢è¨­å®šUI
///-------------------------------------------///
void ParticleEditor::RenderRotationSettings() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("å›è»¢è¨­å®š");

    /// ===å›è»¢ã®è¨­å®š=== ///
    if (ImGui::Checkbox("å›è»¢ã‚’æœ‰åŠ¹åŒ–", &currentDefinition_.rotation.enableRotation)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }

    if (currentDefinition_.rotation.enableRotation) {
        ImGui::Spacing();

        // ===åˆæœŸå›è»¢è¨­å®š=== ///
        ImGui::SeparatorText("åˆæœŸå›è»¢");

        if (ImGui::Checkbox("åˆæœŸå›è»¢ã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ–", &currentDefinition_.rotation.randomInitialRotation)) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }

        bool initialRotationChanged = false;
        if (currentDefinition_.rotation.randomInitialRotation) {
            ImGui::Text("åˆæœŸå›è»¢ç¯„å›²ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰");
            initialRotationChanged |= ImGui::DragFloat3("æœ€å°åˆæœŸå›è»¢", &currentDefinition_.rotation.initialRotationMin.x, 0.01f, -6.28f, 6.28f);
            initialRotationChanged |= ImGui::DragFloat3("æœ€å¤§åˆæœŸå›è»¢", &currentDefinition_.rotation.initialRotationMax.x, 0.01f, -6.28f, 6.28f);
        } else {
            ImGui::Text("å›ºå®šåˆæœŸå›è»¢ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰");
            initialRotationChanged |= ImGui::DragFloat3("åˆæœŸå›è»¢", &currentDefinition_.rotation.initialRotationMin.x, 0.01f, -6.28f, 6.28f);
        }

        if (initialRotationChanged && previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }

        ImGui::Spacing();
        ImGui::Separator();

        /// ===å›è»¢é€Ÿåº¦è¨­å®š=== ///
        ImGui::SeparatorText("å›è»¢é€Ÿåº¦");

        if (ImGui::Checkbox("ãƒ©ãƒ³ãƒ€ãƒ å›è»¢é€Ÿåº¦", &currentDefinition_.rotation.randomRotation)) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }
        ImGui::TextDisabled("ã‚ªãƒ•ã®å ´åˆã¯å›ºå®šé€Ÿåº¦ã§å›è»¢");

        ImGui::Spacing();

        bool rotationChanged = false;

        if (currentDefinition_.rotation.randomRotation) {
            ImGui::Text("å›è»¢é€Ÿåº¦ç¯„å›²ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³/ç§’)");
            rotationChanged |= ImGui::DragFloat3("æœ€å°å›è»¢é€Ÿåº¦", &currentDefinition_.rotation.rotationSpeedMin.x, 0.1f, -10.0f, 10.0f);
            rotationChanged |= ImGui::DragFloat3("æœ€å¤§å›è»¢é€Ÿåº¦", &currentDefinition_.rotation.rotationSpeedMax.x, 0.1f, -10.0f, 10.0f);
        } else {
            ImGui::Text("å›ºå®šå›è»¢é€Ÿåº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³/ç§’)");
            rotationChanged |= ImGui::DragFloat3("å›è»¢é€Ÿåº¦", &currentDefinition_.rotation.rotationSpeedMin.x, 0.1f, -10.0f, 10.0f);
        }

        if (rotationChanged && previewParticle_) {
            previewParticle_->SetParameter(ParticleParameter::RotationSpeedX, currentDefinition_.rotation.rotationSpeedMin.x);
            previewParticle_->SetParameter(ParticleParameter::RotationSpeedY, currentDefinition_.rotation.rotationSpeedMin.y);
            previewParticle_->SetParameter(ParticleParameter::RotationSpeedZ, currentDefinition_.rotation.rotationSpeedMin.z);
        }

        ImGui::Spacing();
    } else {
        ImGui::Spacing();
        ImGui::TextDisabled("å›è»¢ãŒç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã¾ã™");
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ç™ºç”Ÿè¨­å®šUI
///-------------------------------------------///
void ParticleEditor::RenderEmissionSettings() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("ç™ºç”Ÿè¨­å®š");

    /// ===å¯¿å‘½ã®è¨­å®š=== ///
    ImGui::Text("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å¯¿å‘½ (ç§’)");
    bool lifetimeChanged = false;
    lifetimeChanged |= ImGui::DragFloat("æœ€å°å¯¿å‘½", &currentDefinition_.emission.lifetimeMin, 0.1f, 0.1f, 100.0f);
    lifetimeChanged |= ImGui::DragFloat("æœ€å¤§å¯¿å‘½", &currentDefinition_.emission.lifetimeMax, 0.1f, 0.1f, 100.0f);
    ImGui::TextDisabled("å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½ã¯ã“ã®ç¯„å›²ã§ãƒ©ãƒ³ãƒ€ãƒ ");

    if (lifetimeChanged && previewParticle_) {
        previewParticle_->SetParameter(ParticleParameter::LifetimeMin, currentDefinition_.emission.lifetimeMin);
        previewParticle_->SetParameter(ParticleParameter::LifetimeMax, currentDefinition_.emission.lifetimeMax);
    }

    ImGui::Spacing();
    ImGui::Separator();

    /// ===ç™ºç”Ÿç¯„å›²ã®è¨­å®š=== ///
    ImGui::Text("ç™ºç”Ÿç¯„å›²");
    bool rangeChanged = false;
    rangeChanged |= ImGui::DragFloat("Xè»¸ç¯„å›²", &currentDefinition_.physics.explosionRange.x, 0.1f, 0.0f, 20.0f);
    rangeChanged |= ImGui::DragFloat("Yè»¸ç¯„å›²", &currentDefinition_.physics.explosionRange.y, 0.1f, 0.0f, 20.0f);
    rangeChanged |= ImGui::DragFloat("Zè»¸ç¯„å›²", &currentDefinition_.physics.explosionRange.z, 0.1f, 0.0f, 20.0f);
    ImGui::TextDisabled("å„è»¸æ–¹å‘ã®ç™ºç”Ÿç¯„å›²ï¼ˆÂ±æŒ‡å®šå€¤ã®ç¯„å›²å†…ï¼‰");

    if (rangeChanged && previewParticle_) {
        previewParticle_->SetDefinition(currentDefinition_);
    }

    ImGui::Spacing();
    ImGui::Separator();

    /// ===ç™ºç”Ÿãƒ¢ãƒ¼ãƒ‰=== ///
    ImGui::Text("ç™ºç”Ÿãƒ¢ãƒ¼ãƒ‰");
    if (ImGui::Checkbox("ä¸€åº¦ã«å¤§é‡", &currentDefinition_.emission.isBurst)) {
        if (previewParticle_) {
            // ãƒãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆæ™‚ã¯å†ç”Ÿæˆ
            ResetPreview();
            CreatePreviewParticle();
            if (isPlaying_) {
                PlayPreview();
            }
        }
    }
    ImGui::TextDisabled("ä¸€åº¦ã«å¤§é‡ç™ºç”Ÿã™ã‚‹ã‹ã€ç¶™ç¶šçš„ã«ç™ºç”Ÿã™ã‚‹ã‹");
    ImGui::Spacing();

    if (currentDefinition_.emission.isBurst) {
        // ãƒãƒ¼ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰è¨­å®š
        int burstCount = static_cast<int>(currentDefinition_.emission.burstCount);
        if (ImGui::DragInt("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°", &burstCount, 1, 1, 10000)) {
            currentDefinition_.emission.burstCount = static_cast<uint32_t>(burstCount);

            if (previewParticle_) {
                previewParticle_->SetParameter(ParticleParameter::BurstCount, static_cast<float>(currentDefinition_.emission.burstCount));
            }
        }
        ImGui::TextDisabled("ä¸€åº¦ã«ç™ºç”Ÿã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ•°");
    } else {
        // é€£ç¶šç™ºç”Ÿãƒ¢ãƒ¼ãƒ‰è¨­å®š
        bool emissionChanged = false;
        emissionChanged |= ImGui::DragFloat("ç™ºç”Ÿãƒ¬ãƒ¼ãƒˆï¼ˆå€‹/ç§’ï¼‰", &currentDefinition_.emission.emissionRate, 0.1f, 0.1f, 1000.0f);
        ImGui::TextDisabled("1ç§’ã‚ãŸã‚Šã«ç™ºç”Ÿã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°");

        emissionChanged |= ImGui::DragFloat("ç™ºç”Ÿé »åº¦ï¼ˆç§’ï¼‰", &currentDefinition_.emission.frequency, 0.01f, 0.01f, 10.0f);
        ImGui::TextDisabled("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹é–“éš”");

        if (emissionChanged && previewParticle_) {
            previewParticle_->SetParameter(ParticleParameter::EmissionRate, currentDefinition_.emission.emissionRate);
            previewParticle_->SetParameter(ParticleParameter::Frequency, currentDefinition_.emission.frequency);
        }

        ImGui::Spacing();
        ImGui::Text("å®Ÿéš›ã®ç™ºç”Ÿæ•°");
        uint32_t actualCount = static_cast<uint32_t>(currentDefinition_.emission.emissionRate * currentDefinition_.emission.frequency);
        ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "%u å€‹ãšã¤ç™ºç”Ÿ", actualCount);
    }

    ImGui::TextDisabled("1å›ã®ç™ºç”Ÿã§ç”Ÿæˆã•ã‚Œã‚‹ç²’å­æ•°");
    ImGui::Spacing();
    ImGui::Separator();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// é«˜åº¦è¨­å®šUI
///-------------------------------------------///
void ParticleEditor::RenderAdvancedSettings() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("å‹•ä½œè¨­å®š");

    // ===è»Œè·¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«è¨­å®š=== ///
    ImGui::SeparatorText("è»Œè·¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«");
    if (ImGui::Checkbox("è»Œè·¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ¢ãƒ¼ãƒ‰", &currentDefinition_.advanced.isTrajectoryParticle)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
        // è»Œè·¡ãƒ¢ãƒ¼ãƒ‰ã‚’ã‚ªãƒ•ã«ã—ãŸå ´åˆã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰ã‚‚è‡ªå‹•ã§ã‚ªãƒ•
        if (!currentDefinition_.advanced.isTrajectoryParticle) {
            trajectoryPreviewMode_ = false;
        }
    }
    ImGui::TextDisabled("æ”»æ’ƒã®è»Œé“ãªã©ã«ä½¿ç”¨ã™ã‚‹é€£ç¶šç™ºç”Ÿãƒ¢ãƒ¼ãƒ‰");

    if (currentDefinition_.advanced.isTrajectoryParticle) {
        ImGui::Indent();

        // è»Œè·¡é–“éš”è¨­å®š
        if (ImGui::DragFloat("è»Œè·¡é–“éš” (ç§’)", &currentDefinition_.advanced.trailSpacing, 0.001f, 0.001f, 0.1f, "%.3f")) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }
        ImGui::TextDisabled("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹é–“éš”");

        ImGui::Checkbox("åœæ­¢æ™‚ã«ã‚¯ãƒªã‚¢", &currentDefinition_.advanced.clearOnStop);
        ImGui::TextDisabled("ç™ºç”Ÿåœæ­¢æ™‚ã«æ—¢å­˜ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ã‚¯ãƒªã‚¢");

        ImGui::Spacing();
        ImGui::Separator();

        // è»Œè·¡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®š
        ImGui::Text("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®š");
        ImGui::Checkbox("è»Œè·¡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰", &trajectoryPreviewMode_);
        ImGui::TextDisabled("ã‚¨ãƒŸãƒƒã‚¿ã‚’è‡ªå‹•ã§ç§»å‹•ã•ã›ã¦è»Œè·¡ã‚’ç¢ºèª");

        if (trajectoryPreviewMode_) {
            ImGui::Spacing();
            ImGui::Text("è»Œè·¡çµŒè·¯è¨­å®š");
            ImGui::DragFloat3("é–‹å§‹ä½ç½®", &trajectoryStartPos_.x, 0.1f, -20.0f, 20.0f);
            ImGui::DragFloat3("çµ‚äº†ä½ç½®", &trajectoryEndPos_.x, 0.1f, -20.0f, 20.0f);
            ImGui::DragFloat("ç§»å‹•é€Ÿåº¦", &trajectorySpeed_, 0.1f, 0.1f, 5.0f);
            ImGui::DragFloat3("åŸºæœ¬å›è»¢", &trajectoryRotation_.x, 0.1f, -6.28f, 6.28f);

            ImGui::Spacing();

            // é€²è¡ŒçŠ¶æ³è¡¨ç¤º
            ImGui::ProgressBar(trajectoryProgress_, ImVec2(-1, 0));
            ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f),
                "é€²è¡Œåº¦: %.1f%% | ä½ç½®: (%.1f, %.1f, %.1f)",
                trajectoryProgress_ * 100.0f,
                previewPosition_.x,
                previewPosition_.y,
                previewPosition_.z
            );
        }

        ImGui::Unindent();
    }
    ImGui::Spacing();
    ImGui::Separator();

    // ===æ¸¦å·»=== ///
    ImGui::SeparatorText("æ¸¦å·»å‹•ä½œ");
    auto& motion = currentDefinition_.advanced.motion;

    /// ===æ¸¦å·»ãé‹å‹•=== ///
    if (ImGui::Checkbox("æ¸¦å·»ãé‹å‹•", &motion.enableSwirling)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }
	// æ¸¦å·»é‹å‹•ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
    if (motion.enableSwirling) {
        ImGui::Indent();
		// æ¸¦å·»ãé€Ÿåº¦
        if (ImGui::DragFloat("æ¸¦å·»ãé€Ÿåº¦", &motion.swirlingSpeed, 0.1f, 0.0f, 20.0f)) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }
		// æ‹¡æ•£é€Ÿåº¦
        if (ImGui::DragFloat("æ‹¡æ•£é€Ÿåº¦", &motion.expansionRate, 0.1f, 0.0f, 5.0f)) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }
        ImGui::Unindent();
    }
    ImGui::Spacing();

    // ã‚¨ãƒŸãƒƒã‚¿è¿½å¾“
    if (ImGui::Checkbox("ã‚¨ãƒŸãƒƒã‚¿ã«è¿½å¾“", &motion.followEmitter)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }
	// è¿½å¾“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
    ImGui::TextDisabled("ã‚¨ãƒŸãƒƒã‚¿ã®ç§»å‹•ã«è¿½å¾“ã™ã‚‹");
    if (motion.followEmitter) {
        ImGui::Indent();
		// è¿½å¾“å¼·åº¦
        if (ImGui::SliderFloat("è¿½å¾“å¼·åº¦", &motion.followStrength, 0.0f, 1.0f)) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }
        ImGui::TextDisabled("0.0 = è¿½å¾“ã—ãªã„ã€1.0 = å®Œå…¨è¿½å¾“");
        ImGui::Unindent();
    }
    ImGui::Spacing();

    // å›è»¢å½±éŸ¿
    if (ImGui::Checkbox("å›è»¢å½±éŸ¿ã‚’å—ã‘ã‚‹", &motion.useRotationInfluence)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }
    ImGui::TextDisabled("ã‚¨ãƒŸãƒƒã‚¿ã®å›è»¢ãŒãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«å½±éŸ¿");
	// å›è»¢å½±éŸ¿ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
    if (motion.useRotationInfluence) {
        ImGui::Indent();
		// å›è»¢å½±éŸ¿ä¿‚æ•°
        if (ImGui::DragFloat("å›è»¢å½±éŸ¿ä¿‚æ•°", &motion.rotationInfluence, 0.1f, 0.0f, 5.0f)) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }
        ImGui::Unindent();
    }
    ImGui::Spacing();

    // é€Ÿåº¦æ¸›è¡°
    if (ImGui::SliderFloat("é€Ÿåº¦æ¸›è¡°ç‡", &motion.velocityDamping, 0.0f, 1.0f)) {
        if (previewParticle_) {
            previewParticle_->SetDefinition(currentDefinition_);
        }
    }
    ImGui::TextDisabled("æ¯ãƒ•ãƒ¬ãƒ¼ãƒ é€Ÿåº¦ã«æ›ã‘ã‚‹ä¿‚æ•° (1.0 = æ¸›è¡°ãªã—)");
    ImGui::Spacing();

    // ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰å›è»¢
    ImGui::Checkbox("ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰å›è»¢", &motion.enableBillboardRotation);
	// ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰å›è»¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®è¨­å®š
    if (motion.enableBillboardRotation) {
        ImGui::Indent();
		// å›è»¢é€Ÿåº¦
        if (ImGui::DragFloat("å›è»¢é€Ÿåº¦", &motion.billboardRotationSpeed, 0.1f, 0.0f, 10.0f)) {
            if (previewParticle_) {
                previewParticle_->SetDefinition(currentDefinition_);
            }
        }
        ImGui::Unindent();
    }
    ImGui::Spacing();
    ImGui::Separator();

    // ãƒ—ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
    ImGui::SeparatorText("ãƒ—ãƒªã‚»ãƒƒãƒˆ");
    if (ImGui::Button("æ”»æ’ƒè»Œè·¡ãƒ—ãƒªã‚»ãƒƒãƒˆ", ImVec2(200, 30))) {
        ApplyTrajectoryPreset();
    }
    ImGui::SameLine();
    if (ImGui::Button("çˆ†ç™ºãƒ—ãƒªã‚»ãƒƒãƒˆ", ImVec2(200, 30))) {
        ApplyExplosionPreset();
    }
    ImGui::SameLine();
    if (ImGui::Button("ç…™ãƒ—ãƒªã‚»ãƒƒãƒˆ", ImVec2(200, 30))) {
        ApplySmokePreset();
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UI
///-------------------------------------------///
void ParticleEditor::RenderPreviewControls() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼");

    // å†ç”Ÿ/åœæ­¢ãƒœã‚¿ãƒ³
    if (isPlaying_) {
        if (ImGui::Button("åœæ­¢", ImVec2(100, 30))) {
            StopPreview();
        }
    } else {
        if (ImGui::Button("å†ç”Ÿ", ImVec2(100, 30))) {
            PlayPreview();
        }
    }

    ImGui::SameLine();

    // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
    if (ImGui::Button("ãƒªã‚»ãƒƒãƒˆ", ImVec2(100, 30))) {
        ResetPreview();
    }

    ImGui::SameLine();

    // è‡ªå‹•ãƒªãƒ—ãƒ¬ã‚¤ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹
    ImGui::Checkbox("è‡ªå‹•ãƒªãƒ—ãƒ¬ã‚¤", &autoReplay_);
    ImGui::Spacing();
    ImGui::Separator();

    // ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰é¸æŠ
    ImGui::Text("ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰");
    const char* blendModes[] = {
        "ãªã—",
        "é€šå¸¸",
        "åŠ ç®—",
        "æ¸›ç®—",
        "ä¹—ç®—",
        "ã‚¹ã‚¯ãƒªãƒ¼ãƒ³"
    };
    int currentBlendMode = static_cast<int>(previewBlendMode_);
    if (ImGui::Combo("##BlendMode", &currentBlendMode, blendModes, IM_ARRAYSIZE(blendModes))) {
        previewBlendMode_ = static_cast<BlendMode>(currentBlendMode);
    }
    ImGui::TextDisabled("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»æ™‚ã®åˆæˆãƒ¢ãƒ¼ãƒ‰");

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼çŠ¶æ…‹è¡¨ç¤º
    if (isPlaying_ && previewParticle_) {
        ImGui::Spacing();
        ImGui::Text("ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°: %u", previewParticle_->GetActiveParticleCount());
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œUI
///-------------------------------------------///
void ParticleEditor::RenderFileOperations() {
#ifdef USE_IMGUI
    ImGui::Separator();
    ImGui::SeparatorText("ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ");

    // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹å…¥åŠ›
    ImGui::InputText("ä¿å­˜å…ˆãƒ‘ã‚¹", filePathBuffer_, sizeof(filePathBuffer_));
    ImGui::TextDisabled(".jsonæ‹¡å¼µå­ã¯è‡ªå‹•ã§ä»˜åŠ ã•ã‚Œã¾ã™");

    ImGui::Spacing();

    // ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³
    if (ImGui::Button("ä¿å­˜", ImVec2(120, 30))) {
        SaveToJson();
    }

    ImGui::SameLine();

    if (ImGui::Button("èª­ã¿è¾¼ã¿", ImVec2(120, 30))) {
        LoadFromJson();
    }

    // ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¡¨ç¤º
    if (!currentFilePath_.empty()) {
        ImGui::Spacing();
        ImGui::TextColored(ImVec4(0.4f, 1.0f, 0.4f, 1.0f), "ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«:");
        ImGui::TextWrapped("%s", currentFilePath_.c_str());
    }

    // ãƒ—ãƒªã‚»ãƒƒãƒˆé¸æŠ
    if (!availablePresets_.empty()) {
        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Text("ãƒ—ãƒªã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿:");
        if (ImGui::Combo("##Presets", &selectedPresetIndex_,
            [](void* data, int idx, const char** out_text) {
                auto& presets = *static_cast<std::vector<std::string>*>(data);
                *out_text = presets[idx].c_str();
                return true;
            }, &availablePresets_, static_cast<int>(availablePresets_.size()))) {
            strcpy_s(filePathBuffer_, availablePresets_[selectedPresetIndex_].c_str());
            LoadFromJson();
        }
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«æ›´æ–°
///-------------------------------------------///
void ParticleEditor::UpdateAvailableModels() {
#ifdef USE_IMGUI
    availableModels_.clear();
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€Assets/Modelsãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹
    availableModels_.push_back("plane");
    availableModels_.push_back("sphere");
    availableModels_.push_back("cube");
    availableModels_.push_back("triangle");
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// åˆ©ç”¨å¯èƒ½ãªãƒ†ã‚¯ã‚¹ãƒãƒ£æ›´æ–°
///-------------------------------------------///
void ParticleEditor::UpdateAvailableTextures() {
#ifdef USE_IMGUI
    availableTextures_.clear();

    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç¨®é¡
    availableTextures_.push_back("circle");
    availableTextures_.push_back("circle2");
    availableTextures_.push_back("gradationLine");
    availableTextures_.push_back("Spark");
    availableTextures_.push_back("FlameEye");
    availableTextures_.push_back("Fire");

#endif // USE_IMGUI   
}

///-------------------------------------------/// 
/// åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆæ›´æ–°
///-------------------------------------------///
void ParticleEditor::UpdateAvailablePresets() {
#ifdef USE_IMGUI
    availablePresets_.clear();

    // Assets/Particlesãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ã‚¹ã‚­ãƒ£ãƒ³
    std::string path = kDefaultSavePath;
    if (std::filesystem::exists(path)) {
        for (const auto& entry : std::filesystem::directory_iterator(path)) {
            if (entry.path().extension() == kFileExtension) {
                availablePresets_.push_back(entry.path().string());
            }
        }
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è»Œè·¡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®æ›´æ–°
///-------------------------------------------///
void ParticleEditor::UpdateTrajectoryPreview() {
#ifdef USE_IMGUI
    float deltaTime = DeltaTimeSevice::GetDeltaTime();

    // é€²è¡Œåº¦ã‚’æ›´æ–°
    trajectoryProgress_ += deltaTime * trajectorySpeed_;

    // ãƒ«ãƒ¼ãƒ—
    if (trajectoryProgress_ >= 1.0f) {
        trajectoryProgress_ = 0.0f;
    }

    // ç¾åœ¨ä½ç½®ã‚’è£œé–“ï¼ˆç·šå½¢è£œé–“ï¼‰
    Vector3 currentPos;
    currentPos.x = trajectoryStartPos_.x + (trajectoryEndPos_.x - trajectoryStartPos_.x) * trajectoryProgress_;
    currentPos.y = trajectoryStartPos_.y + (trajectoryEndPos_.y - trajectoryStartPos_.y) * trajectoryProgress_;
    currentPos.z = trajectoryStartPos_.z + (trajectoryEndPos_.z - trajectoryStartPos_.z) * trajectoryProgress_;

    // å›è»¢ã‚‚è£œé–“ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼šèºæ—‹é‹å‹•ãªã©ï¼‰
    Vector3 currentRot = trajectoryRotation_;
    currentRot.y += trajectoryProgress_ * 3.14159f * 2.0f; // 1å‘¨å›è»¢

    // ã‚¨ãƒŸãƒƒã‚¿ä½ç½®ã¨å›è»¢ã‚’æ›´æ–°
    previewParticle_->SetEmitterPosition(currentPos);
    previewParticle_->SetEmitterRotate(currentRot);
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ—ãƒªã‚»ãƒƒãƒˆé©ç”¨é–¢æ•°
///-------------------------------------------///
void ParticleEditor::ApplyTrajectoryPreset() {
    // æ”»æ’ƒè»Œè·¡ç”¨ã®ãƒ—ãƒªã‚»ãƒƒãƒˆ
    currentDefinition_.advanced.isTrajectoryParticle = true;
    currentDefinition_.advanced.trailSpacing = 0.008f;
    currentDefinition_.advanced.clearOnStop = true;

    currentDefinition_.advanced.emissionPattern.pattern = ParticleEmissionPattern::Pattern::Sphere;
    currentDefinition_.advanced.emissionPattern.patternRadius = 0.25f;
    currentDefinition_.advanced.emissionPattern.particlesPerEmit = 6;

    currentDefinition_.advanced.motion.enableSwirling = true;
    currentDefinition_.advanced.motion.swirlingSpeed = 3.0f;
    currentDefinition_.advanced.motion.expansionRate = 0.8f;
    currentDefinition_.advanced.motion.useRotationInfluence = true;
    currentDefinition_.advanced.motion.rotationInfluence = 1.2f;
    currentDefinition_.advanced.motion.velocityDamping = 0.95f;
    currentDefinition_.advanced.motion.enableBillboardRotation = true;
    currentDefinition_.advanced.motion.billboardRotationSpeed = 3.0f;

    currentDefinition_.advanced.colorGradient.useGradient = true;
    currentDefinition_.advanced.colorGradient.primaryColor = { 0.2f, 0.8f, 1.0f, 1.0f };
    currentDefinition_.advanced.colorGradient.secondaryColor = { 1.0f, 0.9f, 0.3f, 1.0f };
    currentDefinition_.advanced.colorGradient.oscillateColor = true;

    currentDefinition_.advanced.scaleAnimation.type = ParticleScaleAnimation::AnimationType::Bounce;
    currentDefinition_.advanced.scaleAnimation.startScale = 0.3f;
    currentDefinition_.advanced.scaleAnimation.maxScale = 1.5f;
    currentDefinition_.advanced.scaleAnimation.endScale = 0.1f;

    currentDefinition_.emission.lifetimeMin = 0.4f;
    currentDefinition_.emission.lifetimeMax = 0.8f;

    if (previewParticle_) {
        ResetPreview();
        CreatePreviewParticle();
        PlayPreview();
    }
}
void ParticleEditor::ApplyExplosionPreset() {
    // çˆ†ç™ºç”¨ã®ãƒ—ãƒªã‚»ãƒƒãƒˆ
    currentDefinition_.advanced.isTrajectoryParticle = false;
    currentDefinition_.advanced.emissionPattern.pattern = ParticleEmissionPattern::Pattern::Burst;
    currentDefinition_.advanced.emissionPattern.patternRadius = 2.0f;
    currentDefinition_.advanced.emissionPattern.particlesPerEmit = 30;

    currentDefinition_.advanced.motion.enableSwirling = false;
    currentDefinition_.advanced.motion.velocityDamping = 0.92f;

    currentDefinition_.advanced.colorGradient.useGradient = true;
    currentDefinition_.advanced.colorGradient.primaryColor = { 1.0f, 0.5f, 0.0f, 1.0f };
    currentDefinition_.advanced.colorGradient.secondaryColor = { 1.0f, 0.0f, 0.0f, 1.0f };

    currentDefinition_.advanced.scaleAnimation.type = ParticleScaleAnimation::AnimationType::EaseOut;
    currentDefinition_.emission.isBurst = true;
    currentDefinition_.emission.burstCount = 50;

    if (previewParticle_) {
        ResetPreview();
        CreatePreviewParticle();
        PlayPreview();
    }
}
void ParticleEditor::ApplyMagicCirclePreset() {
    // é­”æ³•é™£ç”¨ã®ãƒ—ãƒªã‚»ãƒƒãƒˆ
    currentDefinition_.advanced.emissionPattern.pattern = ParticleEmissionPattern::Pattern::Ring;
    currentDefinition_.advanced.emissionPattern.patternRadius = 3.0f;
    currentDefinition_.advanced.emissionPattern.particlesPerEmit = 12;

    currentDefinition_.advanced.motion.enableSwirling = true;
    currentDefinition_.advanced.motion.swirlingSpeed = 2.0f;
    currentDefinition_.advanced.motion.followEmitter = true;
    currentDefinition_.advanced.motion.followStrength = 0.8f;

    currentDefinition_.advanced.colorGradient.useGradient = true;
    currentDefinition_.advanced.colorGradient.primaryColor = { 0.5f, 0.2f, 1.0f, 1.0f };
    currentDefinition_.advanced.colorGradient.secondaryColor = { 0.8f, 0.8f, 1.0f, 1.0f };
    currentDefinition_.advanced.colorGradient.oscillateColor = true;

    currentDefinition_.advanced.scaleAnimation.type = ParticleScaleAnimation::AnimationType::Pulse;
    currentDefinition_.emission.isBurst = false;
    currentDefinition_.emission.emissionRate = 20.0f;
    currentDefinition_.emission.frequency = 0.05f;

    if (previewParticle_) {
        ResetPreview();
        CreatePreviewParticle();
        PlayPreview();
    }
}
void ParticleEditor::ApplySmokePreset() {
    // ç…™ç”¨ã®ãƒ—ãƒªã‚»ãƒƒãƒˆ
    currentDefinition_.advanced.emissionPattern.pattern = ParticleEmissionPattern::Pattern::Cone;
    currentDefinition_.advanced.emissionPattern.patternRadius = 0.5f;
    currentDefinition_.advanced.emissionPattern.patternAngle = 30.0f;
    currentDefinition_.advanced.emissionPattern.particlesPerEmit = 3;

    currentDefinition_.advanced.motion.enableSwirling = true;
    currentDefinition_.advanced.motion.swirlingSpeed = 0.5f;
    currentDefinition_.advanced.motion.expansionRate = 1.5f;
    currentDefinition_.advanced.motion.velocityDamping = 0.98f;

    currentDefinition_.advanced.colorGradient.useGradient = true;
    currentDefinition_.advanced.colorGradient.primaryColor = { 0.3f, 0.3f, 0.3f, 0.8f };
    currentDefinition_.advanced.colorGradient.secondaryColor = { 0.6f, 0.6f, 0.6f, 0.2f };

    currentDefinition_.advanced.scaleAnimation.type = ParticleScaleAnimation::AnimationType::Linear;
    currentDefinition_.advanced.scaleAnimation.startScale = 0.5f;
    currentDefinition_.advanced.scaleAnimation.endScale = 3.0f;

    currentDefinition_.emission.lifetimeMin = 2.0f;
    currentDefinition_.emission.lifetimeMax = 3.0f;
    currentDefinition_.physics.upwardForce = 2.0f;

    if (previewParticle_) {
        ResetPreview();
        CreatePreviewParticle();
        PlayPreview();
    }
}

============================================================
File Path: Project/Engine/System/Editor/ParticleEditor.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/Particle/ParticleDefinition.h"
#include "Engine/DataInfo/BlendModeData.h"
// c++
#include <memory>
#include <string>
#include <vector>

/// ===å‰æ–¹å®£è¨€=== ///
class ParticleGroup;

///=====================================================/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
/// ImGuiã‚’ä½¿ç”¨ã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç·¨é›†UI
///=====================================================///
class ParticleEditor {
public:

    ParticleEditor();
    ~ParticleEditor();

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize();

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();

    /// <summary>
    /// ImGUIæç”»å‡¦ç†
    /// </summary>
    void Render();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»å‡¦ç†ï¼ˆã‚²ãƒ¼ãƒ ç”»é¢ã«è¡¨ç¤ºï¼‰
    /// </summary>
    void DrawPreview();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
    /// </summary>
    void ToggleVisibility();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’è¨­å®š
    /// </summary>
    void SetVisible(bool visible);

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹
    /// </summary>
    bool IsVisible() const;

private:

    /// ===ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ=== ///

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    /// </summary>
    void SaveToJson();

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
    /// </summary>
    void LoadFromJson();

    /// <summary>
    /// æ–°è¦ä½œæˆ
    /// </summary>
    void CreateNew();

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ¶å¾¡=== ///

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿé–‹å§‹
    /// </summary>
    void PlayPreview();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åœæ­¢
    /// </summary>
    void StopPreview();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void ResetPreview();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç”Ÿæˆ
    /// </summary>
    void CreatePreviewParticle();

    /// ===ImGuiæç”»é–¢æ•°ç¾¤=== ///

    /// <summary>
    /// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
    /// </summary>
    void RenderMenuBar();

    /// <summary>
    /// åŸºæœ¬è¨­å®šUIã®æç”»
    /// </summary>
    void RenderBasicSettings();

    /// <summary>
    /// ç‰©ç†è¨­å®šUIã®æç”»
    /// </summary>
    void RenderPhysicsSettings();

    /// <summary>
    /// è¦‹ãŸç›®è¨­å®šUIã®æç”»
    /// </summary>
    void RenderAppearanceSettings();

    /// <summary>
    /// å›è»¢è¨­å®šUIã®æç”»
    /// </summary>
    void RenderRotationSettings();

    /// <summary>
    /// ç™ºç”Ÿè¨­å®šUIã®æç”»
    /// </summary>
    void RenderEmissionSettings();

    /// <summary>
    /// é …ã§è¨­å®šUIã®æç”»
    /// </summary>
    void RenderAdvancedSettings();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UIã®æç”»
    /// </summary>
    void RenderPreviewControls();

    /// <summary>
    /// ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œUIã®æç”»
    /// </summary>
    void RenderFileOperations();

    /// ===ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°=== ///

    /// <summary>
    /// åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆã‚’å–å¾—
    /// </summary>
    void UpdateAvailableModels();

    /// <summary>
    /// åˆ©ç”¨å¯èƒ½ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒªã‚¹ãƒˆã‚’å–å¾—
    /// </summary>
    void UpdateAvailableTextures();

    /// <summary>
    /// ãƒ—ãƒªã‚»ãƒƒãƒˆä¸€è¦§ã®å–å¾—
    /// </summary>
    void UpdateAvailablePresets();

    /// <summary>
    /// è»Œè·¡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®æ›´æ–°
    /// </summary>
    void UpdateTrajectoryPreview();

    /// <summary>
    ///  ãƒ—ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void ApplyTrajectoryPreset();
    void ApplyExplosionPreset();
    void ApplyMagicCirclePreset();
    void ApplySmokePreset();

private:

    /// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼çŠ¶æ…‹=== ///
    bool isVisible_ = false;                              // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®è¡¨ç¤ºçŠ¶æ…‹
    ParticleDefinition currentDefinition_;                // ç·¨é›†ä¸­ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é–¢é€£=== ///
    std::unique_ptr<ParticleGroup> previewParticle_;     // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
    bool isPlaying_ = false;                              // å†ç”Ÿä¸­ãƒ•ãƒ©ã‚°
    bool autoReplay_ = true;                              // è‡ªå‹•ãƒªãƒ—ãƒ¬ã‚¤
    Vector3 previewPosition_ = { 0.0f, 0.0f, 0.0f };     // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ä½ç½®
	BlendMode previewBlendMode_ = BlendMode::kBlendModeAdd; // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰

    /// ===ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†=== ///
    char filePathBuffer_[256] = "Assets/Particles/";     // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹å…¥åŠ›ãƒãƒƒãƒ•ã‚¡
    std::string currentFilePath_;                         // ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
    std::vector<std::string> availableModels_;           // åˆ©ç”¨å¯èƒ½ãªãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆ
    std::vector<std::string> availableTextures_;         // åˆ©ç”¨å¯èƒ½ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚¹ãƒˆ
    std::vector<std::string> availablePresets_;          // åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆãƒªã‚¹ãƒˆ

    /// ===UIçŠ¶æ…‹=== ///
    int selectedModelIndex_ = 0;                         // é¸æŠä¸­ã®ãƒ¢ãƒ‡ãƒ«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    int selectedTextureIndex_ = 0;                       // é¸æŠä¸­ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    int selectedPresetIndex_ = 0;                        // é¸æŠä¸­ã®ãƒ—ãƒªã‚»ãƒƒãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
    bool showSaveDialog_ = false;                        // ä¿å­˜ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤ºãƒ•ãƒ©ã‚°
    bool showLoadDialog_ = false;                        // èª­ã¿è¾¼ã¿ãƒ€ã‚¤ã‚¢ãƒ­ã‚°è¡¨ç¤ºãƒ•ãƒ©ã‚°

    /// ===è»Œè·¡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼=== ///
    bool trajectoryPreviewMode_ = false;        // è»Œè·¡ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒ¢ãƒ¼ãƒ‰
    Vector3 trajectoryStartPos_ = { -3, 0, 0 };   // è»Œè·¡é–‹å§‹ä½ç½®
    Vector3 trajectoryEndPos_ = { 3, 0, 0 };      // è»Œè·¡çµ‚äº†ä½ç½®
    float trajectoryProgress_ = 0.0f;           // è»Œè·¡ã®é€²è¡Œåº¦(0~1)
    float trajectorySpeed_ = 1.0f;              // è»Œè·¡ã®é€Ÿåº¦
    Vector3 trajectoryRotation_ = { 0, 0, 0 };    // è»Œè·¡ã®å›è»¢

    /// ===å®šæ•°=== ///
    static constexpr const char* kDefaultSavePath = "Resource/Json/Particles/";
    static constexpr const char* kFileExtension = ".json";
};

============================================================
File Path: Project/Engine/System/ImGui/SceneView.cpp
============================================================
#include "SceneView.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#include <imgui_impl_dx12.h>
#include <imgui_impl_win32.h>
#endif // USE_IMGUI

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void SceneView::SetTextureHandle(D3D12_GPU_DESCRIPTOR_HANDLE handle) { textureHandle_ = handle; }

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void SceneView::Draw() {
#ifdef USE_IMGUI
    ImGui::Begin("Scene");
    ImVec2 size = ImGui::GetContentRegionAvail();
    ImGui::Image((ImTextureID)textureHandle_.ptr, size);
    ImGui::End();
#endif // USE_IMGUI
}


============================================================
File Path: Project/Engine/System/ImGui/SceneView.h
============================================================
#pragma once
/// ===Include=== ///
#include <d3dx12.h>

///-------------------------------------------/// 
/// SceneView
///-------------------------------------------///
class SceneView {
public:
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
	/// </summary>
	/// <param name="handle">ãƒãƒ³ãƒ‰ãƒ«</param>
	void SetTextureHandle(D3D12_GPU_DESCRIPTOR_HANDLE handle);

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

private:
	D3D12_GPU_DESCRIPTOR_HANDLE textureHandle_{};
};



============================================================
File Path: Project/Engine/System/Input/Controller.cpp
============================================================
#include "Controller.h"
// c++
#include <cassert>
#include <algorithm>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Controller::~Controller() {}


///-------------------------------------------/// 
/// åˆæœŸåŒ–ã€€å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
void Controller::Initialize() {
	ZeroMemory(currentState_, sizeof(currentState_));
	ZeroMemory(previousState_, sizeof(previousState_));
	ZeroMemory(currentDIState_, sizeof(currentDIState_));
	ZeroMemory(previousDIState_, sizeof(previousDIState_));

	// XInput / DirectInput ã®ãƒœã‚¿ãƒ³ãƒãƒƒãƒ”ãƒ³ã‚°
	buttonMapping_ = {
		{ControllerButtonType::A, {static_cast<WORD>(XINPUT_GAMEPAD_A), 0}},  // Aãƒœã‚¿ãƒ³
		{ControllerButtonType::B, {static_cast<WORD>(XINPUT_GAMEPAD_B), 1}},  // Bãƒœã‚¿ãƒ³
		{ControllerButtonType::X, {static_cast<WORD>(XINPUT_GAMEPAD_X), 2}},  // Xãƒœã‚¿ãƒ³
		{ControllerButtonType::Y, {static_cast<WORD>(XINPUT_GAMEPAD_Y), 3}},  // Yãƒœã‚¿ãƒ³
		{ControllerButtonType::RB, {static_cast<WORD>(XINPUT_GAMEPAD_RIGHT_SHOULDER), 5}},  // RB
		{ControllerButtonType::LB, {static_cast<WORD>(XINPUT_GAMEPAD_LEFT_SHOULDER), 4}},   // LB
		{ControllerButtonType::DPadUP, {static_cast<WORD>(XINPUT_GAMEPAD_DPAD_UP), 10}},    // DPad â†‘
		{ControllerButtonType::DPadDOWN, {static_cast<WORD>(XINPUT_GAMEPAD_DPAD_DOWN), 12}}, // DPad â†“
		{ControllerButtonType::DPadLEFT, {static_cast<WORD>(XINPUT_GAMEPAD_DPAD_LEFT), 13}}, // DPad â†
		{ControllerButtonType::DPadRIGHT, {static_cast<WORD>(XINPUT_GAMEPAD_DPAD_RIGHT), 11}}, // DPad â†’
		{ControllerButtonType::LeftStick, {static_cast<WORD>(XINPUT_GAMEPAD_LEFT_THUMB), 6}},   // Lã‚¹ãƒ†ã‚£ãƒƒã‚¯æŠ¼ã—è¾¼ã¿
		{ControllerButtonType::RightStick, {static_cast<WORD>(XINPUT_GAMEPAD_RIGHT_THUMB), 7}}, // Rã‚¹ãƒ†ã‚£ãƒƒã‚¯æŠ¼ã—è¾¼ã¿
	};
}


///-------------------------------------------/// 
/// æ›´æ–° å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
void Controller::Update() {
	for (int i = 0; i < XUSER_MAX_COUNT; ++i) {
		previousState_[i] = currentState_[i];
		ZeroMemory(&currentState_[i], sizeof(XINPUT_STATE));
		XInputGetState(i, &currentState_[i]);

		previousDIState_[i] = currentDIState_[i];
		ZeroMemory(&currentDIState_[i], sizeof(DIJOYSTATE2));
	}
}


///-------------------------------------------/// 
/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å–å¾—
///-------------------------------------------///
// XInput
bool Controller::GetJoystickState(int stickNo, XINPUT_STATE& out) const {
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return false;
	out = currentState_[stickNo];
	return true;
}
bool Controller::GetJoystickStatePrevious(int stickNo, XINPUT_STATE& out) const {
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return false;
	out = previousState_[stickNo];
	return true;
}
// DirectInput
bool Controller::GetJoystickState(int stickNo, DIJOYSTATE2& out) const {
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return false;
	out = currentDIState_[stickNo];
	return true;
}
bool Controller::GetJoystickStatePrevious(int stickNo, DIJOYSTATE2& out) const {
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return false;
	out = previousDIState_[stickNo];
	return true;
}


///-------------------------------------------/// 
/// æŒ‡å®šã—ãŸãƒœã‚¿ãƒ³ã® XInput / DirectInput ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å–å¾—
///-------------------------------------------///
std::pair<WORD, int> Controller::ConvertToButton(ControllerButtonType button) const {
	auto it = buttonMapping_.find(button);
	if (it != buttonMapping_.end()) {
		return it->second;
	}
	return std::make_pair(static_cast<WORD>(0), -1); // ç„¡åŠ¹ãªãƒœã‚¿ãƒ³
}


///-------------------------------------------/// 
/// ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã„ã‚‹é–“ã€€å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
bool Controller::PushButton(int stickNo, ControllerButtonType button) const {
	auto [xInputButton, dInputButton] = ConvertToButton(button);

	// XInput ã®é€šå¸¸ãƒœã‚¿ãƒ³
	if ((currentState_[stickNo].Gamepad.wButtons & xInputButton)) {
		return true;
	}

	// DirectInput ã®ãƒœã‚¿ãƒ³å‡¦ç†
	if (dInputButton >= 0 && (currentDIState_[stickNo].rgbButtons[dInputButton] & 0x80)) {
		return true;
	}

	// LTï¼ˆå·¦ãƒˆãƒªã‚¬ãƒ¼ï¼‰ DirectInput è¿½åŠ 
	if (button == ControllerButtonType::LT) {
		return (currentState_[stickNo].Gamepad.bLeftTrigger > TRIGGER_THRESHOLD ||
			currentDIState_[stickNo].lZ > 32767); // DirectInput ã®ãƒˆãƒªã‚¬ãƒ¼å‡¦ç†
	}

	// RTï¼ˆå³ãƒˆãƒªã‚¬ãƒ¼ï¼‰ DirectInput è¿½åŠ 
	if (button == ControllerButtonType::RT) {
		return (currentState_[stickNo].Gamepad.bRightTrigger > TRIGGER_THRESHOLD ||
			currentDIState_[stickNo].lRz > 32767);
	}

	return false;
}


///-------------------------------------------/// 
/// ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ãŸç¬é–“ã€€å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
bool Controller::TriggerButton(int stickNo, ControllerButtonType button) const {
	auto [xInputButton, dInputButton] = ConvertToButton(button);

	// XInput ã®é€šå¸¸ãƒœã‚¿ãƒ³
	if ((currentState_[stickNo].Gamepad.wButtons & xInputButton) &&
		!(previousState_[stickNo].Gamepad.wButtons & xInputButton)) {
		return true;
	}

	// DirectInput ã®ãƒœã‚¿ãƒ³å‡¦ç†
	if (dInputButton >= 0 &&
		(currentDIState_[stickNo].rgbButtons[dInputButton] & 0x80) &&
		!(previousDIState_[stickNo].rgbButtons[dInputButton] & 0x80)) {
		return true;
	}

	// LTï¼ˆå·¦ãƒˆãƒªã‚¬ãƒ¼
	if (button == ControllerButtonType::LT) {
		return (currentState_[stickNo].Gamepad.bLeftTrigger > TRIGGER_THRESHOLD &&
			previousState_[stickNo].Gamepad.bLeftTrigger <= TRIGGER_THRESHOLD) ||
			(currentDIState_[stickNo].lZ > 32767 && previousDIState_[stickNo].lZ <= 32767);
	}

	// RTï¼ˆå³ãƒˆãƒªã‚¬ãƒ¼ï¼‰
	if (button == ControllerButtonType::RT) {
		return (currentState_[stickNo].Gamepad.bRightTrigger > TRIGGER_THRESHOLD &&
			previousState_[stickNo].Gamepad.bRightTrigger <= TRIGGER_THRESHOLD) ||
			(currentDIState_[stickNo].lRz > 32767 && previousDIState_[stickNo].lRz <= 32767);
	}

	return false;
}


///-------------------------------------------/// 
/// ãƒœã‚¿ãƒ³ã‚’é›¢ã—ãŸç¬é–“ å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
bool Controller::ReleaseButton(int stickNo, ControllerButtonType button) const {
	auto [xInputButton, dInputButton] = ConvertToButton(button);

	// XInput ã®é€šå¸¸ãƒœã‚¿ãƒ³
	if (!(currentState_[stickNo].Gamepad.wButtons & xInputButton) &&
		(previousState_[stickNo].Gamepad.wButtons & xInputButton)) {
		return true;
	}

	// DirectInput ã®ãƒœã‚¿ãƒ³å‡¦ç†
	if (dInputButton >= 0 &&
		!(currentDIState_[stickNo].rgbButtons[dInputButton] & 0x80) &&
		(previousDIState_[stickNo].rgbButtons[dInputButton] & 0x80)) {
		return true;
	}

	// LTï¼ˆå·¦ãƒˆãƒªã‚¬ãƒ¼ï¼‰ DirectInput è¿½åŠ 
	if (button == ControllerButtonType::LT) {
		return (currentState_[stickNo].Gamepad.bLeftTrigger <= TRIGGER_THRESHOLD &&
			previousState_[stickNo].Gamepad.bLeftTrigger > TRIGGER_THRESHOLD) ||
			(currentDIState_[stickNo].lZ <= 32767 && previousDIState_[stickNo].lZ > 32767);
	}

	// RTï¼ˆå³ãƒˆãƒªã‚¬ãƒ¼ï¼‰ DirectInput è¿½åŠ 
	if (button == ControllerButtonType::RT) {
		return (currentState_[stickNo].Gamepad.bRightTrigger <= TRIGGER_THRESHOLD &&
			previousState_[stickNo].Gamepad.bRightTrigger > TRIGGER_THRESHOLD) ||
			(currentDIState_[stickNo].lRz <= 32767 && previousDIState_[stickNo].lRz > 32767);
	}

	return false;
}


///-------------------------------------------/// 
/// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ³ã‚’å–å¾— å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
// å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ³ã‚’å–å¾—
StickState Controller::GetLeftStickState(int stickNo) const {
	StickState state = { 0.0f, 0.0f };
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return state;

	// XInput ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯å€¤ï¼ˆ-1.0f ï½ 1.0fï¼‰
	float lxXInput = static_cast<float>(currentState_[stickNo].Gamepad.sThumbLX) / NORMALIZE_RANGE;
	float lyXInput = static_cast<float>(currentState_[stickNo].Gamepad.sThumbLY) / NORMALIZE_RANGE;

	// DirectInput ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯å€¤ï¼ˆ0 ï½ 65535 â†’ -1.0f ï½ 1.0f ã«å¤‰æ›ï¼‰
	float lxDInput = (static_cast<float>(currentDIState_[stickNo].lX) - 32767.0f) / 32767.0f;
	float lyDInput = (static_cast<float>(currentDIState_[stickNo].lY) - 32767.0f) / 32767.0f; // Yè»¸ã¯åè»¢

	// ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³å‡¦ç†ï¼ˆå¾®å°ãªå…¥åŠ›ã‚’ç„¡è¦–ï¼‰
	if (std::abs(lxXInput) < DEADZONE) lxXInput = 0.0f;
	if (std::abs(lyXInput) < DEADZONE) lyXInput = 0.0f;
	if (std::abs(lxDInput) < DEADZONE) lxDInput = 0.0f;
	if (std::abs(lyDInput) < DEADZONE) lyDInput = 0.0f;

	// XInput ã¨ DirectInput ã®å¤§ãã„æ–¹ã‚’æ¡ç”¨
	state.x = std::max<float>(lxXInput, std::clamp<float>(lxDInput, -1.0f, 1.0f));
	state.y = std::max<float>(lyXInput, std::clamp<float>(lyDInput, -1.0f, 1.0f));

	return state;
}
// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ³ã‚’å–å¾—
StickState Controller::GetRightStickState(int stickNo) const {
	StickState state = { 0.0f, 0.0f };
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return state;

	// XInput ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯å€¤ï¼ˆ-1.0f ï½ 1.0fï¼‰
	float rxXInput = static_cast<float>(currentState_[stickNo].Gamepad.sThumbRX) / NORMALIZE_RANGE;
	float ryXInput = static_cast<float>(currentState_[stickNo].Gamepad.sThumbRY) / NORMALIZE_RANGE;

	// DirectInput ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯å€¤ï¼ˆ0 ï½ 65535 â†’ -1.0f ï½ 1.0f ã«å¤‰æ›ï¼‰
	float rxDInput = (static_cast<float>(currentDIState_[stickNo].lRx) - 32767.0f) / 32767.0f;
	float ryDInput = (static_cast<float>(currentDIState_[stickNo].lRy) - 32767.0f) / 32767.0f; // Yè»¸ã¯åè»¢

	// ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³å‡¦ç†ï¼ˆå¾®å°ãªå…¥åŠ›ã‚’ç„¡è¦–ï¼‰
	if (std::abs(rxXInput) < DEADZONE) rxXInput = 0.0f;
	if (std::abs(ryXInput) < DEADZONE) ryXInput = 0.0f;
	if (std::abs(rxDInput) < DEADZONE) rxDInput = 0.0f;
	if (std::abs(ryDInput) < DEADZONE) ryDInput = 0.0f;

	// XInput ã¨ DirectInput ã®å¤§ãã„æ–¹ã‚’æ¡ç”¨
	state.x = std::max<float>(rxXInput, std::clamp<float>(rxDInput, -1.0f, 1.0f));
	state.y = std::max<float>(ryXInput, std::clamp<float>(ryDInput, -1.0f, 1.0f));

	return state;
}


///-------------------------------------------/// 
/// æŒ‡å®šã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å€¤ã‚’å–å¾— å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
float Controller::GetStickValue(int stickNo, ControllerValueType valueType) const {
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return 0.0f;

	// XInput / DirectInput ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯å€¤
	float xInputValue = 0.0f;
	float dInputValue = 0.0f;

	switch (valueType) {
	case ControllerValueType::LX:
		xInputValue = static_cast<float>(currentState_[stickNo].Gamepad.sThumbLX) / NORMALIZE_RANGE;
		dInputValue = static_cast<float>(currentDIState_[stickNo].lX) / 32767.0f; // DirectInput ã®ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´
		break;
	case ControllerValueType::LY:
		xInputValue = static_cast<float>(currentState_[stickNo].Gamepad.sThumbLY) / NORMALIZE_RANGE;
		dInputValue = static_cast<float>(currentDIState_[stickNo].lY) / 32767.0f;
		break;
	case ControllerValueType::RX:
		xInputValue = static_cast<float>(currentState_[stickNo].Gamepad.sThumbRX) / NORMALIZE_RANGE;
		dInputValue = static_cast<float>(currentDIState_[stickNo].lRx) / 32767.0f;
		break;
	case ControllerValueType::RY:
		xInputValue = static_cast<float>(currentState_[stickNo].Gamepad.sThumbRY) / NORMALIZE_RANGE;
		dInputValue = static_cast<float>(currentDIState_[stickNo].lRy) / 32767.0f;
		break;
	default:
		return 0.0f;
	}

	// ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³å‡¦ç†ï¼ˆå¾®å°ãªå…¥åŠ›ã‚’ç„¡è¦–ï¼‰
	if (std::abs(xInputValue) < DEADZONE) xInputValue = 0.0f;
	if (std::abs(dInputValue) < DEADZONE) dInputValue = 0.0f;

	// XInput ã¨ DirectInput ã®å€¤ã®ã†ã¡ã€å¤§ãã„æ–¹ã‚’æ¡ç”¨
	return std::max<float>(xInputValue, std::clamp<float>(dInputValue, -1.0f, 1.0f));
}


///-------------------------------------------/// 
/// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å‰ãƒ•ãƒ¬ãƒ¼ãƒ çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹é–¢æ•°
///-------------------------------------------///
// å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯
StickState Controller::GetLeftStickStatePrevious(int stickNo) const {
	StickState state = { 0.0f, 0.0f };
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return state;

	float lxXInput = static_cast<float>(previousState_[stickNo].Gamepad.sThumbLX) / NORMALIZE_RANGE;
	float lyXInput = static_cast<float>(previousState_[stickNo].Gamepad.sThumbLY) / NORMALIZE_RANGE;

	float lxDInput = (static_cast<float>(previousDIState_[stickNo].lX) - 32767.0f) / 32767.0f;
	float lyDInput = (static_cast<float>(previousDIState_[stickNo].lY) - 32767.0f) / 32767.0f;

	if (std::abs(lxXInput) < DEADZONE) lxXInput = 0.0f;
	if (std::abs(lyXInput) < DEADZONE) lyXInput = 0.0f;
	if (std::abs(lxDInput) < DEADZONE) lxDInput = 0.0f;
	if (std::abs(lyDInput) < DEADZONE) lyDInput = 0.0f;

	state.x = std::max<float>(lxXInput, std::clamp<float>(lxDInput, -1.0f, 1.0f));
	state.y = std::max<float>(lyXInput, std::clamp<float>(lyDInput, -1.0f, 1.0f));

	return state;
}
// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯
StickState Controller::GetRightStickStatePrevious(int stickNo) const {
	StickState state = { 0.0f, 0.0f };
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return state;

	float rxXInput = static_cast<float>(previousState_[stickNo].Gamepad.sThumbRX) / NORMALIZE_RANGE;
	float ryXInput = static_cast<float>(previousState_[stickNo].Gamepad.sThumbRY) / NORMALIZE_RANGE;

	float rxDInput = (static_cast<float>(previousDIState_[stickNo].lRx) - 32767.0f) / 32767.0f;
	float ryDInput = (static_cast<float>(previousDIState_[stickNo].lRy) - 32767.0f) / 32767.0f;

	if (std::abs(rxXInput) < DEADZONE) rxXInput = 0.0f;
	if (std::abs(ryXInput) < DEADZONE) ryXInput = 0.0f;
	if (std::abs(rxDInput) < DEADZONE) rxDInput = 0.0f;
	if (std::abs(ryDInput) < DEADZONE) ryDInput = 0.0f;

	state.x = std::max<float>(rxXInput, std::clamp<float>(rxDInput, -1.0f, 1.0f));
	state.y = std::max<float>(ryXInput, std::clamp<float>(ryDInput, -1.0f, 1.0f));

	return state;
}


///-------------------------------------------/// 
/// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ã¯ã˜ãï¼ˆ Flick ï¼‰ã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°
///-------------------------------------------///
// å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯
bool Controller::FlickLeftStick(int stickNo, float threshold) const {
	StickState prev = GetLeftStickStatePrevious(stickNo);
	StickState curr = GetLeftStickState(stickNo);

	float prevLen = std::sqrt(prev.x * prev.x + prev.y * prev.y);
	float currLen = std::sqrt(curr.x * curr.x + curr.y * curr.y);

	return (prevLen < DEADZONE && currLen >= threshold);
}
// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯
bool Controller::FlickRightStick(int stickNo, float threshold) const {
	StickState prev = GetRightStickStatePrevious(stickNo);
	StickState curr = GetRightStickState(stickNo);

	float prevLen = std::sqrt(prev.x * prev.x + prev.y * prev.y);
	float currLen = std::sqrt(curr.x * curr.x + curr.y * curr.y);

	return (prevLen < DEADZONE && currLen >= threshold);
}


///-------------------------------------------/// 
/// ãƒœã‚¿ãƒ³ã®æŠ¼ã—è¾¼ã¿é‡ã‚’å–å¾—ã€€å¯¾å¿œæ¸ˆã¿
///-------------------------------------------///
float Controller::GetTriggerValue(int stickNo, ControllerButtonType button) const {
	if (stickNo < 0 || stickNo >= XUSER_MAX_COUNT) return 0.0f;

	switch (button) {
		// XInput / DirectInput ã® LTï¼ˆå·¦ãƒˆãƒªã‚¬ãƒ¼ï¼‰
	case ControllerButtonType::LT:
	{
		float lTriggerDI = static_cast<float>(currentDIState_[stickNo].lZ) / 65535.0f;
		float lTriggerX = static_cast<float>(currentState_[stickNo].Gamepad.bLeftTrigger) / 255.0f;
		return std::max<float>(lTriggerX, std::clamp<float>(lTriggerDI, 0.0f, 1.0f));
	}

	// XInput / DirectInput ã® RTï¼ˆå³ãƒˆãƒªã‚¬ãƒ¼ï¼‰
	case ControllerButtonType::RT:
	{
		float rTriggerDI = static_cast<float>(currentDIState_[stickNo].lRz) / 65535.0f;
		float rTriggerX = static_cast<float>(currentState_[stickNo].Gamepad.bRightTrigger) / 255.0f;
		return std::max<float>(rTriggerX, std::clamp<float>(rTriggerDI, 0.0f, 1.0f));
	}

	// XInput / DirectInput ã® LBï¼ˆå·¦ãƒãƒ³ãƒ‘ãƒ¼ï¼‰
	case ControllerButtonType::LB:
		return ((currentState_[stickNo].Gamepad.wButtons & XINPUT_GAMEPAD_LEFT_SHOULDER) ||
			(currentDIState_[stickNo].rgbButtons[4] & 0x80)) ? 1.0f : 0.0f;

		// XInput / DirectInput ã® RBï¼ˆå³ãƒãƒ³ãƒ‘ãƒ¼ï¼‰
	case ControllerButtonType::RB:
		return ((currentState_[stickNo].Gamepad.wButtons & XINPUT_GAMEPAD_RIGHT_SHOULDER) ||
			(currentDIState_[stickNo].rgbButtons[5] & 0x80)) ? 1.0f : 0.0f;

	default:
		return 0.0f;
	}
}


============================================================
File Path: Project/Engine/System/Input/Controller.h
============================================================
#pragma once
/// ===Includ=== ///
// Engine
#include "Engine/Core/ComPtr.h"
#include "Engine/DataInfo/InputData.h"

// c++
#include <cstdint>
#include <map>
#include <cmath>

///=====================================================/// 
///	ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
///=====================================================///
class Controller {
public:

	Controller() =default;
	~Controller();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚’å–å¾—
    /// </summary>
    /// <param name="stickNo">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç•ªå·</param>
    /// <param name="out">ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å ´æ‰€</param>
    /// <returns>ãƒ•ãƒ©ã‚°ã‚’è¿”ã™</returns>
    bool GetJoystickState(int stickNo, XINPUT_STATE& out) const;
    bool GetJoystickStatePrevious(int stickNo, XINPUT_STATE& out) const;
	bool GetJoystickState(int stickNo, DIJOYSTATE2& out) const;
	bool GetJoystickStatePrevious(int stickNo, DIJOYSTATE2& out) const;

    /// <summary>
    /// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®æŠ¼ä¸‹ãƒã‚§ãƒƒã‚¯
    /// </summary>
    /// <param name="stickNo">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç•ªå·</param>
    /// <param name="button">ãƒœã‚¿ãƒ³ã®ç¨®é¡</param>
    /// <returns>ãƒ•ãƒ©ã‚°ã‚’è¿”ã™</returns>
    bool PushButton(int stickNo, ControllerButtonType button) const;
    bool TriggerButton(int stickNo, ControllerButtonType button) const;
    bool ReleaseButton(int stickNo, ControllerButtonType button) const;

    /// <summary>
    /// ãƒœã‚¿ãƒ³ã®æŠ¼ã—è¾¼ã¿é‡ã‚’å–å¾—
    /// </summary>
    /// <param name="stickNo">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç•ªå·</param>
    /// <param name="button">ãƒœã‚¿ãƒ³ã®ç¨®é¡</param>
    /// <returns>æŠ¼ã—è¾¼ã¿ã®æ•°å€¤ã‚’è¿”ã™</returns>
    float GetTriggerValue(int stickNo, ControllerButtonType button) const;

    /// <summary>
    /// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ³ã‚’å–å¾—
    /// </summary>
    /// <param name="stickNo">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç•ªå·</param>
    /// <returns>ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’è¿”ã™</returns>
    StickState GetLeftStickState(int stickNo) const;
    StickState GetRightStickState(int stickNo) const;
    float GetStickValue(int stickNo, ControllerValueType valueType) const;

    /// <summary>
    /// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å‰ãƒ•ãƒ¬ãƒ¼ãƒ çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹é–¢æ•°
    /// </summary>
    /// <param name="stickNo">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç•ªå·</param>
    /// <returns>ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’è¿”ã™</returns>
    StickState GetLeftStickStatePrevious(int stickNo) const;
    StickState GetRightStickStatePrevious(int stickNo) const;

    /// <summary>
    /// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ã¯ã˜ãï¼ˆ Flick ï¼‰ã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°
    /// </summary>
    /// <param name="stickNo">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç•ªå·</param>
    /// <param name="threshold">ã¯ã˜ãã‚’æ„ŸçŸ¥ã™ã‚‹å¤§ãã•</param>
    /// <returns>ãƒ•ãƒ©ã‚°ã‚’è¿”ã™</returns>
    bool FlickLeftStick(int stickNo, float threshold = 0.7f) const;
    bool FlickRightStick(int stickNo, float threshold = 0.7f) const;

private:
    static constexpr float NORMALIZE_RANGE = 32768.0f; // XInputã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯æœ€å¤§å€¤
    static constexpr float TRIGGER_THRESHOLD = 128.0f; // ãƒˆãƒªã‚¬ãƒ¼ãƒœã‚¿ãƒ³åˆ¤å®šã®ã—ãã„å€¤
    static constexpr float DEADZONE = 0.15f; // ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³ï¼ˆ15%ï¼‰

	// XInput å¯¾å¿œç”¨
    XINPUT_STATE currentState_[XUSER_MAX_COUNT]{};
    XINPUT_STATE previousState_[XUSER_MAX_COUNT]{};

    // DirectInput å¯¾å¿œç”¨
    DIJOYSTATE2 currentDIState_[XUSER_MAX_COUNT]{};
    DIJOYSTATE2 previousDIState_[XUSER_MAX_COUNT]{};

    std::map<ControllerButtonType, std::pair<WORD, int>> buttonMapping_;

private:
    /// <summary>
    /// æŒ‡å®šã—ãŸãƒœã‚¿ãƒ³ã® XInput / DirectInput ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’å–å¾—
    /// </summary>
    /// <param name="button">ãƒœã‚¿ãƒ³ã®ç¨®é¡</param>
    /// <returns>ãƒšã‚¢ã‚’è¿”ã™</returns>
    std::pair<WORD, int> ConvertToButton(ControllerButtonType button) const;
};



============================================================
File Path: Project/Engine/System/Input/InputCommon.cpp
============================================================
#include "InputCommon.h"
// Engine
#include "Engine/Core/WinApp.h"
// c++
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
InputCommon::~InputCommon() { 
	directInput_.Reset(); 
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void InputCommon::Initialize(WinApp * winApp) {
	HRESULT hr;

	// DirectInputã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®ç”Ÿæˆ
	hr = DirectInput8Create(winApp->GetWNDClass().hInstance, DIRECTINPUT_VERSION, IID_IDirectInput8, (void**)&directInput_, nullptr);
	assert(SUCCEEDED(hr));
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ComPtr<IDirectInput8> InputCommon::GetDirectInput() { return directInput_; }


============================================================
File Path: Project/Engine/System/Input/InputCommon.h
============================================================
#pragma once
// Engine
#include "Engine/Core/ComPtr.h"
// c++
#define DIRECTINPUT_VERSION   0x0800   // DirectInputã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
#include <dinput.h>
#include <Windows.h>
#include <array>
#include <vector>
#include <wrl.h>

#pragma comment(lib, "dinput8.lib")
#pragma comment(lib, "dxguid.lib")

/// ===å‰æ–¹å®£è¨€=== ///
class WinApp;

///=====================================================/// 
/// å…±é€šå…¥åŠ›å‡¦ç†
///=====================================================///
class InputCommon {
public:

	InputCommon() = default;
	~InputCommon();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="winApp">Class WinApp</param>
	void Initialize(WinApp* winApp);
	
public: /// ===Getter=== ///
	// DirectInput
	ComPtr<IDirectInput8> GetDirectInput();

private:
	// DirectInputã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	ComPtr<IDirectInput8> directInput_; 
};



============================================================
File Path: Project/Engine/System/Input/Keyboard.cpp
============================================================
#include "Keyboard.h"
// Engine
#include "Engine/Core/WinApp.h"
#include "InputCommon.h"
// c++
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Keyboard::~Keyboard() {
	if (keyboard_) {
		keyboard_->Unacquire();
	}
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Keyboard::Initialize(WinApp * winApp, IDirectInput8 * input) {
	HRESULT hr;

	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	hr = input->CreateDevice(GUID_SysKeyboard, &keyboard_, nullptr);
	assert(SUCCEEDED(hr));
	// å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	hr = keyboard_->SetDataFormat(&c_dfDIKeyboard);
	assert(SUCCEEDED(hr));
	// æ’ä»–çš„åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	hr = keyboard_->SetCooperativeLevel(winApp->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Keyboard::Update() {
	HRESULT hr;

	// å‰å›ã®å…¥åŠ›ã‚’ä¿æŒ
	memcpy(preKey_, key_, sizeof(key_));

	// æƒ…å ±ã®å–å¾—ã‚’é–‹å§‹
	hr = keyboard_->Acquire();
	if (SUCCEEDED(hr)) {
		keyboard_->GetDeviceState(sizeof(key_), key_);
	}

	// å…¨ã‚­ãƒ¼ã®å…¥åŠ›æƒ…å ±ã‚’å–å¾—
	hr = keyboard_->GetDeviceState(sizeof(key_), key_);
}

///-------------------------------------------/// 
/// ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
///-------------------------------------------///
bool Keyboard::PushKey(BYTE keyNum) {
	// æŒ‡å®šã‚­ãƒ¼ã‚’æŠ¼ã—ã¦å…¥ã‚Œã°Trueã‚’è¿”ã™
	if (key_[keyNum]) {
		return true;
	}
	// ãã†ã§ãªã‘ã‚Œã°Falseã‚’è¿”ã™
	return false;
}

///-------------------------------------------/// 
/// ã‚­ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
///-------------------------------------------///
bool Keyboard::TriggerKey(BYTE keyNum) {
	// æŒ‡å®šã‚­ãƒ¼ãŒãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã¦ã„ã‚Œã°trueã‚’è¿”ã™
	if (key_[keyNum] && !preKey_[keyNum]) {
		return true;
	}
	// ãã†ã§ãªã‘ã‚Œã°Falseã‚’è¿”ã™
	return false;
}


============================================================
File Path: Project/Engine/System/Input/Keyboard.h
============================================================
#pragma once
/// ===Includ=== ///
// Engine
#include "Engine/Core/ComPtr.h"
#include "Engine/DataInfo/InputData.h"

/// ===å‰æ–¹å®£è¨€=== ///
class WinApp;

///-------------------------------------------///
/// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
///-------------------------------------------///
class Keyboard {
public:

	Keyboard() = default;
	~Keyboard();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="winApp">Class WinApp</param>
	/// <param name="input">DirectInput</param>
	void Initialize(WinApp* winApp, IDirectInput8* input);
	
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="keyNum">ã‚­ãƒ¼ã®ã‚¿ã‚¤ãƒ—</param>
	/// <returns>ãƒ•ãƒ©ã‚°ã‚’è¿”ã™</returns>
	bool PushKey(BYTE keyNum);

	/// <summary>
	/// ã‚­ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="keyNum">ã‚­ãƒ¼ã®ã‚¿ã‚¤ãƒ—</param>
	/// <returns>ãƒ•ãƒ©ã‚°ã‚’è¿”ã™</returns>
	bool TriggerKey(BYTE keyNum);

private:
	// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ç”¨ã®DirectInputãƒ‡ãƒã‚¤ã‚¹
	ComPtr<IDirectInputDevice8> keyboard_; 
	// ç¾åœ¨ã®å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE key_[256] = {}; 
	// å‰å›ã®å…¨ã‚­ãƒ¼ã®çŠ¶æ…‹
	BYTE preKey_[256] = {}; 
};



============================================================
File Path: Project/Engine/System/Input/Mouse.cpp
============================================================
#include "Mouse.h"
// Engine
#include "Engine/Core/WinApp.h"
#include "InputCommon.h"
// c++
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Mouse::~Mouse() {
	if(mouse_) {
		mouse_->Unacquire();
	}
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Mouse::Initialize(WinApp * winApp, IDirectInput8 * input) {
	HRESULT hr;
	winApp_ = winApp;

	// ãƒã‚¦ã‚¹ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	hr = input->CreateDevice(GUID_SysMouse, &mouse_, nullptr);
	assert(SUCCEEDED(hr));
	// å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	hr = mouse_->SetDataFormat(&c_dfDIMouse);
	assert(SUCCEEDED(hr));
	// æ’ä»–çš„åˆ¶å¾¡ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	hr = mouse_->SetCooperativeLevel(winApp_->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE);
	assert(SUCCEEDED(hr));
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Mouse::Update() {
	HRESULT hr;

	// å‰å›ã®å…¥åŠ›ã‚’ä¿æŒ
	preMouseState_ = mouseState_;

	// çŠ¶æ…‹ã‚’å–å¾—
	hr = mouse_->Acquire();
	if (SUCCEEDED(hr)) {
		mouse_->GetDeviceState(sizeof(DIMOUSESTATE), &mouseState_);
	}
}

///-------------------------------------------/// 
/// ãƒã‚¦ã‚¹ã®æŠ¼ä¸‹ãƒã‚§ãƒƒã‚¯
///-------------------------------------------///
bool Mouse::PushMaouseButton(MouseButtonType button) {
	// ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆã«trueã‚’è¿”ã™
	return (mouseState_.rgbButtons[static_cast<int>(button)] & 0x80) != 0;
}

///-------------------------------------------/// 
/// ãƒã‚¦ã‚¹ã®ãƒˆãƒªã‚¬ãƒ¼ãƒã‚§ãƒƒã‚¯
///-------------------------------------------///
bool Mouse::TriggerMouseButton(MouseButtonType button) {
	// ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ãŒãƒˆãƒªã‚¬ãƒ¼ï¼ˆæŠ¼ã•ã‚ŒãŸç¬é–“ï¼‰ã®å ´åˆã«trueã‚’è¿”ã™
	return (mouseState_.rgbButtons[static_cast<int>(button)] & 0x80) &&
		!(preMouseState_.rgbButtons[static_cast<int>(button)] & 0x80);
}

///-------------------------------------------/// 
/// ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®ä½ç½®ã‚’å–å¾—ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ç³»ï¼‰
///-------------------------------------------///
POINT Mouse::GetMouseCursorPosition() const {
	POINT cursorPosition{};
	if (GetCursorPos(&cursorPosition)) {
		// ã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ã‹ã‚‰ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåº§æ¨™ã¸å¤‰æ›
		if (ScreenToClient(winApp_->GetHwnd(), &cursorPosition)) {
			return cursorPosition; // ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆåº§æ¨™ã‚’è¿”ã™
		}
	}
	return { -1, -1 }; // å¤±æ•—ã—ãŸå ´åˆã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
}

///-------------------------------------------/// 
/// ãƒã‚¦ã‚¹ã®Xè»¸ç§»å‹•é‡ã‚’å–å¾—
///-------------------------------------------///
LONG Mouse::GetMouseDeltaX() const {
	// ãƒã‚¦ã‚¹ã®Xè»¸ã®ç§»å‹•é‡ã‚’è¿”ã™
	return mouseState_.lX;
}

///-------------------------------------------/// 
/// ãƒã‚¦ã‚¹ã®Yè»¸ç§»å‹•é‡ã‚’å–å¾—
///-------------------------------------------///
LONG Mouse::GetMouseDeltaY() const {
	// ãƒã‚¦ã‚¹ã®Yè»¸ã®ç§»å‹•é‡ã‚’è¿”ã™
	return mouseState_.lY;
}

///-------------------------------------------/// 
/// ãƒã‚¦ã‚¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é‡ã‚’å–å¾—
///-------------------------------------------///
LONG Mouse::GetMouseDeltaScroll() const {
	// ãƒã‚¦ã‚¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é‡ã‚’è¿”ã™
	return mouseState_.lZ;
}


============================================================
File Path: Project/Engine/System/Input/Mouse.h
============================================================
#pragma once
/// ===Includ=== ///
// Engine
#include "Engine/Core/ComPtr.h"
#include "Engine/DataInfo/InputData.h"

/// ===å‰æ–¹å®£è¨€=== ///
class WinApp;

///=====================================================/// 
/// ãƒã‚¦ã‚¹
///=====================================================///
class Mouse {
public:

	Mouse() = default;
	~Mouse();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="winApp">class WinApp</param>
	/// <param name="input">DirectInput</param>
	void Initialize(WinApp* winApp, IDirectInput8* input);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="button">ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã®å ´æ‰€</param>
	/// <returns>ãƒ•ãƒ©ã‚°ã‚’è¿”ã™</returns>
	bool PushMaouseButton(MouseButtonType button);
	
	/// <summary>
	/// ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="button">ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã®ç¨®é¡</param>
	/// <returns>ãƒ•ãƒ©ã‚°ã‚’è¿”ã™</returns>
	bool TriggerMouseButton(MouseButtonType button);

	/// <summary>
	/// ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®ä½ç½®ã‚’å–å¾—ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ç³»ï¼‰
	/// </summary>
	/// <returns>åº§æ¨™ã‚’è¿”ã™ã€‚</returns>
	POINT GetMouseCursorPosition() const;

	/// <summary>
	/// ãƒã‚¦ã‚¹ã®xè»¸ã‚’ç§»å‹•é‡ã‚’å–å¾—
	/// </summary>
	/// <returns>ç§»å‹•é‡ã‚’è¿”ã™</returns>
	LONG GetMouseDeltaX() const;

	/// <summary>
	/// ãƒã‚¦ã‚¹ã®Yè»¸ã‚’ç§»å‹•é‡ã‚’å–å¾—
	/// </summary>
	/// <returns>ç§»å‹•é‡ã‚’è¿”ã™</returns>
	LONG GetMouseDeltaY() const;

	/// <summary>
	/// ãƒã‚¦ã‚¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é‡ã‚’å–å¾—
	/// </summary>
	/// <returns>ç§»å‹•é‡ã‚’è¿”ã™</returns>
	LONG GetMouseDeltaScroll() const;

private:
	WinApp* winApp_ = nullptr;

	/*NOTE : ä»Šå›ã¯DIMOUSESTATEã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŒãƒã‚¦ã‚¹ã®ãƒœã‚¿ãƒ³ã®æ•°ãŒï¼”ã¤ã˜ã‚ƒãªã‚Šãªã„ã®ãªã‚‰
	         DIMOUSESTATE2ã‚’ä½¿ç”¨ã™ã‚‹ã¨è‰¯ã„*/
	// ãƒã‚¦ã‚¹ç”¨ã®DirectInputãƒ‡ãƒã‚¤ã‚¹
	ComPtr<IDirectInputDevice8> mouse_; 
	// ç¾åœ¨ã®ãƒã‚¦ã‚¹ã®çŠ¶æ…‹
	DIMOUSESTATE mouseState_ = {}; 
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ãƒã‚¦ã‚¹ã®çŠ¶æ…‹
	DIMOUSESTATE preMouseState_ = {}; 
	
};



============================================================
File Path: Project/Engine/System/Managers/AnimationManager.cpp
============================================================
#include "AnimationManager.h"
// c++
#include <fstream>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
AnimationManager::~AnimationManager() {
	animationDatas_.clear();
}

///-------------------------------------------/// 
/// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
///-------------------------------------------///
void AnimationManager::Load(const std::string& baseDirectoryPath, const std::string& Key, const std::string& filename) {
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ¤œç´¢
	if (animationDatas_.contains(filename)) {
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸreturn
		return;
	}

	// Dataã®å®£è¨€
	std::map<std::string, Animation> animationData;
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®èª­ã¿è¾¼ã¿
	animationData = LoadAnimation(baseDirectoryPath, filename);

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’Mapã‚³ãƒ³ãƒ†ãƒŠã«æ ¼ç´
	animationDatas_[Key] = animationData;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
std::map<std::string, Animation> AnimationManager::GetAnimation(const std::string& directorPath) {
	assert(animationDatas_.contains(directorPath));
	return animationDatas_.at(directorPath);
}

///-------------------------------------------/// 
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
///-------------------------------------------///
std::map<std::string, Animation> AnimationManager::LoadAnimation(const std::string& directorPath, const std::string& filename) {
	/// ===LoadAnimationã‚’å®Ÿè£…ã™ã‚‹=== ///
	std::map<std::string, Animation> animations;
	Assimp::Importer importer;
	std::string filePath = directorPath + "/" + filename;
	const aiScene* scene = importer.ReadFile(filePath.c_str(), 0);
	assert(scene->mNumAnimations != 0); // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒãªã„
	
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ•°ã ã‘å›ã™
	for (uint32_t animationIndex = 0; animationIndex < scene->mNumAnimations; ++animationIndex) {
		aiAnimation* animationAssimp = scene->mAnimations[animationIndex];
		Animation animation; // ä»Šå›ä½œã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		animation.duration = float(animationAssimp->mDuration / animationAssimp->mTicksPerSecond); // æ™‚é–“ã®å˜ä½ã‚’ç§’ã«å¤‰æ›
		
		/// ===NodeAnimationã‚’è§£æã™ã‚‹=== ///
		// assimpã§ã¯å€‹ã€…ã®Nodeã®Animationã‚’chnnelã¨èª­ã‚“ã§ã„ã‚‹ã®ã§channelã‚’å›ã—ã¦NodeAnimationã®æƒ…å ±ã‚’å–ã£ã¦ãã‚‹
		for (uint32_t channelIndex = 0; channelIndex < animationAssimp->mNumChannels; ++channelIndex) {
			aiNodeAnim* nodeAnimationAssimp = animationAssimp->mChannels[channelIndex];
			NodeAnimation& nodeAnimation = animation.nodeAnimations[nodeAnimationAssimp->mNodeName.C_Str()];
			// Translateï¼ˆã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
			for (uint32_t keyIndex = 0; keyIndex < nodeAnimationAssimp->mNumPositionKeys; ++keyIndex) {
				aiVectorKey& keyAssimp = nodeAnimationAssimp->mPositionKeys[keyIndex];
				KeyframeVector3 keyframe;
				keyframe.time = float(keyAssimp.mTime / animationAssimp->mTicksPerSecond); // ã“ã“ã‚‚ç§’ã«å¤‰æ›
				keyframe.value = { -keyAssimp.mValue.x, keyAssimp.mValue.y, keyAssimp.mValue.z }; // å³æ‰‹->å·¦æ‰‹
				nodeAnimation.translate.keyframes.push_back(keyframe);
			}
			// Rotate (ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ) 
			for (uint32_t keyIndex = 0; keyIndex < nodeAnimationAssimp->mNumRotationKeys; ++keyIndex) {
				aiQuatKey& keyAssimp = nodeAnimationAssimp->mRotationKeys[keyIndex];
				KeyframeQuaternion keyframe;
				keyframe.time = float(keyAssimp.mTime / animationAssimp->mTicksPerSecond);
				keyframe.value = { keyAssimp.mValue.x, -keyAssimp.mValue.y, -keyAssimp.mValue.z, keyAssimp.mValue.w }; // y, z åè»¢
				nodeAnimation.rotate.keyframes.push_back(keyframe);
			}
			// Scale (ã‚­ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ ) 
			for (uint32_t keyIndex = 0; keyIndex < nodeAnimationAssimp->mNumScalingKeys; ++keyIndex) {
				aiVectorKey& keyAssimp = nodeAnimationAssimp->mScalingKeys[keyIndex];
				KeyframeVector3 keyframe;
				keyframe.time = float(keyAssimp.mTime / animationAssimp->mTicksPerSecond);
				keyframe.value = { keyAssimp.mValue.x, keyAssimp.mValue.y, keyAssimp.mValue.z }; // ã‚¹ã‚±ãƒ¼ãƒ«ã¯å¤‰æ›ä¸è¦
				nodeAnimation.scale.keyframes.push_back(keyframe);
			}
		}

		// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®åå‰ã‚’ç™»éŒ²
		std::string animName = animationAssimp->mName.C_Str();

		// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’Mapã‚³ãƒ³ãƒ†ãƒŠã«æ ¼ç´
		animations[animName] = animation;
		
	}
	// è§£æå®Œäº†
	return animations;
}


============================================================
File Path: Project/Engine/System/Managers/AnimationManager.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/AnimationData.h"
#include "Engine/Core/ComPtr.h"
// DirectXTex
#include "DirectXTex.h"
// assimp
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

///=====================================================/// 
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£
///=====================================================///
class AnimationManager {
public:

	AnimationManager() = default;
	~AnimationManager();

public:
	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="Key">èª­ã¿è¾¼ã‚€ãƒ‡ãƒ¼ã‚¿ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ã€‚</param>
	/// <param name="baseDirectoryPath">ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã™ã‚‹åŸºæœ¬ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ã¾ãŸã¯ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«å¯¾ã™ã‚‹ç›¸å¯¾ãƒ‘ã‚¹ã€‚</param>
	void Load(const std::string& Key, const std::string& baseDirectoryPath, const std::string& filename);

	/// <summary>
	/// æ ¼ç´ã—ã¦ã„ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å–å¾—
	/// </summary>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã€‚</param>
	/// <returns>ãƒ•ã‚¡ã‚¤ãƒ«ã«å«ã¾ã‚Œã‚‹å„ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ã€åå‰ï¼ˆstd::stringï¼‰ã‚’ã‚­ãƒ¼ã€å¯¾å¿œã™ã‚‹ Animation ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å€¤ã¨ã™ã‚‹ std::mapã€‚</returns>
	std::map<std::string, Animation> GetAnimation(const std::string& filename);

private: /// ===Variables(å¤‰æ•°)=== ///

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿	
	std::map<std::string, std::map<std::string, Animation>> animationDatas_;

private: /// ===Functions(é–¢æ•°)=== ///
	
	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="directorPath">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ï¼ˆå¿…è¦ã«å¿œã˜ã¦æ‹¡å¼µå­ã‚’å«ã‚€ï¼‰ã€‚</param>
	/// <returns>ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åã‚’ã‚­ãƒ¼ã€å¯¾å¿œã™ã‚‹ Animation ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å€¤ã¨ã™ã‚‹ std::mapã€‚</returns>
	std::map<std::string, Animation> LoadAnimation(const std::string& directorPath, const std::string& filename);
};



============================================================
File Path: Project/Engine/System/Managers/AudioManager.cpp
============================================================
#include "AudioManager.h"

#include <cassert>
#include <fstream>
#include <vector>

// ãƒãƒ£ãƒ³ã‚¯ãƒ˜ãƒƒãƒ€
struct ChunkHeader {
	char id[4];    // ãƒãƒ£ãƒƒã‚¯æ¯ã®ID
	int32_t size;  // ãƒãƒ£ãƒ³ã‚¯ã‚µã‚¤ã‚º 
};

// RIFFãƒ˜ãƒƒãƒ€ãƒãƒ£ãƒ³ã‚¯
struct RiffHeader {
	ChunkHeader chunk; // "RIFF"
	char type[4];      // "WAVE"
};

// FMIãƒãƒ£ãƒ³ã‚¯
struct FormatChunk {
	ChunkHeader chunk;  // "fmt"
	WAVEFORMATEX fmt;   // æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
};


///-------------------------------------------/// 
///
///-------------------------------------------///
AudioManager::~AudioManager() {
	sourceVoices_.clear();
	masterVoice_ = nullptr;
	xAudio2_.Reset();
}

///-------------------------------------------/// 
///
///-------------------------------------------///
void AudioManager::Initialze() {
	HRESULT result;

	// XAudioã‚¨ãƒ³ã‚¸ãƒ³ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	result = XAudio2Create(&xAudio2_, 0, XAUDIO2_DEFAULT_PROCESSOR);
	assert(SUCCEEDED(result));

	// ãƒã‚¹ã‚¿ãƒ¼ãƒœã‚¤ã‚¹ã‚’ç”Ÿæˆ
	result = xAudio2_->CreateMasteringVoice(&masterVoice_);
	assert(SUCCEEDED(result));
}

///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
///-------------------------------------------///
void AudioManager::Load(const std::string& key, const std::string& filename, bool isMP3) {
	// æ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
	if (soundDatas_.find(key) != soundDatas_.end()) {
		return; // ä½•ã‚‚ã—ãªã„
	}
	if (isMP3) {
		soundDatas_[key] = LoadMP3(filename);
	} else {
		soundDatas_[key] = LoadWave(filename);
	}
}

///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®è§£æ”¾
///-------------------------------------------///
void AudioManager::Unload(const std::string& key) {
	auto it = soundDatas_.find(key);
	if (it != soundDatas_.end()) {
		UnloadSoundData(it->second);
		soundDatas_.erase(it);
	}
}

///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ‹¬é–‹æ”¾
///-------------------------------------------///
void AudioManager::UnloadAll() {
	for (auto& pair : soundDatas_) {
		UnloadSoundData(pair.second);
	}
	soundDatas_.clear(); // ã‚³ãƒ³ãƒ†ãƒŠã‚’ã‚¯ãƒªã‚¢
}

///-------------------------------------------/// 
/// ã‚µã‚¦ãƒ³ãƒ‰ã®å†ç”Ÿ
///-------------------------------------------///
void AudioManager::Play(const std::string& key, bool loop) {
	auto it = soundDatas_.find(key); // æ¢ã—ãŸkeyã‚’ä»£å…¥
	
	assert(it != soundDatas_.end());
	HRESULT result;

	// å†ç”Ÿä¸­ã®éŸ³å£°ãŒã‚ã‚‹å ´åˆã¯å‡¦ç†ã‚’ã‚¹ã‚­ãƒƒãƒ—
	if (sourceVoices_[key]) {
		XAUDIO2_VOICE_STATE state;
		sourceVoices_[key]->GetState(&state);
		if (state.BuffersQueued > 0) {
			return; // æ—¢å­˜ã®éŸ³å£°ãŒå†ç”Ÿä¸­ãªã®ã§æ–°ã—ã„éŸ³å£°ã‚’å†ç”Ÿã—ãªã„
		}
		// æ—¢å­˜ã®SourceVoiceã‚’åœæ­¢ãƒ»ç ´æ£„
		sourceVoices_[key]->Stop(0);                // å†ç”Ÿã‚’åœæ­¢
		sourceVoices_[key]->FlushSourceBuffers();  // ãƒãƒƒãƒ•ã‚¡ã‚’ã‚¯ãƒªã‚¢
		sourceVoices_[key]->DestroyVoice();        // ãƒœã‚¤ã‚¹ã‚’è§£æ”¾
		sourceVoices_[key] = nullptr;              // ãƒã‚¤ãƒ³ã‚¿ã‚’ç„¡åŠ¹åŒ–
	}

	// æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’åŸºã«SourceVoiceã®ç”Ÿæˆ
	result = xAudio2_->CreateSourceVoice(&sourceVoices_[key], &it->second.wfex);
	assert(SUCCEEDED(result));

	// å†ç”Ÿã™ã‚‹æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
	XAUDIO2_BUFFER buf{};
	buf.pAudioData = it->second.pBuffer;
	buf.AudioBytes = it->second.bufferSize;
	buf.Flags = XAUDIO2_END_OF_STREAM;

	// ãƒ«ãƒ¼ãƒ—å†ç”Ÿã®è¨­å®š
	if (loop) {
		buf.LoopCount = XAUDIO2_LOOP_INFINITE; // ç„¡é™ãƒ«ãƒ¼ãƒ—
	} else {
		buf.LoopCount = 0; // ãƒ«ãƒ¼ãƒ—ãªã—
	}

	// æ³¢å½¢ãƒ‡ãƒ¼ã‚¿ã®å†ç”Ÿ
	result = sourceVoices_[key]->SubmitSourceBuffer(&buf);
	assert(SUCCEEDED(result));
	result = sourceVoices_[key]->Start();
	assert(SUCCEEDED(result));
}

///-------------------------------------------/// 
/// ã‚µã‚¦ãƒ³ãƒ‰ã®åœæ­¢
///-------------------------------------------///
void AudioManager::Stop(const std::string& key) {

	if (sourceVoices_[key]) {
		sourceVoices_[key]->Stop();
		sourceVoices_[key]->FlushSourceBuffers();
		sourceVoices_[key]->DestroyVoice();        // ãƒœã‚¤ã‚¹ã‚’è§£æ”¾
		sourceVoices_[key] = nullptr;              // ãƒã‚¤ãƒ³ã‚¿ã‚’ç„¡åŠ¹åŒ–
	}
}

///-------------------------------------------/// 
/// å…¨ã¦ã®ã‚µã‚¦ãƒ³ãƒ‰ã‚’åœæ­¢
///-------------------------------------------///
void AudioManager::StopAll() {
	for (auto& pair : sourceVoices_) {
		if (pair.second) {
			pair.second->Stop();
			pair.second->FlushSourceBuffers();
			pair.second->DestroyVoice();
			pair.second = nullptr;
		}
	}
	sourceVoices_.clear();
}

///-------------------------------------------/// 
/// éŸ³é‡ã®è¨­å®š
///-------------------------------------------///
void AudioManager::SetVolume(const std::string& key, float volume) {
	if (sourceVoices_[key]) {
		sourceVoices_[key]->SetVolume(volume);
	}
}

///-------------------------------------------/// 
/// å†ç”Ÿé€Ÿåº¦ã®è¨­å®š
///-------------------------------------------///
void AudioManager::setPitch(const std::string& key, float pitch) {
	if (sourceVoices_[key]) {
		sourceVoices_[key]->SetFrequencyRatio(pitch);
	}
}


///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿(Wave)
///-------------------------------------------///
SoundData AudioManager::LoadWave(const std::string& filename) {
	/// ===ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³=== ///
	// ãƒ•ã‚¡ã‚¤ãƒ«å…¥åŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	std::ifstream file;
	// .wavãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒã‚¤ãƒŠãƒªãƒ¢ãƒ¼ãƒ‰ã§é–‹ã
	file.open(filename, std::ios_base::binary);
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’æ¤œå‡ºã™ã‚‹
	assert(file.is_open());

	/// ===.wavãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿=== ///
	// RIFFãƒ˜ãƒƒãƒ€ãƒ¼ã®èª­ã¿è¾¼ã¿
	RiffHeader riff;
	file.read((char*)&riff, sizeof(riff));
	//ãƒ•ã‚¡ã‚¤ãƒ«ãŒRIFFã‹ãƒã‚§ãƒƒã‚¯
	if (strncmp(riff.chunk.id, "RIFF", 4) != 0) {
		assert(0);
	}
	// ã‚¿ã‚¤ãƒ—AãŒWAVEã‹ãƒã‚§ãƒƒã‚¯
	if (strncmp(riff.type, "WAVE", 4) != 0) {
		assert(0);
	}
	// Formatãƒãƒ£ãƒ³ã‚¯ã®èª­ã¿è¾¼ã¿
	FormatChunk format = {};
	// ãƒãƒ£ãƒ³ã‚¯ãƒ˜ãƒƒãƒ€ãƒ¼ã®ç¢ºèª
	file.read((char*)&format, sizeof(ChunkHeader));
	if (strncmp(format.chunk.id, "fmt ", 4) != 0) {
		assert(0);
	}
	// ãƒãƒ£ãƒ³ã‚¯æœ¬ä½“ã®èª­ã¿è¾¼ã¿
	assert(format.chunk.size <= sizeof(format.fmt));
	file.read((char*)&format.fmt, format.chunk.size);
	// Dataãƒãƒ£ãƒ³ã‚¯ã®èª­ã¿è¾¼ã¿
	ChunkHeader data;
	while (true) {
		file.read((char*)&data, sizeof(data));
		// "data" ãƒãƒ£ãƒ³ã‚¯ãªã‚‰ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		if (strncmp(data.id, "data", 4) == 0) {
			break;
		}
		// èª­ã¿å–ã‚Šä½ç½®ã‚’ãƒãƒ£ãƒ³ã‚¯ã®çµ‚ã‚ã‚Šã¾ã§é€²ã‚ã‚‹
		file.seekg(data.size, std::ios_base::cur);
	}
	// Dataãƒãƒ£ãƒ³ã‚¯ã®ãƒ‡ãƒ¼ã‚¿éƒ¨ï¼ˆæ³¢å½¢ãƒ‡ãƒ¼ã‚¿ï¼‰ã®èª­ã¿è¾¼ã¿
	char* pBuffer = new char[data.size];
	file.read(pBuffer, data.size);
	// Waveãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
	file.close();

	/// ====èª­ã¿è¾¼ã‚“ã éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’return== ///
	// retrunã™ã‚‹ç‚ºã®éŸ³å£°ãƒ‡ãƒ¼ã‚¿
	SoundData soundData = {};
	soundData.wfex = format.fmt;
	soundData.pBuffer = reinterpret_cast<BYTE*>(pBuffer);
	soundData.bufferSize = data.size;

	return soundData;
}

///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿(MP3)
///-------------------------------------------///
SoundData AudioManager::LoadMP3(const std::string& filename) {

	//// é€šã£ã¦ãªã„
	//// === ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®ç¢ºèªã¨è¿”å´ ===
	//if (auto it = soundDatas_.find(filename); it != soundDatas_.end()) {
	//	return it->second; // æ—¢ã«ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ãªã‚‰ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’è¿”ã™
	//}

	/// ===ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³=== ///
   // ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ wide æ–‡å­—åˆ—ã«å¤‰æ›
	int wideSize = MultiByteToWideChar(CP_ACP, 0, filename.c_str(), -1, nullptr, 0);
	std::wstring wideFilename(wideSize, 0);
	MultiByteToWideChar(CP_ACP, 0, filename.c_str(), -1, &wideFilename[0], wideSize);

	// Media Foundation ã®åˆæœŸåŒ–
	HRESULT result = MFStartup(MF_VERSION);
	assert(SUCCEEDED(result));

	// SourceReader ã‚’ä½œæˆ
	IMFSourceReader* sourceReader = nullptr;
	result = MFCreateSourceReaderFromURL(wideFilename.c_str(), nullptr, &sourceReader);
	assert(SUCCEEDED(result));

	/// ===éŸ³å£°ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿=== ///
	// å‡ºåŠ›å½¢å¼ã‚’ PCM å½¢å¼ã«è¨­å®š
	IMFMediaType* audioType = nullptr;
	result = MFCreateMediaType(&audioType);
	assert(SUCCEEDED(result));
	result = audioType->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Audio);
	assert(SUCCEEDED(result));
	result = audioType->SetGUID(MF_MT_SUBTYPE, MFAudioFormat_PCM);
	assert(SUCCEEDED(result));
	result = sourceReader->SetCurrentMediaType((DWORD)MF_SOURCE_READER_FIRST_AUDIO_STREAM, nullptr, audioType);
	assert(SUCCEEDED(result));

	// PCM å½¢å¼ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’å–å¾—
	IMFMediaType* outputType = nullptr;
	result = sourceReader->GetCurrentMediaType((DWORD)MF_SOURCE_READER_FIRST_AUDIO_STREAM, &outputType);
	assert(SUCCEEDED(result));

	WAVEFORMATEX* pWaveFormat = nullptr;
	UINT32 cbFormat = 0;
	result = MFCreateWaveFormatExFromMFMediaType(outputType, &pWaveFormat, &cbFormat);
	assert(SUCCEEDED(result));

	// ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ä¿å­˜
	FormatChunk format = {};
	memcpy(&format.fmt, pWaveFormat, sizeof(WAVEFORMATEX));
	CoTaskMemFree(pWaveFormat);
	outputType->Release();

	/// ===éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ã«èª­ã¿è¾¼ã¿=== ///
	ChunkHeader data = {};
	std::vector<BYTE> buffer;

	while (true) {
		IMFSample* sample = nullptr;
		DWORD flags = 0;
		result = sourceReader->ReadSample((DWORD)MF_SOURCE_READER_FIRST_AUDIO_STREAM, 0, nullptr, &flags, nullptr, &sample);
		if (flags & MF_SOURCE_READERF_ENDOFSTREAM) {
			break; // ãƒ‡ãƒ¼ã‚¿ã®çµ‚ç«¯ã«åˆ°é”
		}
		assert(SUCCEEDED(result));

		if (sample) {
			IMFMediaBuffer* mediaBuffer = nullptr;
			result = sample->ConvertToContiguousBuffer(&mediaBuffer);
			assert(SUCCEEDED(result));

			BYTE* audioData = nullptr;
			DWORD audioDataLength = 0;
			result = mediaBuffer->Lock(&audioData, nullptr, &audioDataLength);
			assert(SUCCEEDED(result));

			// ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ 
			buffer.insert(buffer.end(), audioData, audioData + audioDataLength);

			result = mediaBuffer->Unlock();
			assert(SUCCEEDED(result));
			mediaBuffer->Release();
			sample->Release();
		}
	}

	// Data ãƒãƒ£ãƒ³ã‚¯ã®ãƒ‡ãƒ¼ã‚¿éƒ¨ã‚’ã‚»ãƒƒãƒˆ
	data.size = static_cast<uint32_t>(buffer.size());
	char* pBuffer = new char[data.size];
	memcpy(pBuffer, buffer.data(), data.size);

	// ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
	sourceReader->Release();
	audioType->Release();
	MFShutdown();

	/// ====èª­ã¿è¾¼ã‚“ã éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ return ==== ///
	SoundData soundData = {};
	soundData.wfex = format.fmt; // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’è¨­å®š
	soundData.pBuffer = reinterpret_cast<BYTE*>(pBuffer);
	soundData.bufferSize = data.size;

	return soundData;
}

///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®è§£æ”¾
///-------------------------------------------///
void AudioManager::UnloadSoundData(SoundData& soundData) {
	// ãƒãƒƒãƒ•ã‚¡ã®ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾
	delete[] soundData.pBuffer;
	soundData.pBuffer = 0;
	soundData.bufferSize = 0;
	soundData.wfex = {};
}


============================================================
File Path: Project/Engine/System/Managers/AudioManager.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
// waveã®èª­ã¿è¾¼ã¿
#include <xaudio2.h> 
// mp3ã®èª­ã¿è¾¼ã¿
#include <mfapi.h>
#include <mfobjects.h>
#include <mfidl.h>
#include <mfreadwrite.h>
// c++
#include <string>
#include <unordered_map>
// ãƒªãƒ³ã‚¯
#pragma comment(lib, "xaudio2.lib")
#pragma comment(lib, "mfplat.lib")
#pragma comment(lib, "mfreadwrite.lib")
#pragma comment(lib, "mfuuid.lib")

// éŸ³å£°ãƒ‡ãƒ¼ã‚¿
struct SoundData {
	// æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	WAVEFORMATEX wfex;
	// ãƒãƒƒãƒ•ã‚¡ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹
	BYTE* pBuffer;
	// ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚º
	unsigned int bufferSize;
};

///=====================================================/// 
/// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
///=====================================================///
class AudioManager {
public:
	AudioManager() = default;
	~AudioManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialze();

public:/// ===é–¢æ•°=== ///

	/// <summary>
	/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="key">èª­ã¿è¾¼ã‚€ãƒªã‚½ãƒ¼ã‚¹ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯åå‰ã€‚</param>
	/// <param name="isMP3">ãƒ•ã‚¡ã‚¤ãƒ«ãŒMP3å½¢å¼ã§ã‚ã‚‹ã‹ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°ã€‚trueã®å ´åˆã¯MP3ã¨ã—ã¦å‡¦ç†ã•ã‚Œã¾ã™ã€‚</param>
	void Load(const std::string& key, const std::string& filename, bool isMP3);

	/// <summary>
	/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®è§£æ”¾å‡¦ç†
	/// </summary>
	/// <param name="key">ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹å¯¾è±¡ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚</param>
	void Unload(const std::string& key);

	/// <summary>
	/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ‹¬è§£æ”¾å‡¦ç†
	/// </summary>
	void UnloadAll();

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®å†ç”Ÿå‡¦ç†
	/// </summary>
	/// <param name="key">å†ç”Ÿå¯¾è±¡ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚</param>
	/// <param name="loop">å†ç”Ÿã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã‹ã©ã†ã‹ã‚’ç¤ºã™ãƒ•ãƒ©ã‚°ã€‚true ã®å ´åˆã¯ç¹°ã‚Šè¿”ã—å†ç”Ÿã—ã€falseï¼ˆæ—¢å®šå€¤ï¼‰ã¯ä¸€åº¦ã ã‘å†ç”Ÿã—ã¾ã™ã€‚</param>
	void Play(const std::string& key, bool loop = false);

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®åœæ­¢å‡¦ç†
	/// </summary>
	/// <param name="key">åœæ­¢å¯¾è±¡ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚</param>
	void Stop(const std::string& key);

	/// <summary>
	/// å…¨ã¦ã®ã‚µã‚¦ãƒ³ãƒ‰ã‚’åœæ­¢å‡¦ç†
	/// </summary>
	void StopAll();

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®éŸ³é‡è¨­å®šå‡¦ç†
	/// </summary>
	/// <param name="key">éŸ³é‡ã‚’è¨­å®šã™ã‚‹å¯¾è±¡ã‚’è­˜åˆ¥ã™ã‚‹ã‚­ãƒ¼æ–‡å­—åˆ—ã€‚</param>
	/// <param name="volume">è¨­å®šã™ã‚‹éŸ³é‡å€¤ã€‚é€šå¸¸ã¯ 0.0ï¼ˆç„¡éŸ³ï¼‰ã‹ã‚‰ 1.0ï¼ˆæœ€å¤§ï¼‰ãªã©ã®ç¯„å›²ã§æŒ‡å®šã—ã¾ã™ã€‚</param>
	void SetVolume(const std::string& key, float volume);

	/// <summary>
	/// å†ç”Ÿé€Ÿåº¦ã®è¨­å®šå‡¦ç†
	/// </summary>
	/// <param name="key">ãƒ”ãƒƒãƒã‚’è¨­å®šã™ã‚‹å¯¾è±¡ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚</param>
	/// <param name="pitch">è¨­å®šã™ã‚‹ãƒ”ãƒƒãƒå€¤ï¼ˆfloatï¼‰ã€‚</param>
	void setPitch(const std::string& key, float pitch);

private: /// ===å¤‰æ•°=== ///
	ComPtr<IXAudio2> xAudio2_;
	IXAudio2MasteringVoice* masterVoice_ = nullptr;
	std::unordered_map<std::string, IXAudio2SourceVoice*> sourceVoices_;

	// éŸ³å£°ãƒ‡ãƒ¼ã‚¿
	std::unordered_map<std::string, SoundData> soundDatas_;

private: /// ===é–¢æ•°=== ///

	/// <summary>
	/// WAVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ WAV ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã€‚</param>
	/// <returns>èª­ã¿è¾¼ã¾ã‚ŒãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã—ãŸ SoundDataã€‚ã‚µãƒ³ãƒ—ãƒ«ã€ãƒãƒ£ãƒ³ãƒãƒ«æ•°ã€ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆãªã©ã‚’å«ã¿ã¾ã™ã€‚</returns>
	SoundData LoadWave(const std::string& filename);
	
	/// <summary>
	/// MP3ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="filenamèª­ã¿è¾¼ã‚€MP3ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã€‚e"></param>
	/// <returèª­ã¿è¾¼ã¾ã‚ŒãŸéŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™SoundDataã€‚èª­ã¿è¾¼ã¿ã‚„ãƒ‡ã‚³ãƒ¼ãƒ‰ã«å¤±æ•—ã—ãŸå ´åˆã®æŒ™å‹•ã¯å®Ÿè£…ä¾å­˜ã§ã™ã€‚ns></returns>
	SoundData LoadMP3(const std::string& filename);

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰å‡¦ç†
	/// </summary>
	/// <param name="data">ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿ã¸ã®å‚ç…§ã€‚é–¢æ•°ã¯ã“ã®å‚ç…§ã«é–¢é€£ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£æ”¾ã—ã¾ã™ã€‚</param>
	void UnloadSoundData(SoundData& data);
};




============================================================
File Path: Project/Engine/System/Managers/CSVManager.cpp
============================================================
#include "CSVManager.h"
// c++
#include <thread>
#include <cassert>

///-------------------------------------------/// 
/// CSVã®èª­ã¿è¾¼ã¿é–¢æ•°
///-------------------------------------------///
void CSVManager::Load(const std::string & file_path) {
    std::vector<std::vector<int>> temp_data;
    std::ifstream file(file_path);
    std::string line;

    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    if (!file.is_open()) {
        std::cerr << "Failed to open file: " << file_path << std::endl;
        return;
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’1è¡Œãšã¤èª­ã¿è¾¼ã‚€
    while (std::getline(file, line)) {
        std::vector<int> row; // 1è¡Œåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã™ã‚‹ãƒ™ã‚¯ã‚¿ãƒ¼
        size_t pos = 0;

        // ã‚«ãƒ³ãƒã§åˆ†å‰²ã—ã¦æ•´æ•°ã«å¤‰æ›ã—ã€è¡Œãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
        while ((pos = line.find(",")) != std::string::npos) {
            row.push_back(std::stoi(line.substr(0, pos))); // ã‚«ãƒ³ãƒã¾ã§ã®æ–‡å­—åˆ—ã‚’æ•°å€¤ã«å¤‰æ›ã—ã¦è¿½åŠ 
            line.erase(0, pos + 1); // å‡¦ç†æ¸ˆã¿ã®éƒ¨åˆ†ã‚’å‰Šé™¤
        }
        row.push_back(std::stoi(line)); // æœ€å¾Œã®è¦ç´ ã‚’è¿½åŠ 
        temp_data.push_back(row); // è¡Œãƒ‡ãƒ¼ã‚¿ã‚’ä¸€æ™‚ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
    }

    file.close(); // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹

    // ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§å…±æœ‰ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°
    {
        std::lock_guard<std::mutex> lock(mtx_);
        map_data_ = temp_data;
        data_ready_ = true; // ãƒ‡ãƒ¼ã‚¿æº–å‚™å®Œäº†ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
    }

    cv_.notify_all(); // ä»–ã®ã‚¹ãƒ¬ãƒƒãƒ‰ã«é€šçŸ¥
}



============================================================
File Path: Project/Engine/System/Managers/CSVManager.h
============================================================
#pragma once
/// ===Inclde=== ///
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <mutex>
#include <condition_variable>

///=====================================================/// 
/// CSVManager
///=====================================================///
class CSVManager {
public:

	CSVManager() = default;
	~CSVManager() = default;

	/// <summary>
	/// CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="file_path">CSVãƒ•ã‚¡ã‚¤ãƒ«ã®ç™»éŒ²å</param>
	void Load(const std::string& file_path);

private:

	std::mutex mtx_;
	std::condition_variable cv_;
	bool data_ready_ = false;
	std::vector<std::vector<int>> map_data_;
};



============================================================
File Path: Project/Engine/System/Managers/CameraManager.cpp
============================================================
#include "CameraManager.h"

#include <cassert>

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
CameraManager::CameraManager() = default;
CameraManager::~CameraManager() {
	activeCamera_.reset();
	cameras_.clear();
}

///-------------------------------------------/// 
/// å…¨ã¦ã®ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
///-------------------------------------------///
void CameraManager::UpdateAllCameras() {
	// æ›´æ–°ã‚’ã™ã‚‹
	for (auto& [name, camera] : cameras_) {
		camera->Update();
	}
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©ã‚’è¿½åŠ 
///-------------------------------------------///
void CameraManager::AddCamera(const std::string& name, std::shared_ptr<GameCamera> camera) {
	cameras_[name] = camera;

	if (!activeCamera_) {
		activeCamera_ = camera; // æœ€åˆã«è¿½åŠ ã•ã‚ŒãŸã‚«ãƒ¡ãƒ©ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹
	}
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©ã‚’å‰Šé™¤
///-------------------------------------------///
void CameraManager::RemoveCamera(const std::string& name) {
	auto it = cameras_.find(name);
	if (it != cameras_.end()) {
		// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ãŒå‰Šé™¤ã•ã‚Œã‚‹ã‚«ãƒ¡ãƒ©ã®å ´åˆã€activeCamera_ã‚’nullptrã«ã™ã‚‹
		if (activeCamera_ == it->second) {
			activeCamera_ = nullptr;
		}
		cameras_.erase(it);
	}
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
///-------------------------------------------///
bool CameraManager::HasCamera(const std::string& name) const {
	return cameras_.find(name) != cameras_.end();
}

///-------------------------------------------/// 
/// Getterãƒ»Setter
///-------------------------------------------///
// æŒ‡å®šã•ã‚ŒãŸã‚«ãƒ¡ãƒ©ã®Getter
std::shared_ptr<GameCamera> CameraManager::GetCamera(const std::string& name) const {
	auto it = cameras_.find(name);
	if (it != cameras_.end()) {
		return it->second;
	}
	return nullptr;
}

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®Getter
std::shared_ptr<GameCamera> CameraManager::GetActiveCamera() const {
	return activeCamera_;
}


// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®Setter
void CameraManager::SetActiveCamera(const std::string& name) {
	auto it = cameras_.find(name);
	if (it != cameras_.end()) {
		activeCamera_ = it->second;
	} else {
		// ã‚«ãƒ¡ãƒ©ãŒå­˜åœ¨ã—ãªã„å ´åˆã®è­¦å‘Š
		assert(false && "æŒ‡å®šã•ã‚ŒãŸã‚«ãƒ¡ãƒ©ãŒå­˜åœ¨ã—ã¾ã›ã‚“");
	}
}

============================================================
File Path: Project/Engine/System/Managers/CameraManager.h
============================================================
#pragma once
/// ===Include=== ///
// GameCamera
#include "application/Game/Camera/GameCamera.h"
// C++
#include <unordered_map>
#include <string>
#include <memory>

///=====================================================/// 
/// ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£
///=====================================================///
class CameraManager {
public:/// ===åŸºæœ¬çš„ãªé–¢æ•°=== ///

	CameraManager();
	~CameraManager();

	/// <summary>
	/// å…¨ã¦ã®ã‚«ãƒ¡ãƒ©ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateAllCameras();

public:/// ===é–¢æ•°=== ///

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®è¿½åŠ å‡¦ç†
	/// </summary>
	/// <param name="name">è¿½åŠ ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®è­˜åˆ¥åï¼ˆconst std::string&ï¼‰ã€‚</param>
	/// <param name="camera">è¿½åŠ ã™ã‚‹ GameCamera ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã® std::shared_ptrã€‚</param>
	void AddCamera(const std::string& name, std::shared_ptr<GameCamera> camera);

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®å‰Šé™¤å‡¦ç†
	/// </summary>
	/// <param name="name">å‰Šé™¤å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©ã®åå‰ã€‚</param>
	void RemoveCamera(const std::string& name);

	/// <summary>
	/// æŒ‡å®šã—ãŸåå‰ã®ã‚«ãƒ¡ãƒ©ãŒå­˜åœ¨ã™ã‚‹ã‹ã®ç¢ºèªå‡¦ç†
	/// </summary>
	/// <param name="name">ç¢ºèªå¯¾è±¡ã®ã‚«ãƒ¡ãƒ©åã€‚å­˜åœ¨ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®æ–‡å­—åˆ—å‚ç…§ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸåå‰ã®ã‚«ãƒ¡ãƒ©ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯ trueã€å­˜åœ¨ã—ãªã„å ´åˆã¯ falseã€‚</returns>
	bool HasCamera(const std::string& name) const;

public:/// ===Setterãƒ»Getter=== ///

	// æŒ‡å®šã•ã‚ŒãŸã‚«ãƒ¡ãƒ©ã®Getter
	std::shared_ptr<GameCamera> GetCamera(const std::string& name) const;
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®Getter
	std::shared_ptr<GameCamera> GetActiveCamera() const;
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®Setter
	void SetActiveCamera(const std::string& name);

private:
	// ã‚«ãƒ¡ãƒ©ã‚’ç®¡ç†ã™ã‚‹ãƒãƒƒãƒ—
	std::unordered_map<std::string, std::shared_ptr<GameCamera>> cameras_;

	// ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©
	std::shared_ptr<GameCamera> activeCamera_;
};

============================================================
File Path: Project/Engine/System/Managers/ColliderManager.cpp
============================================================
#include "ColliderManager.h"
// c++
#include <algorithm>
// ColliderType
#include "Engine/Collider/SphereCollider.h"
#include "Engine/Collider/AABBCollider.h"
#include "Engine/Collider/OBBCollider.h"
// Math
#include "Math/sMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ColliderManager::~ColliderManager() { colliders_.clear(); }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Lightã®è¨­å®š
void ColliderManager::SetLight(LightType type) {
	for (auto itA = colliders_.begin(); itA != colliders_.end(); ++itA) {
		(*itA)->SetLight(type);
	}
}
void ColliderManager::SetLightData(LightInfo light) {
	for (auto itA = colliders_.begin(); itA != colliders_.end(); ++itA) {
		(*itA)->SetLightData(light);
	}
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ColliderManager::Initialize() {
	// nullåˆæœŸåŒ–
	for (int i = 0; i < TypeCount; ++i) {
		for (int j = 0; j < TypeCount; ++j) {
			collisionTable_[i][j] = nullptr;
		}
	}

	// åˆ¤å®šé–¢æ•°ã®ç™»éŒ²
	collisionTable_[(int)ColliderType::Sphere][(int)ColliderType::Sphere] = &ColliderManager::Sphere_Sphere;
	collisionTable_[(int)ColliderType::AABB][(int)ColliderType::AABB] = &ColliderManager::AABB_AABB;
	collisionTable_[(int)ColliderType::OBB][(int)ColliderType::OBB] = &ColliderManager::OBB_OBB;

	collisionTable_[(int)ColliderType::Sphere][(int)ColliderType::AABB] = &ColliderManager::Sphere_AABB;
	collisionTable_[(int)ColliderType::AABB][(int)ColliderType::Sphere] = &ColliderManager::AABB_Sphere;
	collisionTable_[(int)ColliderType::OBB][(int)ColliderType::Sphere] = &ColliderManager::OBB_Sphere;
	collisionTable_[(int)ColliderType::Sphere][(int)ColliderType::OBB] = &ColliderManager::Sphere_OBB;

	collisionTable_[(int)ColliderType::AABB][(int)ColliderType::OBB] = &ColliderManager::AABB_OBB;
	collisionTable_[(int)ColliderType::OBB][(int)ColliderType::AABB] = &ColliderManager::OBB_AABB;
}

///-------------------------------------------/// 
/// ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void ColliderManager::Reset() {
	// ãƒªã‚¹ãƒˆã‚’ç©ºã£ã½ã«ã™ã‚‹
	colliders_.clear();
}

///-------------------------------------------/// 
/// å‰Šé™¤
///-------------------------------------------///
void ColliderManager::RemoveCollider(Collider* collider) {
	//å¼•æ•°ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å‰Šé™¤
	colliders_.remove(collider);
}

///-------------------------------------------/// 
/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¿½åŠ 
///-------------------------------------------///
void ColliderManager::AddCollider(Collider* collider) {
	// å¼•æ•°ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’push_back
	colliders_.push_back(collider);
}

///-------------------------------------------/// 
/// ãƒšã‚¢ã®å½“ãŸã‚Šåˆ¤å®š
///-------------------------------------------///
void ColliderManager::CheckPairCollision(Collider* colliderA, Collider* colliderB) {
	int typeA = static_cast<int>(colliderA->GetColliderType());
	int typeB = static_cast<int>(colliderB->GetColliderType());

	// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹é–¢æ•°ã‚’å–å¾—
	auto func = collisionTable_[typeA][typeB];
	if (!func) {
		// é–¢æ•°ãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
		return;
	}

	// è¡çªåˆ¤å®šã®çµæœã‚’å—ã‘å–ã‚‹
	bool isHit = (this->*func)(colliderA, colliderB);


	// ColliderãŒæŒã£ã¦ã„ã‚‹ãƒ•ãƒ©ã‚°ã‚’å¤‰æ›´
	colliderA->SetIsCollision(isHit);
	colliderB->SetIsCollision(isHit);

	if (isHit) {
		colliderA->OnCollision(colliderB);
		colliderB->OnCollision(colliderA);
	}
}

///-------------------------------------------/// 
/// å…¨ã¦ã®Colliderã®å½“ãŸã‚Šåˆ¤å®š
///-------------------------------------------///
void ColliderManager::CheckAllCollisions() {
	for (auto itA = colliders_.begin(); itA != colliders_.end(); ++itA) {
		auto itB = itA;
		++itB;
		for (; itB != colliders_.end(); ++itB) {
			CheckPairCollision(*itA, *itB);
		}
	}
}

///-------------------------------------------/// 
/// è¡çªåˆ¤å®šé–¢æ•°
///-------------------------------------------///
bool ColliderManager::Sphere_Sphere(Collider* a, Collider* b) { return SphereToSphereCollision(static_cast<SphereCollider*>(a), static_cast<SphereCollider*>(b)); }
bool ColliderManager::AABB_AABB(Collider* a, Collider* b) { return AABBToAABBCollision(static_cast<AABBCollider*>(a), static_cast<AABBCollider*>(b)); }
bool ColliderManager::OBB_OBB(Collider* a, Collider* b) { return OBBToOBBCollision(static_cast<OBBCollider*>(a), static_cast<OBBCollider*>(b)); }
bool ColliderManager::Sphere_AABB(Collider* a, Collider* b) { return SphereToAABBCollision(static_cast<SphereCollider*>(a), static_cast<AABBCollider*>(b)); }
bool ColliderManager::AABB_Sphere(Collider* a, Collider* b) { return SphereToAABBCollision(static_cast<SphereCollider*>(b), static_cast<AABBCollider*>(a)); }
bool ColliderManager::AABB_OBB(Collider* a, Collider* b) { return AABBToOBBCollision(static_cast<AABBCollider*>(a), static_cast<OBBCollider*>(b)); }
bool ColliderManager::OBB_AABB(Collider* a, Collider* b) { return AABBToOBBCollision(static_cast<AABBCollider*>(b), static_cast<OBBCollider*>(a)); }
bool ColliderManager::Sphere_OBB(Collider* a, Collider* b) { return SphereToOBBCollision(static_cast<SphereCollider*>(a), static_cast<OBBCollider*>(b)); }
bool ColliderManager::OBB_Sphere(Collider* a, Collider* b) { return SphereToOBBCollision(static_cast<SphereCollider*>(b), static_cast<OBBCollider*>(a)); }

///-------------------------------------------/// 
/// å½“ãŸã‚Šåˆ¤å®šã®é–¢æ•°
///-------------------------------------------///
// çƒã¨çƒ
bool ColliderManager::SphereToSphereCollision(SphereCollider* a, SphereCollider* b) {
	Sphere s1 = a->GetSphere();
	Sphere s2 = b->GetSphere();

	Vector3 diff = s1.center - s2.center;
	float distSq = Dot(diff);
	float radiusSum = s1.radius + s2.radius;

	// åˆ¤å®š
	if (distSq <= (radiusSum * radiusSum)) {
		return true;
	} else {
		return false;
	}
}
// AABBã¨AABB
bool ColliderManager::AABBToAABBCollision(AABBCollider* a, AABBCollider* b) {
	AABB aabb1 = a->GetAABB();
	AABB aabb2 = b->GetAABB();

	return (aabb1.min.x <= aabb2.max.x && aabb1.max.x >= aabb2.min.x) &&
		(aabb1.min.y <= aabb2.max.y && aabb1.max.y >= aabb2.min.y) &&
		(aabb1.min.z <= aabb2.max.z && aabb1.max.z >= aabb2.min.z);
}
// OBBã¨OBB
bool ColliderManager::OBBToOBBCollision(OBBCollider* a, OBBCollider* b) {
	OBB aCol = a->GetOBB();
	OBB bCol = b->GetOBB();

	return OBBSATCollision(aCol, bCol);
}
// çƒã¨AABB
bool ColliderManager::SphereToAABBCollision(SphereCollider* sphere, AABBCollider* aabb) {
	Sphere sphereCol = sphere->GetSphere();
	AABB aabbCol = aabb->GetAABB();

	Vector3 closestPoint = {
		std::clamp(sphereCol.center.x, aabbCol.min.x, aabbCol.max.x),
		std::clamp(sphereCol.center.y, aabbCol.min.y, aabbCol.max.y),
		std::clamp(sphereCol.center.z, aabbCol.min.z, aabbCol.max.z)
	};

	Vector3 diff = sphereCol.center - closestPoint;

	// è¡çªã®åˆ¤å®š
	if (Dot(diff) <= (sphereCol.radius * sphereCol.radius)) {
		return true;
	} else {
		return false;
	}
}
// AABBã¨OBB
bool ColliderManager::AABBToOBBCollision(AABBCollider* aabb, OBBCollider* obb) {
	AABB aabbCol = aabb->GetAABB();
	OBB obbCol = obb->GetOBB();

	// AABBã‚’OBBã«å¤‰æ›
	OBB fakeAABB = {};
	fakeAABB.center = (aabbCol.min + aabbCol.max) * 0.5f;
	fakeAABB.halfSize = (aabbCol.max - aabbCol.min) * 0.5f;
	fakeAABB.axis[0] = { 1.0f, 0.0f, 0.0f };
	fakeAABB.axis[1] = { 0.0f, 1.0f, 0.0f };
	fakeAABB.axis[2] = { 0.0f, 0.0f, 1.0f };

	return OBBSATCollision(fakeAABB, obbCol);
}
// çƒã¨OBB
bool ColliderManager::SphereToOBBCollision(SphereCollider* sphere, OBBCollider* obb) {
	Sphere sphereCol = sphere->GetSphere();
	OBB obbCol = obb->GetOBB();

	Vector3 dir = sphereCol.center - obbCol.center;
	Vector3 closest = obbCol.center;

	// OBBç©ºé–“ã«ãŠã‘ã‚‹æœ€è¿‘ç‚¹ã‚’è¨ˆç®—
	for (int i = 0; i < 3; ++i) {
		float axisExtent = 0.0f;

		if (i == 0) axisExtent = obbCol.halfSize.x;
		else if (i == 1) axisExtent = obbCol.halfSize.y;
		else if (i == 2) axisExtent = obbCol.halfSize.z;

		float dist = Dot(dir, obbCol.axis[i]);
		dist = std::clamp(dist, -axisExtent, axisExtent);

		closest += obbCol.axis[i] * dist;
	}

	Vector3 diff = sphereCol.center - closest;

	// è¡çªåˆ¤å®š
	if (Dot(diff) <= (sphereCol.radius * sphereCol.radius)) {
		return true;
	} else {
		return false;
	}
}

///-------------------------------------------/// 
/// SATã«ã‚ˆã‚‹OBBvsOBBåˆ¤å®š
///-------------------------------------------///
bool ColliderManager::OBBSATCollision(const OBB& a, const OBB& b) {
	const float EPSILON = 1e-6f;

	Vector3 axes[15] = {};
	int axisCount = 0;

	// 3è»¸ + 3è»¸
	for (int i = 0; i < 3; ++i) {
		axes[axisCount++] = a.axis[i];
		axes[axisCount++] = b.axis[i];
	}

	// äº¤å·®è»¸
	for (int i = 0; i < 3; ++i) {
		for (int j = 0; j < 3; ++j) {
			Vector3 cross = Math::Cross(a.axis[i], b.axis[j]);
			if (Dot(cross) > EPSILON) {
				axes[axisCount++] = Normalize(cross);
			}
		}
	}

	for (int i = 0; i < axisCount; ++i) {
		const Vector3& axis = axes[i];

		float aMin, aMax, bMin, bMax;
		ProjectOBBOntoAxis(a, axis, aMin, aMax);
		ProjectOBBOntoAxis(b, axis, bMin, bMax);

		if (aMax < bMin || bMax < aMin) {
			return false; // åˆ†é›¢è»¸ã‚ã‚Š â†’ è¡çªã—ã¦ã„ãªã„
		}
	}

	return true; // å…¨è»¸ã§é‡ãªã‚Šã‚ã‚Š â†’ è¡çª
}
void ColliderManager::ProjectOBBOntoAxis(const OBB& obb, const Vector3& axis, float& outMin, float& outMax) {
	float centerProjection = Dot(obb.center, axis);

	float extents =
		std::abs(Dot(obb.axis[0] * obb.halfSize.x, axis)) +
		std::abs(Dot(obb.axis[1] * obb.halfSize.y, axis)) +
		std::abs(Dot(obb.axis[2] * obb.halfSize.z, axis));

	outMin = centerProjection - extents;
	outMax = centerProjection + extents;
}


============================================================
File Path: Project/Engine/System/Managers/ColliderManager.h
============================================================
#pragma once
/// ===Include=== ///
// c++
#include <list>
// Collider
#include "Engine/Collider/Base/Collider.h"

/// ===å‰æ–¹å®£è¨€=== ///
class SphereCollider;
class AABBCollider;
class OBBCollider;


///=====================================================/// 
/// ColliderManager
///=====================================================///
class ColliderManager {
public:

	ColliderManager() = default;
	~ColliderManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();	

	/// <summary>
	/// ãƒªã‚»ãƒƒãƒˆå‡¦ç†
	/// </summary>
	void Reset();

	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®å‰Šé™¤å‡¦ç†
	/// </summary>
	/// <param name="collider">å‰Šé™¤å¯¾è±¡ã® Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void RemoveCollider(Collider* collider);

	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¿½åŠ å‡¦ç†
	/// </summary>
	/// <param name="collider">è¿½åŠ ã™ã‚‹ Collider ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚nullptr ã®æ‰±ã„ã¯å®Ÿè£…ä¾å­˜ã§ã™ã€‚</param>
	void AddCollider(Collider* collider);

	/// <summary>
	/// äºŒã¤ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼é–“ã®è¡çªåˆ¤å®šå‡¦ç†
	/// </summary>
	/// <param name="colliderA">è¡çªåˆ¤å®šå¯¾è±¡ã®æœ€åˆã® Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="colliderB">è¡çªåˆ¤å®šå¯¾è±¡ã®2ç•ªç›®ã® Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void CheckPairCollision(Collider* colliderA, Collider* colliderB);

	/// <summary>
	/// å…¨ã¦ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼é–“ã®è¡çªåˆ¤å®šå‡¦ç†
	/// </summary>
	void CheckAllCollisions();

public: /// ===Setter=== ///
	// Lightã®è¨­å®š
	void SetLight(LightType type);
	void SetLightData(LightInfo light);

private: /// ===å¤‰æ•°=== ///

	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ãƒªã‚¹ãƒˆ
	std::list<Collider*> colliders_;

	// è¡çªåˆ¤å®šé–¢æ•°ã®å‹å®šç¾©
	using CollisionFunc = bool (ColliderManager::*)(Collider*, Collider*);
	// è¡çªé–¢æ•°ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ†ãƒ¼ãƒ–ãƒ«
	static constexpr int TypeCount = (int)ColliderType::Count;
	CollisionFunc collisionTable_[TypeCount][TypeCount];

private: /// ===é–¢æ•°=== ///

	// å„å½“ãŸã‚Šåˆ¤å®šé–¢æ•°ï¼ˆCollider*ã‚’å—ã‘å–ã‚‹ãƒ©ãƒƒãƒ‘ãƒ¼ï¼‰
	bool Sphere_Sphere(Collider* a, Collider* b);
	bool AABB_AABB(Collider* a, Collider* b);
	bool OBB_OBB(Collider* a, Collider* b);
	bool Sphere_AABB(Collider* a, Collider* b);
	bool AABB_Sphere(Collider* a, Collider* b);
	bool AABB_OBB(Collider* a, Collider* b);
	bool OBB_AABB(Collider* a, Collider* b);
	bool Sphere_OBB(Collider* a, Collider* b);
	bool OBB_Sphere(Collider* a, Collider* b);

	/// <summary>
	/// 2ã¤ã®çƒå½¢ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ (SphereCollider) é–“ã§è¡çªãŒç™ºç”Ÿã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®š
	/// </summary>
	/// <param name="a">åˆ¤å®šå¯¾è±¡ã®æœ€åˆã®çƒå½¢ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã™ã¨æœªå®šç¾©å‹•ä½œã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</param>
	/// <param name="b">åˆ¤å®šå¯¾è±¡ã®2ç•ªç›®ã®çƒå½¢ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã™ã¨æœªå®šç¾©å‹•ä½œã«ãªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</param>
	/// <returns>è¡çªã—ã¦ã„ã‚‹å ´åˆã¯ trueã€è¡çªã—ã¦ã„ãªã„å ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool SphereToSphereCollision(class SphereCollider* a, class SphereCollider* b);

	/// <summary>
	/// 2ã¤ã®è»¸æ•´åˆ—å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼ˆAABBï¼‰åŒå£«ãŒè¡çªã—ã¦ã„ã‚‹ã‹ã‚’åˆ¤å®š
	/// </summary>
	/// <param name="a">åˆ¤å®šå¯¾è±¡ã®æœ€åˆã® AABBCollider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="b">åˆ¤å®šå¯¾è±¡ã®2ç•ªç›®ã® AABBCollider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <returns>è¡çªã—ã¦ã„ã‚‹å ´åˆã¯ trueã€ãã†ã§ãªã„å ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool AABBToAABBCollision(class AABBCollider* a, class AABBCollider* b);

	/// <summary>
	/// 2ã¤ã®OBBï¼ˆå‘ãä»˜ãå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼é–“ã®è¡çªã‚’åˆ¤å®š
	/// </summary>
	/// <param name="a">è¡çªåˆ¤å®šå¯¾è±¡ã®æœ€åˆã®OBBColliderã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="b">è¡çªåˆ¤å®šå¯¾è±¡ã®2ç•ªç›®ã®OBBColliderã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <returns>è¡çªãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã¯ trueã€æ¤œå‡ºã•ã‚Œãªã‘ã‚Œã° false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool OBBToOBBCollision(class OBBCollider* a, class OBBCollider* b);

	/// <summary>
	/// çƒï¼ˆSphereï¼‰ã¨è»¸å¹³è¡Œå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼ˆAABBï¼‰é–“ã®è¡çªåˆ¤å®šã‚’è¡Œã†é–¢æ•°ã€‚
	/// </summary>
	/// <param name="sphere">åˆ¤å®šå¯¾è±¡ã®çƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ä¸­å¿ƒä½ç½®ã¨åŠå¾„ã‚’ä¿æŒã—ã¦ã„ã‚‹ã“ã¨ã‚’æƒ³å®šã™ã‚‹ï¼ˆnullptr ã‚’æ¸¡ã•ãªã„ã“ã¨ï¼‰ã€‚</param>
	/// <param name="aabb">åˆ¤å®šå¯¾è±¡ã®è»¸å¹³è¡Œå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼ˆAABBï¼‰ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚æœ€å°/æœ€å¤§åº§æ¨™ãªã©ã‚’ä¿æŒã—ã¦ã„ã‚‹ã“ã¨ã‚’æƒ³å®šã™ã‚‹ï¼ˆnullptr ã‚’æ¸¡ã•ãªã„ã“ã¨ï¼‰ã€‚</param>
	/// <returns>çƒã¨AABBãŒé‡ãªã£ã¦ã„ã‚‹å ´åˆã¯ trueã€é‡ãªã£ã¦ã„ãªã„å ´åˆã¯ false ã‚’è¿”ã™ã€‚</returns>
	bool SphereToAABBCollision(class SphereCollider* sphere, class AABBCollider* aabb);

	/// <summary>
	/// AABBï¼ˆè»¸ã«æ²¿ã£ãŸå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰ã¨ OBBï¼ˆä»»æ„æ–¹å‘ã®å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰é–“ã®è¡çªã‚’åˆ¤å®š
	/// </summary>
	/// <param name="aabb">åˆ¤å®šå¯¾è±¡ã®è»¸æ–¹å‘ã«æ•´åˆ—ã—ãŸå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ã‚’è¡¨ã™ AABBCollider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="obb">åˆ¤å®šå¯¾è±¡ã®ä»»æ„æ–¹å‘ã®å¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ã‚’è¡¨ã™ OBBCollider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <returns>è¡çªã—ã¦ã„ã‚‹å ´åˆã¯ trueã€è¡çªã—ã¦ã„ãªã„å ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool AABBToOBBCollision(class AABBCollider* aabb, class OBBCollider* obb);
	
	/// <summary>
	/// çƒã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¨ OBBï¼ˆå‘ãä»˜ãå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼é–“ã®è¡çªã‚’åˆ¤å®š
	/// </summary>
	/// <param name="sphere">åˆ¤å®šå¯¾è±¡ã®çƒã‚’è¡¨ã™ SphereCollider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚æœ‰åŠ¹ãªãƒã‚¤ãƒ³ã‚¿ã‚’æ¸¡ã™ã“ã¨ã‚’å‰æã¨ã—ã¾ã™ã€‚</param>
	/// <param name="obb">åˆ¤å®šå¯¾è±¡ã® OBBï¼ˆå‘ãä»˜ãå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰ã‚’è¡¨ã™ OBBCollider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚æœ‰åŠ¹ãªãƒã‚¤ãƒ³ã‚¿ã‚’æ¸¡ã™ã“ã¨ã‚’å‰æã¨ã—ã¾ã™ã€‚</param>
	/// <returns>çƒã¨ OBB ãŒäº¤å·®ã—ã¦ã„ã‚‹å ´åˆã¯ trueã€äº¤å·®ã—ã¦ã„ãªã„å ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool SphereToOBBCollision(class SphereCollider* sphere, class OBBCollider* obb);

	/// <summary>
	/// åˆ†é›¢è»¸å®šç†ï¼ˆSATï¼‰ã«åŸºã¥ã„ã¦ã€2ã¤ã®OBBï¼ˆå‘ãä»˜ãå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰é–“ã®è¡çªï¼ˆäº¤å·®ï¼‰ã‚’åˆ¤å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="a">åˆ¤å®šå¯¾è±¡ã®æœ€åˆã®OBBã€‚constå‚ç…§ã§æ¸¡ã•ã‚Œã€é–¢æ•°å†…ã§å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚</param>
	/// <param name="b">åˆ¤å®šå¯¾è±¡ã®2ç•ªç›®ã®OBBã€‚constå‚ç…§ã§æ¸¡ã•ã‚Œã€é–¢æ•°å†…ã§å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚</param>
	/// <returns>2ã¤ã®OBBãŒäº¤å·®ã—ã¦ã„ã‚‹å ´åˆã¯trueã€äº¤å·®ã—ã¦ã„ãªã„å ´åˆã¯falseã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool OBBSATCollision(const OBB& a, const OBB& b);

	/// <summary>
	/// OBBï¼ˆå‘ãä»˜ãå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼‰ã‚’æŒ‡å®šã—ãŸè»¸ã«å°„å½±ã—ã€è»¸ä¸Šã®æœ€å°ãƒ»æœ€å¤§ã‚¹ã‚«ãƒ©ãƒ¼å€¤ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="obb">å°„å½±ã•ã‚Œã‚‹å‘ãä»˜ãå¢ƒç•Œãƒœãƒƒã‚¯ã‚¹ï¼ˆconstå‚ç…§ï¼‰ã€‚</param>
	/// <param name="axis">å°„å½±ã«ç”¨ã„ã‚‹è»¸ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconstå‚ç…§ï¼‰ã€‚é€šå¸¸ã¯å˜ä½ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ¸¡ã—ã¾ã™ãŒã€éæ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«ã‚‚æ‰±ãˆã¾ã™ã€‚</param>
	/// <param name="outMin">å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã€‚è»¸ä¸Šã®æœ€å°å°„å½±å€¤ã‚’æ ¼ç´ã™ã‚‹å‚ç…§ã€‚</param>
	/// <param name="outMax">å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã€‚è»¸ä¸Šã®æœ€å¤§å°„å½±å€¤ã‚’æ ¼ç´ã™ã‚‹å‚ç…§ã€‚</param>
	void ProjectOBBOntoAxis(const OBB& obb, const Vector3& axis, float& outMin, float& outMax);
};



============================================================
File Path: Project/Engine/System/Managers/DSVManager.cpp
============================================================
#include "DSVManager.h"
// Engine
#include "Engine/Core/DXCommon.h"
#include "Engine/Core/WinApp.h"
// Service
#include "Engine/System/Service/GraphicsResourceGetter.h"

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
DSVManager::DSVManager() = default;
DSVManager::~DSVManager() {
    descriptorHeap_.Reset();
    resource_->Reset();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// Heap
ID3D12DescriptorHeap* DSVManager::GetDescriptorHeap() const { return descriptorHeap_.Get(); }
// CPU
D3D12_CPU_DESCRIPTOR_HANDLE DSVManager::GetCPUDescriptorHandle(uint32_t index) const {
    D3D12_CPU_DESCRIPTOR_HANDLE handle = descriptorHeap_->GetCPUDescriptorHandleForHeapStart();
    handle.ptr += index * descriptorSize_;
    return handle;
}
// GPU
D3D12_GPU_DESCRIPTOR_HANDLE DSVManager::GetGPUDescriptorHandle(uint32_t index) const {
    D3D12_GPU_DESCRIPTOR_HANDLE handle = descriptorHeap_->GetGPUDescriptorHandleForHeapStart();
    handle.ptr += index * descriptorSize_;
    return handle;
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void DSVManager::Initialize(DXCommon* dxcommon, WinApp* winApp) {
    dxcommon_ = dxcommon;
    winApp_ = winApp;
    // DescriptorSizeã®å–å¾—, Heapã®ç”Ÿæˆ
    descriptorHeap_ = dxcommon_->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_DSV, kMaxDSVCount_, false);
    descriptorSize_ = dxcommon_->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_DSV);
}

///-------------------------------------------/// 
/// ã‚¯ãƒªã‚¢
///-------------------------------------------///
void DSVManager::ClearDepthBufferView(ID3D12GraphicsCommandList* commandList) {
    for (uint32_t i = 0; i < useIndex_; ++i) {
        commandList->ClearDepthStencilView(GetCPUDescriptorHandle(i), D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
    }
}

///-------------------------------------------/// 
/// ç¢ºä¿é–¢æ•°
///-------------------------------------------///
uint32_t DSVManager::Allocate() {
    /// ===ä¸Šé™ã«é”ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦assert=== ///
    assert(AssertAllocate());
    // return ã™ã‚‹ç•ªå·ã‚’ã„ã£ãŸã‚“è¨˜éŒ²ã—ã¦ãŠã
    int index = useIndex_;
    // æ¬¡å›ã®ãŸã‚ã«ç•ªå·ã‚’1é€²ã‚ã‚‹
    useIndex_++;
    // ä¸Šã§è¨˜éŒ²ã—ãŸç•ªå·ã‚’return(0ç•ªã¯ImGuiã ã‹ã‚‰+1)
    return index;
}
bool DSVManager::AssertAllocate() { return useIndex_ < kMaxDSVCount_; }

///-------------------------------------------/// 
/// ç”Ÿæˆ
///-------------------------------------------///
void DSVManager::CreateDepthBufferView(uint32_t index) {
    D3D12_RESOURCE_DESC desc{};
    desc.Width = winApp_->GetWindowWidth();
    desc.Height = winApp_->GetWindowHeight();
    desc.MipLevels = 1;
    desc.DepthOrArraySize = 1;
    desc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
    desc.SampleDesc.Count = 1;
    desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
    desc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;

    D3D12_HEAP_PROPERTIES heapProps{};
    heapProps.Type = D3D12_HEAP_TYPE_DEFAULT;

    D3D12_CLEAR_VALUE clearValue{};
    clearValue.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
    clearValue.DepthStencil.Depth = 1.0f;

    dxcommon_->GetDevice()->CreateCommittedResource(&heapProps, D3D12_HEAP_FLAG_NONE, &desc,
        D3D12_RESOURCE_STATE_DEPTH_WRITE, &clearValue, IID_PPV_ARGS(&resource_[index]));

    D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
    dsvDesc.Format = desc.Format;
    dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;

    dxcommon_->GetDevice()->CreateDepthStencilView(
        resource_[index].Get(), &dsvDesc, GetCPUDescriptorHandle(index));

    // ã“ã®éƒ¨åˆ†ãŒã‚ã£ã¦ã„ã‚‹ã®ã‹ãŒè‰¯ãã‚ã‹ã‚‰ãªã„ã€‚
    useIndex_ = index + 1;
}


============================================================
File Path: Project/Engine/System/Managers/DSVManager.h
============================================================
#pragma once
/// ===Include=== ///
// DirectX
#include <d3d12.h>
// c++
#include <cstdint>
#include <cassert>
// Engien
#include "Engine/Core/ComPtr.h"

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;
class WinApp;

///=====================================================/// 
/// DSVManager
///=====================================================///
class DSVManager {
public:

	DSVManager();
	~DSVManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxcommon">Class DXCommon</param>
	void Initialize(DXCommon* dxcommon, WinApp* winApp);

	/// <summary>
	/// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="index">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	void CreateDepthBufferView(uint32_t index);
	
	/// <summary>
	/// ã‚¯ãƒªã‚¢å‡¦ç†
	/// </summary>
	/// <param name="commandList">ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ</param>
	void ClearDepthBufferView(ID3D12GraphicsCommandList* commandList);
	
	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å‰²ã‚Šå½“ã¦ã‚’è¡Œã„ã€å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸè­˜åˆ¥å­ã‚’è¿”ã™
	/// </summary>
	/// <returns>å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã®è­˜åˆ¥å­ã‚’è¡¨ã™ 32 ãƒ“ãƒƒãƒˆç¬¦å·ãªã—æ•´æ•° (uint32_t)ã€‚</returns>
	uint32_t Allocate();

	/// <summary>
	/// ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ã®æˆå¦ã‚’æ¤œè¨¼
	/// </summary>
	/// <returns>ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool AssertAllocate();

public: /// ===Getter=== ///
	// Heap
	ID3D12DescriptorHeap* GetDescriptorHeap() const;
	// CPU
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(uint32_t index) const;
	// GPU
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(uint32_t index) const;

public:/// ===å®šæ•°=== ///

	// DSVã®æ•°
	static const uint32_t kMaxDSVCount_ = 16;

private:
	// DXCommon
	DXCommon* dxcommon_ = nullptr;
	// WinApp
	WinApp* winApp_ = nullptr;
	// depthStencilResource
	ComPtr<ID3D12Resource> resource_[kMaxDSVCount_];
	// ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descriptorHeap_;
	// ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize_ = 0;
	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t useIndex_ = 0;
};



============================================================
File Path: Project/Engine/System/Managers/ImGuiManager.cpp
============================================================
#include "ImGuiManager.h"
// Engine
#include "Engine/Core/WinApp.h"
#include "Engine/Core/DXCommon.h"
#include "Engine/System/Managers/SRVManager.h"
#include "Engine/System/ImGui/SceneView.h"
// c++
#include <cassert>


///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ImGuiManager::ImGuiManager() = default;
ImGuiManager::~ImGuiManager() = default;

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ImGuiManager::Initialize(WinApp* winApp, DXCommon* dxCommon, SRVManager* srvManager) {

	assert(winApp);
	assert(dxCommon);
	assert(srvManager);

	winApp_ = winApp;
	dxCommon_ = dxCommon;
	srvManager_ = srvManager;

#ifdef USE_IMGUI
	IMGUI_CHECKVERSION(); //ã€€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ãƒã‚§ãƒƒã‚¯
	ImGui::CreateContext(); // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç”Ÿæˆ
	ImGui::StyleColorsDark(); // ã‚¹ã‚¿ã‚¤ãƒ«ã®è¨­å®š
	ImGui_ImplWin32_Init(winApp_->GetHwnd()); // Win32ç”¨ã®åˆæœŸåŒ– 
	ImGui_ImplDX12_Init( // DirectX12ç”¨ã®åˆæœŸåŒ–
		dxCommon_->GetDevice(),
		static_cast<int>(dxCommon_->GetBackBufferCount()),
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB,
		srvManager_->GetDescriptorHeap(),
		srvManager_->GetDescriptorHeap()->GetCPUDescriptorHandleForHeapStart(),
		srvManager_->GetDescriptorHeap()->GetGPUDescriptorHandleForHeapStart());

	ImGuiIO& io = ImGui::GetIO();
	io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // ãƒ‰ãƒƒã‚­ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«ã™ã‚‹

	/// ===æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆé©ç”¨=== ///
	// æ—¥æœ¬èªãƒ•ã‚©ãƒ³ãƒˆã®èª­ã¿è¾¼ã¿
	ImFontConfig fontConfig;
	fontConfig.MergeMode = false;
	fontConfig.OversampleH = 1;
	fontConfig.OversampleV = 1;
	fontConfig.PixelSnapH = true;

	// æ—¥æœ¬èªã‚°ãƒªãƒ•ã®ç¯„å›²ã‚’æŒ‡å®š
	io.Fonts->AddFontFromFileTTF(
		"Resource/Fonts/JNRfont_n.ttf",
		16.0f,
		&fontConfig,
		io.Fonts->GetGlyphRangesJapanese()
	);

	// ãƒ•ã‚©ãƒ³ãƒˆã‚¢ãƒˆãƒ©ã‚¹ã®ãƒ“ãƒ«ãƒ‰
	io.Fonts->Build();
#endif // USE_IMGUI
}


///-------------------------------------------/// 
/// çµ‚äº†
///-------------------------------------------///
void ImGuiManager::Finalize() {
#ifdef USE_IMGUI
	// ImGuiã®çµ‚äº†å‡¦ç†.ã€‚
	ImGui_ImplDX12_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();
#endif // USE_IMGUI
}


///-------------------------------------------/// 
/// é–‹å§‹å‡¦ç†
///-------------------------------------------///
void ImGuiManager::Begin() {
#ifdef USE_IMGUI
	// ãƒ•ãƒ¬ãƒ¼ãƒ ã®å…ˆé ­ã§ImGuiã«ã€ã“ã“ã‹ã‚‰ãƒ•ãƒ¬ãƒ¼ãƒ ãŒå§‹ã¾ã‚‹æ—¨ã‚’å‘Šã’ã‚‹
	ImGui_ImplDX12_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
	// é–‹ç™ºç”¨UIã®å‡¦ç†ã€‚å®Ÿéš›ã«é–‹ç™ºç”¨ã®UIã‚’å‡ºã™å ´åˆã¯ã“ã“ã‚’ã‚²ãƒ¼ãƒ å›ºæœ‰ã®åˆæœŸã«ç½®ãæ›ãˆã‚‹
	//ImGui::ShowDemoWindow();

	// Dockä»˜ãUIæç”»
	//DrawMainDockWindow();
	// ãƒ‰ãƒƒã‚­ãƒ³ã‚°è¨­å®š
	ImGui::DockSpaceOverViewport(ImGui::GetMainViewport()->ID, ImGui::GetMainViewport(), ImGuiDockNodeFlags_None);

#endif // USE_IMGUI
}


///-------------------------------------------/// 
/// çµ‚äº†å‡¦ç†
///-------------------------------------------///
void ImGuiManager::End() {
#ifdef USE_IMGUI
	// æç”»ç”¨ã®DescriptorHeapã®è¨­å®š
	ComPtr<ID3D12GraphicsCommandList> commandList = dxCommon_->GetCommandList();
	// ImGuiã®å†…éƒ¨ã‚³ãƒãƒ³ãƒ‰ã‚’ç”Ÿæˆã™ã‚‹
	ImGui::Render();
	// SRVã®è¨­å®š
	srvManager_->PreDraw();
	// å®Ÿéš›ã®CommandListã®ImGuiã®æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), commandList.Get());
#endif // USE_IMGUI
}


///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ImGuiManager::Draw() {
#ifdef USE_IMGUI
	// å„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æç”»
	if (sceneView_) {
		sceneView_->Draw();
	}
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void ImGuiManager::SetSceneView(SceneView* sceneView) { sceneView_ = sceneView; }

///-------------------------------------------/// 
/// Dockä»˜ãUIæç”»
///-------------------------------------------///
void ImGuiManager::DrawMainDockWindow() {
#ifdef USE_IMGUI
	ImGuiViewport* viewport = ImGui::GetMainViewport();
	ImGui::SetNextWindowPos(viewport->Pos);
	ImGui::SetNextWindowSize(viewport->Size);
	ImGui::SetNextWindowViewport(viewport->ID);

	ImGuiWindowFlags window_flags =
		ImGuiWindowFlags_NoTitleBar |
		ImGuiWindowFlags_NoCollapse |
		ImGuiWindowFlags_NoResize |
		ImGuiWindowFlags_NoMove |
		ImGuiWindowFlags_NoBringToFrontOnFocus |
		ImGuiWindowFlags_NoNavFocus |
		ImGuiWindowFlags_MenuBar;

	ImGui::PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
	ImGui::PushStyleVar(ImGuiStyleVar_WindowBorderSize, 0.0f);
	ImGui::Begin("DockSpace Window", nullptr, window_flags);
	ImGui::PopStyleVar(2);

	MenuBar();

	ImGui::DockSpaceOverViewport(ImGui::GetMainViewport()->ID, ImGui::GetMainViewport(), ImGuiDockNodeFlags_None);
	ImGui::End();

	// å„ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’æç”»
	if (sceneView_) sceneView_->Draw();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®ã¿
///-------------------------------------------///
void ImGuiManager::MenuBar() {
#ifdef USE_IMGUI
	if (ImGui::BeginMenuBar()) {
		if (ImGui::BeginMenu("File")) {
			ImGui::MenuItem("Open", "Ctrl+O");
			ImGui::MenuItem("Save", "Ctrl+S");
			ImGui::EndMenu();
		}
		if (ImGui::BeginMenu("Edit")) {
			ImGui::MenuItem("Undo", "Ctrl+Z");
			ImGui::MenuItem("Redo", "Ctrl+Y");
			ImGui::EndMenu();
		}
		ImGui::EndMenuBar();
	}
#endif // USE_IMGUI
}


============================================================
File Path: Project/Engine/System/Managers/ImGuiManager.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Core/ComPtr.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#include <imgui_impl_dx12.h>
#include <imgui_impl_win32.h>
#endif // USE_IMGUI

/// ===å‰æ–¹å®£è¨€=== ///
class WinApp;
class DXCommon;
class SRVManager;
class SceneView;

///=====================================================/// 
/// ImGuiManager
///=====================================================///
class ImGuiManager {
public:

	ImGuiManager();
	~ImGuiManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="winApp">ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚„ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å›ºæœ‰ã®è¨­å®šãƒ»çŠ¶æ…‹ã‚’ç®¡ç†ã™ã‚‹ WinApp ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="dxCommon">DirectX ã«é–¢é€£ã™ã‚‹å…±é€šãƒªã‚½ãƒ¼ã‚¹ã‚„åˆæœŸåŒ–å‡¦ç†ã‚’ç®¡ç†ã™ã‚‹ DXCommon ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ï¼ˆSRVï¼‰ãªã©ã®ãƒªã‚½ãƒ¼ã‚¹ç®¡ç†ã‚’è¡Œã† SRVManager ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Initialize(WinApp* winApp, DXCommon* dxCommon, SRVManager* srvManager);
	
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

	/// <summary>
	/// å—ä»˜é–‹å§‹å‡¦ç†
	/// </summary>
	void Begin();

	/// <summary>
	/// å—ä»˜çµ‚äº†å‡¦ç†
	/// </summary>
	void End();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();
	
public: /// ===Setter=== ///
	// SceneViewã®è¨­å®š
	void SetSceneView(SceneView* sceneView);

private:
	
	WinApp* winApp_ = nullptr;
	DXCommon* dxCommon_ = nullptr;
	SRVManager* srvManager_ = nullptr;
	SceneView* sceneView_ = nullptr;

private:
	/// <summary>
	/// Dockä»˜ãUIæç”»å‡¦ç†
	/// </summary>
	void DrawMainDockWindow(); 

	/// <summary>
	/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®å‡¦ç†
	/// </summary>
	void MenuBar();
};



============================================================
File Path: Project/Engine/System/Managers/LevelManager.cpp
============================================================
#include "LevelManager.h"
// c++
#include <thread>
#include <cassert>
// Math
#include "Math/sMath.h"

///-------------------------------------------/// 
/// Jsonã®èª­ã¿è¾¼ã¿é–¢æ•°
///-------------------------------------------///
void LevelManager::LoadLevelJson(const std::string& basePath, const std::string& file_path) {

    /// ===JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã¿ã‚‹=== ///
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
    std::ifstream file;

	// basePath`ã¨`file_path`ã‚’çµåˆã—ã¦å®Œå…¨ãªãƒ‘ã‚¹ã‚’ä½œæˆ
	std::string full_path = basePath + "/" + file_path;

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    file.open(full_path);

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³å¤±æ•—ã‚’ãƒã‚§ãƒƒã‚¯
    if (file.fail()) {
        assert(0);
    }

    /// ===ãƒ•ã‚¡ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯=== ///
    // JSONæ–‡å­—åˆ—ã‹ã‚‰è§£å‡ã—ãŸãƒ‡ãƒ¼ã‚¿
    nlohmann::json deserialized;

    // è§£å‡
    file >> deserialized;

    // æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
    assert(deserialized.is_object());
    assert(deserialized.contains("name"));
    assert(deserialized["name"].is_string());

    // "name"ã‚’æ–‡å­—åˆ—ã¨ã—ã¦å–å¾—
    std::string name =
        deserialized["name"].get<std::string>();
    // æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ãƒã‚§ãƒƒã‚¯
    assert(name.compare("scene") == 0);

    /// ===ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®èµ°æŸ»=== ///
    // ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
    LevelData* levelData = new LevelData();

    // "objects"ã®å…¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èµ°æŸ»
    if (deserialized.contains("objects")) {
        LoadobjectRecursive(deserialized["objects"], levelData);
    }
    

	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒƒãƒ—ã«æ ¼ç´ 
    m_objectMap[file_path] = std::move(levelData);
}

///-------------------------------------------/// 
/// èµ°æŸ»é–¢æ•°
///-------------------------------------------///
void LevelManager::LoadobjectRecursive(nlohmann::json& obj, LevelData* levelData) {

    for (nlohmann::json& object : obj) {
        assert(object.contains("type"));

        // ç„¡åŠ¹ã‚ªãƒ—ã‚·ãƒ§ãƒ³
        if (object.contains("disabled")) {
            // æœ‰åŠ¹ç„¡åŠ¹ãƒ•ãƒ©ã‚°
            bool disabled = object["disabled"].get<bool>();
            if (disabled) {
                // é…ç½®ã—ãªã„
                continue;
            }
        }

        // ç¨®åˆ¥ã‚’å–å¾—
        std::string type = object["type"].get<std::string>();

        // ç¨®é¡ã”ã¨ã®å‡¦ç†
        /// ===ãƒ¡ãƒƒã‚·ãƒ¥ã®èª­ã¿è¾¼ã¿=== ///
        // MESH
        if (type.compare("MESH") == 0) {
            // è¦ç´ è¿½åŠ 
            levelData->objects.emplace_back(LevelData::JsonObjectData{});
            // ä»Šè¿½åŠ ã—ãŸè¦ç´ ã®å‚ç…§ã‚’å¾—ã‚‹
            LevelData::JsonObjectData& objectData = levelData->objects.back();

            /// ===FileName=== ///
            if (object.contains("file_name")) {
                // ãƒ•ã‚¡ã‚¤ãƒ«å
                objectData.fileName = object["file_name"];
            }

            /// ===ClassName=== ///
            if (object.contains("class_name")) {
                std::string classStr = object["class_name"].get<std::string>();
                objectData.classType = StringToClassType(classStr);
            } else {
                objectData.classType = LevelData::ClassTypeLevel::None;
            }

            /// ===ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿=== ///
            // ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
            nlohmann::json& transform = object["transform"];
            // å¹³è¡Œç§»å‹•
            objectData.translation.x = (float)transform["translation"][0];
            objectData.translation.y = (float)transform["translation"][2];
            objectData.translation.z = -(float)transform["translation"][1];
            // å›è»¢è§’
            objectData.rotation.x = -(float)transform["rotation"][0];
            objectData.rotation.y = -(float)transform["rotation"][2];
            objectData.rotation.z = -(float)transform["rotation"][1];
            // ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
            objectData.scaling.x = (float)transform["scaling"][0];
            objectData.scaling.y = (float)transform["scaling"][2];
            objectData.scaling.z = (float)transform["scaling"][1];

            /// ===Collideræƒ…å ±=== /// 
            if (object.contains("collider")) {
                // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼æƒ…å ±ã®èª­ã¿è¾¼ã¿
                nlohmann::json& collider = object["collider"];

                // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¿ã‚¤ãƒ—ã®å–å¾—
                if (collider.contains("type")) {
                    std::string colliderTypeStr = collider["type"].get<std::string>();
                    objectData.colliderType = StringToColliderType(colliderTypeStr);
                } else {
                    objectData.colliderType = LevelData::ColliderTypeLevel::None;
                }

                // collider_info1ã®èª­ã¿è¾¼ã¿ (OBB: Center, AABB: Min, Sphere: Center)
                if (collider.contains("info1")) {
                    objectData.colliderInfo1.x = (float)collider["info1"][0];
                    objectData.colliderInfo1.y = (float)collider["info1"][2];
                    objectData.colliderInfo1.z = (float)collider["info1"][1];
                }

                // collider_info2ã®èª­ã¿è¾¼ã¿ (OBB: Size, AABB: Max, Sphere: Radius)
                if (collider.contains("info2")) {
                    objectData.colliderInfo2.x = (float)collider["info2"][0];
                    objectData.colliderInfo2.y = (float)collider["info2"][2];
                    objectData.colliderInfo2.z = (float)collider["info2"][1];
                }
            } else {
                // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼æƒ…å ±ãŒãªã„å ´åˆ
                objectData.colliderType = LevelData::ColliderTypeLevel::None;
            }

            // å†å¸°å‡¦ç†ï¼ˆå­ä¾›ãŒã„ã‚‹å ´åˆï¼‰
            if (object.contains("children")) {
                LoadobjectRecursive(object["children"], levelData);
            }
        }
    }
}

///-------------------------------------------/// 
/// æ–‡å­—åˆ—ã‹ã‚‰ClassTypeã«å¤‰æ›
///-------------------------------------------///
LevelData::ClassTypeLevel LevelManager::StringToClassType(const std::string& str) {
    if (str == "NoClass")   return LevelData::ClassTypeLevel::None;

    if (str == "Player1")   return LevelData::ClassTypeLevel::Player1;
    if (str == "Player2")   return LevelData::ClassTypeLevel::Player2;

    if (str == "Enemy1")    return LevelData::ClassTypeLevel::Enemy1;
    if (str == "Enemy2")    return LevelData::ClassTypeLevel::Enemy2;
    if (str == "Enemy3")    return LevelData::ClassTypeLevel::Enemy3;
    if (str == "Enemy4")    return LevelData::ClassTypeLevel::Enemy4;
    if (str == "Enemy5")    return LevelData::ClassTypeLevel::Enemy5;
    if (str == "Enemy6")    return LevelData::ClassTypeLevel::Enemy6;
    if (str == "Enemy7")    return LevelData::ClassTypeLevel::Enemy7;
    if (str == "Enemy8")    return LevelData::ClassTypeLevel::Enemy8;
    if (str == "Enemy9")    return LevelData::ClassTypeLevel::Enemy9;
    if (str == "Enemy10")   return LevelData::ClassTypeLevel::Enemy10;

    if (str == "Object1")   return LevelData::ClassTypeLevel::Object1;
    if (str == "Object2")   return LevelData::ClassTypeLevel::Object2;
    if (str == "Object3")   return LevelData::ClassTypeLevel::Object3;
    if (str == "Object4")   return LevelData::ClassTypeLevel::Object4;
    if (str == "Object5")   return LevelData::ClassTypeLevel::Object5;
    if (str == "Object6")   return LevelData::ClassTypeLevel::Object6;
    if (str == "Object7")   return LevelData::ClassTypeLevel::Object7;
    if (str == "Object8")   return LevelData::ClassTypeLevel::Object8;
    if (str == "Object9")   return LevelData::ClassTypeLevel::Object9;
    if (str == "Object10")  return LevelData::ClassTypeLevel::Object10;

    if (str == "Ground1")   return LevelData::ClassTypeLevel::Ground1;
    if (str == "Ground2")   return LevelData::ClassTypeLevel::Ground2;
    if (str == "Ground3")   return LevelData::ClassTypeLevel::Ground3;
    if (str == "Ground4")   return LevelData::ClassTypeLevel::Ground4;
    if (str == "Ground5")   return LevelData::ClassTypeLevel::Ground5;
    if (str == "Ground6")   return LevelData::ClassTypeLevel::Ground6;
    if (str == "Ground7")   return LevelData::ClassTypeLevel::Ground7;
    if (str == "Ground8")   return LevelData::ClassTypeLevel::Ground8;
    if (str == "Ground9")   return LevelData::ClassTypeLevel::Ground9;
    if (str == "Ground10")  return LevelData::ClassTypeLevel::Ground10;

    if (str == "SkyDome1")  return LevelData::ClassTypeLevel::SkyBox1;
    if (str == "SkyDome2")  return LevelData::ClassTypeLevel::SkyBox2;
    if (str == "SkyDome3")  return LevelData::ClassTypeLevel::SkyBox3;
    if (str == "SkyDome4")  return LevelData::ClassTypeLevel::SkyBox4;
    if (str == "SkyDome5")  return LevelData::ClassTypeLevel::SkyBox5;
    if (str == "SkyDome6")  return LevelData::ClassTypeLevel::SkyBox6;
    if (str == "SkyDome7")  return LevelData::ClassTypeLevel::SkyBox7;
    if (str == "SkyDome8")  return LevelData::ClassTypeLevel::SkyBox8;
    if (str == "SkyDome9")  return LevelData::ClassTypeLevel::SkyBox9;
    if (str == "SkyDome10") return LevelData::ClassTypeLevel::SkyBox10;

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ None
    return LevelData::ClassTypeLevel::None;
}

///-------------------------------------------/// 
/// æ–‡å­—åˆ—ã‹ã‚‰ColliderTypeã«å¤‰æ›
///-------------------------------------------///
LevelData::ColliderTypeLevel LevelManager::StringToColliderType(const std::string& str) {
    if (str == "OBB")    return LevelData::ColliderTypeLevel::OBB;
    if (str == "AABB")   return LevelData::ColliderTypeLevel::AABB;
    if (str == "SPHERE") return LevelData::ColliderTypeLevel::Sphere;

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ None
    return LevelData::ColliderTypeLevel::None;
}

///-------------------------------------------/// 
/// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
///-------------------------------------------///
LevelData* LevelManager::GetLevelData(const std::string& file_path) {
    assert(m_objectMap.contains(file_path));
    return m_objectMap.at(file_path);
}




============================================================
File Path: Project/Engine/System/Managers/LevelManager.h
============================================================
#pragma once
/// ===Include=== ///
// C++
#include <iostream>
#include <fstream>
#include <map>
// JSON
#include <json.hpp>

// Data
#include "Engine/DataInfo/LevelData.h"


///=====================================================/// 
/// LevelManager
///=====================================================///
class LevelManager {
public:

	LevelManager() = default;
	~LevelManager() = default;

	/// <summary>
	/// Jsonãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="basePath">èª­ã¿è¾¼ã¿æ™‚ã®åŸºæº–ã¨ãªã‚‹ãƒ™ãƒ¼ã‚¹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã€‚</param>
	/// <param name="file_path">èª­ã¿è¾¼ã‚€ JSON ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ï¼ˆbasePath ã‚’åŸºæº–ã¨ã™ã‚‹ç›¸å¯¾ãƒ‘ã‚¹ã€ã¾ãŸã¯çµ¶å¯¾ãƒ‘ã‚¹ï¼‰ã€‚</param>
	void LoadLevelJson(const std::string& basePath, const std::string& file_path);

public: /// ===Getter=== ///
	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	LevelData* GetLevelData(const std::string& file_path);

private:

	// æ ¼ç´ãƒ‡ãƒ¼ã‚¿
	std::map<std::string, LevelData*> m_objectMap;

private:

	/// <summary>
	/// nlohmann::json ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å†å¸°çš„ã«èª­ã¿è¾¼ã¿ã€LevelData ã«åæ˜ ã™ã‚‹ã€‚
	/// </summary>
	/// <param name="object">èª­ã¿è¾¼ã‚€ JSON ãƒ‡ãƒ¼ã‚¿ï¼ˆnlohmann::jsonï¼‰ã€‚é–¢æ•°ã¯ã“ã® JSON ã‚’å†å¸°çš„ã«èµ°æŸ»ã—ã¦å†…å®¹ã‚’å‡¦ç†ã™ã‚‹ã€‚</param>
	/// <param name="levelData">èª­ã¿è¾¼ã¿å…ˆã® LevelData æ§‹é€ ä½“ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚é–¢æ•°ã¯ã“ã®ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã™ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ã™ã‚‹ã€‚</param>
	void LoadobjectRecursive(nlohmann::json& obj, LevelData* levelData);
	
	/// <summary>
	/// æ–‡å­—åˆ—ã‚’ LevelData::ClassType ã«å¤‰æ›ã™ã‚‹é™çš„ãƒ¡ãƒ³ãƒãƒ¼é–¢æ•°ã€‚
	/// </summary>
	/// <param name="str">å¤‰æ›å¯¾è±¡ã®æ–‡å­—åˆ—ï¼ˆã‚¯ãƒ©ã‚¹ã‚¿ã‚¤ãƒ—ã‚’è¡¨ã™ï¼‰ã€‚</param>
	/// <returns>å¼•æ•°ã®æ–‡å­—åˆ—ã«å¯¾å¿œã™ã‚‹ LevelData::ClassType ã®å€¤ã€‚</returns>
	static LevelData::ClassTypeLevel StringToClassType(const std::string& str);

	/// <summary>
	/// æ–‡å­—åˆ—ã‚’ LevelData::ColliderTypeLevel å‹ã®å€¤ã«å¤‰æ›ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="str">å¤‰æ›ã™ã‚‹å…¥åŠ›æ–‡å­—åˆ—ã€‚</param>
	/// <returns>å…¥åŠ›æ–‡å­—åˆ—ã«å¯¾å¿œã™ã‚‹ LevelData::ColliderTypeLevel ã®å€¤ã€‚å¯¾å¿œã™ã‚‹å€¤ãŒãªã„å ´åˆã®æŒ™å‹•ã¯å®Ÿè£…ä¾å­˜ã§ã™ã€‚</returns>
	static LevelData::ColliderTypeLevel StringToColliderType(const std::string& str);
};



============================================================
File Path: Project/Engine/System/Managers/ModelManager.cpp
============================================================
#include "ModelManager.h"
// c++
#include <fstream>
// Engine
#include "Engine/System/Managers/TextureManager.h"
// Math
#include "Math/sMath.h"
#include "Math/MatrixMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ModelManager::~ModelManager() {
	modelDatas_.clear();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ModelManager::Initialize(TextureManager* texture) {
	assert(texture);
	textureManager_ = texture;
}

///-------------------------------------------/// 
/// ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
///-------------------------------------------///
void ModelManager::Load(const std::string& baseDirectoryPath, const std::string& Key, const std::string& filename) {
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (modelDatas_.contains(filename)) {
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸreturn
		return;
	}

	// Dataã®å®£è¨€
	ModelData modeldata;
	// ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	modeldata = LoadObjFile(baseDirectoryPath, filename);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿ã¨ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹è¨­å®š
	if (!modeldata.material.textureFilePath.empty()) { // ç©ºã§ãªã‘ã‚Œã°
		// TextureManager ã‹ã‚‰ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’èª­ã¿è¾¼ã¿ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
		textureManager_->LoadTexture(modeldata.material.textureFilePath, modeldata.material.textureFilePath);
	}

	// ãƒ¢ãƒ‡ãƒ«ã‚’Mapã‚³ãƒ³ãƒ†ãƒŠã«æ ¼ç´
	modelDatas_[Key] = modeldata;
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
ModelData ModelManager::GetModelData(const std::string& directorPath) {
	assert(modelDatas_.contains(directorPath));
	return modelDatas_.at(directorPath);
}

///-------------------------------------------/// 
/// .mltãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
///-------------------------------------------///
MaterialData ModelManager::LoadMaterialTemplateFile(const std::string& directorPath, const std::string& filename) {
	/// ===å¿…è¦ãªå¤‰æ•°ã¨å®£è¨€ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã=== ///
	MaterialData materialData; // æ§‹ç¯‰ã™ã‚‹MaterialData
	std::string line; // ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã 1è¡Œã‚’æ ¼ç´ã™ã‚‹ã‚‚ã®
	std::ifstream file(directorPath + "/" + filename); // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	assert(file.is_open()); // ã¨ã‚Šã‚ãˆãšé–‹ã‘ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
	//materialData.textureFilePath = directorPath + "/" + filename; // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å…¥ã‚Œã‚‹

	/// ===ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿ã€MaterialDataã‚’æ§‹ç¯‰=== ///
	while (std::getline(file, line)) {
		std::string identifier;
		std::istringstream s(line);
		s >> identifier;

		// identifierã«å¿œã˜ãŸå‡¦ç†
		if (identifier == "map_Kd") {
			std::string textureFilename;
			s >> textureFilename;

			// é€£çµã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«ã™ã‚‹
			materialData.textureFilePath = directorPath + "/" + textureFilename;
		}
	}

	// MaterialDataã‚’è¿”ã™
	return materialData;
}

ModelData ModelManager::LoadObjFile(const std::string& directoryPath, const std::string& filename) {
	ModelData modelData; // æ§‹ç¯‰ã™ã‚‹ModelData

	/// ===Assimpã§objã‚’èª­ã‚€=== ///
	Assimp::Importer importer;
	std::string filePath = directoryPath + "/" + filename;
	const aiScene* scene = importer.ReadFile(filePath.c_str(), aiProcess_FlipWindingOrder | aiProcess_FlipUVs);
	assert(scene->HasMeshes()); // ãƒ¡ãƒƒã‚·ãƒ¥ãŒãªã„ã®ã¯å¯¾å¿œã—ãªã„ã€‚

	// ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹ã‚’å–å¾—ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ï¼‰
	std::string modelDirectory = directoryPath;
	size_t lastSlash = filename.find_last_of("/\\");
	if (lastSlash != std::string::npos) {modelDirectory = directoryPath + "/" + filename.substr(0, lastSlash);}

	/// ===meshã‚’è§£æ=== ///
	for (uint32_t meshIndex = 0; meshIndex < scene->mNumMeshes; ++meshIndex) {
		aiMesh* mesh = scene->mMeshes[meshIndex];
		assert(mesh->HasNormals()); // æ³•ç·šãŒãªã„Meshã¯ä»Šå›éå¯¾å¿œ
		assert(mesh->HasTextureCoords(0)); // TexcoordãŒãªã„Meshã¯ä»Šå›éå¯¾å¿œ
		modelData.vertices.resize(mesh->mNumVertices); // æœ€åˆã«é ‚ç‚¹æ•°åˆ†ã®ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã—ã¦ãŠã
		/// ===é ‚ç‚¹ã‚’è§£æã™ã‚‹=== ///
		for (uint32_t vertexIndex = 0; vertexIndex < mesh->mNumVertices; ++vertexIndex) {
			aiVector3D& position = mesh->mVertices[vertexIndex];
			aiVector3D& normal = mesh->mNormals[vertexIndex];
			aiVector3D& texcoord = mesh->mTextureCoords[0][vertexIndex];
			// å³æ‰‹ç³»->å·¦æ‰‹ç³»ã¸ã®å¤‰æ›ã‚’å¿˜ã‚Œãšã«
			modelData.vertices[vertexIndex].position = { -position.x, position.y, position.z, 1.0f };
			modelData.vertices[vertexIndex].normal = { -normal.x, normal.y, normal.z };
			modelData.vertices[vertexIndex].texcoord = { texcoord.x, texcoord.y };
		}
		/// ===Meshã®ä¸­èº«ï¼ˆfaceï¼‰ã‚’è§£æã™ã‚‹=== ///
		for (uint32_t faceIndex = 0; faceIndex < mesh->mNumFaces; ++faceIndex) {
			aiFace& face = mesh->mFaces[faceIndex];
			assert(face.mNumIndices == 3); // ä¸‰è§’å½¢ã®ã¿ã‚µãƒãƒ¼ãƒˆ
			/// ===Faceã®ä¸­èº«ï¼ˆindexï¼‰ã‚’è§£æã™ã‚‹=== ///
			for (uint32_t element = 0; element < face.mNumIndices; ++element) {
				uint32_t vertexIndex = face.mIndices[element];
				modelData.indices.push_back(vertexIndex);
			}
		}
		// BoneãŒã‚ã‚‹ã‹ã©ã†ã‹ã‚’ç¢ºèª
		if (mesh->HasBones()) {
			modelData.haveBone = true;
			/// ===Boneã®è§£æ=== ///
			for (uint32_t boneIndex = 0; boneIndex < mesh->mNumBones; ++boneIndex) {
				/// ===Jointã”ã¨ã®æ ¼ç´é ˜åŸŸã‚’ä½œæˆ=== ///
				aiBone* bone = mesh->mBones[boneIndex];
				std::string jointName = bone->mName.C_Str();
				jointWeightData& jointWeightData = modelData.skinClusterData[jointName];
				/// ===InverseBindPoseMatrixã®æŠ½å‡º=== ///
				aiMatrix4x4 bindPoseMatrixAssimp = bone->mOffsetMatrix.Inverse(); // BindPoseMatrixã«æˆ»ã™
				aiVector3D scale, translate;
				aiQuaternion rotate;
				bindPoseMatrixAssimp.Decompose(scale, rotate, translate); // æˆåˆ†ã‚’æŠ½å‡º
				// å·¦æ‰‹ç³»ã®BindPoseMatrixã‚’ä½œæˆ
				Matrix4x4 bindPoseMatrix = Math::MakeAffineQuaternionMatrix(
					{ scale.x, scale.y, scale.z }, { rotate.x, -rotate.y, -rotate.z, rotate.w }, { -translate.x, translate.y, translate.z });
				// InverseBindMatrixã«ã™ã‚‹
				jointWeightData.inverseBindPoseMatrix = Math::Inverse4x4(bindPoseMatrix);
				/// ===Weightæƒ…å ±ã‚’å–ã‚Šå‡ºã™=== ///
				for (uint32_t weightIndex = 0; weightIndex < bone->mNumWeights; ++weightIndex) {
					jointWeightData.vertexWeights.push_back({ bone->mWeights[weightIndex].mWeight, bone->mWeights[weightIndex].mVertexId });
				}
			}
		} else {
			modelData.haveBone = false;
		}
		/// ===materialã‚’è§£æã™ã‚‹=== ///
		for (uint32_t materialIndex = 0; materialIndex < scene->mNumMaterials; ++materialIndex) {
			aiMaterial* material = scene->mMaterials[materialIndex];
			if (material->GetTextureCount(aiTextureType_DIFFUSE) != 0) {
				aiString textureFilePath;
				material->GetTexture(aiTextureType_DIFFUSE, 0, &textureFilePath);
				// ãƒ¢ãƒ‡ãƒ«ã¨åŒã˜ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«ã‚ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒ‘ã‚¹ã‚’æ§‹ç¯‰
				modelData.material.textureFilePath = modelDirectory + "/" + textureFilePath.C_Str();
			}
		}
	}
	/// ===assimpã§Nodeã‚’è§£æã™ã‚‹=== ///
	modelData.rootNode = ReadNode(scene->mRootNode);
	// ModelDataã‚’è¿”ã™
	return modelData;
}

///-------------------------------------------/// 
/// æ§‹é€ ä½“Nodeã«å¤‰æ›ã™ã‚‹ãŸã‚ã®é–¢æ•°
///-------------------------------------------///
Node ModelManager::ReadNode(aiNode* node) {
	Node result;
	aiMatrix4x4 aiLocalMatrix = node->mTransformation; // nodeã®localMatrixã‚’å–å¾—
	aiVector3D scale;
	aiVector3D	translate;
	aiQuaternion rotate;
	aiLocalMatrix.Transpose(); // åˆ—ãƒ™ã‚¯ãƒˆãƒ«å½¢å¼ã‚’è¡Œãƒ™ã‚¯ãƒˆãƒ«å½¢å¼ã«è»¢ç½®
	std::memcpy(result.localMatrix.m, &aiLocalMatrix, sizeof(aiMatrix4x4)); // aiMatrix4x4 ã®ãƒ‡ãƒ¼ã‚¿ã‚’ result.localMatrix ã«ã‚³ãƒ”ãƒ¼ (memcpy ã‚’ä½¿ç”¨)
	node->mTransformation.Decompose(scale, rotate, translate); // assimpã®è¡Œåˆ—ã‹ã‚‰SRTã‚’æŠ½å‡ºã™ã‚‹é–¢æ•°ã‚’åˆ©ç”¨
	result.transform.scale = { scale.x, scale.y, scale.z }; // Scaleã¯ãã®ã¾ã¾
	result.transform.rotate = { rotate.x, -rotate.y, -rotate.z, rotate.w }; //ï½˜è»¸åè»¢ã€ã•ã‚‰ã«å›è»¢æ–¹å‘ãŒé€†ãªã®ã§è»¸ã‚’åè»¢ã•ã›ã‚‹
	result.transform.translate = { -translate.x, translate.y, translate.z }; // ï½˜è»¸ã‚’åè»¢
	result.localMatrix = Math::MakeAffineQuaternionMatrix(result.transform.scale, result.transform.rotate, result.transform.translate);
	result.name = node->mName.C_Str(); // Nodeåã‚’æ ¼ç´
	result.children.resize(node->mNumChildren); // å­ä¾›ã®æ•°ã ã‘ç¢ºä¿
	for (uint32_t childIndex = 0; childIndex < node->mNumChildren; ++childIndex) {
		// å†å¸°çš„ã«èª­ã‚“ã§éšå±¤æ§‹é€ ã‚’ä½œã£ã¦ã„ã
		result.children[childIndex] = ReadNode(node->mChildren[childIndex]);
	}
	return result;
}


============================================================
File Path: Project/Engine/System/Managers/ModelManager.h
============================================================
#pragma once
/// ===include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
#include "Engine/DataInfo/CData.h"
// DirectXTex
#include "DirectXTex.h"
// C++
#include <string>
#include <map>
// assimp
#include <assimp/Importer.hpp>
#include <assimp/scene.h>
#include <assimp/postprocess.h>

/// ===å‰æ–¹å®£è¨€=== ///
class TextureManager;

///=====================================================///  
/// ãƒ¢ãƒ‡ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£
///=====================================================///
class ModelManager {
public:/// ===åŸºæœ¬çš„ãªé–¢æ•°=== ///

	ModelManager() = default;
	~ModelManager();

public:/// ===Functions(é–¢æ•°)=== ///

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="texture">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ TextureManager ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Initialize(TextureManager* texture);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="Key">èª­ã¿è¾¼ã‚€ã‚¨ãƒ³ãƒˆãƒªã¾ãŸã¯ãƒªã‚½ãƒ¼ã‚¹ã‚’è­˜åˆ¥ã™ã‚‹ã‚­ãƒ¼ï¼ˆconst std::string&ï¼‰ã€‚</param>
	/// <param name="baseDirectoryPath">ãƒ•ã‚¡ã‚¤ãƒ«æ¢ç´¢ã®åŸºç‚¹ã¨ãªã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ï¼ˆconst std::string&ï¼‰ã€‚</param>
	/// <param name="filename">åŸºæº–ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªå†…ã§èª­ã¿è¾¼ã‚€ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ï¼ˆconst std::string&ï¼‰ã€‚</param>
	void Load(const std::string& Key, const std::string& baseDirectoryPath, const std::string& filename);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆconst std::string&ï¼‰ã€‚</param>
	/// <returns>èª­ã¿è¾¼ã¾ã‚ŒãŸãƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’å«ã‚€ ModelData ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚èª­ã¿è¾¼ã¿å¤±æ•—æ™‚ã®æŒ™å‹•ï¼ˆä¾‹: ä¾‹å¤–ã‚’æŠ•ã’ã‚‹ã€ç©ºã® ModelData ã‚’è¿”ã™ãªã©ï¼‰ã¯å®Ÿè£…ä¾å­˜ã§ã™ã€‚</returns>
	ModelData GetModelData(const std::string& filename);

private:/// ===Variables(å¤‰æ•°)=== ///

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒãƒ¼ã‚¸ãƒ£
	TextureManager* textureManager_ = nullptr;

	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	std::map<std::string, ModelData> modelDatas_;

private:/// ===Functions(é–¢æ•°)=== ///
	
	/// <summary>
	/// æŒ‡å®šã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€MaterialData ã‚’è¿”ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="directorPath">ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸ã®ãƒ‘ã‚¹ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åï¼‰ã€‚</param>
	/// <returns>èª­ã¿è¾¼ã¾ã‚ŒãŸãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆã«å¯¾å¿œã™ã‚‹ MaterialDataã€‚èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸå ´åˆã®å‹•ä½œï¼ˆä¾‹: ç©ºã® MaterialData ã‚’è¿”ã™ã€ä¾‹å¤–ã‚’æŠ•ã’ã‚‹ãªã©ï¼‰ã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚</returns>
	MaterialData LoadMaterialTemplateFile(const std::string& directorPath, const std::string& filename);

	/// <summary>
	/// æŒ‡å®šã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¨ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰Wavefront OBJãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ã€ModelDataã¨ã—ã¦è¿”ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="directoryPath">OBJãƒ•ã‚¡ã‚¤ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€OBJãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆæ‹¡å¼µå­ã‚’å«ã‚€ï¼‰ã€‚</param>
	/// <returns>èª­ã¿è¾¼ã¾ã‚ŒãŸãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã—ãŸModelDataã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚èª­ã¿è¾¼ã¿å¤±æ•—æ™‚ã®æŒ™å‹•ï¼ˆä¾‹ï¼šä¾‹å¤–ã‚’æŠ•ã’ã‚‹ã€ç©ºã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™ãªã©ï¼‰ã¯å®Ÿè£…ã«ã‚ˆã‚Šã¾ã™ã€‚</returns>
	ModelData LoadObjFile(const std::string& directoryPath, const std::string& filename);

	/// <summary>
	/// aiNode ãƒã‚¤ãƒ³ã‚¿ã‹ã‚‰ Node ã‚’èª­ã¿å–ã‚Šã€å¯¾å¿œã™ã‚‹ Node ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆã—ã¦è¿”ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="node">èª­ã¿å–ã‚‹ aiNode ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚é–¢æ•°ã¯ã“ã®ãƒãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’åŸºã« Node ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚</param>
	/// <returns>èª­ã¿å–ã‚‰ã‚ŒãŸãƒãƒ¼ãƒ‰ã‚’è¡¨ã™ Node ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</returns>
	Node ReadNode(aiNode* node);
};



============================================================
File Path: Project/Engine/System/Managers/ParticleManager.cpp
============================================================
#include "ParticleManager.h"
#include "Engine/System/Service/CameraService.h"
// c++
#include <fstream>
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ParticleManager::~ParticleManager() {
	definitions_.clear();
	activeParticles_.clear();
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®è¿½åŠ ï¼ˆJSONã‹ã‚‰ï¼‰
///-------------------------------------------///
void ParticleManager::LoadParticleDefinition(const std::string& jsonPath) {
	try {
		// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
		std::ifstream file(jsonPath);
		// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
		if (!file.is_open()) {
			assert(false && "Failed to open particle definition file");
			return;
		}

		// JSONã‚’ãƒ‘ãƒ¼ã‚¹
		nlohmann::json j;
		file >> j;
		file.close();

		// JSONã‹ã‚‰ParticleDefinitionã‚’ç”Ÿæˆ
		ParticleDefinition def = ParticleDefinition::FromJson(j);
		// ã™ã§ã«å®šç¾©ãŒå­˜åœ¨ã—ã¦ã„ãŸã‚‰return
		if (definitions_.find(def.name) != definitions_.end()) {
			return;
		}
		// å®šç¾©ã‚’è¿½åŠ 
		definitions_[def.name] = def;

	} catch (const std::exception& e) {
		// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ï¼ˆãƒ­ã‚°å‡ºåŠ›ãªã©ï¼‰
		assert(false && "Failed to parse particle definition JSON");
		e;
	}
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®è¿½åŠ ï¼ˆç›´æ¥æŒ‡å®šï¼‰
///-------------------------------------------///
void ParticleManager::AddParticleDefinition(const std::string& name, const ParticleDefinition& definition) {
	definitions_[name] = definition;
}

///-------------------------------------------/// 
/// ç™ºç”Ÿ
///-------------------------------------------///
ParticleGroup* ParticleManager::Emit(const std::string& name, const Vector3& translate) {
	// å®šç¾©ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
	auto it = definitions_.find(name);
	if (it == definitions_.end()) {
		return nullptr; // å®šç¾©ãŒè¦‹ã¤ã‹ã‚‰ãªã„
	}

	// æ–°ã—ã„ParticleGroupã‚’ä½œæˆ
	auto particleGroup = std::make_unique<ParticleGroup>();
	particleGroup->Initialze(translate, it->second);

	// ãƒã‚¤ãƒ³ã‚¿ã‚’ä¿å­˜ã—ã¦ã‹ã‚‰è¿”ã™
	ParticleGroup* ptr = particleGroup.get();
	activeParticles_.push_back(std::move(particleGroup));

	return ptr;
}

///-------------------------------------------/// 
/// å…¨ã¦ã®Particleã®æ›´æ–°
///-------------------------------------------///
void ParticleManager::Update() {
	// å®Œäº†ã—ãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
	activeParticles_.erase(
		std::remove_if(activeParticles_.begin(), activeParticles_.end(),
			[](const std::unique_ptr<ParticleGroup>& particle) {
				return particle->IsFinish();
			}),
		activeParticles_.end()
	);

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ›´æ–°
	for (auto& particle : activeParticles_) {
		particle->Update();
	}
}

///-------------------------------------------/// 
/// å…¨ã¦ã®Particleã®æç”»
///-------------------------------------------///
void ParticleManager::Draw(BlendMode mode) {
	for (auto& particle : activeParticles_) {
		particle->Draw(mode);
	}
}

///-------------------------------------------/// 
/// åœæ­¢å‡¦ç†
///-------------------------------------------///
void ParticleManager::StopParticle(const std::string& name) {
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‹ã‚‰è©²å½“ã™ã‚‹åå‰ã®ã‚‚ã®ã‚’å…¨ã¦åœæ­¢
	for (auto& particle : activeParticles_) {
		if (particle->GetDefinition().name == name) {
			particle->Stop();
		}
	}
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‰Šé™¤
///-------------------------------------------///
void ParticleManager::RemoveParticleDefinition(const std::string& name) {
	// å®šç¾©ã‹ã‚‰å‰Šé™¤
	definitions_.erase(name);

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‹ã‚‰ã‚‚è©²å½“ã™ã‚‹ã‚‚ã®ã‚’å‰Šé™¤
	activeParticles_.erase(
		std::remove_if(activeParticles_.begin(), activeParticles_.end(),
			[&name](const std::unique_ptr<ParticleGroup>& particle) {
				return particle->GetDefinition().name == name;
			}),
		activeParticles_.end()
	);
}

///-------------------------------------------/// 
/// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
///-------------------------------------------///
void ParticleManager::RemoveAllParticles() {
	activeParticles_.clear();
}

///-------------------------------------------/// 
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£è¨­å®š
///-------------------------------------------///
void ParticleManager::SetTexture(const std::string& name, const std::string& textureName) {
	// å®šç¾©ã‚’æ›´æ–°
	auto defIt = definitions_.find(name);
	if (defIt != definitions_.end()) {
		defIt->second.appearance.texturePath = textureName;
	}

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«ã‚‚é©ç”¨
	for (auto& particle : activeParticles_) {
		if (particle->GetDefinition().name == name) {
			particle->SetTexture(textureName);
		}
	}
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®šï¼ˆå‹å®‰å…¨ç‰ˆï¼‰
///-------------------------------------------///
void ParticleManager::SetParameter(const std::string& name, ParticleParameter param, float value) {
	// å®šç¾©ã‚’æ›´æ–°
	auto defIt = definitions_.find(name);
	if (defIt != definitions_.end()) {
		// å®šç¾©å†…ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆæ¬¡å›ç™ºç”Ÿæ™‚ã«åæ˜ ï¼‰
		switch (param) {
			// ç‰©ç†ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
		case ParticleParameter::Gravity:
			defIt->second.physics.gravity = value;
			break;
		case ParticleParameter::ExplosionRadiusX:
			defIt->second.physics.explosionRange.x = value;
			break;
		case ParticleParameter::ExplosionRadiusY:
			defIt->second.physics.explosionRange.y = value;
			break;
		case ParticleParameter::ExplosionRadiusZ:
			defIt->second.physics.explosionRange.z = value;
			break;
		case ParticleParameter::UpwardForce:
			defIt->second.physics.upwardForce = value;
			break;
		case ParticleParameter::AccelerationX:
			defIt->second.physics.acceleration.x = value;
			break;
		case ParticleParameter::AccelerationY:
			defIt->second.physics.acceleration.y = value;
			break;
		case ParticleParameter::AccelerationZ:
			defIt->second.physics.acceleration.z = value;
			break;

			// ç™ºç”Ÿãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
		case ParticleParameter::EmissionRate:
			defIt->second.emission.emissionRate = value;
			break;
		case ParticleParameter::Frequency:
			defIt->second.emission.frequency = value;
			break;
		case ParticleParameter::LifetimeMin:
			defIt->second.emission.lifetimeMin = value;
			break;
		case ParticleParameter::LifetimeMax:
			defIt->second.emission.lifetimeMax = value;
			break;
		case ParticleParameter::BurstCount:
			defIt->second.emission.burstCount = static_cast<uint32_t>(value);
			break;

			// è¦‹ãŸç›®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
		case ParticleParameter::StartColorR:
			defIt->second.appearance.startColor.x = value;
			break;
		case ParticleParameter::StartColorG:
			defIt->second.appearance.startColor.y = value;
			break;
		case ParticleParameter::StartColorB:
			defIt->second.appearance.startColor.z = value;
			break;
		case ParticleParameter::StartColorA:
			defIt->second.appearance.startColor.w = value;
			break;
		case ParticleParameter::EndColorR:
			defIt->second.appearance.endColor.x = value;
			break;
		case ParticleParameter::EndColorG:
			defIt->second.appearance.endColor.y = value;
			break;
		case ParticleParameter::EndColorB:
			defIt->second.appearance.endColor.z = value;
			break;
		case ParticleParameter::EndColorA:
			defIt->second.appearance.endColor.w = value;
			break;

			// å›è»¢ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
		case ParticleParameter::RotationSpeedX:
			defIt->second.rotation.rotationSpeedMin.x = value;
			break;
		case ParticleParameter::RotationSpeedY:
			defIt->second.rotation.rotationSpeedMin.y = value;
			break;
		case ParticleParameter::RotationSpeedZ:
			defIt->second.rotation.rotationSpeedMin.z = value;
			break;

			// é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
		case ParticleParameter::VelocityMinX:
			defIt->second.physics.velocityMin.x = value;
			break;
		case ParticleParameter::VelocityMinY:
			defIt->second.physics.velocityMin.y = value;
			break;
		case ParticleParameter::VelocityMinZ:
			defIt->second.physics.velocityMin.z = value;
			break;
		case ParticleParameter::VelocityMaxX:
			defIt->second.physics.velocityMax.x = value;
			break;
		case ParticleParameter::VelocityMaxY:
			defIt->second.physics.velocityMax.y = value;
			break;
		case ParticleParameter::VelocityMaxZ:
			defIt->second.physics.velocityMax.z = value;
			break;
		}
	}

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«ã‚‚é©ç”¨
	for (auto& particle : activeParticles_) {
		if (particle->GetDefinition().name == name) {
			particle->SetParameter(param, value);
		}
	}
}

///-------------------------------------------/// 
/// æƒ…å ±å–å¾—
///-------------------------------------------///
const ParticleDefinition* ParticleManager::GetDefinition(const std::string& name) const {
	auto it = definitions_.find(name);
	if (it != definitions_.end()) {
		return &it->second;
	}
	return nullptr;
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
///-------------------------------------------///
bool ParticleManager::HasDefinition(const std::string& name) const {
	return definitions_.find(name) != definitions_.end();
}

///-------------------------------------------/// 
/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’å–å¾—
///-------------------------------------------///
uint32_t ParticleManager::GetActiveParticleCount(const std::string& name) const {
	uint32_t totalCount = 0;

	// vectorã‚’ç·šå½¢æ¢ç´¢ã—ã¦è©²å½“ã™ã‚‹åå‰ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
	for (const auto& particle : activeParticles_) {
		if (particle && particle->GetDefinition().name == name) {
			totalCount += particle->GetActiveParticleCount();
		}
	}

	return totalCount;
}

///-------------------------------------------/// 
/// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®ä¸€è¦§ã‚’å–å¾—
///-------------------------------------------///
std::vector<std::string> ParticleManager::GetDefinitionNames() const {
	std::vector<std::string> names;
	names.reserve(definitions_.size());

	for (const auto& [name, def] : definitions_) {
		names.push_back(name);
	}

	return names;
}

///-------------------------------------------/// 
/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—æ•°ã‚’å–å¾—
///-------------------------------------------///
size_t ParticleManager::GetActiveGroupCount(const std::string& name) const {
	size_t count = 0;

	// vectorã‚’ç·šå½¢æ¢ç´¢ã—ã¦è©²å½“ã™ã‚‹åå‰ã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
	for (const auto& particle : activeParticles_) {
		if (particle && particle->GetDefinition().name == name) {
			++count;
		}
	}

	return count;
}

============================================================
File Path: Project/Engine/System/Managers/ParticleManager.h
============================================================
#pragma once
/// ===include=== ///
// ParticleGroup
#include "Engine/Graphics/Particle/ParticleGroup.h"
#include "Engine/Graphics/Particle/ParticleDefinition.h"
#include "Engine/Graphics/Particle/ParticleParameter.h"
// c++
#include <map>
#include <memory>
#include <string>
#include <vector>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// ParticleManager
///=====================================================///
class ParticleManager {
public:
	ParticleManager() = default;
	~ParticleManager();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®è¿½åŠ ï¼ˆJSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ï¼‰
	/// </summary>
	/// <param name="jsonPath">JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <returns>èª­ã¿è¾¼ã¿ã«æˆåŠŸã—ãŸã‹ã©ã†ã‹</returns>
	void LoadParticleDefinition(const std::string& jsonPath);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®è¿½åŠ ï¼ˆç›´æ¥æŒ‡å®šï¼‰
	/// </summary>
	/// <param name="name">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="definition">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©</param>
	void AddParticleDefinition(const std::string& name, const ParticleDefinition& definition);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿå‡¦ç†
	/// </summary>
	/// <param name="name">ç™ºç”Ÿã•ã›ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="translate">ç™ºç”Ÿã•ã›ã‚‹å ´æ‰€</param>
	/// <returns>ç”Ÿæˆã•ã‚ŒãŸParticleGroupã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆnullptrã®å ´åˆã¯å¤±æ•—ï¼‰</returns>
	ParticleGroup* Emit(const std::string& name, const Vector3& translate);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å…¨ä½“ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å…¨ä½“ã®æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰</param>
	void Draw(BlendMode mode = BlendMode::kBlendModeAdd);

	/// <summary>
	/// æŒ‡å®šã—ãŸåå‰ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ã™ã¹ã¦åœæ­¢
	/// </summary>
	/// <param name="name">åœæ­¢ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	void StopParticle(const std::string& name);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®å‰Šé™¤
	/// </summary>
	/// <param name="name">å‰Šé™¤ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	void RemoveParticleDefinition(const std::string& name);

	/// <summary>
	/// ã™ã¹ã¦ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’åœæ­¢
	/// </summary>
	void RemoveAllParticles();

public: /// ===è¨­å®š=== ///

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®š
	/// </summary>
	/// <param name="name">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®šã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="textureName">è¨­å®šã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®åå‰</param>
	void SetTexture(const std::string& name, const std::string& textureName);

	/// <summary>
	/// å®Ÿè¡Œæ™‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´ï¼ˆå‹å®‰å…¨ç‰ˆï¼‰
	/// </summary>
	/// <param name="name">å¯¾è±¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="param">å¤‰æ›´ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</param>
	/// <param name="value">è¨­å®šã™ã‚‹å€¤</param>
	void SetParameter(const std::string& name, ParticleParameter param, float value);

public: /// ===æƒ…å ±å–å¾—=== ///

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã‚’å–å¾—
	/// </summary>
	/// <param name="name">å–å¾—ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <returns>ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯nullptrï¼‰</returns>
	const ParticleDefinition* GetDefinition(const std::string& name) const;

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
	/// </summary>
	/// <param name="name">ç¢ºèªã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <returns>ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯true</returns>
	bool HasDefinition(const std::string& name) const;

	/// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’å–å¾—
	/// </summary>
	/// <param name="name">å¯¾è±¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç·æ•°</returns>
	uint32_t GetActiveParticleCount(const std::string& name) const;

	/// <summary>
	/// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®ä¸€è¦§ã‚’å–å¾—
	/// </summary>
	/// <returns>å®šç¾©åã®ãƒªã‚¹ãƒˆ</returns>
	std::vector<std::string> GetDefinitionNames() const;

	/// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—æ•°ã‚’å–å¾—
	/// </summary>
	/// <param name="name">å¯¾è±¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚°ãƒ«ãƒ¼ãƒ—æ•°</returns>
	size_t GetActiveGroupCount(const std::string& name) const;

private:
	// å®šç¾©ãƒ™ãƒ¼ã‚¹
	std::map<std::string, ParticleDefinition> definitions_;

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	std::vector<std::unique_ptr<ParticleGroup>> activeParticles_;
};

============================================================
File Path: Project/Engine/System/Managers/PiplineManager.cpp
============================================================
#include "PiplineManager.h"

#include <cassert>

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
PipelineManager::PipelineManager() = default;
PipelineManager::~PipelineManager() { 
	graphicsPipelines_.clear();
	computePipelines_.clear();
	compiler_.clear();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void PipelineManager::Initialize(DXCommon* dxCommon) {
	for (PipelineType type : AllPipelineTypes()) {

		// Compilerã®ä½œæˆã¨åˆæœŸåŒ–
		auto compiler = std::make_unique<Compiler>();
		compiler->Initialize(dxCommon, type);
		compiler_[type] = std::move(compiler);

		// Computeãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä½œæˆ
		if (IsComputePipeline(type)) {
			auto CSPipeline = std::make_unique<CSPSOCommon>();
			CSPipeline->Create(dxCommon, compiler_[type].get(), type);
			// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¿½åŠ 
			computePipelines_[type] = std::move(CSPipeline);
		} else {
			// BlendModeæ¯ã«ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’ä½œæˆ
			for (BlendMode mode : AllBlendModes()) {

				// ãƒšã‚¢ã®ã‚­ãƒ¼ã‚’ï½“ä½œæˆ
				auto key = std::make_pair(type, mode);

				// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä½œæˆ
				auto GSPipeline = std::make_unique<GSPSOCommon>();
				GSPipeline->Create(dxCommon, compiler_[type].get(), type, mode);

				// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¿½åŠ 
				graphicsPipelines_[key] = std::move(GSPipeline);
			}
		}
	}
}

///-------------------------------------------/// 
/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç™»éŒ²
///-------------------------------------------///
void PipelineManager::SetPipeline(ID3D12GraphicsCommandList * commandList, PipelineType type, BlendMode mode, D3D12_PRIMITIVE_TOPOLOGY topology) {
	
	// Computeãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å ´åˆ
	if (IsComputePipeline(type)) {
		CSPSOCommon* CSPipeline = GetCSPipeline(type);
		assert(CSPipeline != nullptr);
		// PSO ã‚’è¨­å®š
		CSPipeline->SetPSO(commandList);
	} else {
		// Graphicsãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å–å¾—
		GSPSOCommon* GSPipeline = GetGSPipeline(type, mode);
		assert(GSPipeline != nullptr);

		// PSO ã‚’è¨­å®š
		GSPipeline->SetPSO(commandList);

		//ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ãƒ¼è¨­å®š
		commandList->IASetPrimitiveTopology(topology);
	}
}


///-------------------------------------------/// 
/// ã‚¿ã‚¤ãƒ—ã¨ãƒ¢ãƒ¼ãƒ‰ã‚’å–å¾—
///-------------------------------------------///
GSPSOCommon* PipelineManager::GetGSPipeline(PipelineType type, BlendMode mode) {
	auto key = std::make_pair(type, mode);
	auto it = graphicsPipelines_.find(key);
	if (it != graphicsPipelines_.end()) {
		return it->second.get();
	}
	return nullptr;
}

///-------------------------------------------/// 
/// CSãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®å–å¾—
///-------------------------------------------///
CSPSOCommon* PipelineManager::GetCSPipeline(PipelineType type) {
	auto it = computePipelines_.find(type);
	if (it != computePipelines_.end()) {
		return it->second.get();
	}
	return nullptr;
}


============================================================
File Path: Project/Engine/System/Managers/PiplineManager.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/DataInfo/PipelineStateObjectType.h"
#include "Engine/Graphics/Pipeline/GS/GSPSOCommon.h"
#include "Engine/Graphics/Pipeline/CS/CSPSOCommon.h"
#include "Engine/Graphics/Pipeline/Compiler.h"
// c++
#include <unordered_map>
#include <memory>
#include <utility> // std::pair
#include <functional> // std::hash

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;

///-------------------------------------------/// 
/// std::pair ç”¨ã®ãƒãƒƒã‚·ãƒ¥é–¢æ•°ã‚’ç‰¹æ®ŠåŒ–
///-------------------------------------------///
namespace std {
    template <>
    struct hash<std::pair<PipelineType, BlendMode>> {
        size_t operator()(const std::pair<PipelineType, BlendMode>& p) const noexcept {
            size_t h1 = std::hash<int>()(static_cast<int>(p.first));   // PipelineType ã®ãƒãƒƒã‚·ãƒ¥å€¤
            size_t h2 = std::hash<int>()(static_cast<int>(p.second)); // BlendMode ã®ãƒãƒƒã‚·ãƒ¥å€¤
            return h1 ^ (h2 << 1); // ãƒãƒƒã‚·ãƒ¥å€¤ã‚’çµ„ã¿åˆã‚ã›ã‚‹ï¼ˆXOR ã¨ã‚·ãƒ•ãƒˆï¼‰
        }
    };
}

///=====================================================/// 
/// PipeLineManager
///=====================================================///
class PipelineManager {
public:
    
    PipelineManager();
    ~PipelineManager();

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    /// <param name="dxCommon">åˆæœŸåŒ–ã™ã‚‹ DXCommon ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    void Initialize(DXCommon* dxCommon);
    
    /// <summary>
    /// PSOï¼ˆPipelineStateObjectï¼‰ã®è¨­å®šå‡¦ç†
    /// </summary>
    /// <param name="commandList">ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ID3D12GraphicsCommandListã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚è¨­å®šã¯ã“ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«é©ç”¨ã•ã‚Œã¾ã™ã€‚</param>
    /// <param name="type">ä½¿ç”¨ã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™PipelineTypeï¼ˆä¾‹: ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆãªã©ï¼‰ã€‚</param>
    /// <param name="mode">ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æ™‚ã®ãƒ–ãƒ¬ãƒ³ãƒ‰å‹•ä½œã‚’æŒ‡å®šã™ã‚‹BlendModeã€‚</param>
    /// <param name="topology">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã®ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’ç¤ºã™D3D12_PRIMITIVE_TOPOLOGYå€¤ã€‚</param>
    void SetPipeline(ID3D12GraphicsCommandList* commandList, PipelineType type, BlendMode mode, D3D12_PRIMITIVE_TOPOLOGY topology);

private:/// ===å¤‰æ•°=== ///
    /// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç®¡ç†
	// Graphicsãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
    std::unordered_map<std::pair<PipelineType, BlendMode>, std::unique_ptr<GSPSOCommon>> graphicsPipelines_;
	// Computeãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
    std::unordered_map<PipelineType, std::unique_ptr<CSPSOCommon>> computePipelines_;
	// Compilerã®ç®¡ç†
    std::unordered_map<PipelineType, std::unique_ptr<Compiler>> compiler_;

private:/// ===é–¢æ•°=== ///
    /// <summary>
    /// æŒ‡å®šã•ã‚ŒãŸ PipelineType ã¨ BlendMode ã«åŸºã¥ã„ã¦ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’å–å¾—
    /// </summary>
    /// <param name="type">å–å¾—ã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™å€¤ã€‚</param>
    /// <param name="mode">é©ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’ç¤ºã™å€¤ã€‚</param>
    /// <returns>è¦æ±‚ã—ãŸãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³çŠ¶æ…‹ã‚’è¡¨ã™ GSPSOCommon ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</returns>
    GSPSOCommon* GetGSPipeline(PipelineType type, BlendMode mode);

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸç¨®é¡ã® CSPSOCommon ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="type">å–å¾—ã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™ PipelineType ã®å€¤ã€‚</param>
	/// <returns>æŒ‡å®šã•ã‚ŒãŸç¨®é¡ã«å¯¾å¿œã™ã‚‹ CSPSOCommon ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è©²å½“ã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ nullptr ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	CSPSOCommon* GetCSPipeline(PipelineType type);
};

============================================================
File Path: Project/Engine/System/Managers/RTVManager.cpp
============================================================
#include "RTVManager.h"
// Engine
#include "Engine/Core/DXCommon.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
RTVManager::~RTVManager() {
	descriptorHeap_.Reset();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// Heap
ID3D12DescriptorHeap* RTVManager::GetDescriptorHeap() const { return descriptorHeap_.Get(); }
// CPU
D3D12_CPU_DESCRIPTOR_HANDLE RTVManager::GetCPUDescriptorHandle(uint32_t index) const {
	D3D12_CPU_DESCRIPTOR_HANDLE handle = descriptorHeap_->GetCPUDescriptorHandleForHeapStart();
	handle.ptr += index * descriptorSize_;
	return handle;
}
// GPU
D3D12_GPU_DESCRIPTOR_HANDLE RTVManager::GetGPUDescriptorHandle(uint32_t index) const {
	D3D12_GPU_DESCRIPTOR_HANDLE handle = descriptorHeap_->GetGPUDescriptorHandleForHeapStart();
	handle.ptr += index * descriptorSize_;
	return handle;
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void RTVManager::Initialize(DXCommon* dxcommon) {
	dxcommon_ = dxcommon;
	// RTVã®ç”Ÿæˆ(ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼)
	descriptorHeap_ = dxcommon_->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, kMaxRTVCount_, false); // ã“ã®é–¢æ•°ã¯å¤‰æ›´
	descriptorSize_ = dxcommon_->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
}

///-------------------------------------------/// 
/// ä½œæˆ
///-------------------------------------------///
void RTVManager::CreateRenderTargetView(uint32_t index, ID3D12Resource* resource, const D3D12_RENDER_TARGET_VIEW_DESC& desc) {
	assert(index < kMaxRTVCount_);
	// ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	D3D12_CPU_DESCRIPTOR_HANDLE handle = GetCPUDescriptorHandle(index);

	// RTVã®ç”Ÿæˆ
	dxcommon_->GetDevice()->CreateRenderTargetView(resource, &desc, GetCPUDescriptorHandle(index));

	// ãƒãƒ³ãƒ‰ãƒ«ã‚’è¨˜éŒ²ï¼ˆClearRenderTargetViewã§ä½¿ã†ãŸã‚ï¼‰
	descriptorHandles_[index] = handle;
}

///-------------------------------------------/// 
/// ã‚¯ãƒªã‚¢
///-------------------------------------------///
void RTVManager::ClearRenderTargetView(ID3D12GraphicsCommandList* commandList, uint32_t index, const float color[4]) {
	// RTVã‚’ã‚¯ãƒªã‚¢
	commandList->ClearRenderTargetView(descriptorHandles_[index], color, 0, nullptr);
}

///-------------------------------------------/// 
/// ç¢ºä¿é–¢æ•°
///-------------------------------------------///
uint32_t RTVManager::Allocate() {
	/// ===ä¸Šé™ã«é”ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦assert=== ///
	assert(AssertAllocate());
	// return ã™ã‚‹ç•ªå·ã‚’ã„ã£ãŸã‚“è¨˜éŒ²ã—ã¦ãŠã
	int index = useIndex_;
	// æ¬¡å›ã®ãŸã‚ã«ç•ªå·ã‚’1é€²ã‚ã‚‹
	useIndex_++;
	// ä¸Šã§è¨˜éŒ²ã—ãŸç•ªå·ã‚’return(0ç•ªã¯ImGuiã ã‹ã‚‰+1)
	return index;
}
bool RTVManager::AssertAllocate() const { return useIndex_ < kMaxRTVCount_; }

///-------------------------------------------/// 
/// ä½œæˆ
///-------------------------------------------///
void RTVManager::CreateSwapChainRenderTargetView() {
	D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
	rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;

	// ã¾ãš1ã¤ç›®ã‚’ä½œã‚‹ã€‚1ã¤ç›®ã¯æœ€åˆã®ã¨ã“ã‚ã«ä½œã‚‹ã€‚ä½œã‚‹å ´æ‰€ã‚’ã‚³ãƒªã‚‰ã§æŒ‡å®šã—ã¦ã‚ã’ã‚‹å¿…è¦ãŒã‚ã‚‹
	descriptorHandles_[0] = dxcommon_->GetCPUDescriptorHandle(descriptorHeap_.Get(), descriptorSize_, 0);
	CreateRenderTargetView(0, dxcommon_->GetSwapChainResource(0), rtvDesc);

	//2ã¤ç›®ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å¾—ã‚‹
	descriptorHandles_[1].ptr = descriptorHandles_[0].ptr + dxcommon_->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
	//2ã¤ç›®ã‚’ä½œã‚‹
	CreateRenderTargetView(1, dxcommon_->GetSwapChainResource(1), rtvDesc);

	useIndex_ = 2;
}





============================================================
File Path: Project/Engine/System/Managers/RTVManager.h
============================================================
#pragma once
/// ===Include=== ///
// DirectX
#include <d3d12.h>
// c++
#include <cstdint>
#include <cassert>
// Engine
#include "Engine/Core/ComPtr.h"

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;

///=====================================================/// 
/// RTVManager
///=====================================================///
class RTVManager {
public:

	RTVManager() = default;
	~RTVManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxcommon">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ DXCommon ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã‚’æ¸¡ã—ãŸå ´åˆã®å‹•ä½œã¯å‘¼ã³å‡ºã—å´ã§ç¢ºèªã—ã¦ãã ã•ã„ã€‚</param>
	void Initialize(DXCommon* dxcommon);

	/// <summary>
	/// RTVï¼ˆRenderTargetViewï¼‰ã®ä½œæˆ
	/// </summary>
	/// <param name="index">ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚¹ãƒ­ãƒƒãƒˆã¾ãŸã¯ä½ç½®ã‚’ç¤ºã™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</param>
	/// <param name="resource">ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ä½¿ç”¨ã™ã‚‹ ID3D12Resource ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚nullptr ã§ã‚ã£ã¦ã¯ãªã‚Šã¾ã›ã‚“ã€‚</param>
	/// <param name="desc">ãƒ“ãƒ¥ãƒ¼ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€ãƒŸãƒƒãƒ—ã‚¹ãƒ©ã‚¤ã‚¹ã€é…åˆ—ã‚¹ãƒ©ã‚¤ã‚¹ãªã©ã‚’æŒ‡å®šã™ã‚‹ D3D12_RENDER_TARGET_VIEW_DESC æ§‹é€ ä½“ã€‚</param>
	void CreateRenderTargetView(uint32_t index, ID3D12Resource* resource, const D3D12_RENDER_TARGET_VIEW_DESC& desc);

	/// <summary>
	/// RTVï¼ˆRenderTargetViewï¼‰ã®ã‚¯ãƒªã‚¢
	/// </summary>
	/// <param name="commandList">ã‚¯ãƒªã‚¢æ“ä½œã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="index">ã‚¯ãƒªã‚¢ã™ã‚‹ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆã‚¹ãƒ­ãƒƒãƒˆç•ªå·ï¼‰ã€‚</param>
	/// <param name="color">RGBA é †ã® 4 è¦ç´ é…åˆ—ã§æŒ‡å®šã™ã‚‹ã‚¯ãƒªã‚¢è‰²ã€‚å„è¦ç´ ã¯é€šå¸¸ 0.0 ã‹ã‚‰ 1.0 ã®æµ®å‹•å°æ•°ç‚¹å€¤ã§ã™ã€‚</param>
	void ClearRenderTargetView(ID3D12GraphicsCommandList* commandList, uint32_t index, const float color[4]);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å‰²ã‚Šå½“ã¦ã‚’è¡Œã„ã€å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸè­˜åˆ¥å­ã‚’è¿”ã™
	/// </summary>
	/// <returns>å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã®è­˜åˆ¥å­ã‚’è¡¨ã™ 32 ãƒ“ãƒƒãƒˆç¬¦å·ãªã—æ•´æ•° (uint32_t)ã€‚</returns>
	uint32_t Allocate();

	/// <summary>
	/// ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ã®æˆå¦ã‚’æ¤œè¨¼
	/// </summary>
	/// <returns>ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool AssertAllocate() const;

	/// <summary>
	/// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ç”¨ã®ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ä½œæˆ
	/// </summary>
	void CreateSwapChainRenderTargetView();

public: /// ===Getter=== ///
	// Heap
	ID3D12DescriptorHeap* GetDescriptorHeap() const;
	// CPU
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(uint32_t index) const;
	// GPU
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(uint32_t index) const;

public:/// ===å®šæ•°=== ///

	// RTVã®æ•°
	static const uint32_t kMaxRTVCount_ = 16;

private:
	// DXCommon
	DXCommon* dxcommon_ = nullptr;
	// ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descriptorHeap_;
	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«
	D3D12_CPU_DESCRIPTOR_HANDLE descriptorHandles_[kMaxRTVCount_];
	// ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize_ = 0;
	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t useIndex_ = 0;
};



============================================================
File Path: Project/Engine/System/Managers/SRVManager.cpp
============================================================
#include "SRVManager.h"
// Engine
#include "Engine/Core/DXCommon.h"

const uint32_t SRVManager::kMaxSRVCount_ = 512;

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
SRVManager::~SRVManager() {}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void SRVManager::SetGraphicsRootDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex) {
	dXCommon_->GetCommandList()->SetGraphicsRootDescriptorTable(RootParameterIndex, GetGPUDescriptorHandle(srvIndex));
}


///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// DescriptorHeap
ID3D12DescriptorHeap* SRVManager::GetDescriptorHeap() const { return descriptorHeap_.Get(); }
// CPUHandle
D3D12_CPU_DESCRIPTOR_HANDLE SRVManager::GetCPUDescriptorHandle(uint32_t index) {
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap_->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize_ * index);
	return handleCPU;
}
// GPUHandle
D3D12_GPU_DESCRIPTOR_HANDLE SRVManager::GetGPUDescriptorHandle(uint32_t index) {
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap_->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize_ * index);
	return handleGPU;
}


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void SRVManager::Initialize(DXCommon* dxcommon) {

	// å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	dXCommon_ = dxcommon;

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	descriptorHeap_ = dXCommon_->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount_, true);

	// ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿1å€‹åˆ†ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã—ã¦è¨˜éŒ²
	descriptorSize_ = dXCommon_->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}


///-------------------------------------------/// 
/// æç”»å‰å‡¦ç†
///-------------------------------------------///
void SRVManager::PreDraw() {

	// æç”»ç”¨ã®DescriptorHeapã®è¨­å®š
	ID3D12DescriptorHeap* descriptorHeaps[] = { descriptorHeap_.Get() };
	dXCommon_->GetCommandList()->SetDescriptorHeaps(1, descriptorHeaps);
}

///-------------------------------------------/// 
/// SRVã®ä½œæˆ
///-------------------------------------------///
void SRVManager::CreateShaderResourceView(uint32_t srvIndex, ID3D12Resource* pResource, D3D12_SHADER_RESOURCE_VIEW_DESC desc) {
	dXCommon_->GetDevice()->CreateShaderResourceView(pResource, &desc, GetCPUDescriptorHandle(srvIndex));
}


///-------------------------------------------/// 
/// ç¢ºä¿é–¢æ•°
///-------------------------------------------///
uint32_t SRVManager::Allocate() {
	// è§£æ”¾ã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãŒã‚ã‚Œã°å†åˆ©ç”¨
	if (!freeIndices_.empty()) {
		uint32_t index = freeIndices_.back();
		freeIndices_.pop_back();
		return index;
	}

	/// ===ä¸Šé™ã«é”ã—ã¦ã„ãªã„ã‹ãƒã‚§ãƒƒã‚¯ã—ã¦assert=== ///
	assert(AssertAllocate());
	// return ã™ã‚‹ç•ªå·ã‚’ã„ã£ãŸã‚“è¨˜éŒ²ã—ã¦ãŠã
	int index = useIndex_;
	// æ¬¡å›ã®ãŸã‚ã«ç•ªå·ã‚’1é€²ã‚ã‚‹
	useIndex_++;
	// ä¸Šã§è¨˜éŒ²ã—ãŸç•ªå·ã‚’return(0ç•ªã¯ImGuiã ã‹ã‚‰+1)
	return index + 1;
}

///-------------------------------------------/// 
/// è§£æ”¾é–¢æ•°
///-------------------------------------------///
void SRVManager::Free(uint32_t srvIndex) {
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹0ã¯ImGuiç”¨ãªã®ã§è§£æ”¾ã—ãªã„
	if (srvIndex == 0) {
		return;
	}

	// è§£æ”¾ã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒ—ãƒ¼ãƒ«ã«è¿½åŠ 
	freeIndices_.push_back(srvIndex);
}
// ä¸Šé™ãƒãƒ£ãƒƒã‚¯
bool SRVManager::AssertAllocate() const  { return useIndex_ < kMaxSRVCount_; }


///-------------------------------------------/// 
/// SRVç”Ÿæˆï¼ˆï¼‰
///-------------------------------------------///
// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨
void SRVManager::CreateSRVForTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels) {

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D; // 2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
	srvDesc.Texture2D.MipLevels = MipLevels;

	// SRVã‚’ä½œæˆ
	CreateShaderResourceView(srvIndex, pResource, srvDesc);
}
// CubMapç”¨
void SRVManager::CreateSRVForCubeMap(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels) {

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = Format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
	srvDesc.TextureCube.MipLevels = MipLevels;
	srvDesc.TextureCube.MostDetailedMip = 0; // unionãŒTextureCubeã«ãªã£ãŸãŒã€å†…éƒ¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ„å‘³ã¯Texture2Dã¨å¤‰ã‚ã‚‰ãªã„
	srvDesc.TextureCube.ResourceMinLODClamp = 0.0f;

	// SRVã‚’ä½œæˆ
	CreateShaderResourceView(srvIndex, pResource, srvDesc);
}
// Struct Bufferç”¨
void SRVManager::CreateSRVForStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStride) {

	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;  // ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	srvDesc.Format = DXGI_FORMAT_UNKNOWN;  // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ãªã—
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Buffer.NumElements = numElements;
	srvDesc.Buffer.StructureByteStride = structureByteStride;
	srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

	// SRVã‚’ä½œæˆ
	CreateShaderResourceView(srvIndex, pResource, srvDesc);
}

============================================================
File Path: Project/Engine/System/Managers/SRVManager.h
============================================================
#pragma once
/// ===Include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
// DirectX
#include <d3d12.h>
// c++
#include <cstdint>
#include <cassert>
#include <vector>

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;

///=====================================================/// 
/// SRVManager
///=====================================================///
class SRVManager {
public:

	SRVManager() = default;
	~SRVManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxcommon">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ DXCommon ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚æœ‰åŠ¹ãªãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’æ¸¡ã—ã¦ãã ã•ã„ã€‚</param>
	void Initialize(DXCommon* dxcommon);

	/// <summary>
	/// æç”»å‡¦ç†ã®å‰ã«å®Ÿè¡Œã•ã‚Œã‚‹æº–å‚™å‡¦ç†ã‚’è¡Œã†é–¢æ•°
	/// </summary>
	void PreDraw();

	/// <summary>
	/// SRVï¼ˆã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ï¼‰ã®ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="srvIndex">ä½œæˆã™ã‚‹SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚„SRVã‚¹ãƒ­ãƒƒãƒˆå†…ã®ä½ç½®ï¼‰ã€‚</param>
	/// <param name="pResource">SRVãŒå‚ç…§ã™ã‚‹ID3D12Resourceã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚ãƒ“ãƒ¥ãƒ¼ã®å¯¾è±¡ã¨ãªã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="desc">ãƒ“ãƒ¥ãƒ¼ã®è©³ç´°ã‚’æŒ‡å®šã™ã‚‹D3D12_SHADER_RESOURCE_VIEW_DESCæ§‹é€ ä½“ï¼ˆãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€ãƒŸãƒƒãƒ—ç¯„å›²ã€ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¤ãƒ—ãªã©ï¼‰ã€‚</param>
	void CreateShaderResourceView(uint32_t srvIndex, ID3D12Resource* pResource, D3D12_SHADER_RESOURCE_VIEW_DESC desc);

	/// <summary>
	/// ãƒªã‚½ãƒ¼ã‚¹ã®å‰²ã‚Šå½“ã¦ã‚’è¡Œã„ã€å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸè­˜åˆ¥å­ã‚’è¿”ã™
	/// </summary>
	/// <returns>å‰²ã‚Šå½“ã¦ã‚‰ã‚ŒãŸãƒªã‚½ãƒ¼ã‚¹ã®è­˜åˆ¥å­ã‚’è¡¨ã™ 32 ãƒ“ãƒƒãƒˆç¬¦å·ãªã—æ•´æ•° (uint32_t)ã€‚</returns>
	uint32_t Allocate();

	/// <summary>
	/// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è§£æ”¾ã—ã¦å†åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
	/// </summary>
	/// <param name="srvIndex">è§£æ”¾ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	void Free(uint32_t srvIndex);

	/// <summary>
	/// ãƒ¡ãƒ¢ãƒªå‰²ã‚Šå½“ã¦ã®æˆå¦ã‚’æ¤œè¨¼
	/// </summary>
	/// <returns>ã‚¢ãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãŒæˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	bool AssertAllocate() const;

	/// <summary>
	/// 2D ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ã® SRVï¼ˆShader Resource Viewï¼‰ã‚’ä½œæˆ
	/// </summary>
	/// <param name="srvIndex">SRV ã‚’ä½œæˆã™ã‚‹ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚¹ãƒ­ãƒƒãƒˆã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</param>
	/// <param name="pResource">SRV ã‚’ä½œæˆã™ã‚‹å¯¾è±¡ã® ID3D12Resource ã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆ2D ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ï¼‰ã€‚</param>
	/// <param name="Format">SRV ã«ä½¿ç”¨ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ (DXGI_FORMAT)ã€‚</param>
	/// <param name="MipLevels">ä½¿ç”¨ã™ã‚‹ãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®æ•°ã€‚</param>
	void CreateSRVForTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels);

	/// <summary>
	/// æŒ‡å®šã—ãŸ D3D12 ãƒªã‚½ãƒ¼ã‚¹ã«å¯¾ã—ã¦ã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—ç”¨ã® Shader Resource View (SRV) ã‚’ä½œæˆ
	/// </summary>
	/// <param name="srvIndex">SRV ã‚’ä½œæˆã™ã‚‹è¨˜è¿°å­ãƒ’ãƒ¼ãƒ—å†…ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆé…ç½®å…ˆï¼‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="pResource">ã‚­ãƒ¥ãƒ¼ãƒ–ãƒãƒƒãƒ—ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¡¨ã™ ID3D12Resource* ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚SRV ã‚’ä½œæˆã™ã‚‹å…ƒã®ãƒªã‚½ãƒ¼ã‚¹ã§ã™ã€‚</param>
	/// <param name="Format">SRV ã«ä½¿ç”¨ã™ã‚‹ãƒ”ã‚¯ã‚»ãƒ«ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ (DXGI_FORMAT)ã€‚ãƒ“ãƒ¥ãƒ¼ã§ãƒªã‚½ãƒ¼ã‚¹ã‚’è§£é‡ˆã™ã‚‹ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="MipLevels">SRV ã«å«ã‚ã‚‹ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®æ•°ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void CreateSRVForCubeMap(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels);

	/// <summary>
	/// æ§‹é€ åŒ–ãƒãƒƒãƒ•ã‚¡ï¼ˆstructured bufferï¼‰ç”¨ã® Shader Resource View (SRV) ã‚’ä½œæˆ
	/// </summary>
	/// <param name="srvIndex">SRV ã‚’æ ¼ç´ã™ã‚‹ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—å†…ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆã¾ãŸã¯é…ç½®å…ˆã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ä½ç½®ï¼‰ã€‚</param>
	/// <param name="pResource">SRV ã‚’ä½œæˆã™ã‚‹å¯¾è±¡ã® ID3D12Resource ã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆæ§‹é€ åŒ–ãƒãƒƒãƒ•ã‚¡ã‚’æŒ‡ã™ï¼‰ã€‚</param>
	/// <param name="numElements">ãƒãƒƒãƒ•ã‚¡å†…ã®è¦ç´ ï¼ˆæ§‹é€ ä½“ï¼‰ã®æ•°ã€‚</param>
	/// <param name="structureByteStride">å„è¦ç´ ï¼ˆæ§‹é€ ä½“ï¼‰ã®ãƒã‚¤ãƒˆå˜ä½ã®ã‚µã‚¤ã‚ºï¼ˆã‚¹ãƒˆãƒ©ã‚¤ãƒ‰ï¼‰ã€‚</param>
	void CreateSRVForStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStride);

public:/// ===Setter=== ///

	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é–‹å§‹ç•ªå·ã®è¨­å®š
	void SetGraphicsRootDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex);

public:/// ===Getter=== ///
	// Heap
	ID3D12DescriptorHeap* GetDescriptorHeap() const;
	// CPU
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(uint32_t index);
	// GPU
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(uint32_t index);

public:/// ===å®šæ•°=== ///

	// æœ€å¤§SRVæ•°ï¼ˆæœ€å¤§ãƒ†ã‚¯ã‚¹ãƒãƒ£æ•°ï¼‰
	static const uint32_t kMaxSRVCount_;

private:/// ===variable=== ///
	DXCommon* dXCommon_ = nullptr; // DXCommon
	
	// SRVç”¨ã®ã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize_;

	// SRVç”¨ã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	ComPtr<ID3D12DescriptorHeap> descriptorHeap_;

	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t useIndex_ = 0;

	// å†åˆ©ç”¨å¯èƒ½ãªSRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒªã‚¹ãƒˆ
	std::vector<uint32_t> freeIndices_;
};




============================================================
File Path: Project/Engine/System/Managers/SceneManager.cpp
============================================================
#include "SceneManager.h"
// c++
#include <cassert>
// SceneTransitionManager
#include "Engine/Scene/Transition/SceneTransitionManager.h"
// å„ã‚·ãƒ¼ãƒ³
#include "application/Scene/TitleScene.h"
#include "application/Scene/SelectScene.h"
#include "application/Scene/GameScene.h"
#include "application/Scene/ClearScene.h"
#include "application/Scene/GameOverScene.h"
#include "Engine/Scene/Debug/ParticleEditorScene.h"
#include "application/Scene/Debug/AttackEditorScene.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
SceneManager::~SceneManager() {
	currentScene_.reset();
	sceneTransitionManager_.reset();
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void SceneManager::SetSelectedLevel(int level) { selectLevel_ = level; }
void SceneManager::SetSceneFactory(AbstractSceneFactory* sceneFactory) { sceneFactory_ = sceneFactory; }

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// é¸æŠã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ç•ªå·ã®å–å¾—
int SceneManager::GetSelectedLevel() const { return selectLevel_; }
// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³å®Œäº†ã®å–å¾—
bool SceneManager::GetTransitionFinished() const { return sceneTransitionManager_->IsFinished(); }
// ãƒ•ã‚§ãƒ¼ãƒ‰çŠ¶æ…‹ã®å–å¾—
FadeState SceneManager::GetFadeState() const { return sceneTransitionManager_->GetState(); }

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void SceneManager::Initialize(AbstractSceneFactory* sceneFactor) {
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ã‚»ãƒƒãƒˆ
	SetSceneFactory(sceneFactor);

	// ã‚·ãƒ¼ãƒ³ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã®ç”Ÿæˆ
	sceneTransitionManager_ = std::make_unique<SceneTransitionManager>();
	sceneTransitionManager_->Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void SceneManager::Update() {
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆå®Œäº†å¾Œã®æ–°è¦ä½œæˆ
	if (sceneTransitionManager_->GetState() == FadeState::FadeIn && sceneTransitionManager_->IsFinished()) {
		sceneTransitionManager_->NewMake();
	}

	// ã‚·ãƒ¼ãƒ³ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã®æ›´æ–°
	sceneTransitionManager_->Update();

	// ã‚·ãƒ¼ãƒ³ã®ç¢ºèª
	if (currentScene_) {
		// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã®æ›´æ–°
		currentScene_->Update();
	}

	// ImGui
	SceneObservation();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void SceneManager::Draw() {
	// ã‚·ãƒ¼ãƒ³ã®ç¢ºèª
	assert(currentScene_);
	if (currentScene_) {
		// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã®æç”»
		currentScene_->Draw();
	}

	// ã‚·ãƒ¼ãƒ³ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ã®æç”»
	sceneTransitionManager_->Draw();
}

///-------------------------------------------/// 
/// ã‚·ãƒ¼ãƒ³å¤‰æ›´
///-------------------------------------------///
void SceneManager::ChangeScene(SceneType type) {
	// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã‚’æ›´æ–°
	currentSceneType_ = type;
	// æ–°ã—ã„ã‚·ãƒ¼ãƒ³ã‚’ç”Ÿæˆ
	if (currentScene_) { currentScene_.reset(); }
	currentScene_ = sceneFactory_->CreateScene(currentSceneType_);
	// æ–°ã—ã„ã‚·ãƒ¼ãƒ³ã«SceneManagerã‚’ã‚»ãƒƒãƒˆ
	if (currentScene_) {
		currentScene_->SetSceneManager(this);
		sceneTransitionManager_->Reset();
	}
	SceneInit();
}

///-------------------------------------------/// 
/// ã‚·ãƒ¼ãƒ³ç›£è¦–
///-------------------------------------------///
void SceneManager::SceneObservation() {
#ifdef USE_IMGUI
	ImGui::Begin("Scene Manager");
	/// ===ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã‚’è¡¨ç¤º=== /// 
	if (currentScene_) {
		std::string currentSceneName = typeid(*currentScene_).name();
		ImGui::Text("Current Scene: %s", currentSceneName.c_str());
	} else {
		ImGui::Text("No Current Scene");
	}

	/// ===ã‚·ãƒ¼ãƒ³å¤‰æ›´ç”¨ã®ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼=== ///
	if (ImGui::BeginCombo("Select Scene", "Change Scene")) {
		/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³
		if (ImGui::Selectable("Title Scene", currentSceneType_ == SceneType::Title)) {
			ChangeScene(SceneType::Title);
		}
		/// ã‚»ãƒ¬ã‚¯ãƒˆã‚·ãƒ¼ãƒ³
		if (ImGui::Selectable("Select Scene", currentSceneType_ == SceneType::Select)) {
			ChangeScene(SceneType::Select);
		}
		/// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³
		if (ImGui::Selectable("Game Scene", currentSceneType_ == SceneType::Game)) {
			ChangeScene(SceneType::Game);
		}
		/// ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³
		if (ImGui::Selectable("Clear Scene", currentSceneType_ == SceneType::Clear)) {
			ChangeScene(SceneType::Clear);
		}
		/// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
		if (ImGui::Selectable("GameOver Scene", currentSceneType_ == SceneType::GameOver)) {
			ChangeScene(SceneType::GameOver);
		}
		/// ç²’å­ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚·ãƒ¼ãƒ³
		if (ImGui::Selectable("ParticleEditor", currentSceneType_ == SceneType::ParticleEditor)) {
			ChangeScene(SceneType::ParticleEditor);
		}
		// ã‚¢ã‚¿ãƒƒã‚¯ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚·ãƒ¼ãƒ³
		if (ImGui::Selectable("AttackEditor", currentSceneType_ == SceneType::AttackEditor)) {
			ChangeScene(SceneType::AttackEditor);
		}
		ImGui::EndCombo();
	}
	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
///-------------------------------------------///
void SceneManager::StartFadeIn(TransitionType type, const float duration) {
	sceneTransitionManager_->StartFadeIn(type, duration);
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé–‹å§‹
///-------------------------------------------///
void SceneManager::StartFadeOut(TransitionType type, const float duration) {
	sceneTransitionManager_->StartFadeOut(type, duration);
}

///-------------------------------------------/// 
/// ã‚·ãƒ¼ãƒ³åˆæœŸåŒ–
///-------------------------------------------///
void SceneManager::SceneInit() {
	// ã‚·ãƒ¼ãƒ³ã®ç¢ºèª
	if (currentScene_) {
		// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–
		currentScene_->Initialize();
	}
}



============================================================
File Path: Project/Engine/System/Managers/SceneManager.h
============================================================
#pragma once
/// ===Include=== ///
// c++
#include <memory>
#include <string>
// Game
#include "Engine/Scene/AbstractSceneFactory.h"
// SceneTransitionManager
#include "Engine/Scene/Transition/SceneTransitionManager.h"
// Imgui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI

///=====================================================/// 
/// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
///=====================================================///
class SceneManager {
public:/// ===åŸºæœ¬çš„ãªé–¢æ•°=== ///

	SceneManager() = default;
	~SceneManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(AbstractSceneFactory* sceneFactor);

	/// <summary>
	/// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³ã®æç”»å‡¦ç†
	/// </summary>
	void Draw();

public:/// ===ã‚·ãƒ¼ãƒ³å‡¦ç†=== ///

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆå‡¦ç†
	/// </summary>
	/// <param name="type">åˆ‡ã‚Šæ›¿ãˆã‚‹ã‚·ãƒ¼ãƒ³ã‚’ç¤ºã™å€¤ï¼ˆSceneType å‹ï¼‰ã€‚</param>
	/// <param name="transition">ä½¿ç”¨ã™ã‚‹é·ç§»åŠ¹æœï¼ˆTransitionTypeï¼‰ã€‚çœç•¥æ™‚ã¯ TransitionType::Noneã€‚</param>
	/// <param name="duraiton">é·ç§»ã®ç¶™ç¶šæ™‚é–“ï¼ˆç§’ï¼‰ã€‚æ—¢å®šå€¤ã¯ 1.0fã€‚</param>
	void ChangeScene(SceneType type);

	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ã®è¦³æ¸¬ã‚’è¡Œã†é–¢æ•°
	/// </summary>
	void SceneObservation();

	/// <summary>
	/// æŒ‡å®šã—ãŸãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’é–‹å§‹
	/// </summary>
	/// <param name="type">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã«ä½¿ç”¨ã™ã‚‹ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã®ç¨®é¡ã€‚TransitionType å‹ã§æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="duration">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆç§’å˜ä½ï¼‰ã€‚</param>
	void StartFadeIn(TransitionType type, const float duration);

	/// <summary>
	/// æŒ‡å®šã—ãŸç¶™ç¶šæ™‚é–“ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã‚’é–‹å§‹
	/// </summary>
	/// <param name="type">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã«ä½¿ç”¨ã™ã‚‹ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã®ç¨®é¡ã€‚TransitionType å‹ã§æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="duration">ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®ç¶™ç¶šæ™‚é–“ï¼ˆç§’å˜ä½ï¼‰ã€‚</param>
	void StartFadeOut(TransitionType type, const float duration);

public: /// ===Getter=== ///

	// é¸æŠã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ç•ªå·ã®å–å¾—
	int GetSelectedLevel() const;

	// ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã—ãŸã‹
	bool GetTransitionFinished() const;
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’å–å¾—
	FadeState GetFadeState() const;


public: /// ===Setter=== ///

	// ãƒ¬ãƒ™ãƒ«ã®è¨­å®š
	void SetSelectedLevel(int level);

	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®Setter
	void SetSceneFactory(AbstractSceneFactory* sceneFactory);

private:
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	AbstractSceneFactory* sceneFactory_ = nullptr;

	// ã‚·ãƒ¼ãƒ³ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£
	std::unique_ptr<SceneTransitionManager> sceneTransitionManager_;

	// ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³
	SceneType currentSceneType_ = SceneType::Title; // åˆæœŸã®ã‚·ãƒ¼ãƒ³
	std::unique_ptr<IScene> currentScene_; // ç¾åœ¨ã®ã‚·ãƒ¼ãƒ³

	// é¸æŠã•ã‚ŒãŸãƒ¬ãƒ™ãƒ«ç•ªå·ã‚’ä¿æŒã™ã‚‹
	int selectLevel_ = 1;

private: 

	/// <summary>
	/// æŒ‡å®šã—ãŸæŒç¶šæ™‚é–“ã§ã‚·ãƒ¼ãƒ³ã‚’åˆæœŸåŒ–
	/// </summary>
	/// <param name="duration">åˆæœŸåŒ–å‡¦ç†ã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰ã€‚ã‚·ãƒ¼ãƒ³ã®è¨­å®šã‚„é·ç§»ã®æŒç¶šæ™‚é–“ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void SceneInit();
};



============================================================
File Path: Project/Engine/System/Managers/TextureManager.cpp
============================================================
#include "TextureManager.h"
// Engine
#include "Engine/Core/DXCommon.h"
#include "Engine/Core/StringUtility.h"
#include "Engine/System/Managers/SRVManager.h"
// Function
#include "Engine/DataInfo/FunctionData.h"
// c++
#include <cassert>

// StringUtility
using namespace StringUtility;

// ImGuiã§0ç•ªã‚’ä½¿ç”¨ã™ã‚‹ãŸã‚ã€ï¼‘ç•ªã‹ã‚‰ä½¿ç”¨
uint32_t TextureManager::kSRVIndexTop_ = 1;

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
TextureManager::~TextureManager() {
	textureDates_.clear();
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
const DirectX::TexMetadata& TextureManager::GetMetaData(const std::string& Key) {
	TextureData& textureData = textureDates_[Key];
	return textureData.metadata;
}
// GPUãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetSRVHandleGPU(const std::string& Key) {
	TextureData& textureData = textureDates_[Key];
	return textureData.srvHandleGPU;
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®è¨­å®š
void TextureManager::SetGraphicsRootDescriptorTable(
	ID3D12GraphicsCommandList* commandList, UINT rootParameterIndex, std::string Key) {
	commandList->SetGraphicsRootDescriptorTable(rootParameterIndex, textureDates_[Key].srvHandleGPU);
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void TextureManager::Initialize(DXCommon* dxCommon, SRVManager* srvManager) {

	assert(dxCommon);
	assert(srvManager);

	dxCommon_ = dxCommon;
	srvManager_ = srvManager;

	// SRVã®æ•°ã¨åŒæ•°
	textureDates_.reserve(SRVManager::kMaxSRVCount_);
}

///-------------------------------------------/// 
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿	
///-------------------------------------------///
void TextureManager::LoadTexture(const std::string& key, const std::string& filePath) {

	// èª­ã¿è¾¼ã¿æ¸ˆã¿ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ¤œç´¢
	if (textureDates_.contains(key)) {
		assert(srvManager_->AssertAllocate());
		return;
	}

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ä¸Šé™ãƒã‚§ãƒƒã‚¯
	assert(srvManager_->Allocate());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¦æ›¸ãè¾¼ã‚€
	TextureData& textureData = textureDates_[key];
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	textureData.filePath = filePath;
	DirectX::ScratchImage mipImages = Load(key, filePath); // ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ã®ä½œæˆ
	textureData.metadata = mipImages.GetMetadata();
	textureData.resource = CreateTextureResource(textureData.metadata);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è»¢é€
	textureData.intermediateResource = UploadTextureData(textureData.resource,  mipImages);

	// SRVã‚’ä½œæˆã™ã‚‹DescriptorHeapã®å ´æ‰€è¨­å®š
	textureData.srvIndex = srvManager_->Allocate();
	textureData.srvHandleCPU = srvManager_->GetCPUDescriptorHandle(textureData.srvIndex);
	textureData.srvHandleGPU = srvManager_->GetGPUDescriptorHandle(textureData.srvIndex);

	// SRVã®ç”Ÿæˆ
	if (textureData.metadata.IsCubemap()) {
		// CubMap
		srvManager_->CreateSRVForCubeMap(
			textureData.srvIndex, textureData.resource.Get(), textureData.metadata.format, UINT_MAX);
	} else {
		// Texture2D
		srvManager_->CreateSRVForTexture2D(
			textureData.srvIndex, textureData.resource.Get(), textureData.metadata.format, UINT(textureData.metadata.mipLevels));
	}
	
}


///-------------------------------------------/// 
/// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ã®ä½œæˆ
///-------------------------------------------///
DirectX::ScratchImage TextureManager::Load(const std::string& key, const std::string& filePath) {
	
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§æ‰±ãˆã‚‹ã‚ˆã«ã™ã‚‹
	DirectX::ScratchImage image{};
	std::wstring filePathW = ConvertString(filePath);
	HRESULT hr;

	// æ‹¡å¼µå­ã®åˆ¤åˆ¥
	if (filePath.ends_with(".dds") || filePath.ends_with(".DDS")) {
		hr = DirectX::LoadFromDDSFile(filePathW.c_str(), DirectX::DDS_FLAGS_NONE, nullptr, image);
	} else {
		hr = DirectX::LoadFromWICFile(filePathW.c_str(), DirectX::WIC_FLAGS_FORCE_SRGB, nullptr, image);
	}

	// ãƒªãƒªãƒ¼ã‚¹ã§ã‚‚ã‚¨ãƒ©ãƒ¼ãŒå‡ºã‚‹ã‚ˆã†ã«ã™ã‚‹
	if (FAILED(hr)) {
		throw std::runtime_error("Failed to load texture with key: " + key + ", from file: " + filePath);
	}
	 
	/// ===ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ã®å¯¾å¿œå‡¦ç†=== ///
	// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ã®ä½œæˆ
	DirectX::ScratchImage mipImages{};
	if (DirectX::IsCompressed(image.GetMetadata().format)) { // åœ§ç¸®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹ã©ã†ã‹ã‚’èª¿ã¹ã‚‹
		mipImages = std::move(image); // åœ§ç¸®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãªã‚‰ãã®ã¾ã¾ä½¿ã†ã®ã§moveã™ã‚‹
	} else {
		hr = DirectX::GenerateMipMaps(image.GetImages(), image.GetImageCount(), image.GetMetadata(), DirectX::TEX_FILTER_SRGB, 4, mipImages);
	}
	if (FAILED(hr)) {
		throw std::runtime_error("Failed to generate mipmaps for texture with key: " + key + ", from file: " + filePath);
	}

	// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
	return mipImages;
}

///-------------------------------------------/// 
/// TextureResourceã®ä½œæˆ
///-------------------------------------------///
ComPtr<ID3D12Resource> TextureManager::CreateTextureResource(const DirectX::TexMetadata& metadata) {
	/// ***************************
	/// metadataã‚’åŸºã«Resourceã®è¨­å®š
	/// ***************************
	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = UINT(metadata.width); // Textureã®å¹…
	resourceDesc.Height = UINT(metadata.height); // Textureã®é«˜ã•
	resourceDesc.MipLevels = UINT16(metadata.mipLevels); // mipmapã®æ•°
	resourceDesc.DepthOrArraySize = UINT16(metadata.arraySize); // å¥¥è¡Œ or é…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = metadata.format; // Textureã®Format
	resourceDesc.SampleDesc.Count = 1; // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆã€‚1å›ºå®š
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION(metadata.dimension); // Textureã®æ¬¡å…ƒæ•°ã€‚æ™®æ®µä½¿ã£ã¦ã„ã‚‹ã®ã¯ï¼’æ¬¡å…ƒ
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_NONE; // SRVä½œæˆå¯èƒ½ã« 

	/// ***************************
	/// åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®š
	/// ***************************
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆHeapã«è¨­å®š
	heapProperties.CPUPageProperty = D3D12_CPU_PAGE_PROPERTY_UNKNOWN; // WriteBackãƒãƒªã‚·ãƒ¼ã§CPUã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½
	heapProperties.MemoryPoolPreference = D3D12_MEMORY_POOL_UNKNOWN; // ãƒ—ãƒ­ã‚»ãƒƒã‚µã®è¿‘ãã«é…ç½®
	// ãƒãƒ«ãƒGPUã‚’ä½¿ç”¨ã—ã¦ã„ãªã‘ã‚Œã°1ã§å¤§ä¸ˆå¤«
	heapProperties.CreationNodeMask = 1;  // ãƒãƒ¼ãƒ‰0ã§ä½œæˆ
	heapProperties.VisibleNodeMask = 1;   // ãƒãƒ¼ãƒ‰0ã‹ã‚‰è¦‹ãˆã‚‹

	/// ***************************
	/// Resourceã®ç”Ÿæˆ
	/// ***************************
	ComPtr<ID3D12Resource> resource = nullptr;
	HRESULT hr = dxCommon_->GetDevice()->CreateCommittedResource(
		&heapProperties, // Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE, // Heapã®ç‰¹æ®Šãªè¨­å®šã€‚
		&resourceDesc, // Resourceã®è¨­å®š
		D3D12_RESOURCE_STATE_COPY_DEST, // ãƒ‡ãƒ¼ã‚¿ã‚’è»¢é€ã•ã‚Œã‚‹è¨­å®š
		nullptr, // Clearæœ€é©å€¤ã€‚
		IID_PPV_ARGS(&resource)); // ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	assert(SUCCEEDED(hr));
	hr;
	return resource;
}

///-------------------------------------------/// 
/// ãƒ‡ãƒ¼ã‚¿ã‚’è»¢é€ã™ã‚‹
///-------------------------------------------///
ComPtr<ID3D12Resource> TextureManager::UploadTextureData(ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages) {

	/// ===IntermediateResource(ä¸­é–“ãƒªã‚½ãƒ¼ã‚¹)=== ///
	std::vector<D3D12_SUBRESOURCE_DATA> subResources;
	// PrepareUploadã‚’åˆ©ç”¨ã—ã¦ã€èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰DirectX12ç”¨ã®ã‚µãƒ–ãƒªã‚½ãƒ¼ã‚¹ã®é…åˆ—ã‚’ä½œæˆ
	DirectX::PrepareUpload(dxCommon_->GetDevice(), mipImages.GetImages(), mipImages.GetImageCount(), mipImages.GetMetadata(), subResources);
	// SubResourceã®æ•°ã‚’å…ƒã«ã€ã‚³ãƒ”ãƒ¼å…ƒã¨ãªã‚‹IntermediateResourceã«å¿…è¦ãªã‚µã‚¤ã‚ºã‚’è¨ˆç®—
	uint64_t intermediateSize = GetRequiredIntermediateSize(texture.Get(), 0, UINT(subResources.size()));
	// è¨ˆç®—ã—ãŸã‚µã‚¤ã‚ºã§IntermediateResourceã‚’ä½œæˆã€€
	ComPtr<ID3D12Resource> intermediateResource = nullptr;
	intermediateResource = CreateBufferResourceComPtr(dxCommon_->GetDevice(), intermediateSize);

	/// ===ãƒ‡ãƒ¼ã‚¿è»¢é€ã‚³ãƒãƒ³ãƒ‰ã«ç©ã‚€=== ///
	UpdateSubresources(dxCommon_->GetCommandList(), texture.Get(), intermediateResource.Get(), 0, 0, UINT(subResources.size()), subResources.data());

	/// ===ResourceStateã‚’å¤‰æ›´ã—ã€IntermediateResourceã‚’è¿”ã™=== ///
	// Textureã¸ã®è»¢é€å¾Œã¯åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã«D3D12_RESOURCE_STATE_COPY_DESTã‹ã‚‰D3D12_RESOURCE_STATE_GENERIC_READã¸ResourceStateã‚’å¤‰æ›´
	D3D12_RESOURCE_BARRIER barrier{};
	barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrier.Transition.pResource = texture.Get();
	barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_GENERIC_READ;
	dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);

	return intermediateResource;
}

============================================================
File Path: Project/Engine/System/Managers/TextureManager.h
============================================================
#pragma once
/// ===include=== ///
// Engine
#include "Engine/Core/ComPtr.h"
#include "Engine/DataInfo/CData.h"
// DirectXTex
#include "DirectXTex.h"
// C++
#include <string>
#include <unordered_map>
// DirectX
#include <d3dx12.h>

/// ===å‰æ–¹å®£è¨€=== ///
class DXCommon;
class SRVManager;

///=====================================================/// 
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒãƒ¼ã‚¸ãƒ£
///=====================================================///
class TextureManager {

public:/// ===åŸºæœ¬çš„ãªé–¢æ•°=== ///
	
	TextureManager() = default;
	~TextureManager();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxCommon">DirectX ã«é–¢é€£ã™ã‚‹å…±é€šãƒ‡ãƒ¼ã‚¿ã‚„ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ã™ DXCommon ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚åˆæœŸåŒ–å‡¦ç†ã§ä½¿ç”¨ã•ã‚Œã‚‹æœ‰åŠ¹ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	/// <param name="srvManager">ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ï¼ˆSRVï¼‰ã‚’ç®¡ç†ã™ã‚‹ SRVManager ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚SRV ã®ç™»éŒ²ã‚„ç®¡ç†ã«ä½¿ç”¨ã•ã‚Œã‚‹æœ‰åŠ¹ãªã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	void Initialize(DXCommon* dxCommon, SRVManager* srvManager);

public:/// ===Getter=== ///

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·ã‹ã‚‰GPUãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	D3D12_GPU_DESCRIPTOR_HANDLE GetSRVHandleGPU(const std::string& Key);
	// ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿
	const DirectX::TexMetadata& GetMetaData(const std::string& Key);

public:/// ==Setter==== ///

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ«ãƒ¼ãƒˆãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã®è¨­å®š
	void SetGraphicsRootDescriptorTable(ID3D12GraphicsCommandList* commandList, UINT rootParameterIndex, std::string Key);

public:/// ===Variables(å¤‰æ•°)=== ///

	/// ===ImGuiå¯¾å¿œ=== ///
	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®é–‹å§‹ç•ªå·
	static uint32_t kSRVIndexTop_;

public:/// ===Functions(é–¢æ•°)=== ///

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="key">èª­ã¿è¾¼ã‚“ã ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è­˜åˆ¥ãƒ»å‚ç…§ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ã€‚</param>
	/// <param name="filePath">èª­ã¿è¾¼ã‚€ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ï¼ˆç›¸å¯¾ãƒ‘ã‚¹ã¾ãŸã¯çµ¶å¯¾ãƒ‘ã‚¹ï¼‰ã€‚</param>
	void LoadTexture(const std::string& key, const std::string& filePath);

private:/// ===Variables(å¤‰æ•°)=== ///

	// DXCommonã®ãƒã‚¤ãƒ³ã‚¿
	DXCommon* dxCommon_ = nullptr; 
	// SRVManagerã®ãƒã‚¤ãƒ³ã‚¿
	SRVManager* srvManager_ = nullptr; 

	/// ===ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ ä½“=== ///
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£1æšåˆ†ã®ãƒ‡ãƒ¼ã‚¿
	struct TextureData {
		std::string filePath;
		DirectX::TexMetadata metadata;
		ComPtr<ID3D12Resource> resource;
		ComPtr<ID3D12Resource> intermediateResource;
		uint32_t srvIndex;
		D3D12_CPU_DESCRIPTOR_HANDLE srvHandleCPU;
		D3D12_GPU_DESCRIPTOR_HANDLE srvHandleGPU;
	};

	/// ===ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚³ãƒ³ãƒ†ãƒŠ=== ///
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿
	std::unordered_map<std::string, TextureData> textureDates_;

private:/// ===Functions(é–¢æ•°)=== ///
	
	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’èª­ã¿è¾¼ã¿ã€DirectX::ScratchImage ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦è¿”ã™
	/// </summary>
	/// <param name="key">èª­ã¿è¾¼ã¿æ“ä½œã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ã€‚ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®è­˜åˆ¥å­ãªã©ã«ä½¿ç”¨ã•ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</param>
	/// <param name="filePath">èª­ã¿è¾¼ã‚€ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ•ã‚¡ã‚¤ãƒ«ã¸ã®ãƒ‘ã‚¹ã€‚</param>
	/// <returns>èª­ã¿è¾¼ã¾ã‚ŒãŸã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’ä¿æŒã™ã‚‹ DirectX::ScratchImage ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸå ´åˆã®æŒ™å‹•ï¼ˆä¾‹: ç©ºã®ç”»åƒã‚„ä¾‹å¤–ï¼‰ã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚</returns>
	DirectX::ScratchImage Load(const std::string& key, const std::string& filePath);

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸ DirectX::TexMetadata ã«åŸºã¥ã„ã¦ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”¨ã® ID3D12Resource ã‚’ä½œæˆã—ã€ComPtr<ID3D12Resource> ã¨ã—ã¦è¿”ã™
	/// </summary>
	/// <param name="metadata">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®å¹…ãƒ»é«˜ã•ãƒ»ãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ãƒ»ãƒ”ã‚¯ã‚»ãƒ«å½¢å¼ãªã©ã‚’å«ã‚€ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã€‚ä½œæˆã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ç‰¹æ€§ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <returns>ä½œæˆã•ã‚ŒãŸ ID3D12Resource ã‚’ä¿æŒã™ã‚‹ ComPtrã€‚ä½œæˆã«å¤±æ•—ã—ãŸå ´åˆã¯ç©ºã® ComPtrï¼ˆnull ç›¸å½“ï¼‰ã‚’è¿”ã™å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	ComPtr<ID3D12Resource> CreateTextureResource( const DirectX::TexMetadata& metadata);

	/// <summary>
	/// ãƒŸãƒƒãƒ—ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’GPUã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã€ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰æ¸ˆã¿ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã‚’è¿”ã™
	/// </summary>
	/// <param name="texture">ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã™ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã‚’ä¿æŒã™ã‚‹ ComPtr<ID3D12Resource>ã€‚</param>
	/// <param name="mipImages">å„ãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«ã®ç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã—ãŸ DirectX::ScratchImage ã®å‚ç…§ã€‚</param>
	/// <returns>ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¡¨ã™ ComPtr<ID3D12Resource>ã€‚æˆ»ã‚Šå€¤ã¯ç„¡è¦–ã—ãªã„ã§ãã ã•ã„ã€‚</returns>
	[[nodiscard]]
	ComPtr<ID3D12Resource> UploadTextureData(ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages);
};



============================================================
File Path: Project/Engine/System/Service/AudioService.cpp
============================================================
#include "AudioService.h"
#include "Engine/System/Managers/AudioManager.h"
// ServiceLocator
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// Audioã®å‡¦ç†
///-------------------------------------------///
// éŸ³å£°ã®å†ç”Ÿ
void AudioService::PlayeSound(const std::string& key, bool loop) {
	ServiceLocator::GetAudioManager()->Play(key, loop);
}
// éŸ³å£°ã®åœæ­¢
void AudioService::StopSound(const std::string& key) {
	ServiceLocator::GetAudioManager()->Stop(key);
}
// éŸ³å£°ã®ãƒœãƒªãƒ¥ãƒ¼ãƒ ã®èª¿æ•´
void AudioService::VolumeSound(const std::string& key, float volume) {
	ServiceLocator::GetAudioManager()->SetVolume(key, volume);
}
// éŸ³å£°ã®å†ç”Ÿé€Ÿåº¦ã®èª¿æ•´
void AudioService::PitchSound(const std::string& key, float pitch) {
	ServiceLocator::GetAudioManager()->setPitch(key, pitch);
}


============================================================
File Path: Project/Engine/System/Service/AudioService.h
============================================================
#pragma once
/// ===Include=== ///
#include <string>

///=====================================================/// 
/// AudioService
///=====================================================///
class AudioService {
public:
	
	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹éŸ³å£°ã‚’å†ç”Ÿã™ã‚‹é™çš„é–¢æ•°ã€‚
	/// </summary>
	/// <param name="key">å†ç”Ÿã™ã‚‹éŸ³å£°ã‚’è­˜åˆ¥ã™ã‚‹ã‚­ãƒ¼ã‚’è¡¨ã™æ–‡å­—åˆ—ã€‚</param>
	/// <param name="loop">å†ç”Ÿã‚’ãƒ«ãƒ¼ãƒ—ã™ã‚‹ã‹ã©ã†ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚true ã®å ´åˆã¯ãƒ«ãƒ¼ãƒ—å†ç”Ÿã€false ã®å ´åˆã¯ä¸€åº¦ã ã‘å†ç”Ÿã—ã¾ã™ã€‚</param>
	static void PlayeSound(const std::string& key, bool loop);

	/// <summary>
	/// æŒ‡å®šã—ãŸã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹å†ç”Ÿä¸­ã®ã‚µã‚¦ãƒ³ãƒ‰ã‚’åœæ­¢ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="key">åœæ­¢ã™ã‚‹ã‚µã‚¦ãƒ³ãƒ‰ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚</param>
	static void StopSound(const std::string& key);

	/// <summary>
	/// æŒ‡å®šã—ãŸã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹ã‚µã‚¦ãƒ³ãƒ‰ã®éŸ³é‡ã‚’è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="key">ã‚µã‚¦ãƒ³ãƒ‰ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚</param>
	/// <param name="volume">è¨­å®šã™ã‚‹éŸ³é‡ã‚’è¡¨ã™æµ®å‹•å°æ•°ç‚¹å€¤ã€‚ç¯„å›²ã‚„å˜ä½ã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ã€‚</param>
	static void VolumeSound(const std::string& key, float volume);

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹ã‚µã‚¦ãƒ³ãƒ‰ã‚’æŒ‡å®šã—ãŸãƒ”ãƒƒãƒã§å†ç”Ÿã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="key">å†ç”Ÿã™ã‚‹ã‚µã‚¦ãƒ³ãƒ‰ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚é€šå¸¸ã¯ã‚µã‚¦ãƒ³ãƒ‰ãƒªã‚½ãƒ¼ã‚¹ã‚„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åå‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="pitch">å†ç”Ÿæ™‚ã®ãƒ”ãƒƒãƒã‚’è¡¨ã™æµ®å‹•å°æ•°ç‚¹å€¤ã€‚å€¤ã®è§£é‡ˆï¼ˆå€ç‡ã‚„ã‚»ãƒŸãƒˆãƒ¼ãƒ³ãªã©ï¼‰ã¯å®Ÿè£…ã«ã‚ˆã£ã¦ç•°ãªã‚Šã¾ã™ã€‚</param>
	static void PitchSound(const std::string& key, float pitch);
};



============================================================
File Path: Project/Engine/System/Service/CameraService.cpp
============================================================
#include "CameraService.h"
// CameraManager
#include "Engine/System/Managers/CameraManager.h"
// ServiceLovator
#include "ServiceLocator.h"

// è¿½åŠ 
void CameraService::AddCamera(const std::string& name, std::shared_ptr<GameCamera> camera) {
	ServiceLocator::GetCameraManager()->AddCamera(name, camera);
}
// å‰Šé™¤
void CameraService::Remove(const std::string& name) {
	ServiceLocator::GetCameraManager()->RemoveCamera(name);
}
// ã‚«ãƒ¡ãƒ©ã®ãƒã‚§ãƒƒã‚¯
void CameraService::HasCamera(const std::string& name) {
	ServiceLocator::GetCameraManager()->HasCamera(name);
}
// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®Getter
std::shared_ptr<GameCamera> CameraService::GetActiveCamera() {
	return ServiceLocator::GetCameraManager()->GetActiveCamera();
}
// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ¡ãƒ©ã®Setter
void CameraService::SetActiveCamera(const std::string& name) {
	ServiceLocator::GetCameraManager()->SetActiveCamera(name);
}


============================================================
File Path: Project/Engine/System/Service/CameraService.h
============================================================
#pragma once
/// ===Include=== ///
// c++
#include <string>
#include <memory>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///=====================================================/// 
/// CameraService
///=====================================================///
class CameraService {
public:

	/// <summary>
	/// æŒ‡å®šã—ãŸåå‰ã§ã‚«ãƒ¡ãƒ©ã‚’ç™»éŒ²ã™ã‚‹é™çš„é–¢æ•°ã€‚ã‚«ãƒ¡ãƒ©ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã«æ–°ã—ã„ã‚«ãƒ¡ãƒ©ã‚’è¿½åŠ ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="name">ç™»éŒ²ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®è­˜åˆ¥åã‚’ç¤ºã™æ–‡å­—åˆ—ã€‚</param>
	/// <param name="camera">è¿½åŠ ã™ã‚‹ GameCamera ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã® std::shared_ptrã€‚ç®¡ç†å¯¾è±¡ã®ã‚«ãƒ¡ãƒ©ã‚’æŒ‡ã™ã‚¹ãƒãƒ¼ãƒˆãƒã‚¤ãƒ³ã‚¿ã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	static void AddCamera(const std::string& name, std::shared_ptr<GameCamera> camera);

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸåå‰ã®é …ç›®ã‚’å‰Šé™¤ã™ã‚‹é™çš„ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚
	/// </summary>
	/// <param name="name">å‰Šé™¤å¯¾è±¡ã®åå‰ã‚’æŒ‡å®šã™ã‚‹æ–‡å­—åˆ—ï¼ˆconst std::string&ï¼‰ã€‚</param>
	static void Remove(const std::string& name);

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸåå‰ã®ã‚«ãƒ¡ãƒ©ã®å­˜åœ¨ã‚’ç¢ºèªã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="name">ç¢ºèªå¯¾è±¡ã®ã‚«ãƒ¡ãƒ©åã‚’è¡¨ã™æ–‡å­—åˆ—å‚ç…§ã€‚</param>
	static void HasCamera(const std::string& name);

	/// <summary>
	/// ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©ã¸ã®å…±æœ‰ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—ã—ã¾ã™ï¼ˆé™çš„ãƒ¡ãƒ³ãƒé–¢æ•°ï¼‰ã€‚
	/// </summary>
	/// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãª GameCamera ã‚’æŒ‡ã™ std::shared_ptr<GameCamera>ã€‚ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚«ãƒ¡ãƒ©ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ nullptr ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static std::shared_ptr<GameCamera> GetActiveCamera();

	/// <summary>
	/// æŒ‡å®šã—ãŸåå‰ã®ã‚«ãƒ¡ãƒ©ã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="name">ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®åå‰ã€‚</param>
	static void SetActiveCamera(const std::string& name);
};



============================================================
File Path: Project/Engine/System/Service/ColliderService.cpp
============================================================
#include "ColliderService.h"
// Manager
#include "Engine/System/Managers/ColliderManager.h"
// Service
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// è¿½åŠ 
///-------------------------------------------///
void ColliderService::AddCollider(Collider* collider) { ServiceLocator::GetColliderManager()->AddCollider(collider); }

///-------------------------------------------/// 
/// å‰Šé™¤
///-------------------------------------------///
void ColliderService::RemoveCollider(Collider* collider) { ServiceLocator::GetColliderManager()->RemoveCollider(collider); }

///-------------------------------------------/// 
/// ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void ColliderService::Reset() { ServiceLocator::GetColliderManager()->Reset(); }

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// LightTYpe
void ColliderService::SetLight(LightType lightType) {ServiceLocator::GetColliderManager()->SetLight(lightType);}

// LightData
void ColliderService::SetLightData(LightInfo light) {ServiceLocator::GetColliderManager()->SetLightData(light);}

============================================================
File Path: Project/Engine/System/Service/ColliderService.h
============================================================
#pragma once
/// ===Include=== ///
// Data
#include "Engine/DataInfo/LightData.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Collider;
class Camera;
class Light;

///-------------------------------------------/// 
/// ColliderService
///-------------------------------------------///
class ColliderService {
public:

	/// <summary>
	/// å†…éƒ¨çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã€‚
	/// </summary>
	static void Reset();

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å‰Šé™¤ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="collider">å‰Šé™¤å¯¾è±¡ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚å‘¼ã³å‡ºã™å‰ã«ãƒã‚¤ãƒ³ã‚¿ãŒæœ‰åŠ¹ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</param>
	static void RemoveCollider(Collider* collider);

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’è¿½åŠ ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="collider">è¿½åŠ ã™ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	static void AddCollider(Collider* collider);

	/// <summary>
	/// ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="type">è¨­å®šã™ã‚‹ãƒ©ã‚¤ãƒˆã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	static void SetLight(LightType type);

	/// <summary>
	/// ãƒ©ã‚¤ãƒˆã®ãƒ‡ãƒ¼ã‚¿ã‚’è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="light">è¨­å®šã™ã‚‹ãƒ©ã‚¤ãƒˆæƒ…å ±ã‚’æ ¼ç´ã—ãŸ LightInfo ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</param>
	static void SetLightData(LightInfo light);
};



============================================================
File Path: Project/Engine/System/Service/DeltaTimeSevice.cpp
============================================================
#include "DeltaTimeSevice.h"
// DeltaTime
#include "Engine/System/DeltraTime/DeltaTime.h"
// ServiceLocator
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void DeltaTimeSevice::SetDeltaTime(const float& deltaTime) {ServiceLocator::GetDeltaTime()->SetDeltaTime(deltaTime);}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
const float& DeltaTimeSevice::GetDeltaTime() {return ServiceLocator::GetDeltaTime()->GetDeltaTime();}






============================================================
File Path: Project/Engine/System/Service/DeltaTimeSevice.h
============================================================
#pragma once
/// ===Include=== ///

///=====================================================/// 
/// DeltaTimeSevice
///=====================================================///
class DeltaTimeSevice {
public:

	/// <summary>
	/// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼ˆãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ï¼‰ã‚’å–å¾—
	/// </summary>
	/// <returns>å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’è¡¨ã™ const float å‹ã¸ã®å‚ç…§ã€‚é€šå¸¸ã¯ç§’å˜ä½ã§æ ¼ç´ã•ã‚ŒãŸå†…éƒ¨å€¤ã¸ã®å‚ç…§ã‚’è¿”ã—ã¾ã™ï¼ˆå¤‰æ›´ã—ãªã„ã§ãã ã•ã„ï¼‰ã€‚</returns>
	static const float& GetDeltaTime();

	/// <summary>
	/// é™çš„é–¢æ•°ã€‚ãƒ•ãƒ¬ãƒ¼ãƒ é–“ã®çµŒéæ™‚é–“ï¼ˆãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ï¼‰ã‚’è¨­å®š
	/// </summary>
	/// <param name="deltaTime">è¨­å®šã™ã‚‹çµŒéæ™‚é–“ï¼ˆfloat ã® const å‚ç…§ï¼‰ã€‚é€šå¸¸ã¯ç§’å˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚</param>
	static void SetDeltaTime(const float& deltaTime);
};



============================================================
File Path: Project/Engine/System/Service/GraphicsResourceGetter.cpp
============================================================
#include "GraphicsResourceGetter.h"
// c++
#include <cassert>
// Engine
#include "Engine/Core/WinApp.h"
#include "Engine/Core/DXCommon.h"
// Manager
#include "Engine/System/Managers/SRVManager.h"
#include "Engine/System/Managers/RTVManager.h"
#include "Engine/System/Managers/DSVManager.h"
#include "Engine/System/Managers/TextureManager.h"
#include "Engine/System/Managers/ModelManager.h"
#include "Engine/System/Managers/AnimationManager.h"
#include "Engine/System/Managers/LevelManager.h"
// ServiceLocator
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// DescriptorHandle
///-------------------------------------------///
// RTV
D3D12_CPU_DESCRIPTOR_HANDLE GraphicsResourceGetter::GetRTVCPUDescriptorHandle(uint32_t index) {
	return ServiceLocator::GetRTVManager()->GetCPUDescriptorHandle(index);
}
D3D12_GPU_DESCRIPTOR_HANDLE GraphicsResourceGetter::GetRTVGPUDescriptorHandle(uint32_t index) {
	return ServiceLocator::GetRTVManager()->GetGPUDescriptorHandle(index);
}
// DSV
D3D12_CPU_DESCRIPTOR_HANDLE GraphicsResourceGetter::GetDSVCPUDescriptorHandle(uint32_t index) {
	return ServiceLocator::GetDSVManager()->GetCPUDescriptorHandle(index);
}
D3D12_GPU_DESCRIPTOR_HANDLE GraphicsResourceGetter::GetDSVGPUDescriptorHandle(uint32_t index) {
	return ServiceLocator::GetDSVManager()->GetGPUDescriptorHandle(index);
}
// SRV
D3D12_CPU_DESCRIPTOR_HANDLE GraphicsResourceGetter::GetSRVCPUDescriptorHandle(uint32_t index) {
	return ServiceLocator::GetSRVManager()->GetCPUDescriptorHandle(index);
}
D3D12_GPU_DESCRIPTOR_HANDLE GraphicsResourceGetter::GetSRVGPUDescriptorHandle(uint32_t index) {
	return ServiceLocator::GetSRVManager()->GetGPUDescriptorHandle(index);
}

///-------------------------------------------/// 
/// WinApp
///-------------------------------------------///
const int GraphicsResourceGetter::GetWindowWidth() {
	return ServiceLocator::GetWinApp()->GetWindowWidth();
}
const int GraphicsResourceGetter::GetWindowHeight() {
	return ServiceLocator::GetWinApp()->GetWindowHeight();
}

///-------------------------------------------/// 
/// Data
///-------------------------------------------///
// ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
const DirectX::TexMetadata& GraphicsResourceGetter::GetMetaData(const std::string& key) {
	return ServiceLocator::GetTextureManager()->GetMetaData(key);
}
// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
ModelData GraphicsResourceGetter::GetModelData(const std::string& directorPath) {
	return ServiceLocator::GetModelManager()->GetModelData(directorPath);
}
// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®å–å¾—
std::map<std::string, Animation> GraphicsResourceGetter::GetAnimationData(const std::string& directorPath) {
	return ServiceLocator::GetAnimationManager()->GetAnimation(directorPath);
}
// LevelDataã®å–å¾—
LevelData* GraphicsResourceGetter::GetLevelData(const std::string& file_name) {
	return ServiceLocator::GetLevelManager()->GetLevelData(file_name);
}


///-------------------------------------------/// 
/// DXCommon
///-------------------------------------------///
// Deviceã®å–å¾—
ID3D12Device* GraphicsResourceGetter::GetDXDevice() {
	return ServiceLocator::GetDXCommon()->GetDevice();
}
// CommandListã®å–å¾—
ID3D12GraphicsCommandList* GraphicsResourceGetter::GetDXCommandList() {
	return ServiceLocator::GetDXCommon()->GetCommandList();
}

============================================================
File Path: Project/Engine/System/Service/GraphicsResourceGetter.h
============================================================
#pragma once
/// ===Include=== ///
// C++
#include <string>
#include <d3d12.h>
// DirectXTex
#include "DirectXTex.h"
// Engine
#include "Engine/DataInfo/CData.h"
#include "Engine/DataInfo/AnimationData.h"
#include "Engine/DataInfo/LevelData.h"

///=====================================================/// 
/// GraphicsResourceGetter
///=====================================================///
class GraphicsResourceGetter {
public: /// ===DescriptorHandle=== ///
	/// <summary>
	///  RTVã®æŒ‡å®šç•ªå·ã®CPUã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">RTV ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—å†…ã®å¯¾è±¡ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã® 0 ãƒ™ãƒ¼ã‚¹ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹ D3D12_CPU_DESCRIPTOR_HANDLEã€‚CPU å´ã® RTV ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã¸ã®ãƒãƒ³ãƒ‰ãƒ«ã‚’è¡¨ã—ã¾ã™ã€‚</returns>
	static D3D12_CPU_DESCRIPTOR_HANDLE GetRTVCPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// RTVã®æŒ‡å®šç•ªå·ã®GPUã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">å–å¾—ã™ã‚‹ RTV ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆé…åˆ—ã‚„ãƒ’ãƒ¼ãƒ—å†…ã®ä½ç½®ï¼‰ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸ RTV ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’æŒ‡ã™ D3D12_GPU_DESCRIPTOR_HANDLEï¼ˆGPU ãŒä½¿ç”¨ã™ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ï¼‰ã€‚</returns>
	static D3D12_GPU_DESCRIPTOR_HANDLE GetRTVGPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// DSVã®æŒ‡å®šç•ªå·ã®CPUã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">å–å¾—ã™ã‚‹ DSV ç”¨ CPU ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹ D3D12_CPU_DESCRIPTOR_HANDLEã€‚</returns>
	static D3D12_CPU_DESCRIPTOR_HANDLE GetDSVCPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// DSVã®æŒ‡å®šç•ªå·ã®GPUã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">å–å¾—ã™ã‚‹DSVãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹D3D12_GPU_DESCRIPTOR_HANDLEï¼ˆGPUå´ã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ï¼‰ã€‚</returns>
	static D3D12_GPU_DESCRIPTOR_HANDLE GetDSVGPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// SRVã®æŒ‡å®šç•ªå·ã®CPUã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">å–å¾—ã™ã‚‹ SRV ã® CPU ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿é…åˆ—å†…ã®ä½ç½®ï¼‰ã€‚</param>
	/// <returns>æŒ‡å®šã•ã‚ŒãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹ D3D12_CPU_DESCRIPTOR_HANDLE ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static D3D12_CPU_DESCRIPTOR_HANDLE GetSRVCPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// SRVã®æŒ‡å®šç•ªå·ã®GPUã§ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <param name="index">å–å¾—ã™ã‚‹ SRV ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆé…åˆ—ã‚ªãƒ•ã‚»ãƒƒãƒˆã€é€šå¸¸ã¯ 0 ã‹ã‚‰å§‹ã¾ã‚Šã¾ã™ï¼‰ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«å¯¾å¿œã™ã‚‹ D3D12_GPU_DESCRIPTOR_HANDLEï¼ˆGPU å´ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ï¼‰ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static D3D12_GPU_DESCRIPTOR_HANDLE GetSRVGPUDescriptorHandle(uint32_t index);

public:/// ===Window=== ///
	
	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®å¹…ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <returns>ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®å¹…ã‚’è¡¨ã™å®šæ•°ã®æ•´æ•°å€¤ã€‚</returns>
	static const int GetWindowWidth();
	
	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®é«˜ã•ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	/// <returns>ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®é«˜ã•ã‚’è¡¨ã™æ•´æ•°å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«å˜ä½ï¼‰ã€‚</returns>
	static const int GetWindowHeight();

public:/// ===Data=== ///
	
	/// <summary>
	/// TextureDataã®å–å¾—
	/// </summary>
	/// <param name="key">æ¤œç´¢ã™ã‚‹ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã«å¯¾å¿œã™ã‚‹ã‚­ãƒ¼ã‚’è¡¨ã™æ–‡å­—åˆ—ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹DirectX::TexMetadataã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®constå‚ç…§ã€‚</returns>
	static const DirectX::TexMetadata& GetMetaData(const std::string& key);

	/// <summary>
	/// ModelDataã®å–å¾—
	/// </summary>
	/// <param name="directorPath">ãƒ¢ãƒ‡ãƒ« ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã®ãƒ‘ã‚¹ã€‚</param>
	/// <returns>å–å¾—ã—ãŸ ModelData ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚æŒ‡å®šã—ãŸãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«åŸºã¥ããƒ¢ãƒ‡ãƒ«æƒ…å ±ã‚’å«ã¿ã¾ã™ã€‚</returns>
	static ModelData GetModelData(const std::string& directorPath);
	
	/// <summary>
	/// AnimationDataã®å–å¾—
	/// </summary>
	/// <param name="directorPath">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¾ãŸã¯ãƒªã‚½ãƒ¼ã‚¹ã¸ã®ãƒ‘ã‚¹ã€‚ãƒ‡ãƒ¼ã‚¿ã®æ¢ç´¢ï¼èª­ã¿è¾¼ã¿ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>ã‚­ãƒ¼ãŒæ–‡å­—åˆ—ã€å€¤ãŒ Animation ã® std::mapã€‚å„ã‚¨ãƒ³ãƒˆãƒªã¯è­˜åˆ¥å­ï¼ˆä¾‹: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åï¼‰ã¨å¯¾å¿œã™ã‚‹ Animation ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã—ã¾ã™ã€‚</returns>
	static std::map<std::string, Animation> GetAnimationData(const std::string& directorPath);
	
	/// <summary>
	/// LevelDataã®å–å¾—
	/// </summary>
	/// <param name="file_name">èª­ã¿è¾¼ã‚€ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒ•ã‚¡ã‚¤ãƒ«åï¼ˆãƒ•ãƒ«ãƒ‘ã‚¹ã¾ãŸã¯ç›¸å¯¾ãƒ‘ã‚¹ã‚’æŒ‡å®šï¼‰ã€‚</param>
	/// <returns>èª­ã¿è¾¼ã¾ã‚ŒãŸ LevelData ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ãŸå ´åˆã‚„ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ nullptr ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	static LevelData* GetLevelData(const std::string& file_name);

public:/// ===ID3D12=== ///
	
	/// <summary>
	///	Deviceã®å–å¾—
	/// </summary>
	/// <returns>Deviceã‚’è¿”ã™</returns>
	static ID3D12Device* GetDXDevice();

	/// <summary>
	/// CommandListã®å–å¾—
	/// </summary>
	/// <returns>CommandListã‚’è¿”ã™</returns>
	static ID3D12GraphicsCommandList* GetDXCommandList();
};

============================================================
File Path: Project/Engine/System/Service/InputService.cpp
============================================================
#include "InputService.h"
// c++
#include <cassert>
// Input
#include "Engine/System/Input/Keyboard.h"
#include "Engine/System/Input/Mouse.h"
#include "Engine/System/Input/Controller.h"
// ServiceLocator
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void InputService::Update() {
	ServiceLocator::GetKeyboard()->Update();
	ServiceLocator::GetMouse()->Update();
	ServiceLocator::GetController()->Update();
}

///-------------------------------------------/// 
/// ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å‡¦ç†
///-------------------------------------------///
// ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
bool InputService::PushKey(BYTE keyNum) {
	return ServiceLocator::GetKeyboard()->PushKey(keyNum);
}
// ã‚­ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
bool InputService::TriggerKey(BYTE keyNum) {
	return ServiceLocator::GetKeyboard()->TriggerKey(keyNum);
}

///-------------------------------------------/// 
/// ãƒã‚¦ã‚¹å‡¦ç†
///-------------------------------------------///
// ãƒã‚¦ã‚¹ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
bool InputService::PushMouse(MouseButtonType button) {
	return ServiceLocator::GetMouse()->PushMaouseButton(button);
}
// ãƒã‚¦ã‚¹ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
bool InputService::TriggerMouse(MouseButtonType button) {
	return ServiceLocator::GetMouse()->TriggerMouseButton(button);
}
// ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®ä½ç½®ã‚’å–å¾—ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ç³»ï¼‰
POINT InputService::GetMousePosition() {
	return ServiceLocator::GetMouse()->GetMouseCursorPosition();
}
// ãƒã‚¦ã‚¹ã®Xè»¸ç§»å‹•é‡ã‚’å–å¾—
LONG InputService::GetMouseDeltaX() {
	return ServiceLocator::GetMouse()->GetMouseDeltaX();
}
// ãƒã‚¦ã‚¹ã®Yè»¸ç§»å‹•é‡ã‚’å–å¾—
LONG InputService::GetMouseDeltaY() {
	return ServiceLocator::GetMouse()->GetMouseDeltaY();
}
// ãƒã‚¦ã‚¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é‡ã‚’å–å¾—
LONG InputService::GetMouseDeltaScroll() {
	return ServiceLocator::GetMouse()->GetMouseDeltaScroll();
}

///-------------------------------------------/// 
/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼å‡¦ç†
///-------------------------------------------///
// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å–å¾—
bool InputService::GetJoystickState(int stickNo, XINPUT_STATE& out) {
	return ServiceLocator::GetController()->GetJoystickState(stickNo, out);
}
bool InputService::GetJoystickStatePrevious(int stickNo, XINPUT_STATE& out) {
	return ServiceLocator::GetController()->GetJoystickStatePrevious(stickNo, out);
}
bool InputService::GetJoystickState(int stickNo, DIJOYSTATE2& out) {
	return ServiceLocator::GetController()->GetJoystickState(stickNo, out);
}
bool InputService::GetJoystickStatePrevious(int stickNo, DIJOYSTATE2& out) {
	return ServiceLocator::GetController()->GetJoystickStatePrevious(stickNo, out);
}
// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®æŠ¼ä¸‹ãƒã‚§ãƒƒã‚¯
bool InputService::PushButton(int stickNo, ControllerButtonType button) {
	return ServiceLocator::GetController()->PushButton(stickNo, button);
}
bool InputService::TriggerButton(int stickNo, ControllerButtonType button) {
	return ServiceLocator::GetController()->TriggerButton(stickNo, button);
}
bool InputService::ReleaseButton(int stickNo, ControllerButtonType button) {
	return ServiceLocator::GetController()->ReleaseButton(stickNo, button);
}
// ãƒœã‚¿ãƒ³ã®æŠ¼ã—è¾¼ã¿é‡ã‚’å–å¾—
float InputService::GetTriggerValue(int stickNo, ControllerButtonType button) {
	return ServiceLocator::GetController()->GetTriggerValue(stickNo, button);
}
// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ³ã‚’å–å¾—
StickState InputService::GetLeftStickState(int stickNo) {
	return ServiceLocator::GetController()->GetLeftStickState(stickNo);
}
StickState InputService::GetRightStickState(int stickNo) {
	return ServiceLocator::GetController()->GetRightStickState(stickNo);
}
float InputService::GetStickValue(int stickNo, ControllerValueType valueType) {
	return ServiceLocator::GetController()->GetStickValue(stickNo, valueType);
}
// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å‰ãƒ•ãƒ¬ãƒ¼ãƒ çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹é–¢æ•°
StickState InputService::GetLeftStickStatePrevious(int stickNo) {
	return ServiceLocator::GetController()->GetLeftStickStatePrevious(stickNo);
}
StickState InputService::GetRightStickStatePrevious(int stickNo) {
	return ServiceLocator::GetController()->GetRightStickStatePrevious(stickNo);
}
// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ã¯ã˜ãï¼ˆ Flick ï¼‰ã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°
bool InputService::FlickLeftStick(int stickNo, float threshold) {
	return ServiceLocator::GetController()->FlickLeftStick(stickNo, threshold);
}
bool InputService::FlickRightStick(int stickNo, float threshold) {
	return ServiceLocator::GetController()->FlickRightStick(stickNo, threshold);
}


============================================================
File Path: Project/Engine/System/Service/InputService.h
============================================================
#pragma once
/// ===Includ=== ///
#include "Engine/DataInfo/InputData.h"

///=====================================================/// 
/// InputService
///=====================================================///
class InputService {
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	static void Update();

	/// ===ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰=== ///
	
	/// <summary>
	///  ã‚­ãƒ¼ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="keyNum">ãƒ—ãƒƒã‚·ãƒ¥ã™ã‚‹ã‚­ãƒ¼ã‚’è¡¨ã™ BYTE å‹ã®ç•ªå·ã€‚</param>
	/// <returns>æ“ä½œãŒæˆåŠŸã—ãŸå ´åˆã« true ã‚’ã€å¤±æ•—ã—ãŸå ´åˆã« false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static bool PushKey(BYTE keyNum);
	
	/// <summary>
	/// ã‚­ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="keyNum">ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹ã‚­ãƒ¼ã‚’è­˜åˆ¥ã™ã‚‹ BYTE å‹ã®ç•ªå·ã€‚</param>
	/// <returns>æ“ä½œãŒæˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static bool TriggerKey(BYTE keyNum);

	/// ===ãƒã‚¦ã‚¹=== ///
	
	/// <summary>
	/// ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã®æŠ¼ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="button">æŠ¼ã™ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã‚’æŒ‡å®šã—ã¾ã™ï¼ˆMouseButtonTypeï¼‰ã€‚</param>
	/// <returns>æ“ä½œãŒæˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static bool PushMouse(MouseButtonType button);

	/// <summary>
	/// ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã®ãƒˆãƒªã‚¬ãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="button">ãƒˆãƒªã‚¬ãƒ¼ã™ã‚‹ãƒã‚¦ã‚¹ãƒœã‚¿ãƒ³ã‚’ç¤ºã™ MouseButtonType å‹ã®å€¤ã€‚</param>
	/// <returns>æ“ä½œãŒæˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static bool TriggerMouse(MouseButtonType button);

	/// <summary>
	/// ãƒã‚¦ã‚¹ã‚«ãƒ¼ã‚½ãƒ«ã®ä½ç½®ã‚’å–å¾—ï¼ˆã‚¹ã‚¯ãƒªãƒ¼ãƒ³åº§æ¨™ç³»ï¼‰
	/// </summary>
	/// <returns>ç¾åœ¨ã®ãƒã‚¦ã‚¹ä½ç½®ã‚’ç¤ºã™POINTæ§‹é€ ä½“ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static POINT GetMousePosition();

	/// <summary>
	/// ãƒã‚¦ã‚¹ã®xè»¸ã‚’ç§»å‹•é‡ã‚’å–å¾—
	/// </summary>
	/// <returns>X è»¸æ–¹å‘ã®ç§»å‹•é‡ã‚’è¡¨ã™ LONG å€¤ã€‚æ­£ã®å€¤ã¯å³æ–¹å‘ã®ç§»å‹•ã€è² ã®å€¤ã¯å·¦æ–¹å‘ã®ç§»å‹•ã‚’ç¤ºã—ã¾ã™ã€‚</returns>
	static LONG GetMouseDeltaX();

	/// <summary>
	/// ãƒã‚¦ã‚¹ã®Yè»¸ã‚’ç§»å‹•é‡ã‚’å–å¾—
	/// </summary>
	/// <returns>Yè»¸æ–¹å‘ã®ç§»å‹•é‡ã®å·®åˆ†ã‚’LONGå‹ã§è¿”ã—ã¾ã™ã€‚</returns>
	static LONG GetMouseDeltaY();

	/// <summary>
	/// ãƒã‚¦ã‚¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é‡ã‚’å–å¾—
	/// </summary>
	/// <returns>ãƒã‚¦ã‚¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é‡ã‚’è¡¨ã™LONGå€¤ã€‚æ­£ã®å€¤ã¯ä¸Šæ–¹å‘/å‰æ–¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã€è² ã®å€¤ã¯ä¸‹æ–¹å‘/å¾Œæ–¹ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’ç¤ºã™ã“ã¨ãŒä¸€èˆ¬çš„ã§ã™ã€‚</returns>
	static LONG GetMouseDeltaScroll();

	/// ===ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©=== ///
	
	/// <summary>
	/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å–å¾—
	/// </summary>
	/// <param name="stickNo">å–å¾—å¯¾è±¡ã®ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ç•ªå·ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰ã€‚</param>
	/// <param name="out">å–å¾—ã—ãŸçŠ¶æ…‹ã‚’æ ¼ç´ã™ã‚‹å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã€‚XINPUT_STATE å‹ã¸ã®å‚ç…§ã€‚</param>
	/// <returns>çŠ¶æ…‹ã‚’æ­£å¸¸ã«å–å¾—ã§ããŸå ´åˆã¯ trueã€å–å¾—ã§ããªã‹ã£ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static bool GetJoystickState(int stickNo, XINPUT_STATE& out);
	static bool GetJoystickState(int stickNo, DIJOYSTATE2& out);

	/// <summary>
	/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å‰å›ã®çŠ¶æ…‹ã‚’å–å¾—
	/// </summary>
	/// <param name="stickNo">å–å¾—å¯¾è±¡ã®ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ç•ªå·ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰ã€‚ã©ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="out">å‡ºåŠ›ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã€‚å‰å›ã®çŠ¶æ…‹ãŒå—ã‘å–ã‚‰ã‚Œã‚‹ XINPUT_STATE æ§‹é€ ä½“ã¸ã®å‚ç…§ã€‚é–¢æ•°æˆåŠŸæ™‚ã«å€¤ãŒè¨­å®šã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>å‰å›ã®çŠ¶æ…‹ãŒæ­£å¸¸ã«å–å¾—ã§ããŸå ´åˆã¯ true ã‚’ã€å–å¾—ã«å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static bool GetJoystickStatePrevious(int stickNo, XINPUT_STATE& out);
	static bool GetJoystickStatePrevious(int stickNo, DIJOYSTATE2& out);

	/// <summary>
	/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®æŠ¼ä¸‹ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="stickNo">æ“ä½œå¯¾è±¡ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ï¼ˆã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼‰ã‚’è­˜åˆ¥ã™ã‚‹ç•ªå·ã€‚ã©ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã«å¯¾ã—ã¦ãƒœã‚¿ãƒ³æ“ä½œã‚’è¡Œã†ã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="button">æŠ¼ã™ãƒœã‚¿ãƒ³ã‚’ç¤ºã™å€¤ã€‚ControllerButtonType åˆ—æŒ™å‹ã®ã„ãšã‚Œã‹ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <returns>æ“ä½œãŒæˆåŠŸã—ãŸã‹ã©ã†ã‹ã‚’ç¤ºã™å€¤ã€‚æˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ falseã€‚</returns>
	static bool PushButton(int stickNo, ControllerButtonType button);

	/// <summary>
	/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒˆãƒªã‚¬ãƒ¼ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="stickNo">åˆ¤å®šå¯¾è±¡ã®ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã¾ãŸã¯ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®è­˜åˆ¥ç•ªå·ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰ã€‚</param>
	/// <param name="button">åˆ¤å®šã™ã‚‹ãƒœã‚¿ãƒ³ã‚’è¡¨ã™ ControllerButtonType å‹ã®å€¤ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸãƒœã‚¿ãƒ³ãŒãƒˆãƒªã‚¬ãƒ¼ã•ã‚Œã¦ã„ã‚Œã° trueã€ãã†ã§ãªã‘ã‚Œã° falseã€‚</returns>
	static bool TriggerButton(int stickNo, ControllerButtonType button);

	/// <summary>
	/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ãƒœã‚¿ãƒ³ã‚’é›¢ã—ãŸçŠ¶æ…‹ã‚’ãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="stickNo">æ“ä½œå¯¾è±¡ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã¾ãŸã¯ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ç•ªå·ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰ã§ã™ã€‚</param>
	/// <param name="button">è§£é™¤ã™ã‚‹ãƒœã‚¿ãƒ³ã‚’ç¤ºã™ ControllerButtonType å‹ã®å€¤ã§ã™ã€‚</param>
	/// <returns>ãƒœã‚¿ãƒ³ã®è§£æ”¾å‡¦ç†ãŒæˆåŠŸã—ãŸå ´åˆã¯ trueã€å¤±æ•—ã—ãŸå ´åˆã¯ false ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static bool ReleaseButton(int stickNo, ControllerButtonType button);

	/// <summary>
	/// ãƒœã‚¿ãƒ³ã®æŠ¼ã—è¾¼ã¿é‡ã‚’å–å¾—
	/// </summary>
	/// <param name="stickNo">å…¥åŠ›ã‚’å–å¾—ã™ã‚‹ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚’è­˜åˆ¥ã™ã‚‹ç•ªå·ã€‚</param>
	/// <param name="button">å–å¾—å¯¾è±¡ã®ãƒœã‚¿ãƒ³ï¼ˆãƒˆãƒªã‚¬ãƒ¼ï¼‰ã‚’ç¤ºã™ ControllerButtonType å‹ã®å€¤ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®æŒ‡å®šãƒœã‚¿ãƒ³ã«å¯¾å¿œã™ã‚‹ãƒˆãƒªã‚¬ãƒ¼ã®ç¾åœ¨ã®å…¥åŠ›å€¤ã‚’è¿”ã—ã¾ã™ã€‚é€šå¸¸ã¯ 0.0ï¼ˆæœªæŠ¼ä¸‹ï¼‰ã‹ã‚‰ 1.0ï¼ˆå…¨æŠ¼ä¸‹ï¼‰ã®ç¯„å›²ã®æµ®å‹•å°æ•°ç‚¹å€¤ã§ã™ã€‚</returns>
	static float GetTriggerValue(int stickNo, ControllerButtonType button);

	/// <summary>
	/// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ³ã‚’å–å¾—
	/// </summary>
	/// <param name="stickNo">çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ç•ªå·ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®çŠ¶æ…‹ã‚’ç¤ºã™ StickState å€¤ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	static StickState GetLeftStickState(int stickNo);
	static StickState GetRightStickState(int stickNo);

	/// <summary>
	/// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å‰ãƒ•ãƒ¬ãƒ¼ãƒ çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹é–¢æ•°
	/// </summary>
	/// <param name="stickNo">çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ç•ªå·ï¼ˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰ã€‚é€šå¸¸ã¯ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ã‚„å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯è­˜åˆ¥å­ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¹ãƒ†ã‚£ãƒƒã‚¯ç•ªå·ã«å¯¾å¿œã™ã‚‹å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ç›´å‰ã®çŠ¶æ…‹ã‚’è¡¨ã™ StickState å€¤ã€‚</returns>
	static StickState GetLeftStickStatePrevious(int stickNo);
	static StickState GetRightStickStatePrevious(int stickNo);

	/// <summary>
	/// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å€¤ã‚’å–å¾—
	/// </summary>
	/// <param name="stickNo">å–å¾—ã™ã‚‹ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ç•ªå·ï¼ˆè­˜åˆ¥å­ï¼‰ã€‚</param>
	/// <param name="valueType">å–å¾—ã™ã‚‹å€¤ã®ç¨®é¡ã‚’ç¤ºã™ ControllerValueType å‹ã®å€¤ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¹ãƒ†ã‚£ãƒƒã‚¯ã¨å€¤ç¨®åˆ¥ã«å¯¾å¿œã™ã‚‹æµ®å‹•å°æ•°ç‚¹å€¤ï¼ˆfloatï¼‰ã€‚</returns>
	static float GetStickValue(int stickNo, ControllerValueType valueType);

	/// <summary>
	/// ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ã¯ã˜ãï¼ˆ Flick ï¼‰ã‚’æ¤œå‡ºã™ã‚‹é–¢æ•°
	/// </summary>
	/// <param name="stickNo">åˆ¤å®šã™ã‚‹ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®ç•ªå·ã€‚</param>
	/// <param name="threshold">ãƒ•ãƒªãƒƒã‚¯ã¨è¦‹ãªã™å…¥åŠ›ã®å¼·ã•ã®é–¾å€¤ã€‚çœç•¥æ™‚ã®æ—¢å®šå€¤ã¯ 0.7fã€‚</param>
	/// <returns>ãƒ•ãƒªãƒƒã‚¯ãŒæ¤œå‡ºã•ã‚ŒãŸå ´åˆã¯ trueã€æ¤œå‡ºã•ã‚Œãªã„å ´åˆã¯ falseã€‚</returns>
	static bool FlickLeftStick(int stickNo, float threshold = 0.7f);
	static bool FlickRightStick(int stickNo, float threshold = 0.7f);

};



============================================================
File Path: Project/Engine/System/Service/Loader.cpp
============================================================
#include "Loader.h"
// Manager
#include "Engine/System/Managers/TextureManager.h"
#include "Engine/System/Managers/ModelManager.h"
#include "Engine/System/Managers/AudioManager.h"
#include "Engine/System/Managers/CSVManager.h"
#include "Engine/System/Managers/AnimationManager.h"
#include "Engine/system/Managers/LevelManager.h"
// ServiceLocator
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£
///-------------------------------------------///
void Loader::LoadTexture(const std::string& key, const std::string& filePath) {
	// ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
	const std::string& baseDirectorPath = "./Resource/Textures";
	ServiceLocator::GetTextureManager()->LoadTexture(key, baseDirectorPath + "/" + filePath);
}

///-------------------------------------------/// 
/// ãƒ¢ãƒ‡ãƒ«
///-------------------------------------------///
void Loader::LoadModel(const std::string& Key, const std::string& filename) {
	// ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
	const std::string& baseDirectorPath = "./Resource/Models";
	ServiceLocator::GetModelManager()->Load(baseDirectorPath, Key, filename);
}

///-------------------------------------------/// 
/// csv
///-------------------------------------------///
void Loader::LoadCSV(const std::string& filename) {
	const std::string& baseDirectorPath = "./Resource/CSV";
	ServiceLocator::GetCSVManager()->Load(baseDirectorPath + "/" + filename);
}

///-------------------------------------------/// 
/// Json
///-------------------------------------------///
void Loader::LoadLevelJson(const std::string& filename) {
	// ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
	const std::string& baseDirectorPath = "./Resource/Json";
	ServiceLocator::GetLevelManager()->LoadLevelJson(baseDirectorPath, filename);
}

///-------------------------------------------/// 
/// Animation
///-------------------------------------------///
void Loader::LoadAnimation(const std::string& key, const std::string& filename) {
	// ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
	const std::string& baseDirectorPath = "./Resource/Animations";
	ServiceLocator::GetModelManager()->Load(baseDirectorPath, key, filename);
	ServiceLocator::GetAnimationManager()->Load(baseDirectorPath, key, filename);
}
void Loader::LoadAnimationdifferentModel(const std::string& key, const std::string& ModelFilename, const std::string& AnimationFilename) {
	// ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
	const std::string& baseDirectorPath = "./Resource/Animations";
	ServiceLocator::GetModelManager()->Load(baseDirectorPath, key, ModelFilename);
	ServiceLocator::GetAnimationManager()->Load(baseDirectorPath, key, AnimationFilename);
}

///-------------------------------------------/// 
/// WAVE
///-------------------------------------------///
void Loader::LoadWave(const std::string& key, const std::string& filename) {
	const std::string& directorPath = "./Resource/BGM";
	ServiceLocator::GetAudioManager()->Load(key, directorPath + "/" + filename, false);
}

///-------------------------------------------/// 
/// MP3
///-------------------------------------------///
void Loader::LoadMP3(const std::string& key, const std::string& filename) {
	const std::string& directorPath = "./Resource/BGM";
	ServiceLocator::GetAudioManager()->Load(key, directorPath + "/" + filename, true);
}

///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®è§£æ”¾
///-------------------------------------------///
void Loader::UnloadSound(const std::string& key) {
	ServiceLocator::GetAudioManager()->Unload(key);
}

///-------------------------------------------/// 
/// éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ‹¬é–‹æ”¾
///-------------------------------------------///
void Loader::AllUnloadSound() {
	ServiceLocator::GetAudioManager()->UnloadAll();
}


============================================================
File Path: Project/Engine/System/Service/Loader.h
============================================================
#pragma once
/// ===Include=== ///
// C++
#include <string>

///=====================================================/// 
/// Loadé–¢æ•°
///=====================================================///
class Loader {
public:
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="key">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è­˜åˆ¥ãŠã‚ˆã³å‚ç…§ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ã€‚</param>
	/// <param name="filePath">èª­ã¿è¾¼ã‚€ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã€‚</param>
	static void LoadTexture(const std::string& key, const std::string& filePath);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="Key">èª­ã¿è¾¼ã‚€ãƒ¢ãƒ‡ãƒ«ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®ã‚­ãƒ¼ã€‚</param>
	/// <param name="filename">ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã€‚</param>
	static void LoadModel(const std::string& Key, const std::string& filename);

	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="Key">èª­ã¿è¾¼ã‚“ã ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã«å‰²ã‚Šå½“ã¦ã‚‹è­˜åˆ¥ã‚­ãƒ¼ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã€‚</param>
	static void LoadAnimation(const std::string& Key, const std::string& filename);

	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ã¿ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="directorPath">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŠã‚ˆã³ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã¸ã®ãƒ‘ã‚¹ã€‚</param>
	/// <param name="ModelFilename">èª­ã¿è¾¼ã‚€ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åï¼‰ã€‚</param>
	/// <param name="AnimationFilename">èª­ã¿è¾¼ã‚€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åï¼‰ã€‚</param>
	static void LoadAnimationdifferentModel(const std::string& directorPath, const std::string& ModelFilename, const std::string& AnimationFilename);
	
	/// <summary>
	/// CSVãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ CSV ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã€‚</param>
	static void LoadCSV(const std::string& filename);

	/// <summary>
	/// Jsonãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="filename">èª­ã¿è¾¼ã‚€JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯åå‰ã€‚</param>
	static void LoadLevelJson(const std::string& filename);

	/// <summary>
	/// Waveãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="key">èª­ã¿è¾¼ã‚“ã éŸ³å£°ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®ä¸€æ„ã®ã‚­ãƒ¼ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€WAVãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã€‚</param>
	static void LoadWave(const std::string& key, const std::string& filename);

	/// <summary>
	/// MP3ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿å‡¦ç†
	/// </summary>
	/// <param name="key">MP3 ãƒªã‚½ãƒ¼ã‚¹ã‚’è­˜åˆ¥ã™ã‚‹ãŸã‚ã®ä¸€æ„ã®ã‚­ãƒ¼ã€‚</param>
	/// <param name="filename">èª­ã¿è¾¼ã‚€ MP3 ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«åã€‚</param>
	static void LoadMP3(const std::string& key, const std::string& filename);

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®è§£æ”¾å‡¦ç†
	/// </summary>
	/// <param name="key">è§£æ”¾ã™ã‚‹ã‚µã‚¦ãƒ³ãƒ‰ã‚’è­˜åˆ¥ã™ã‚‹ã‚­ãƒ¼ã€‚</param>
	static void UnloadSound(const std::string& key);

	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿ã®ä¸€æ‹¬é–‹æ”¾å‡¦ç†
	/// </summary>
	static void AllUnloadSound();
};



============================================================
File Path: Project/Engine/System/Service/OffScreenService.cpp
============================================================
#include "OffScreenService.h"
// c++
#include <cassert>
// Engine
#include "Engine/Graphics/OffScreen/OffScreenRenderer.h"
// ServiceLocator
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// OffScreenTypeã®è¨­å®š
void OffScreenService::SetOffScreenType(OffScreenType type) {
	return ServiceLocator::GetOffScreenRenderer()->SetType(type);
}
// Dissolve
void OffScreenService::SetDissolveData(DissolveData data) {
	if (ServiceLocator::GetOffScreenRenderer()->GetType() != OffScreenType::Dissolve) return;
	return ServiceLocator::GetOffScreenRenderer()->GetDissolve()->SetData(data);
}
// RadiusBlur
void OffScreenService::SetRadiusBlurData(RadiusBlurData data) {
	if (ServiceLocator::GetOffScreenRenderer()->GetType() != OffScreenType::RadiusBlur) return;
	return ServiceLocator::GetOffScreenRenderer()->GetRadiusBlur()->SetData(data);
}
// Vignette
void OffScreenService::SetVignetteData(VignetteData data) {
	if (ServiceLocator::GetOffScreenRenderer()->GetType() != OffScreenType::Vignette) return;
	return ServiceLocator::GetOffScreenRenderer()->GetVignette()->SetData(data);
}
// ShatterGlass
void OffScreenService::SetShatterGlassData(ShatterGlassData data) {
	if (ServiceLocator::GetOffScreenRenderer()->GetType() != OffScreenType::ShatterGlass) return;
	return ServiceLocator::GetOffScreenRenderer()->GetShatterGlass()->SetData(data);
}

============================================================
File Path: Project/Engine/System/Service/OffScreenService.h
============================================================
#pragma once
/// ===Include=== ///
// C++
#include <string>
#include <d3d12.h>
// DirectXTex
#include "DirectXTex.h"
// Data
#include "Engine/DataInfo/OffScreenData.h"

/// ===å‰æ–¹å®£è¨€=== ///
struct DissolveData;
struct RadiusBlurData;
struct VignetteData;
struct ShatterGlassData;


///=====================================================/// 
/// OffScreenService
///=====================================================///
class OffScreenService {
public: /// ===OffScreen=== ///

	/// <summary>
	/// OffScreenã®ç¨®é¡ã‚’è¨­å®š
	/// </summary>
	/// <param name="type">è¨­å®šã™ã‚‹ã‚ªãƒ•ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ã€‚é€šå¸¸ã¯ OffScreenType åˆ—æŒ™å‹ã®å€¤ã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	static void SetOffScreenType(OffScreenType type);

	/// <summary>
	/// Dissolvedataã®è¨­å®š
	/// </summary>
	/// <param name="data">è¨­å®šã™ã‚‹ DissolveData å‹ã®ãƒ‡ãƒ¼ã‚¿ã€‚å€¤æ¸¡ã—ã§å—ã‘å–ã‚‰ã‚Œã€ã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ã€‚</param>
	static void SetDissolveData(DissolveData data);

	/// <summary>
	/// RadiusBlurDataã®è¨­å®š
	/// </summary>
	/// <param name="data">åŠå¾„ãƒ–ãƒ©ãƒ¼å‡¦ç†ã«ä½¿ç”¨ã™ã‚‹è¨­å®šã‚’æ ¼ç´ã—ãŸ RadiusBlurData æ§‹é€ ä½“ï¼ˆå€¤æ¸¡ã—ï¼‰ã€‚</param>
	static void SetRadiusBlurData(RadiusBlurData data);

	/// <summary>
	/// VignetteDataã®è¨­å®š
	/// </summary>
	/// <param name="data">è¨­å®šã™ã‚‹ãƒ“ãƒãƒƒãƒˆãƒ‡ãƒ¼ã‚¿ã€‚VignetteData å‹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã§ã€ãƒ“ãƒãƒƒãƒˆã®å¼·åº¦ã‚„ç¯„å›²ãªã©ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã‚’å«ã¿ã¾ã™ã€‚</param>
	static void SetVignetteData(VignetteData data);

	/// <summary>
	/// ShatterGlassEffectDataã®è¨­å®š
	/// </summary>
	/// <param name="data">è¨­å®šã™ã‚‹ ShatterGlassData ã®å€¤ã€‚å€¤æ¸¡ã—ã•ã‚Œã€å†…éƒ¨çŠ¶æ…‹ãŒã“ã®å€¤ã§æ›´æ–°ã•ã‚Œã‚‹ã€‚</param>
	static void SetShatterGlassData(ShatterGlassData data);

};



============================================================
File Path: Project/Engine/System/Service/ParticleService.cpp
============================================================
#include "ParticleService.h"
// Manager
#include "Engine/System/Managers/ParticleManager.h"
// ServiceLocator
#include "ServiceLocator.h"
// Definition
#include "Engine/Graphics/Particle/ParticleDefinition.h"
#include "Engine/Graphics/Particle/ParticleParameter.h"

///-------------------------------------------/// 
/// å®šç¾©ã®ç®¡ç†
///-------------------------------------------///

// JSONã‹ã‚‰å®šç¾©ã‚’èª­ã¿è¾¼ã¿
void ParticleService::LoadParticleDefinition(const std::string& jsonPath) {
	// ãƒ™ãƒ¼ã‚¹ã®ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒ‘ã‚¹
	const std::string& baseDirectoryPath = "./Resource/Json/Particles";
	return ServiceLocator::GetParticleManager()->LoadParticleDefinition(baseDirectoryPath + "/" + jsonPath);
}

// å®šç¾©ã‚’ç›´æ¥è¿½åŠ 
void ParticleService::AddParticleDefinition(const std::string& name, const ParticleDefinition& definition) {
	ServiceLocator::GetParticleManager()->AddParticleDefinition(name, definition);
}

// å®šç¾©ã‚’å‰Šé™¤
void ParticleService::RemoveParticleDefinition(const std::string& name) {
	ServiceLocator::GetParticleManager()->RemoveParticleDefinition(name);
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ“ä½œ
///-------------------------------------------///
// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿ
ParticleGroup* ParticleService::Emit(const std::string& name, const Vector3& translate) {
	return ServiceLocator::GetParticleManager()->Emit(name, translate);
}

// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®š
void ParticleService::SetTexture(const std::string& name, const std::string& textureName) {
	ServiceLocator::GetParticleManager()->SetTexture(name, textureName);
}

// ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¨­å®šï¼ˆå‹å®‰å…¨ç‰ˆï¼‰
void ParticleService::SetParameter(const std::string& name, ParticleParameter param, float value) {
	ServiceLocator::GetParticleManager()->SetParameter(name, param, value);
}

// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’åœæ­¢
void ParticleService::StopParticle(const std::string& name) {
	ServiceLocator::GetParticleManager()->StopParticle(name);
}

// å…¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
void ParticleService::RemoveAllParticles() {
	ServiceLocator::GetParticleManager()->RemoveAllParticles();
}

///-------------------------------------------/// 
/// æƒ…å ±å–å¾—
///-------------------------------------------///
// å®šç¾©ã‚’å–å¾—
const ParticleDefinition* ParticleService::GetDefinition(const std::string& name) {
	return ServiceLocator::GetParticleManager()->GetDefinition(name);
}

// å®šç¾©ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
bool ParticleService::HasDefinition(const std::string& name) {
	return ServiceLocator::GetParticleManager()->HasDefinition(name);
}

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’å–å¾—
uint32_t ParticleService::GetActiveParticleCount(const std::string& name) {
	return ServiceLocator::GetParticleManager()->GetActiveParticleCount(name);
}

// å®šç¾©åã®ä¸€è¦§ã‚’å–å¾—
std::vector<std::string> ParticleService::GetDefinitionNames() {
	return ServiceLocator::GetParticleManager()->GetDefinitionNames();
}

// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚°ãƒ«ãƒ¼ãƒ—æ•°ã‚’å–å¾—
size_t ParticleService::GetActiveGroupCount(const std::string& name) {
	return ServiceLocator::GetParticleManager()->GetActiveGroupCount(name);
}

============================================================
File Path: Project/Engine/System/Service/ParticleService.h
============================================================
#pragma once
/// ===include=== ///
// ParticleGroup
#include "Engine/Graphics/Particle/ParticleGroup.h"
// c++
#include <string>
#include <vector>
// Math
#include "Math/Vector3.h"

/// ===å‰æ–¹å®£è¨€=== ///
struct ParticleDefinition;
enum class ParticleParameter;

///=====================================================/// 
/// ParticleServiceï¼ˆæ–°æ–¹å¼å¯¾å¿œï¼‰
/// ParticleManagerã¸ã®é™çš„ã‚¢ã‚¯ã‚»ã‚¹ã‚’æä¾›
///=====================================================///
class ParticleService {
public:

	/// ===å®šç¾©ã®ç®¡ç†=== ///

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®è¿½åŠ ï¼ˆJSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ï¼‰
	/// </summary>
	/// <param name="jsonPath">JSONãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹</param>
	/// <returns>èª­ã¿è¾¼ã¿ã«æˆåŠŸã—ãŸã‹ã©ã†ã‹</returns>
	static void LoadParticleDefinition(const std::string& jsonPath);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®è¿½åŠ ï¼ˆç›´æ¥æŒ‡å®šï¼‰
	/// </summary>
	/// <param name="name">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="definition">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©</param>
	static void AddParticleDefinition(const std::string& name, const ParticleDefinition& definition);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿå‡¦ç†
	/// </summary>
	/// <param name="name">ç™ºç”Ÿã•ã›ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="translate">ç™ºç”Ÿã•ã›ã‚‹å ´æ‰€</param>
	/// <returns>ç”Ÿæˆã•ã‚ŒãŸParticleGroupã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆnullptrã®å ´åˆã¯å¤±æ•—ï¼‰</returns>
	static ParticleGroup* Emit(const std::string& name, const Vector3& translate);

	/// <summary>
	/// æŒ‡å®šã—ãŸåå‰ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ã™ã¹ã¦åœæ­¢
	/// </summary>
	/// <param name="name">åœæ­¢ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	static void StopParticle(const std::string& name);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®å‰Šé™¤
	/// </summary>
	/// <param name="name">å‰Šé™¤ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	static void RemoveParticleDefinition(const std::string& name);

	/// <summary>
	/// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‰Šé™¤
	/// </summary>
	static void RemoveAllParticles();

public: /// ===è¨­å®š=== ///
	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®š
	/// </summary>
	/// <param name="name">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è¨­å®šã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="textureName">è¨­å®šã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®åå‰</param>
	static void SetTexture(const std::string& name, const std::string& textureName);

	/// <summary>
	/// å®Ÿè¡Œæ™‚ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¤‰æ›´ï¼ˆå‹å®‰å…¨ç‰ˆï¼‰
	/// </summary>
	/// <param name="name">å¯¾è±¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="param">å¤‰æ›´ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</param>
	/// <param name="value">è¨­å®šã™ã‚‹å€¤</param>
	static void SetParameter(const std::string& name, ParticleParameter param, float value);

public: /// ===å–å¾—=== ///
	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã‚’å–å¾—
	/// </summary>
	/// <param name="name">å–å¾—ã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <returns>ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯nullptrï¼‰</returns>
	static const ParticleDefinition* GetDefinition(const std::string& name);

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ãŒç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
	/// </summary>
	/// <param name="name">ç¢ºèªã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <returns>ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯true</returns>
	static bool HasDefinition(const std::string& name);

	/// <summary>
	/// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’å–å¾—
	/// </summary>
	/// <param name="name">å¯¾è±¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç·æ•°</returns>
	static uint32_t GetActiveParticleCount(const std::string& name);

	/// <summary>
	/// ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å®šç¾©ã®ä¸€è¦§ã‚’å–å¾—
	/// </summary>
	/// <returns>å®šç¾©åã®ãƒªã‚¹ãƒˆ</returns>
	static std::vector<std::string> GetDefinitionNames();

	/// <summary>
    /// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—æ•°ã‚’å–å¾—
    /// </summary>
    /// <param name="name">å¯¾è±¡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
    /// <returns>ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªã‚°ãƒ«ãƒ¼ãƒ—æ•°</returns>
	static size_t GetActiveGroupCount(const std::string& name);
};

============================================================
File Path: Project/Engine/System/Service/Render.cpp
============================================================
#include "Render.h"
// Manager
#include "Engine/System/Managers/PiplineManager.h"
#include "Engine/System/Managers/TextureManager.h"
// ServiceLocator
#include "ServiceLocator.h"

///-------------------------------------------/// 
/// Pipeline
///-------------------------------------------///
// PSOã®å–å¾—
void Render::SetPSO(ID3D12GraphicsCommandList* commandList, PipelineType type, BlendMode mode, D3D12_PRIMITIVE_TOPOLOGY topology) {
	ServiceLocator::GetPipelineManager()->SetPipeline(commandList, type, mode, topology);
}

///-------------------------------------------/// 
/// Texture
///-------------------------------------------///
// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹é–‹å§‹ç•ªå·ã®å–å¾—
void Render::SetGraphicsRootDescriptorTable(ID3D12GraphicsCommandList* commandList, UINT RootParameterIndex, std::string key) { 
	ServiceLocator::GetTextureManager()->SetGraphicsRootDescriptorTable(commandList, RootParameterIndex, key);
}


============================================================
File Path: Project/Engine/System/Service/Render.h
============================================================
#pragma once
/// ===Include=== ///
// C++
#include <string>
#include <d3d12.h>
// Data
#include "Engine/DataInfo/PipelineStateObjectType.h"


///=====================================================/// 
/// ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚µãƒ¼ãƒ“ã‚¹ãƒ­ã‚±ãƒ¼ã‚¿
///=====================================================///
class Render {
public:

	/// <summary>
	/// æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¿ã‚¤ãƒ—ã€ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€ãŠã‚ˆã³ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ãƒ¼ã«åŸºã¥ã„ã¦ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆä¸Šã®ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆPSOï¼‰ã‚’è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="commandList">ã‚³ãƒãƒ³ãƒ‰ã®è¨˜éŒ²å…ˆã¨ãªã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚PSO ã®è¨­å®šã¯ã“ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã«è¨˜éŒ²ã•ã‚Œã¾ã™ã€‚</param>
	/// <param name="type">è¨­å®šã™ã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç¨®é¡ã‚’ç¤ºã™ PipelineType åˆ—æŒ™å€¤ï¼ˆä¾‹: ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã€ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ãƒˆãªã©ï¼‰ã€‚</param>
	/// <param name="mode">ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã™ã‚‹ BlendMode åˆ—æŒ™å€¤ã€‚</param>
	/// <param name="topology">ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’æŒ‡å®šã™ã‚‹ D3D12_PRIMITIVE_TOPOLOGY å€¤ã€‚æ—¢å®šå€¤ã¯ D3D_PRIMITIVE_TOPOLOGY_TRIANGLELISTã€‚</param>
	static void SetPSO(ID3D12GraphicsCommandList* commandList, PipelineType type, BlendMode mode, D3D12_PRIMITIVE_TOPOLOGY topology = D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	/// <summary>
	/// æŒ‡å®šã—ãŸã‚­ãƒ¼ã«å¯¾å¿œã™ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’ã€æŒ‡å®šã—ãŸãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä½ç½®ã«è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="commandList">ã‚³ãƒãƒ³ãƒ‰ã‚’è¨˜éŒ²ã™ã‚‹ ID3D12GraphicsCommandList ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚ã“ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆä¸Šã§ãƒ«ãƒ¼ãƒˆãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã®è¨­å®šãŒè¡Œã‚ã‚Œã¾ã™ã€‚</param>
	/// <param name="RootParameterIndex">ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£å†…ã®ã€ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è¨­å®šã™ã‚‹ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆUINTï¼‰ã€‚</param>
	/// <param name="key">è¨­å®šã™ã‚‹ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ†ãƒ¼ãƒ–ãƒ«ã‚’è­˜åˆ¥ã™ã‚‹æ–‡å­—åˆ—ã‚­ãƒ¼ã€‚</param>
	static void SetGraphicsRootDescriptorTable(ID3D12GraphicsCommandList* commandList, UINT RootParameterIndex, std::string key);
};



============================================================
File Path: Project/Engine/System/Service/ServiceLocator.cpp
============================================================
#include "ServiceLocator.h"
// c++
#include <cassert>

///-------------------------------------------/// 
/// å…¨ã¦ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›
///-------------------------------------------///
void ServiceLocator::ProvideAll(const ServiceRegister& registry) {
	/// ===nullãƒã‚§ãƒƒã‚¯=== ///
	// WinApp
	assert(registry.winApp);
	// DXCommon
	assert(registry.dxCommon);
	// SRV, RTV, DSV
	assert(registry.srvManager);
	assert(registry.dsvManager);
	assert(registry.rtvManager);
	// PipelineManager
	assert(registry.pipelineManager);
	// TextureManager
	assert(registry.textureManager);
	// ModelManager
	assert(registry.modelManager);
	// AnimationManager
	assert(registry.animationManager);
	// AudioManager
	assert(registry.audioManager);
	// CSVManager
	assert(registry.csvManager);
	// LevelManager
	assert(registry.levelManager);
	// OffScreenRenderer
	assert(registry.offScreenRenderer);
	// LineObject3D
	assert(registry.lineObject3D);
	// Input
	assert(registry.keyboard);
	assert(registry.mouse);
	assert(registry.controller);
	// CameraManager
	assert(registry.cameraManager);
	// ParticleManager
	assert(registry.particleManager);
	// ColliderManager
	assert(registry.colliderManager);
	// DeltaTime
	assert(registry.deltaTime);

	/// ===ä»£å…¥=== ///
	// WinApp
	winApp_ = registry.winApp;
	// DXCommon
	dxCommon_ = registry.dxCommon;
	// SRV, RTV, DSV
	srvManager_ = registry.srvManager;
	rtvManager_ = registry.rtvManager;
	dsvManager_ = registry.dsvManager;
	// PipelineManager
	pipelineManager_ = registry.pipelineManager;
	// Texture
	textureManager_ = registry.textureManager;
	// Model
	modelManager_ = registry.modelManager;
	// Animation
	animationManager_ = registry.animationManager;
	// Audio
	audioManager_ = registry.audioManager;
	// CSV
	csvManager_ = registry.csvManager;
	// Level
	levelManager_ = registry.levelManager;
	// OffScreen
	offScreenRenderer_ = registry.offScreenRenderer;
	// LineObject
	lineObject3D_ = registry.lineObject3D;
	// Input
	keyboard_ = registry.keyboard;
	mouse_ = registry.mouse;
	controller_ = registry.controller;
	// CameraManager
	cameraManager_ = registry.cameraManager;
	// ParticleManager
	particleManager_ = registry.particleManager;
	// ColliderManager
	colliderManager_ = registry.colliderManager;
	// DeltaTime
	deltaTime_ = registry.deltaTime;
}

///-------------------------------------------/// 
/// å…¨ã¦ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’çµ‚äº†
///-------------------------------------------///
void ServiceLocator::Finalize() {
	colliderManager_ = nullptr;
	particleManager_ = nullptr;
	cameraManager_ = nullptr;
	controller_ = nullptr;
	mouse_ = nullptr;
	keyboard_ = nullptr;
	levelManager_ = nullptr;
	csvManager_ = nullptr;
	audioManager_ = nullptr;
	lineObject3D_ = nullptr;
	offScreenRenderer_ = nullptr;
	animationManager_ = nullptr;
	modelManager_ = nullptr;
	textureManager_ = nullptr;
	pipelineManager_ = nullptr;
	dsvManager_ = nullptr;
	rtvManager_ = nullptr;
	srvManager_ = nullptr;
	deltaTime_ = nullptr;
	winApp_ = nullptr;
	dxCommon_ = nullptr;
}

///-------------------------------------------/// 
/// DXCommon
///-------------------------------------------///
DXCommon* ServiceLocator::GetDXCommon() { return dxCommon_; }

///-------------------------------------------/// 
/// WinApp
///-------------------------------------------///
WinApp* ServiceLocator::GetWinApp() { return winApp_; }

///-------------------------------------------/// 
/// SRVManager
///-------------------------------------------///
SRVManager* ServiceLocator::GetSRVManager() { return srvManager_; }

///-------------------------------------------/// 
/// RTVManager
///-------------------------------------------///
RTVManager* ServiceLocator::GetRTVManager() { return rtvManager_; }

///-------------------------------------------/// 
/// DSVManager
///-------------------------------------------///
DSVManager* ServiceLocator::GetDSVManager() { return dsvManager_; }

///-------------------------------------------/// 
/// PipelineManager
///-------------------------------------------///
PipelineManager* ServiceLocator::GetPipelineManager() { return pipelineManager_; }

///-------------------------------------------/// 
/// TextureManager
///-------------------------------------------///
TextureManager* ServiceLocator::GetTextureManager() { return textureManager_; }

///-------------------------------------------/// 
/// ModelManager
///-------------------------------------------///
ModelManager* ServiceLocator::GetModelManager() { return modelManager_; }

///-------------------------------------------/// 
/// AnimationManager
///-------------------------------------------///
AnimationManager* ServiceLocator::GetAnimationManager() { return animationManager_; }

///-------------------------------------------/// 
/// CSVManager
///-------------------------------------------///
CSVManager* ServiceLocator::GetCSVManager() { return csvManager_; }

///-------------------------------------------/// 
/// LevelManager
///-------------------------------------------///
LevelManager* ServiceLocator::GetLevelManager() { return levelManager_; }

///-------------------------------------------/// 
/// AudioManager
///-------------------------------------------///
AudioManager* ServiceLocator::GetAudioManager() { return audioManager_; }

///-------------------------------------------/// 
/// LineObject3D
///-------------------------------------------///
LineObject3D* ServiceLocator::GetLineObject3D() { return lineObject3D_; }

///-------------------------------------------/// 
/// OffScreenRenderer
///-------------------------------------------///
OffScreenRenderer* ServiceLocator::GetOffScreenRenderer() { return offScreenRenderer_; }

///-------------------------------------------/// 
/// Input
///-------------------------------------------///
Keyboard* ServiceLocator::GetKeyboard() { return keyboard_; }
Mouse* ServiceLocator::GetMouse() { return mouse_; }
Controller* ServiceLocator::GetController() { return controller_; }

///-------------------------------------------/// 
/// CameraManager
///-------------------------------------------///
CameraManager* ServiceLocator::GetCameraManager() { return cameraManager_; }

///-------------------------------------------/// 
/// particleManager
///-------------------------------------------///
ParticleManager* ServiceLocator::GetParticleManager() { return particleManager_; }

///-------------------------------------------/// 
/// ColliderManager
///-------------------------------------------///
ColliderManager* ServiceLocator::GetColliderManager() { return colliderManager_; }

///-------------------------------------------/// 
/// DeltaTime
///-------------------------------------------///
DeltaTime* ServiceLocator::GetDeltaTime() { return deltaTime_; }


============================================================
File Path: Project/Engine/System/Service/ServiceLocator.h
============================================================
#pragma once
/// ===Include=== ///
#include <memory>

/// ===å‰æ–¹å®£è¨€=== ///
/// <Engine>
// Core
class WinApp;
class DXCommon;
class SRVManager;
class RTVManager;
class DSVManager;
// Graphics
class PipelineManager;
class TextureManager;
class ModelManager;
class AnimationManager;
class OffScreenRenderer;
// Audio
class AudioManager;
// Level
class CSVManager;
class LevelManager;
/// <Game>
// Line
class LineObject3D;
// Input
class Keyboard;
class Mouse;
class Controller;
// Camera
class CameraManager;
// Particle
class ParticleManager;
// ColliderManager
class ColliderManager;
// DeltaTime
class DeltaTime;

/// ===ã‚µãƒ¼ãƒ“ã‚¹å€™è£œ=== ///
struct ServiceRegister {
	WinApp* winApp = nullptr;
	DXCommon* dxCommon = nullptr;
	SRVManager* srvManager = nullptr;
	RTVManager* rtvManager = nullptr;
	DSVManager* dsvManager = nullptr;
	PipelineManager* pipelineManager = nullptr;
	TextureManager* textureManager = nullptr;
	ModelManager* modelManager = nullptr;
	AnimationManager* animationManager = nullptr;
	OffScreenRenderer* offScreenRenderer = nullptr;
	AudioManager* audioManager = nullptr;
	CSVManager* csvManager = nullptr;
	LevelManager* levelManager = nullptr;
	LineObject3D* lineObject3D = nullptr;
	Keyboard* keyboard = nullptr;
	Mouse* mouse = nullptr;
	Controller* controller = nullptr;
	CameraManager* cameraManager = nullptr;
	ParticleManager* particleManager = nullptr;
	ColliderManager* colliderManager = nullptr;
	DeltaTime* deltaTime = nullptr;
};

///=====================================================/// 
/// ã‚µãƒ¼ãƒ“ã‚¹ãƒ­ã‚±ãƒ¼ã‚¿
///=====================================================///
class ServiceLocator {
public:
	// å…¨ã¦ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’æä¾›
	static void ProvideAll(const ServiceRegister& registry);
	// å…¨ã¦ã®ã‚µãƒ¼ãƒ“ã‚¹ã‚’çµ‚äº†
	static void Finalize();

	// WinApp
	static WinApp* GetWinApp();
	// DXCommon
	static DXCommon* GetDXCommon();
	// SRVManager
	static SRVManager* GetSRVManager();
	// RTVManager 
	static RTVManager* GetRTVManager();
	// DSVManager
	static DSVManager* GetDSVManager();
	// PipelineManager
	static PipelineManager* GetPipelineManager();
	// TextureManager
	static TextureManager* GetTextureManager();
	// ModelManager
	static ModelManager* GetModelManager();
	// AnimationManager
	static AnimationManager* GetAnimationManager();
	// OffScreenRenderer
	static OffScreenRenderer* GetOffScreenRenderer();
	// CSVManager
	static CSVManager* GetCSVManager();
	// LevelLoader
	static LevelManager* GetLevelManager();
	// AudioManager
	static AudioManager* GetAudioManager();
	// LineObject3D
	static LineObject3D* GetLineObject3D();
	// Input (Keyboard, Mouse, Controller)
	static Keyboard* GetKeyboard();
	static Mouse* GetMouse();
	static Controller* GetController();
	// CameraManager
	static CameraManager* GetCameraManager();
	// ParticleManager
	static ParticleManager* GetParticleManager();
	// ColliderManager
	static ColliderManager* GetColliderManager();
	// DeltaTime
	static DeltaTime* GetDeltaTime();

private:
	// Core
	static inline WinApp* winApp_ = nullptr;
	static inline DXCommon* dxCommon_ = nullptr;
	static inline SRVManager* srvManager_ = nullptr;
	static inline RTVManager* rtvManager_ = nullptr;
	static inline DSVManager* dsvManager_ = nullptr;
	// Graphics
	static inline PipelineManager* pipelineManager_ = nullptr;
	static inline TextureManager* textureManager_ = nullptr;
	static inline ModelManager* modelManager_ = nullptr;
	static inline AnimationManager* animationManager_ = nullptr;
	static inline OffScreenRenderer* offScreenRenderer_ = nullptr;
	// Level
	static inline CSVManager* csvManager_ = nullptr;
	static inline LevelManager* levelManager_ = nullptr;
	// Audio
	static inline AudioManager* audioManager_ = nullptr;
	// Game
	static inline LineObject3D* lineObject3D_ = nullptr;
	static inline Keyboard* keyboard_ = nullptr;
	static inline Mouse* mouse_ = nullptr;
	static inline Controller* controller_ = nullptr;
	static inline CameraManager* cameraManager_ = nullptr;
	static inline ParticleManager* particleManager_ = nullptr;
	static inline ColliderManager* colliderManager_ = nullptr;
	static inline DeltaTime* deltaTime_ = nullptr;
};



============================================================
File Path: Project/FallenAscent.vcxproj
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{A75EB43D-A0A1-4770-9630-303DC69102D1}</ProjectGuid>
    <RootNamespace>Engine</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>FallenAscent</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IncludePath>$(SolutionDir)imgui;$(SolutionDir)DirextXTex;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IncludePath>$(SolutionDir)imgui;$(SolutionDir)DirextXTex;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;USE_IMGUI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)externals\assimp\include;$(ProjectDir)externals\DirectXTex;$(ProjectDir)externals\imgui;$(ProjectDir)externals\JSON</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions>/ignore:4049 %(AdditionalOptions)</AdditionalOptions>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <AdditionalLibraryDirectories>$(ProjectDir)externals\assimp\lib\Debug;$(SolutionDir)..\generated\outputs\$(Configuration)\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>assimp-vc143-mtd.lib;imgui.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(ProjectDir);$(ProjectDir)externals\assimp\include;$(ProjectDir)externals\DirectXTex;$(ProjectDir)externals\imgui;$(ProjectDir)externals\JSON</AdditionalIncludeDirectories>
      <Optimization>Disabled</Optimization>
      <TreatWarningAsError>true</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(ProjectDir)externals\assimp\lib\Release;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>assimp-vc143-mt.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll"
copy "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="application\Game\Entity\Enemy\State\Base\EnemyState.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyAttackState.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyMoveState.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\Manager\EnemyManager.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyPrePareAttackState.cpp" />
    <ClCompile Include="application\Game\Entity\GameCharacter\GameCharacterCollision.cpp" />
    <ClCompile Include="application\Scene\GameScene.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\Component\EnemyMoveComponent.cpp" />
    <ClCompile Include="application\Scene\Debug\AttackEditorScene.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Editor\AttackDataSerializer.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Editor\AttackEditor.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\Component\EnemyHitReactionComponent.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyHitReactionState.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\CS\CSRootSignature.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\CS\CSPSOCommon.cpp" />
    <ClCompile Include="Engine\Collider\Collision\ColliderCollision.cpp" />
    <ClCompile Include="Engine\System\Service\DeltaTimeSevice.cpp" />
    <ClCompile Include="Engine\System\DeltraTime\DeltaTime.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\DissolveEffect.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\BoxFilter3x3Effect.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\BoxFilter5x5Effect.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\CloseRange\CloseRangeEnemy.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\Base\BaseEnemy.cpp" />
    <ClCompile Include="application\Game\Entity\Player\State\AttackState.cpp" />
    <ClCompile Include="Engine\Scene\Transition\ShatterGlassTransition.cpp" />
    <ClCompile Include="Engine\System\Service\ColliderService.cpp" />
    <ClCompile Include="Engine\Collider\AABBCollider.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Model\AnimationModel.cpp" />
    <ClCompile Include="Engine\Collider\Base\Collider.cpp" />
    <ClCompile Include="Engine\System\Managers\ColliderManager.cpp" />
    <ClCompile Include="Engine\System\Managers\DSVManager.cpp" />
    <ClCompile Include="Engine\DataInfo\FunctionData.cpp" />
    <ClCompile Include="Engine\System\Service\GraphicsResourceGetter.cpp" />
    <ClCompile Include="Engine\System\Managers\LevelManager.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Line\LineObject3D.cpp" />
    <ClCompile Include="application\Drawing\3d\Line.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\GrayScaleEffect.cpp" />
    <ClCompile Include="application\Game\Object\GameGround\Ground.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemy.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemyBullet.cpp" />
    <ClCompile Include="application\Game\Entity\GameCharacter\GameCharacter.cpp" />
    <ClCompile Include="Engine\Camera\FollowCamera.cpp" />
    <ClCompile Include="application\Game\Camera\GameCamera.cpp" />
    <ClCompile Include="application\Game\Object\GameGround\GroundOcean.cpp" />
    <ClCompile Include="application\Game\Animation\GameOverAnimation.cpp" />
    <ClCompile Include="application\Game\Object\GameStage.cpp" />
    <ClCompile Include="application\Game\Animation\GameClearAnimation.cpp" />
    <ClCompile Include="application\Game\UI\Game\GameSceneUI.cpp" />
    <ClCompile Include="application\Game\Object\GameObject\GameObject.cpp" />
    <ClCompile Include="Math\EasingMath.cpp" />
    <ClCompile Include="Engine\System\Managers\AnimationManager.cpp" />
    <ClCompile Include="Engine\System\Service\AudioService.cpp" />
    <ClCompile Include="Engine\System\Input\Controller.cpp" />
    <ClCompile Include="Engine\System\Managers\CSVManager.cpp" />
    <ClCompile Include="Engine\Scene\AbstractSceneFactory.cpp" />
    <ClCompile Include="application\Scene\ClearScene.cpp" />
    <ClCompile Include="Engine\Scene\Framework.cpp" />
    <ClCompile Include="Engine\System\Managers\AudioManager.cpp" />
    <ClCompile Include="application\Scene\GameOverScene.cpp" />
    <ClCompile Include="Engine\System\Managers\CameraManager.cpp" />
    <ClCompile Include="Engine\Camera\NormalCamera.cpp" />
    <ClCompile Include="Engine\Core\DXCommon.cpp" />
    <ClCompile Include="Engine\System\Service\InputService.cpp" />
    <ClCompile Include="Engine\Core\Logger.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Base\Material3D.cpp" />
    <ClCompile Include="Engine\System\Managers\ImGuiManager.cpp" />
    <ClCompile Include="Engine\Scene\IScene.cpp" />
    <ClCompile Include="Engine\System\Service\Loader.cpp" />
    <ClCompile Include="Engine\System\Input\InputCommon.cpp" />
    <ClCompile Include="Engine\System\Input\Keyboard.cpp" />
    <ClCompile Include="Math\Matrix3x3.cpp" />
    <ClCompile Include="Math\Matrix4x4.cpp" />
    <ClCompile Include="Math\MatrixMath.cpp" />
    <ClCompile Include="Math\sMath.cpp" />
    <ClCompile Include="Math\Vector2.cpp" />
    <ClCompile Include="Math\Vector3.cpp" />
    <ClCompile Include="Math\Vector4.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\GS\BlendState.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\Compiler.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\GS\InputLayout.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\GS\GSPSOCommon.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\GS\RasterizerState.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\GS\GSRootSignature.cpp" />
    <ClCompile Include="Engine\Core\Mii.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Base\Transform3D.cpp" />
    <ClCompile Include="Engine\Core\WinApp.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\GS\DepthStencil.cpp" />
    <ClCompile Include="Engine\Graphics\2d\Base\IndexBuffer2D.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Base\IndexBuffer3D.cpp" />
    <ClCompile Include="Engine\Graphics\Base\BufferBase.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="application\Drawing\2d\Sprite.cpp" />
    <ClCompile Include="Engine\System\Managers\TextureManager.cpp" />
    <ClCompile Include="Engine\Core\StringUtility.cpp" />
    <ClCompile Include="Engine\Graphics\2d\Base\Transform2D.cpp" />
    <ClCompile Include="Engine\Graphics\2d\Base\Material2D.cpp" />
    <ClCompile Include="Engine\Graphics\2d\Base\VertexBuffer2D.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Base\VertexBuffer3D.cpp" />
    <ClCompile Include="Engine\System\Managers\SRVManager.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Model\Model.cpp" />
    <ClCompile Include="Engine\System\Managers\ModelManager.cpp" />
    <ClCompile Include="Engine\System\Managers\PiplineManager.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Model\ModelCommon.cpp" />
    <ClCompile Include="Engine\Graphics\2d\Sprite\SpriteCommon.cpp" />
    <ClCompile Include="Engine\Scene\MyGame.cpp" />
    <ClCompile Include="Engine\System\Managers\SceneManager.cpp" />
    <ClCompile Include="application\Scene\SelectScene.cpp" />
    <ClCompile Include="application\Scene\TitleScene.cpp" />
    <ClCompile Include="Engine\Scene\SceneFactory.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleGroup.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleSetUp.cpp" />
    <ClCompile Include="Engine\System\Managers\ParticleManager.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleCommon.cpp" />
    <ClCompile Include="Engine\System\Input\Mouse.cpp" />
    <ClCompile Include="Math\Quaternion.cpp" />
    <ClCompile Include="Engine\System\Service\Render.cpp" />
    <ClCompile Include="Engine\System\Service\ServiceLocator.cpp" />
    <ClCompile Include="Engine\System\Managers\RTVManager.cpp" />
    <ClCompile Include="Engine\Collider\SphereCollider.cpp" />
    <ClCompile Include="Engine\Collider\OBBCollider.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\OffScreenRenderer.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\RenderPass.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\RenderTexture.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\CopyImageEffect.cpp" />
    <ClCompile Include="application\Drawing\3d\Object3d.cpp" />
    <ClCompile Include="Engine\System\ImGui\SceneView.cpp" />
    <ClCompile Include="Engine\System\Service\OffScreenService.cpp" />
    <ClCompile Include="Engine\Graphics\3d\SkyBox\SkyBox.cpp" />
    <ClCompile Include="Engine\System\Service\CameraService.cpp" />
    <ClCompile Include="Engine\System\Service\ParticleService.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Base\ObjectCommon.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Primitive3D\Primitive3DCommon.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\OutLineEffect.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\RadiusBlurEffect.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\VignetteEffect.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Player.cpp" />
    <ClCompile Include="application\Game\Entity\Player\State\Base\PlayerState.cpp" />
    <ClCompile Include="application\Game\Entity\Player\State\RootState.cpp" />
    <ClCompile Include="application\Game\Entity\Player\State\MoveState.cpp" />
    <ClCompile Include="application\Game\Entity\Player\State\AvoidanceState.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Weapon\PlayerWeapon.cpp" />
    <ClCompile Include="application\Game\UI\Title\TitleUI.cpp" />
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\ShatterGlassEffect.cpp" />
    <ClCompile Include="Engine\Graphics\2d\Base\Object2DCommon.cpp" />
    <ClCompile Include="application\Game\Animation\StartAnimation.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Ocean\Ocean.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Ocean\OceanCommon.cpp" />
    <ClCompile Include="application\Game\Object\StageObject\StageObject.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleDefinition.cpp" />
    <ClCompile Include="Engine\System\Editor\ParticleEditor.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleFactory.cpp" />
    <ClCompile Include="Engine\Scene\Debug\ParticleEditorScene.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleParameter.cpp" />
    <ClCompile Include="Engine\Graphics\Base\UAV.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\PSOBase.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Ocean\OceanWaveCompute.cpp" />
    <ClCompile Include="Engine\Scene\Transition\Base\SceneTransitionBase.cpp" />
    <ClCompile Include="Engine\Scene\Transition\SceneTransitionManager.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Component\PlayerMoveComponent.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Component\PlayerAvoidanceComponent.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Component\PlayerAttackComponent.cpp" />
    <ClCompile Include="application\Game\UI\Game\PlayerUI.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Engine\Collider\ColliderConcept.h" />
    <ClInclude Include="application\Game\Entity\Player\Editor\Data\AttackData.h" />
    <ClInclude Include="application\Game\Entity\Enemy\State\Base\EnemyState.h" />
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyAttackState.h" />
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyMoveState.h" />
    <ClInclude Include="application\Game\Entity\Enemy\Manager\EnemyManager.h" />
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyPrePareAttackState.h" />
    <ClInclude Include="application\Game\Entity\GameCharacter\GameCharacterCollision.h" />
    <ClInclude Include="application\Game\Entity\Enemy\Component\EnemyMoveComponent.h" />
    <ClInclude Include="application\Scene\Debug\AttackEditorScene.h" />
    <ClInclude Include="application\Game\Entity\Player\Editor\AttackDataSerializer.h" />
    <ClInclude Include="application\Game\Entity\Player\Editor\AttackEditor.h" />
    <ClInclude Include="application\Game\Entity\Enemy\Component\EnemyHitReactionComponent.h" />
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyHitReactionState.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\CS\CSRootSignature.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\CS\CSPSOCommon.h" />
    <ClInclude Include="Engine\Collider\Collision\ColliderCollision.h" />
    <ClInclude Include="Engine\System\Service\DeltaTimeSevice.h" />
    <ClInclude Include="Engine\System\DeltraTime\DeltaTime.h" />
    <ClInclude Include="Engine\DataInfo\OceanData.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\DissolveEffect.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\BoxFilter3x3Effect.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\BoxFilter5x5Effect.h" />
    <ClInclude Include="application\Game\Entity\Enemy\Base\BaseEnemy.h" />
    <ClInclude Include="application\Game\Entity\Player\State\AttackState.h" />
    <ClInclude Include="Engine\DataInfo\BlendModeData.h" />
    <ClInclude Include="Engine\DataInfo\LevelData.h" />
    <ClInclude Include="application\Game\Entity\Enemy\CloseRange\CloseRangeEnemy.h" />
    <ClInclude Include="Engine\Scene\Transition\ShatterGlassTransition.h" />
    <ClInclude Include="Engine\System\Service\ColliderService.h" />
    <ClInclude Include="Engine\Collider\AABBCollider.h" />
    <ClInclude Include="Engine\DataInfo\LightData.h" />
    <ClInclude Include="Engine\DataInfo\OffScreenData.h" />
    <ClInclude Include="Engine\DataInfo\LineObjectData.h" />
    <ClInclude Include="Engine\Graphics\3d\Model\AnimationModel.h" />
    <ClInclude Include="Engine\Collider\Base\Collider.h" />
    <ClInclude Include="Engine\System\Managers\ColliderManager.h" />
    <ClInclude Include="Engine\System\Managers\DSVManager.h" />
    <ClInclude Include="Engine\DataInfo\FunctionData.h" />
    <ClInclude Include="Engine\System\Service\GraphicsResourceGetter.h" />
    <ClInclude Include="Engine\System\Managers\LevelManager.h" />
    <ClInclude Include="Engine\Graphics\3d\Line\LineObject3D.h" />
    <ClInclude Include="application\Drawing\3d\Line.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\GrayScaleEffect.h" />
    <ClInclude Include="application\Game\Object\GameGround\Ground.h" />
    <ClInclude Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemy.h" />
    <ClInclude Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemyBullet.h" />
    <ClInclude Include="application\Game\Entity\GameCharacter\GameCharacter.h" />
    <ClInclude Include="Engine\Camera\FollowCamera.h" />
    <ClInclude Include="application\Game\Camera\GameCamera.h" />
    <ClInclude Include="application\Game\Object\GameGround\GroundOcean.h" />
    <ClInclude Include="application\Game\Animation\GameOverAnimation.h" />
    <ClInclude Include="application\Game\Object\GameStage.h" />
    <ClInclude Include="application\Game\Animation\GameClearAnimation.h" />
    <ClInclude Include="application\Game\UI\Game\GameSceneUI.h" />
    <ClInclude Include="application\Game\Object\GameObject\GameObject.h" />
    <ClInclude Include="Math\EasingMath.h" />
    <ClInclude Include="Engine\System\Managers\AnimationManager.h" />
    <ClInclude Include="Engine\DataInfo\AnimationData.h" />
    <ClInclude Include="Engine\System\Service\AudioService.h" />
    <ClInclude Include="Engine\DataInfo\InputData.h" />
    <ClInclude Include="Engine\System\Input\Controller.h" />
    <ClInclude Include="Engine\System\Managers\CSVManager.h" />
    <ClInclude Include="Engine\DataInfo\ParticleData.h" />
    <ClInclude Include="Engine\Scene\AbstractSceneFactory.h" />
    <ClInclude Include="application\Scene\ClearScene.h" />
    <ClInclude Include="Engine\Scene\Framework.h" />
    <ClInclude Include="Engine\System\Managers\AudioManager.h" />
    <ClInclude Include="application\Scene\GameOverScene.h" />
    <ClInclude Include="Engine\System\Managers\CameraManager.h" />
    <ClInclude Include="Engine\Camera\NormalCamera.h" />
    <ClInclude Include="Engine\DataInfo\CData.h" />
    <ClInclude Include="Engine\Core\DXCommon.h" />
    <ClInclude Include="Engine\System\Service\InputService.h" />
    <ClInclude Include="Engine\Core\Logger.h" />
    <ClInclude Include="Engine\Graphics\3d\Base\Material3D.h" />
    <ClInclude Include="Engine\System\Managers\ImGuiManager.h" />
    <ClInclude Include="Engine\Scene\IScene.h" />
    <ClInclude Include="Engine\DataInfo\SceneType.h" />
    <ClInclude Include="Engine\System\Service\Loader.h" />
    <ClInclude Include="Engine\System\Input\InputCommon.h" />
    <ClInclude Include="Engine\System\Input\Keyboard.h" />
    <ClInclude Include="Engine\DataInfo\ColliderData.h" />
    <ClInclude Include="Math\Matrix3x3.h" />
    <ClInclude Include="Math\Matrix4x4.h" />
    <ClInclude Include="Math\MatrixMath.h" />
    <ClInclude Include="Math\sMath.h" />
    <ClInclude Include="Math\Vector2.h" />
    <ClInclude Include="Math\Vector3.h" />
    <ClInclude Include="Math\Vector4.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\GS\BlendState.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\Compiler.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\GS\InputLayout.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\GS\GSPSOCommon.h" />
    <ClInclude Include="Engine\DataInfo\PipelineStateObjectType.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\GS\RasterizerState.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\GS\GSRootSignature.h" />
    <ClInclude Include="Engine\Core\Mii.h" />
    <ClInclude Include="Engine\Graphics\3d\Base\Transform3D.h" />
    <ClInclude Include="Engine\Core\WinApp.h" />
    <ClInclude Include="Engine\Core\ComPtr.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\GS\DepthStencil.h" />
    <ClInclude Include="application\Scene\GameScene.h" />
    <ClInclude Include="application\Drawing\2d\Sprite.h" />
    <ClInclude Include="Engine\System\Managers\TextureManager.h" />
    <ClInclude Include="Engine\Core\StringUtility.h" />
    <ClInclude Include="Engine\Graphics\2d\Base\Transform2D.h" />
    <ClInclude Include="Engine\Graphics\2d\Base\Material2D.h" />
    <ClInclude Include="Engine\Graphics\2d\Base\IndexBuffer2D.h" />
    <ClInclude Include="Engine\Graphics\3d\Base\IndexBuffer3D.h" />
    <ClInclude Include="Engine\Graphics\2d\Base\VertexBuffer2D.h" />
    <ClInclude Include="Engine\Graphics\3d\Base\VertexBuffer3D.h" />
    <ClInclude Include="Engine\System\Managers\SRVManager.h" />
    <ClInclude Include="Engine\Graphics\3d\Model\Model.h" />
    <ClInclude Include="Engine\System\Managers\ModelManager.h" />
    <ClInclude Include="Engine\Graphics\Base\BufferBase.h" />
    <ClInclude Include="Engine\System\Managers\PiplineManager.h" />
    <ClInclude Include="Engine\Graphics\3d\Model\ModelCommon.h" />
    <ClInclude Include="Engine\Graphics\2d\Sprite\SpriteCommon.h" />
    <ClInclude Include="Engine\Scene\MyGame.h" />
    <ClInclude Include="Engine\System\Managers\SceneManager.h" />
    <ClInclude Include="application\Scene\SelectScene.h" />
    <ClInclude Include="application\Scene\TitleScene.h" />
    <ClInclude Include="Engine\Scene\SceneFactory.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleGroup.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleSetUp.h" />
    <ClInclude Include="Engine\System\Managers\ParticleManager.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleCommon.h" />
    <ClInclude Include="Engine\System\Input\Mouse.h" />
    <ClInclude Include="Math\Quaternion.h" />
    <ClInclude Include="Engine\System\Service\Render.h" />
    <ClInclude Include="Engine\System\Service\ServiceLocator.h" />
    <ClInclude Include="Engine\System\Managers\RTVManager.h" />
    <ClInclude Include="Engine\Collider\SphereCollider.h" />
    <ClInclude Include="Engine\Collider\OBBCollider.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\OffScreenRenderer.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\RenderPass.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\RenderTexture.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\CopyImageEffect.h" />
    <ClInclude Include="application\Drawing\3d\Object3d.h" />
    <ClInclude Include="Engine\System\ImGui\SceneView.h" />
    <ClInclude Include="Engine\System\Service\OffScreenService.h" />
    <ClInclude Include="Engine\Graphics\3d\SkyBox\SkyBox.h" />
    <ClInclude Include="Engine\System\Service\CameraService.h" />
    <ClInclude Include="Engine\System\Service\ParticleService.h" />
    <ClInclude Include="Engine\Graphics\3d\Base\ObjectCommon.h" />
    <ClInclude Include="Engine\Graphics\3d\Primitive3D\Primitive3DCommon.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\OutLineEffect.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\RadiusBlurEffect.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\VignetteEffect.h" />
    <ClInclude Include="application\Game\Entity\Player\Player.h" />
    <ClInclude Include="application\Game\Entity\Player\State\Base\PlayerState.h" />
    <ClInclude Include="application\Game\Entity\Player\State\RootState.h" />
    <ClInclude Include="application\Game\Entity\Player\State\MoveState.h" />
    <ClInclude Include="application\Game\Entity\Player\State\AvoidanceState.h" />
    <ClInclude Include="application\Game\Entity\Player\Weapon\PlayerWeapon.h" />
    <ClInclude Include="application\Game\UI\Title\TitleUI.h" />
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\ShatterGlassEffect.h" />
    <ClInclude Include="Engine\Graphics\2d\Base\Object2DCommon.h" />
    <ClInclude Include="application\Game\Animation\StartAnimation.h" />
    <ClInclude Include="Engine\Graphics\3d\Ocean\Ocean.h" />
    <ClInclude Include="Engine\Graphics\3d\Ocean\OceanCommon.h" />
    <ClInclude Include="application\Game\Object\StageObject\StageObject.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleDefinition.h" />
    <ClInclude Include="Engine\System\Editor\ParticleEditor.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleFactory.h" />
    <ClInclude Include="Engine\Scene\Debug\ParticleEditorScene.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleParameter.h" />
    <ClInclude Include="Engine\Graphics\Base\UAV.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\PSOBase.h" />
    <ClInclude Include="Engine\Graphics\3d\Ocean\OceanWaveCompute.h" />
    <ClInclude Include="Engine\Scene\Transition\Base\SceneTransitionBase.h" />
    <ClInclude Include="Engine\Scene\Transition\SceneTransitionManager.h" />
    <ClInclude Include="application\Game\Entity\Player\Component\PlayerMoveComponent.h" />
    <ClInclude Include="application\Game\Entity\Player\Component\PlayerAvoidanceComponent.h" />
    <ClInclude Include="application\Game\Entity\Player\Component\PlayerAttackComponent.h" />
    <ClInclude Include="application\Game\UI\Game\PlayerUI.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="externals\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="Resource\Shaders\2D\CircularGauge.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\LIne3D.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\LIne3D.VS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Ocean.CS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Compute</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">4.0</ShaderModel>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Compute</ShaderType>
      <ShaderModel Condition="'$(Configuration)|$(Platform)'=='Release|x64'">4.0</ShaderModel>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Skybox.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Skybox.VS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\BoxFilter3x3.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\BoxFilter5x5.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\CopyImage.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Dissolve.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Fullscreen.VS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Grayscale.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\LuminanceBasedOutline.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\RadialBlur.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\ShatterGlass.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Ocean.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Ocean.VS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\Particle\Particle.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\Particle\Particle.VS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\Obj.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\Obj.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\2D\Obj2D.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\2D\Obj2D.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Obj3D.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Obj3D.VS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\SkinningObj3D.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\SkinningObj3D.VS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Vertex</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Vertex</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Vignette.PS.hlsl">
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Pixel</ShaderType>
      <ShaderType Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Pixel</ShaderType>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="Resource\Shaders\3D\LIne3D.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="Resource\Shaders\3D\Skybox.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="Resource\Shaders\OffScreen\Fullscreen.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="Resource\Shaders\3D\Ocean.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="Resource\Shaders\Particle\Particle.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="Resource\Shaders\Obj.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="Resource\Shaders\3D\Obj3D.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </None>
    <None Include="Resource\Shaders\3D\SkinningObj3D.hlsli">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
    </None>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: Project/FallenAscent.vcxproj.filters
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <FxCompile Include="Resource\Shaders\Obj.PS.hlsl">
      <Filter>Resource\Shaders</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\Obj.VS.hlsl">
      <Filter>Resource\Shaders</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\2D\Obj2D.PS.hlsl">
      <Filter>Resource\Shaders\2D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\2D\Obj2D.VS.hlsl">
      <Filter>Resource\Shaders\2D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Obj3D.VS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Obj3D.PS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\LIne3D.PS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\LIne3D.VS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\SkinningObj3D.VS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\SkinningObj3D.PS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Skybox.PS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Skybox.VS.hlsl">
      <Filter>Resource\Shaders\3D</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\Particle\Particle.PS.hlsl">
      <Filter>Resource\Shaders\Particle</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\Particle\Particle.VS.hlsl">
      <Filter>Resource\Shaders\Particle</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\RadialBlur.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Vignette.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Dissolve.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\BoxFilter3x3.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\BoxFilter5x5.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\CopyImage.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Grayscale.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\LuminanceBasedOutline.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\Fullscreen.VS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\OffScreen\ShatterGlass.PS.hlsl">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Ocean.VS.hlsl">
      <Filter>Resource\Shaders\Oshan</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Ocean.PS.hlsl">
      <Filter>Resource\Shaders\Oshan</Filter>
    </FxCompile>
    <FxCompile Include="Resource\Shaders\3D\Ocean.CS.hlsl" />
    <FxCompile Include="Resource\Shaders\2D\CircularGauge.PS.hlsl" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="application\Game\Camera\GameCamera.cpp">
      <Filter>application\Game\Camera</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\GameCharacter\GameCharacter.cpp">
      <Filter>application\Game\Entity\GameCharacter</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\Base\BaseEnemy.cpp">
      <Filter>application\Game\Entity\Enemy\Base</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\CloseRange\CloseRangeEnemy.cpp">
      <Filter>application\Game\Entity\Enemy\CloseRange</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemyBullet.cpp">
      <Filter>application\Game\Entity\Enemy\LongRange</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemy.cpp">
      <Filter>application\Game\Entity\Enemy\LongRange</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\Manager\EnemyManager.cpp">
      <Filter>application\Game\Entity\Enemy\Manager</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\State\Base\EnemyState.cpp">
      <Filter>application\Game\Entity\Enemy\State\Base</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyAttackState.cpp">
      <Filter>application\Game\Entity\Enemy\State</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyMoveState.cpp">
      <Filter>application\Game\Entity\Enemy\State</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Player\Player.cpp">
      <Filter>application\Game\Entity\Player</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Player\Weapon\PlayerWeapon.cpp">
      <Filter>application\Game\Entity\Player\Weapon</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Player\State\AttackState.cpp">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Player\State\Base\PlayerState.cpp">
      <Filter>application\Game\Entity\Player\State\Base</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Player\State\AvoidanceState.cpp">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Player\State\MoveState.cpp">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Entity\Player\State\RootState.cpp">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClCompile>
    <ClCompile Include="application\Drawing\2d\Sprite.cpp">
      <Filter>application\Drawing\2D</Filter>
    </ClCompile>
    <ClCompile Include="application\Drawing\3d\Line.cpp">
      <Filter>application\Drawing\3D</Filter>
    </ClCompile>
    <ClCompile Include="application\Drawing\3d\Object3d.cpp">
      <Filter>application\Drawing\3D</Filter>
    </ClCompile>
    <ClCompile Include="application\Scene\ClearScene.cpp">
      <Filter>application\Scene</Filter>
    </ClCompile>
    <ClCompile Include="application\Scene\GameOverScene.cpp">
      <Filter>application\Scene</Filter>
    </ClCompile>
    <ClCompile Include="application\Scene\SelectScene.cpp">
      <Filter>application\Scene</Filter>
    </ClCompile>
    <ClCompile Include="application\Scene\TitleScene.cpp">
      <Filter>application\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Camera\FollowCamera.cpp">
      <Filter>Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Camera\NormalCamera.cpp">
      <Filter>Engine\Camera</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Collider\Base\Collider.cpp">
      <Filter>Engine\Collider\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Collider\AABBCollider.cpp">
      <Filter>Engine\Collider</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Collider\OBBCollider.cpp">
      <Filter>Engine\Collider</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Collider\SphereCollider.cpp">
      <Filter>Engine\Collider</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Core\DXCommon.cpp">
      <Filter>Engine\Core</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Core\Logger.cpp">
      <Filter>Engine\Core</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Core\Mii.cpp">
      <Filter>Engine\Core</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Core\StringUtility.cpp">
      <Filter>Engine\Core</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Core\WinApp.cpp">
      <Filter>Engine\Core</Filter>
    </ClCompile>
    <ClCompile Include="Engine\DataInfo\FunctionData.cpp">
      <Filter>Engine\DataInfo</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Base\IndexBuffer3D.cpp">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Base\Material3D.cpp">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Base\ObjectCommon.cpp">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Base\Transform3D.cpp">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Base\VertexBuffer3D.cpp">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Line\LineObject3D.cpp">
      <Filter>Engine\Graphics\3D\Line</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Model\Model.cpp">
      <Filter>Engine\Graphics\3D\Moel</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Model\ModelCommon.cpp">
      <Filter>Engine\Graphics\3D\Moel</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Primitive3D\Primitive3DCommon.cpp">
      <Filter>Engine\Graphics\3D\Primitive3D</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\SkyBox\SkyBox.cpp">
      <Filter>Engine\Graphics\3D\SkyBox</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Base\BufferBase.cpp">
      <Filter>Engine\Graphics\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\BoxFilter3x3Effect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\BoxFilter5x5Effect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\CopyImageEffect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\DissolveEffect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\GrayScaleEffect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\OutLineEffect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\RadiusBlurEffect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\VignetteEffect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\OffScreenRenderer.cpp">
      <Filter>Engine\Graphics\OffScreen</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\RenderPass.cpp">
      <Filter>Engine\Graphics\OffScreen</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\RenderTexture.cpp">
      <Filter>Engine\Graphics\OffScreen</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Particle\ParticleCommon.cpp">
      <Filter>Engine\Graphics\Particle\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Particle\ParticleGroup.cpp">
      <Filter>Engine\Graphics\Particle\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Particle\ParticleSetUp.cpp">
      <Filter>Engine\Graphics\Particle\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Pipeline\GS\BlendState.cpp">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Pipeline\Compiler.cpp">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Pipeline\GS\DepthStencil.cpp">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Pipeline\GS\InputLayout.cpp">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Pipeline\GS\GSPSOCommon.cpp">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Pipeline\GS\GSRootSignature.cpp">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\Pipeline\GS\RasterizerState.cpp">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Scene\AbstractSceneFactory.cpp">
      <Filter>Engine\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Scene\Framework.cpp">
      <Filter>Engine\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Scene\IScene.cpp">
      <Filter>Engine\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Scene\MyGame.cpp">
      <Filter>Engine\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Scene\SceneFactory.cpp">
      <Filter>Engine\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\ImGui\SceneView.cpp">
      <Filter>Engine\System\ImGui</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Input\Controller.cpp">
      <Filter>Engine\System\Input</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Input\InputCommon.cpp">
      <Filter>Engine\System\Input</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Input\Keyboard.cpp">
      <Filter>Engine\System\Input</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Input\Mouse.cpp">
      <Filter>Engine\System\Input</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Model\AnimationModel.cpp">
      <Filter>Engine\Graphics\3D\Moel</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\AnimationManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\AudioManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\CameraManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\ColliderManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\CSVManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\DSVManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\ImGuiManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\ModelManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\ParticleManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\RTVManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\SceneManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\PiplineManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\AudioService.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\CameraService.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\ColliderService.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Math\EasingMath.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\GraphicsResourceGetter.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\InputService.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\LevelManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Math\Matrix3x3.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Math\Matrix4x4.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Math\MatrixMath.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\OffScreenService.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\ServiceLocator.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\ParticleService.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\Render.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Math\Quaternion.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\SRVManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Managers\TextureManager.cpp">
      <Filter>Engine\System\Manager</Filter>
    </ClCompile>
    <ClCompile Include="Math\sMath.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Math\Vector2.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Math\Vector3.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Math\Vector4.cpp">
      <Filter>Math</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\Loader.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\OffScreen\Effect\ShatterGlassEffect.cpp">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\UI\Title\TitleUI.cpp">
      <Filter>application\UI\Title</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\2d\Sprite\SpriteCommon.cpp">
      <Filter>Engine\Graphics\2D\Sprite</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\2d\Base\IndexBuffer2D.cpp">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\2d\Base\Material2D.cpp">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\2d\Base\Transform2D.cpp">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\2d\Base\VertexBuffer2D.cpp">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\2d\Base\Object2DCommon.cpp">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Scene\Transition\ShatterGlassTransition.cpp">
      <Filter>application\Game\Transition</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Animation\StartAnimation.cpp">
      <Filter>application\Game\Animation</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Animation\GameOverAnimation.cpp">
      <Filter>application\Game\Animation</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\DeltraTime\DeltaTime.cpp">
      <Filter>Engine\System\DeltaTime</Filter>
    </ClCompile>
    <ClCompile Include="Engine\System\Service\DeltaTimeSevice.cpp">
      <Filter>Engine\System\Service</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Object\GameGround\Ground.cpp">
      <Filter>application\Game\Object\GameGround</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Object\GameGround\GroundOcean.cpp">
      <Filter>application\Game\Object\GameGround</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Object\StageObject\StageObject.cpp">
      <Filter>application\Game\Object\GameObject</Filter>
    </ClCompile>
    <ClCompile Include="application\Game\Object\GameStage.cpp">
      <Filter>application\Game\Object</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Ocean\Ocean.cpp">
      <Filter>Engine\Graphics\3D\Oshan</Filter>
    </ClCompile>
    <ClCompile Include="Engine\Graphics\3d\Ocean\OceanCommon.cpp">
      <Filter>Engine\Graphics\3D\Oshan</Filter>
    </ClCompile>
    <ClCompile Include="application\Scene\GameScene.cpp" />
    <ClCompile Include="Engine\Collider\Collision\ColliderCollision.cpp" />
    <ClCompile Include="application\Game\Entity\GameCharacter\GameCharacterCollision.cpp" />
    <ClCompile Include="application\Game\Animation\GameClearAnimation.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleFactory.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleDefinition.cpp" />
    <ClCompile Include="Engine\System\Editor\ParticleEditor.cpp" />
    <ClCompile Include="Engine\Scene\Debug\ParticleEditorScene.cpp" />
    <ClCompile Include="Engine\Graphics\Particle\ParticleParameter.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\CS\CSPSOCommon.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\CS\CSRootSignature.cpp" />
    <ClCompile Include="Engine\Graphics\Base\UAV.cpp" />
    <ClCompile Include="Engine\Graphics\Pipeline\PSOBase.cpp" />
    <ClCompile Include="Engine\Graphics\3d\Ocean\OceanWaveCompute.cpp" />
    <ClCompile Include="Engine\Scene\Transition\Base\SceneTransitionBase.cpp" />
    <ClCompile Include="Engine\Scene\Transition\SceneTransitionManager.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyPrePareAttackState.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\Component\EnemyMoveComponent.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Component\PlayerMoveComponent.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Component\PlayerAvoidanceComponent.cpp" />
    <ClCompile Include="application\Scene\Debug\AttackEditorScene.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Editor\AttackEditor.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Editor\AttackDataSerializer.cpp" />
    <ClCompile Include="application\Game\Entity\Player\Component\PlayerAttackComponent.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\Component\EnemyHitReactionComponent.cpp" />
    <ClCompile Include="application\Game\Entity\Enemy\State\EnemyHitReactionState.cpp" />
    <ClCompile Include="application\Game\UI\Game\GameSceneUI.cpp" />
    <ClCompile Include="application\Game\UI\Game\PlayerUI.cpp" />
    <ClCompile Include="application\Game\Object\GameObject\GameObject.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="application\Game\Camera\GameCamera.h">
      <Filter>application\Game\Camera</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\GameCharacter\GameCharacter.h">
      <Filter>application\Game\Entity\GameCharacter</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\Base\BaseEnemy.h">
      <Filter>application\Game\Entity\Enemy\Base</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\CloseRange\CloseRangeEnemy.h">
      <Filter>application\Game\Entity\Enemy\CloseRange</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemyBullet.h">
      <Filter>application\Game\Entity\Enemy\LongRange</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\LongRange\LongRangeEnemy.h">
      <Filter>application\Game\Entity\Enemy\LongRange</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\Manager\EnemyManager.h">
      <Filter>application\Game\Entity\Enemy\Manager</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\State\Base\EnemyState.h">
      <Filter>application\Game\Entity\Enemy\State\Base</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyMoveState.h">
      <Filter>application\Game\Entity\Enemy\State</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyAttackState.h">
      <Filter>application\Game\Entity\Enemy\State</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Player\Player.h">
      <Filter>application\Game\Entity\Player</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Player\Weapon\PlayerWeapon.h">
      <Filter>application\Game\Entity\Player\Weapon</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Player\State\AttackState.h">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Player\State\Base\PlayerState.h">
      <Filter>application\Game\Entity\Player\State\Base</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Player\State\AvoidanceState.h">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Player\State\MoveState.h">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Entity\Player\State\RootState.h">
      <Filter>application\Game\Entity\Player\State</Filter>
    </ClInclude>
    <ClInclude Include="application\Drawing\2d\Sprite.h">
      <Filter>application\Drawing\2D</Filter>
    </ClInclude>
    <ClInclude Include="application\Drawing\3d\Line.h">
      <Filter>application\Drawing\3D</Filter>
    </ClInclude>
    <ClInclude Include="application\Drawing\3d\Object3d.h">
      <Filter>application\Drawing\3D</Filter>
    </ClInclude>
    <ClInclude Include="application\Scene\ClearScene.h">
      <Filter>application\Scene</Filter>
    </ClInclude>
    <ClInclude Include="application\Scene\GameOverScene.h">
      <Filter>application\Scene</Filter>
    </ClInclude>
    <ClInclude Include="application\Scene\GameScene.h">
      <Filter>application\Scene</Filter>
    </ClInclude>
    <ClInclude Include="application\Scene\SelectScene.h">
      <Filter>application\Scene</Filter>
    </ClInclude>
    <ClInclude Include="application\Scene\TitleScene.h">
      <Filter>application\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Camera\FollowCamera.h">
      <Filter>Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Camera\NormalCamera.h">
      <Filter>Engine\Camera</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Collider\Base\Collider.h">
      <Filter>Engine\Collider\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Collider\AABBCollider.h">
      <Filter>Engine\Collider</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Collider\OBBCollider.h">
      <Filter>Engine\Collider</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Collider\SphereCollider.h">
      <Filter>Engine\Collider</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Core\ComPtr.h">
      <Filter>Engine\Core</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Core\DXCommon.h">
      <Filter>Engine\Core</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Core\Logger.h">
      <Filter>Engine\Core</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Core\Mii.h">
      <Filter>Engine\Core</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Core\StringUtility.h">
      <Filter>Engine\Core</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Core\WinApp.h">
      <Filter>Engine\Core</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\AnimationData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\BlendModeData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\CData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\ColliderData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\FunctionData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\InputData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\LightData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\LevelData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\OffScreenData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\ParticleData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\PipelineStateObjectType.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\SceneType.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Base\IndexBuffer3D.h">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Base\Material3D.h">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Base\ObjectCommon.h">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Base\Transform3D.h">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Base\VertexBuffer3D.h">
      <Filter>Engine\Graphics\3D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Line\LineObject3D.h">
      <Filter>Engine\Graphics\3D\Line</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\LineObjectData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Model\Model.h">
      <Filter>Engine\Graphics\3D\Moel</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Model\ModelCommon.h">
      <Filter>Engine\Graphics\3D\Moel</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Primitive3D\Primitive3DCommon.h">
      <Filter>Engine\Graphics\3D\Primitive3D</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\SkyBox\SkyBox.h">
      <Filter>Engine\Graphics\3D\SkyBox</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Base\BufferBase.h">
      <Filter>Engine\Graphics\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\BoxFilter3x3Effect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\BoxFilter5x5Effect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\CopyImageEffect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\DissolveEffect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\GrayScaleEffect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\OutLineEffect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\RadiusBlurEffect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\VignetteEffect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\OffScreenRenderer.h">
      <Filter>Engine\Graphics\OffScreen</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\RenderPass.h">
      <Filter>Engine\Graphics\OffScreen</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\RenderTexture.h">
      <Filter>Engine\Graphics\OffScreen</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Particle\ParticleGroup.h">
      <Filter>Engine\Graphics\Particle\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Particle\ParticleCommon.h">
      <Filter>Engine\Graphics\Particle\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Particle\ParticleSetUp.h">
      <Filter>Engine\Graphics\Particle\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Pipeline\GS\BlendState.h">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Pipeline\Compiler.h">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Pipeline\GS\DepthStencil.h">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Pipeline\GS\InputLayout.h">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Pipeline\GS\GSPSOCommon.h">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Pipeline\GS\GSRootSignature.h">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\Pipeline\GS\RasterizerState.h">
      <Filter>Engine\Graphics\Pipeline</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Scene\AbstractSceneFactory.h">
      <Filter>Engine\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Scene\Framework.h">
      <Filter>Engine\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Scene\IScene.h">
      <Filter>Engine\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Scene\MyGame.h">
      <Filter>Engine\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Scene\SceneFactory.h">
      <Filter>Engine\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\ImGui\SceneView.h">
      <Filter>Engine\System\ImGui</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Input\Controller.h">
      <Filter>Engine\System\Input</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Input\InputCommon.h">
      <Filter>Engine\System\Input</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Input\Keyboard.h">
      <Filter>Engine\System\Input</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Input\Mouse.h">
      <Filter>Engine\System\Input</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Model\AnimationModel.h">
      <Filter>Engine\Graphics\3D\Moel</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\AnimationManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\AudioManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\CameraManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\ColliderManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\CSVManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\DSVManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\ImGuiManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\ModelManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\ParticleManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\SceneManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\RTVManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\PiplineManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\AudioService.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\CameraService.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\ColliderService.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Math\EasingMath.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\GraphicsResourceGetter.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\InputService.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\LevelManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Math\Matrix3x3.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Math\Matrix4x4.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Math\MatrixMath.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\OffScreenService.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\ServiceLocator.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\ParticleService.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\Render.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Math\Quaternion.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\TextureManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Managers\SRVManager.h">
      <Filter>Engine\System\Manager</Filter>
    </ClInclude>
    <ClInclude Include="Math\Vector4.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Math\sMath.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Math\Vector2.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Math\Vector3.h">
      <Filter>Math</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\Loader.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\OffScreen\Effect\ShatterGlassEffect.h">
      <Filter>Engine\Graphics\OffScreen\Effect</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\UI\Title\TitleUI.h">
      <Filter>application\UI\Title</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\2d\Sprite\SpriteCommon.h">
      <Filter>Engine\Graphics\2D\Sprite</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\2d\Base\VertexBuffer2D.h">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\2d\Base\IndexBuffer2D.h">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\2d\Base\Material2D.h">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\2d\Base\Transform2D.h">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\2d\Base\Object2DCommon.h">
      <Filter>Engine\Graphics\2D\Base</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Scene\Transition\ShatterGlassTransition.h">
      <Filter>application\Game\Transition</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Animation\StartAnimation.h">
      <Filter>application\Game\Animation</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Animation\GameOverAnimation.h">
      <Filter>application\Game\Animation</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\DeltraTime\DeltaTime.h">
      <Filter>Engine\System\DeltaTime</Filter>
    </ClInclude>
    <ClInclude Include="Engine\System\Service\DeltaTimeSevice.h">
      <Filter>Engine\System\Service</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Object\GameGround\Ground.h">
      <Filter>application\Game\Object\GameGround</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Object\GameGround\GroundOcean.h">
      <Filter>application\Game\Object\GameGround</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Object\StageObject\StageObject.h">
      <Filter>application\Game\Object\GameObject</Filter>
    </ClInclude>
    <ClInclude Include="application\Game\Object\GameStage.h">
      <Filter>application\Game\Object</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Ocean\Ocean.h">
      <Filter>Engine\Graphics\3D\Oshan</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Graphics\3d\Ocean\OceanCommon.h">
      <Filter>Engine\Graphics\3D\Oshan</Filter>
    </ClInclude>
    <ClInclude Include="Engine\DataInfo\OceanData.h">
      <Filter>Engine\DataInfo</Filter>
    </ClInclude>
    <ClInclude Include="Engine\Collider\Collision\ColliderCollision.h" />
    <ClInclude Include="application\Game\Entity\GameCharacter\GameCharacterCollision.h" />
    <ClInclude Include="application\Game\Animation\GameClearAnimation.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleFactory.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleDefinition.h" />
    <ClInclude Include="Engine\System\Editor\ParticleEditor.h" />
    <ClInclude Include="Engine\Scene\Debug\ParticleEditorScene.h" />
    <ClInclude Include="Engine\Graphics\Particle\ParticleParameter.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\CS\CSPSOCommon.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\CS\CSRootSignature.h" />
    <ClInclude Include="Engine\Graphics\Base\UAV.h" />
    <ClInclude Include="Engine\Graphics\Pipeline\PSOBase.h" />
    <ClInclude Include="Engine\Graphics\3d\Ocean\OceanWaveCompute.h" />
    <ClInclude Include="Engine\Scene\Transition\Base\SceneTransitionBase.h" />
    <ClInclude Include="Engine\Scene\Transition\SceneTransitionManager.h" />
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyPrePareAttackState.h" />
    <ClInclude Include="application\Game\Entity\Enemy\Component\EnemyMoveComponent.h" />
    <ClInclude Include="application\Game\Entity\Player\Component\PlayerMoveComponent.h" />
    <ClInclude Include="application\Game\Entity\Player\Component\PlayerAvoidanceComponent.h" />
    <ClInclude Include="application\Game\Entity\Player\Editor\Data\AttackData.h" />
    <ClInclude Include="application\Scene\Debug\AttackEditorScene.h" />
    <ClInclude Include="application\Game\Entity\Player\Editor\AttackEditor.h" />
    <ClInclude Include="application\Game\Entity\Player\Editor\AttackDataSerializer.h" />
    <ClInclude Include="application\Game\Entity\Player\Component\PlayerAttackComponent.h" />
    <ClInclude Include="application\Game\Entity\Enemy\Component\EnemyHitReactionComponent.h" />
    <ClInclude Include="application\Game\Entity\Enemy\State\EnemyHitReactionState.h" />
    <ClInclude Include="application\Game\UI\Game\GameSceneUI.h" />
    <ClInclude Include="application\Game\UI\Game\PlayerUI.h" />
    <ClInclude Include="Engine\Collider\ColliderConcept.h" />
    <ClInclude Include="application\Game\Object\GameObject\GameObject.h" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Resource\Shaders\Obj.hlsli">
      <Filter>Resource\Shaders</Filter>
    </None>
    <None Include="Resource\Shaders\3D\Obj3D.hlsli">
      <Filter>Resource\Shaders\3D</Filter>
    </None>
    <None Include="Resource\Shaders\3D\LIne3D.hlsli">
      <Filter>Resource\Shaders\3D</Filter>
    </None>
    <None Include="Resource\Shaders\3D\SkinningObj3D.hlsli">
      <Filter>Resource\Shaders\3D</Filter>
    </None>
    <None Include="Resource\Shaders\3D\Skybox.hlsli">
      <Filter>Resource\Shaders\3D</Filter>
    </None>
    <None Include="Resource\Shaders\Particle\Particle.hlsli">
      <Filter>Resource\Shaders\Particle</Filter>
    </None>
    <None Include="Resource\Shaders\OffScreen\Fullscreen.hlsli">
      <Filter>Resource\Shaders\OffScreen</Filter>
    </None>
    <None Include="Resource\Shaders\3D\Ocean.hlsli">
      <Filter>Resource\Shaders\Oshan</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="application">
      <UniqueIdentifier>{2424093c-5030-4b5e-871b-dbf64bfa7e8a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine">
      <UniqueIdentifier>{5faaa807-6088-449a-af57-f9a48b79a068}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game">
      <UniqueIdentifier>{739b285b-7a41-4180-be2e-b3b771c6758e}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Scene">
      <UniqueIdentifier>{aee14971-8c35-47d3-87e5-6003558fedb2}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Drawing">
      <UniqueIdentifier>{ac9ce136-20e2-4cb7-89de-c3d8509bac53}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Drawing\2D">
      <UniqueIdentifier>{ac36eeeb-b36d-461f-a803-d976ea22e5b2}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Drawing\3D">
      <UniqueIdentifier>{be487939-5181-4833-b3a0-e6945774caab}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity">
      <UniqueIdentifier>{fd701977-b533-4bad-b59e-8792fda0bb3e}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Camera">
      <UniqueIdentifier>{5c33d645-33cb-4a19-b636-6e94dbf7890c}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Object">
      <UniqueIdentifier>{dc046158-1126-47f6-aec7-738569fcbfe3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Collider">
      <UniqueIdentifier>{7e4962f9-4ee2-4650-ad51-9883edc2ea79}</UniqueIdentifier>
    </Filter>
    <Filter Include="Math">
      <UniqueIdentifier>{9ab1711d-d388-44ec-96ba-ce6ce915334c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource">
      <UniqueIdentifier>{cd7f0920-dd49-4592-86fa-5cc731dccc22}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Enemy">
      <UniqueIdentifier>{46cf7957-30a3-4826-a7c3-b4e172c28a6f}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\GameCharacter">
      <UniqueIdentifier>{8a22159a-1dbf-4efb-aaa0-b78171bdf8d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Player">
      <UniqueIdentifier>{5763af23-4495-4d95-ab7c-8e5cd5575a33}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Enemy\Base">
      <UniqueIdentifier>{15419c83-d69a-44af-85b5-bd7fdfd5f559}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Enemy\CloseRange">
      <UniqueIdentifier>{8762c489-74ef-4f11-81b8-7d564aff190c}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Enemy\LongRange">
      <UniqueIdentifier>{829a48a3-1384-42a5-b4a5-0db1799284b4}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Enemy\State">
      <UniqueIdentifier>{3c568908-0279-4052-95cc-e14938c40a84}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Enemy\Manager">
      <UniqueIdentifier>{98ab8bf7-927a-4ff1-8b7b-8884ede0595b}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Enemy\State\Base">
      <UniqueIdentifier>{a96e1b4a-6cf5-477e-ad7a-2d1ec1853299}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Player\State">
      <UniqueIdentifier>{8f50ec41-028d-4999-8cb4-255de96c8ddb}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Player\Weapon">
      <UniqueIdentifier>{08ac4947-14bf-4baa-8409-64009d3a0cb4}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Entity\Player\State\Base">
      <UniqueIdentifier>{9b5525b2-1a4a-4526-8b22-c3f317798217}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Camera">
      <UniqueIdentifier>{406750d7-3536-417c-bc57-4798477aab2a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Core">
      <UniqueIdentifier>{d739916b-c921-4b95-bad9-c65f517693ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\DataInfo">
      <UniqueIdentifier>{5334b93e-9ac6-4c27-8018-f878c73cc22e}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics">
      <UniqueIdentifier>{e7e15fb2-c760-4e63-a30b-06bdefc8375a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Scene">
      <UniqueIdentifier>{fc49bfc1-9e68-4308-ab96-e007191cde7c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\System">
      <UniqueIdentifier>{d146c341-5d55-4212-835b-96549f3a169b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Collider\Base">
      <UniqueIdentifier>{3ed911fe-cfe3-4e4e-86d1-0efe2f7fa4a3}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\2D">
      <UniqueIdentifier>{c17124e2-5aaa-4f1a-b822-a13e0f106e1a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\3D">
      <UniqueIdentifier>{492c262c-df5f-4661-b286-c27dfe7f7ad9}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\Base">
      <UniqueIdentifier>{a03dfd2b-5f58-4c6c-88a4-ba46065e6874}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\OffScreen">
      <UniqueIdentifier>{a3199f09-2924-4087-96bc-0b2158e1743d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\Particle">
      <UniqueIdentifier>{6dab81c7-9fb6-407e-b4ce-8f9288ed88ec}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\Pipeline">
      <UniqueIdentifier>{4cfff284-e1c1-4eee-894f-ef90b409fdbd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\3D\Base">
      <UniqueIdentifier>{727db2ef-5c52-444e-8c22-bf0b7697119c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\3D\Line">
      <UniqueIdentifier>{cb72e48c-de25-400c-845b-6deac8dc34a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\3D\Moel">
      <UniqueIdentifier>{24a22b7d-2066-4c3b-8e0b-93f3be523f46}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\3D\Primitive3D">
      <UniqueIdentifier>{751e0f66-a86c-4344-b347-d5591b222e64}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\3D\SkyBox">
      <UniqueIdentifier>{4a646223-14eb-4142-9188-fb09b4a5c6a0}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\OffScreen\Effect">
      <UniqueIdentifier>{bdcd1d96-d618-47c3-9488-851f0e350bac}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\Particle\Base">
      <UniqueIdentifier>{c51d0923-1ca7-473c-98ef-c645c2b6ae80}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\Particle\Derivative">
      <UniqueIdentifier>{75067441-708b-45c3-98e3-2f3618ea31f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\System\ImGui">
      <UniqueIdentifier>{1ba47b9d-0e95-4338-9f1f-64d69dece035}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\System\Input">
      <UniqueIdentifier>{5213cf03-f4a4-4fed-af07-730386c573cf}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\System\Manager">
      <UniqueIdentifier>{8272557d-6a59-4e0b-802b-4dae3138e967}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\System\Service">
      <UniqueIdentifier>{482e8d8e-2156-475d-93ae-2d00c96bdd5c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource\Shaders">
      <UniqueIdentifier>{d5376277-5907-465c-b4fc-6f636f9f830c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource\Shaders\2D">
      <UniqueIdentifier>{ba6ff5dc-c140-414b-9b41-91b91e9bff15}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource\Shaders\3D">
      <UniqueIdentifier>{07f68af8-0d5f-4e19-9d88-79a33e905879}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource\Shaders\OffScreen">
      <UniqueIdentifier>{ea4921dd-8093-4474-adcb-3ff1d8c5cb49}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource\Shaders\Particle">
      <UniqueIdentifier>{e208032c-4174-4e19-86e0-f615c28dde0d}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Scene\Transition">
      <UniqueIdentifier>{b8f4e3a6-2da5-413a-9528-f6cef748c013}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\UI">
      <UniqueIdentifier>{40deb47d-99c0-4514-b379-f9406b1914b1}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\UI\Title">
      <UniqueIdentifier>{3a1fbc3e-6980-4309-b497-63300e33f2de}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\2D\Base">
      <UniqueIdentifier>{9e5b3652-441f-4ca3-a932-4206d1d0aaeb}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\2D\Sprite">
      <UniqueIdentifier>{2562fb89-85bb-4bad-9689-08236e5b4917}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource\Shaders\Oshan">
      <UniqueIdentifier>{2dce79e3-2a1e-4233-b40a-999ce9144972}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Animation">
      <UniqueIdentifier>{085e0d29-b6e3-4284-83a5-a67f8d2ef173}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Transition">
      <UniqueIdentifier>{ac3e439e-48cc-4acf-b0fc-9847e8a02d95}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\Oshan">
      <UniqueIdentifier>{393687b5-6d3a-4c5f-bea1-cc4c155d66f4}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\System\DeltaTime">
      <UniqueIdentifier>{a33a4348-398a-4784-ae8d-6b689a04db3d}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Object\GameGround">
      <UniqueIdentifier>{6aa7c32d-ec09-4e50-8d8d-59d2fa4d56b3}</UniqueIdentifier>
    </Filter>
    <Filter Include="application\Game\Object\GameObject">
      <UniqueIdentifier>{4a5f8f95-907f-4a10-baee-87153ed89ae1}</UniqueIdentifier>
    </Filter>
    <Filter Include="Engine\Graphics\3D\Oshan">
      <UniqueIdentifier>{162736ff-601d-43a0-a358-c07c7e42961a}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
</Project>

============================================================
File Path: Project/Math/EasingMath.cpp
============================================================
#include "EasingMath.h"
#define _USE_MATH_DEFINES
#include <cmath>

namespace Easing {
    // ç·šå½¢è£œé–“ï¼ˆç­‰é€Ÿã§å¤‰åŒ–ï¼‰
    float Linear(float t) {
        return t;
    }

    // 2æ¬¡é–¢æ•°ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆåŠ é€Ÿï¼‰
    float EaseInQuad(float t) {
        // å§‹ã‚ã¯ã‚†ã£ãã‚Šã€å¾ŒåŠã§åŠ é€Ÿ
        return t * t;
    }

    float EaseOutQuad(float t) {
        // å§‹ã‚ã¯é€Ÿãã€å¾ŒåŠã§æ¸›é€Ÿ
        return 1.0f - (1.0f - t) * (1.0f - t);
    }

    float EaseInOutQuad(float t) {
        // å‰åŠã¯åŠ é€Ÿã€å¾ŒåŠã¯æ¸›é€Ÿ
        if (t < 0.5f) {
            return 2.0f * t * t;
        }
        return 1.0f - std::pow(-2.0f * t + 2.0f, 2.0f) / 2.0f;
    }

    // 3æ¬¡é–¢æ•°ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã‚ˆã‚Šæ€¥ãªåŠ é€Ÿ/æ¸›é€Ÿï¼‰
    float EaseInCubic(float t) {
        // å§‹ã‚ã¯éå¸¸ã«ã‚†ã£ãã‚Šã€å¾ŒåŠã§æ€¥åŠ é€Ÿ
        return t * t * t;
    }

    float EaseOutCubic(float t) {
        // å§‹ã‚ã¯æ€¥åŠ é€Ÿã€å¾ŒåŠã§ã‚†ã£ãã‚Š
        return 1.0f - std::pow(1.0f - t, 3.0f);
    }

    float EaseInOutCubic(float t) {
        // å‰åŠã¯æ€¥åŠ é€Ÿã€å¾ŒåŠã¯æ€¥æ¸›é€Ÿ
        if (t < 0.5f) {
            return 4.0f * t * t * t;
        }
        return 1.0f - std::pow(-2.0f * t + 2.0f, 3.0f) / 2.0f;
    }

    // 4æ¬¡é–¢æ•°ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã•ã‚‰ã«æ€¥ãªåŠ é€Ÿ/æ¸›é€Ÿï¼‰
    float EaseInQuart(float t) {
        return t * t * t * t;
    }

    float EaseOutQuart(float t) {
        return 1.0f - std::pow(1.0f - t, 4.0f);
    }

    float EaseInOutQuart(float t) {
        if (t < 0.5f) {
            return 8.0f * t * t * t * t;
        }
        return 1.0f - std::pow(-2.0f * t + 2.0f, 4.0f) / 2.0f;
    }

    // 5æ¬¡é–¢æ•°ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆæœ€ã‚‚æ€¥ãªåŠ é€Ÿ/æ¸›é€Ÿï¼‰
    float EaseInQuint(float t) {
        return t * t * t * t * t;
    }

    float EaseOutQuint(float t) {
        return 1.0f - std::pow(1.0f - t, 5.0f);
    }

    float EaseInOutQuint(float t) {
        if (t < 0.5f) {
            return 16.0f * t * t * t * t * t;
        }
        return 1.0f - std::pow(-2.0f * t + 2.0f, 5.0f) / 2.0f;
    }

    // ã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆæ»‘ã‚‰ã‹ãªåŠ æ¸›é€Ÿï¼‰
    float EaseInSine(float t) {
        // å§‹ã‚ã¯ã‚†ã£ãã‚Šã€å¾ŒåŠã§åŠ é€Ÿ
        return 1.0f - std::cos(t * static_cast<float>(M_PI) / 2.0f);
    }

    float EaseOutSine(float t) {
        // å§‹ã‚ã¯é€Ÿãã€å¾ŒåŠã§ã‚†ã£ãã‚Š
        return std::sin(t * static_cast<float>(M_PI) / 2.0f);
    }

    float EaseInOutSine(float t) {
        // å‰åŠã¯åŠ é€Ÿã€å¾ŒåŠã¯æ¸›é€Ÿ
        return -(std::cos(static_cast<float>(M_PI) * t) - 1.0f) / 2.0f;
    }

    // æŒ‡æ•°é–¢æ•°ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆæ€¥æ¿€ãªåŠ é€Ÿ/æ¸›é€Ÿï¼‰
    float EaseInExpo(float t) {
        // å§‹ã‚ã¯éå¸¸ã«ã‚†ã£ãã‚Šã€å¾ŒåŠã§æ€¥åŠ é€Ÿ
        if (t == 0.0f) return 0.0f;
        return std::pow(2.0f, 10.0f * t - 10.0f);
    }

    float EaseOutExpo(float t) {
        // å§‹ã‚ã¯æ€¥åŠ é€Ÿã€å¾ŒåŠã§ã‚†ã£ãã‚Š
        if (t == 1.0f) return 1.0f;
        return 1.0f - std::pow(2.0f, -10.0f * t);
    }

    float EaseInOutExpo(float t) {
        // å‰åŠã¯æ€¥åŠ é€Ÿã€å¾ŒåŠã¯æ€¥æ¸›é€Ÿ
        if (t == 0.0f) return 0.0f;
        if (t == 1.0f) return 1.0f;
        if (t < 0.5f) {
            return std::pow(2.0f, 20.0f * t - 10.0f) / 2.0f;
        }
        return (2.0f - std::pow(2.0f, -20.0f * t + 10.0f)) / 2.0f;
    }

    // å††é‹å‹•ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆå††å¼§ã®ã‚ˆã†ãªå‹•ãï¼‰
    float EaseInCirc(float t) {
        // å§‹ã‚ã¯ã‚†ã£ãã‚Šã€å¾ŒåŠã§åŠ é€Ÿ
        return 1.0f - std::sqrt(1.0f - t * t);
    }

    float EaseOutCirc(float t) {
        // å§‹ã‚ã¯é€Ÿãã€å¾ŒåŠã§ã‚†ã£ãã‚Š
        return std::sqrt(1.0f - std::pow(t - 1.0f, 2.0f));
    }

    float EaseInOutCirc(float t) {
        // å‰åŠã¯åŠ é€Ÿã€å¾ŒåŠã¯æ¸›é€Ÿ
        if (t < 0.5f) {
            return (1.0f - std::sqrt(1.0f - std::pow(2.0f * t, 2.0f))) / 2.0f;
        }
        return (std::sqrt(1.0f - std::pow(-2.0f * t + 2.0f, 2.0f)) + 1.0f) / 2.0f;
    }

    // ãƒãƒƒã‚¯ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã™ã‚‹å‹•ãï¼‰
    float EaseInBack(float t) {
        // å§‹ã‚ã«å°‘ã—é€†æ–¹å‘ã«å‹•ã„ã¦ã‹ã‚‰åŠ é€Ÿ
        const float c1 = 1.70158f;
        const float c3 = c1 + 1.0f;
        return c3 * t * t * t - c1 * t * t;
    }

    float EaseOutBack(float t) {
        // çµ‚ã‚ã‚Šã«å°‘ã—ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã—ã¦ã‹ã‚‰æˆ»ã‚‹
        const float c1 = 1.70158f;
        const float c3 = c1 + 1.0f;
        return 1.0f + c3 * std::pow(t - 1.0f, 3.0f) + c1 * std::pow(t - 1.0f, 2.0f);
    }

    float EaseInOutBack(float t) {
        // ä¸¡ç«¯ã§ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã™ã‚‹å‹•ã
        const float c1 = 1.70158f;
        const float c2 = c1 * 1.525f;
        if (t < 0.5f) {
            return (std::pow(2.0f * t, 2.0f) * ((c2 + 1.0f) * 2.0f * t - c2)) / 2.0f;
        }
        return (std::pow(2.0f * t - 2.0f, 2.0f) * ((c2 + 1.0f) * (t * 2.0f - 2.0f) + c2) + 2.0f) / 2.0f;
    }

    // ãƒã‚¦ãƒ³ãƒ‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆè·³ã­ã‚‹å‹•ãï¼‰
    float EaseOutBounce(float t) {
        // è·³ã­ã‚‹ã‚ˆã†ãªæ¸›é€Ÿ
        const float n1 = 7.5625f;
        const float d1 = 2.75f;

        if (t < 1.0f / d1) {
            return n1 * t * t;
        } else if (t < 2.0f / d1) {
            t -= 1.5f / d1;
            return n1 * t * t + 0.75f;
        } else if (t < 2.5f / d1) {
            t -= 2.25f / d1;
            return n1 * t * t + 0.9375f;
        } else {
            t -= 2.625f / d1;
            return n1 * t * t + 0.984375f;
        }
    }

    float EaseInBounce(float t) {
        // è·³ã­ã‚‹ã‚ˆã†ãªåŠ é€Ÿ
        return 1.0f - EaseOutBounce(1.0f - t);
    }

    float EaseInOutBounce(float t) {
        // å‰åŠã¯åŠ é€Ÿã€å¾ŒåŠã¯æ¸›é€Ÿã—ãªãŒã‚‰è·³ã­ã‚‹
        if (t < 0.5f) {
            return (1.0f - EaseOutBounce(1.0f - 2.0f * t)) / 2.0f;
        }
        return (1.0f + EaseOutBounce(2.0f * t - 1.0f)) / 2.0f;
    }
}

============================================================
File Path: Project/Math/EasingMath.h
============================================================
#pragma once

namespace Easing {
	/// <summary>
	/// ç·šå½¢ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã€‚å…¥åŠ›å€¤ t ã‚’ãã®ã¾ã¾è¿”ã™
	/// </summary>
	/// <param name="t">è£œé–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã€‚é€šå¸¸ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ã®å€¤ã‚’å–ã‚Šã¾ã™ã€‚</param>
	/// <returns>å…¥åŠ›ã¨åŒã˜æµ®å‹•å°æ•°ç‚¹å€¤ï¼ˆt ã‚’ãã®ã¾ã¾è¿”ã™ï¼‰ã€‚</returns>
	float Linear(float t);

	/// <summary>
	/// äºŒæ¬¡ï¼ˆQuadï¼‰ã®ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ï¼ˆEase-Inï¼‰ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€‚å…¥åŠ›ã«åŸºã¥ã„ã¦åŠ é€Ÿã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">æ™‚é–“ã¾ãŸã¯é€²è¡Œåº¦ã‚’è¡¨ã™å€¤ã€‚é€šå¸¸ã¯ 0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1ï¼ˆçµ‚äº†ï¼‰ã®ç¯„å›²ã§ä¸ãˆã¾ã™ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®å€¤ã€‚å…¥åŠ› t ã«å¯¾ã™ã‚‹äºŒæ¬¡çš„ãªã‚¤ãƒ¼ã‚ºã‚¤ãƒ³çµæœï¼ˆé€šå¸¸ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseInQuad(float t);

	/// <summary>
	/// äºŒæ¬¡ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã® Ease-Out é–¢æ•°ã€‚é€²è¡Œåº¦ t ã«å¯¾ã—ã¦æ¸›é€Ÿã™ã‚‹è£œé–“å€¤ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é€²è¡Œåº¦ã¾ãŸã¯æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚åˆ»ï¼ˆé€šå¸¸ 0ã€œ1 ã®ç¯„å›²ï¼‰ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚’é©ç”¨ã—ãŸè£œé–“å€¤ï¼ˆfloatï¼‰ã€‚t ã«å¯¾ã—ã¦æ¸›é€Ÿã—ãŸå‡ºåŠ›ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	float EaseOutQuad(float t);

	/// <summary>
	/// äºŒæ¬¡ã®ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ãƒ»ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆè£œé–“ã‚’è¡Œã†ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã€‚é€²è¡Œåº¦ã«å¿œã˜ãŸè£œé–“å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">çµŒéæ™‚é–“ã¾ãŸã¯é€²è¡Œåº¦ã€‚é€šå¸¸ã¯ 0.0ã€œ1.0 ã®ç¯„å›²ã§ã€0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸé€²è¡Œåº¦ t ã«å¯¾ã™ã‚‹è£œé–“çµæœï¼ˆfloatï¼‰ã€‚ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ãƒ»ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆã®äºŒæ¬¡è£œé–“å€¤ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	float EaseInOutQuad(float t);

	/// <summary>
	/// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ï¼ˆåŠ é€Ÿï¼‰ã™ã‚‹3æ¬¡ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã€‚é€²æ—ã«å¿œã˜ã¦åŠ é€Ÿã™ã‚‹è£œé–“å€¤ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">è£œé–“ã®é€²æ—ã‚’è¡¨ã™å€¤ã€‚é€šå¸¸ã¯ 0ã€œ1 ã®ç¯„å›²ã§æŒ‡å®šã—ã¾ã™ï¼ˆ0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ï¼‰ã€‚</param>
	/// <returns>æ™‚åˆ» t ã«ãŠã‘ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®å€¤ã€‚é€šå¸¸ã¯ 0ã€œ1 ã®ç¯„å›²ã®è£œé–“çµæœã§ã™ã€‚</returns>
	float EaseInCubic(float t);

	/// <summary>
	/// ç«‹æ–¹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã®ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆé–¢æ•°ã€‚å…¥åŠ›ã®é€²è¡Œå€¤ã«å¯¾ã—ã¦æ¸›é€Ÿã™ã‚‹è£œé–“å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">çµŒéæ™‚é–“ã¾ãŸã¯é€²è¡Œæ¯”ç‡ã€‚é€šå¸¸ã¯ 0.0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1.0ï¼ˆçµ‚äº†ï¼‰ã®ç¯„å›²ã§ä½¿ç”¨ã—ã¾ã™ã€‚</param>
	/// <returns>å…¥åŠ› t ã«ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆï¼ˆç«‹æ–¹é–¢æ•°ã«ã‚ˆã‚‹æ¸›é€Ÿï¼‰ã‚’é©ç”¨ã—ãŸè£œé–“å€¤ã€‚é€šå¸¸ã¯ 0.0ã€œ1.0 ã®ç¯„å›²ã§å¤‰åŒ–ã—ã¾ã™ã€‚</returns>
	float EaseOutCubic(float t);

	/// <summary>
	/// 3æ¬¡ï¼ˆã‚­ãƒ¥ãƒ¼ãƒ“ãƒƒã‚¯ï¼‰ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ï¼ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆã®è£œé–“ã‚’è¡Œã†é–¢æ•°ã€‚å…¥åŠ›ã«å¿œã˜ã¦é–‹å§‹ã§åŠ é€Ÿã—çµ‚äº†ã§æ¸›é€Ÿã™ã‚‹è£œé–“å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚åˆ»ã¾ãŸã¯é€²è¡Œåº¦ï¼ˆé€šå¸¸ã¯ 0ã€œ1 ã®ç¯„å›²ï¼‰ã€‚0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã™ã€‚</param>
	/// <returns>è£œé–“ï¼ˆã‚¤ãƒ¼ã‚ºï¼‰å¾Œã®å€¤ã‚’ float å‹ã§è¿”ã™ã€‚é€šå¸¸ã¯å…¥åŠ› t ã¨åŒæ§˜ã« 0ã€œ1 ã®ç¯„å›²ã®å€¤ã«ãªã‚‹ã€‚</returns>
	float EaseInOutCubic(float t);

	/// <summary>
	/// å››ä¹—ã®ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ï¼ˆEaseInQuartï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">é€²è¡Œåº¦ã‚’è¡¨ã™å…¥åŠ›å€¤ã€‚é€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ã§ã€é–‹å§‹ã‹ã‚‰çµ‚äº†ã¸ã®æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨å¾Œã®å€¤ï¼ˆfloatï¼‰ã€‚t ã®å¢—åŠ ã«å¿œã˜ã¦åŠ é€Ÿã™ã‚‹å››ä¹—ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°çµæœã‚’è¿”ã—ã¾ã™ã€‚</returns>
	float EaseInQuart(float t);

	/// <summary>
	/// 4æ¬¡ã®ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆï¼ˆEase-Out Quartï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã€‚å…¥åŠ› t ã«å¯¾ã—ã¦æ¸›é€Ÿã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å€¤ã‚’è¨ˆç®—ã—ã¦è¿”ã™
	/// </summary>
	/// <param name="t">é€²è¡Œåº¦ã‚’è¡¨ã™å€¤ã€‚é€šå¸¸ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ã§ã€0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’ç¤ºã—ã¾ã™ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãŒé©ç”¨ã•ã‚ŒãŸå€¤ï¼ˆé€šå¸¸ã¯ 0 ï½ 1 ã®ç¯„å›²ã® floatï¼‰ã€‚</returns>
	float EaseOutQuart(float t);

	/// <summary>
	/// å››ä¹—ï¼ˆquarticï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã® Ease-In-Out ã‚’è¨ˆç®—ã—ã¾ã™ã€‚å‰åŠã§åŠ é€Ÿã—å¾ŒåŠã§æ¸›é€Ÿã™ã‚‹æ»‘ã‚‰ã‹ãªè£œé–“ã‚’æä¾›ã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“å€¤ï¼ˆé€šå¸¸ 0.0 ã‹ã‚‰ 1.0ï¼‰ã€‚0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã—ã¾ã™ã€‚ç¯„å›²å¤–ã®å€¤ã‚‚å—ã‘å–ã‚Œã¾ã™ãŒã€ãã®å ´åˆã®çµæœã¯é€šå¸¸ã® [0,1] åŒºé–“ã‹ã‚‰å¤–ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨å¾Œã®å€¤ï¼ˆé€šå¸¸ 0.0 ã‹ã‚‰ 1.0ï¼‰ã€‚t=0 ã®ã¨ã 0ã€t=1 ã®ã¨ã 1 ã«ãªã‚Šã¾ã™ã€‚</returns>
	float EaseInOutQuart(float t);

	/// <summary>
	/// ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ï¼ˆ5æ¬¡ï¼‰é–¢æ•°ã€‚å…¥åŠ›å€¤ t ã®5ä¹—ã«åŸºã¥ã„ã¦ã€é–‹å§‹æ™‚ã«é…ãå¾ã€…ã«åŠ é€Ÿã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚åˆ»ã¾ãŸã¯é€²æ—ï¼ˆé€šå¸¸ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ï¼‰ã®å€¤ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®å€¤ï¼ˆé€šå¸¸ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseInQuint(float t);

	/// <summary>
	/// ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆï¼ˆ5æ¬¡ï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã€‚æ™‚é–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ t ã«åŸºã¥ãã€æ¸›é€Ÿã™ã‚‹è£œé–“å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">è£œé–“ã®æ™‚é–“ï¼ˆé€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0ï¼‰ã€‚0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã™æ­£è¦åŒ–ã•ã‚ŒãŸé€²è¡Œåº¦ã€‚</param>
	/// <returns>t ã«å¯¾ã™ã‚‹ 5æ¬¡ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆæ›²ç·šã«åŸºã¥ãè£œé–“å€¤ã€‚å…¥åŠ›ç¯„å›²ã«å¿œã˜ã¦é€šå¸¸ã¯ 0.0ã€œ1.0 ã®ç¯„å›²ã«ãªã‚Šã¾ã™ã€‚</returns>
	float EaseOutQuint(float t);

	/// <summary>
	/// 5æ¬¡ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã®ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚¢ã‚¦ãƒˆè£œé–“ã‚’è¡Œã†é–¢æ•°
	/// </summary>
	/// <param name="t">é€²è¡Œåº¦ã‚’è¡¨ã™æ­£è¦åŒ–ã•ã‚ŒãŸå€¤ï¼ˆé€šå¸¸ã¯ 0.0 ã€œ 1.0ï¼‰ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸ t ã«å¯¾å¿œã™ã‚‹ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ã‚¢ã‚¦ãƒˆï¼ˆ5æ¬¡ï¼‰è£œé–“å¾Œã®å€¤ï¼ˆé€šå¸¸ã¯ 0.0 ã€œ 1.0ï¼‰ã€‚</returns>
	float EaseInOutQuint(float t);

	/// <summary>
	/// ã‚µã‚¤ãƒ³æ›²ç·šã«åŸºã¥ãã‚¤ãƒ¼ã‚ºã‚¤ãƒ³é–¢æ•°ã€‚å…¥åŠ›ã®é€²è¡Œç‡ã«å¿œã˜ã¦é–‹å§‹æ™‚ã«ã‚†ã£ãã‚ŠåŠ é€Ÿã™ã‚‹å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">é€²è¡Œç‡ã‚’è¡¨ã™å€¤ã€‚é€šå¸¸ã¯ 0.0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1.0ï¼ˆçµ‚äº†ï¼‰ã®ç¯„å›²ã§ä½¿ç”¨ã—ã¾ã™ã€‚</param>
	/// <returns>å…¥åŠ› t ã«å¯¾ã—ã¦ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ãŒé©ç”¨ã•ã‚ŒãŸå€¤ã€‚é€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ã¨ãªã‚Šã¾ã™ãŒã€å…¥åŠ›ã®ç¯„å›²ã«ä¾å­˜ã—ã¾ã™ã€‚</returns>
	float EaseInSine(float t);

	/// <summary>
	/// ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆï¼ˆSineï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã€‚æ™‚é–“ t ã«åŸºã¥ã„ã¦ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆã•ã‚ŒãŸå€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">é€²è¡Œæ™‚é–“ã¾ãŸã¯æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ï¼ˆé€šå¸¸ã¯ 0ã€œ1 ã®ç¯„å›²ï¼‰ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆã•ã‚ŒãŸå€¤ï¼ˆé€šå¸¸ã¯ 0ã€œ1 ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseOutSine(float t);

	/// <summary>
	/// ã‚µã‚¤ãƒ³é–¢æ•°ã«åŸºã¥ãã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ãƒ»ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆè£œé–“ã®å€¤ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">è£œé–“ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã¨ãªã‚‹æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚åˆ»ã€‚é€šå¸¸ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ã§ä½¿ç”¨ã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸæ™‚åˆ» t ã«ãŠã‘ã‚‹è£œé–“å€¤ï¼ˆé€šå¸¸ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseInOutSine(float t);

	/// <summary>
	/// æŒ‡æ•°é–¢æ•°çš„ãªã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆEase-Inï¼‰ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">çµŒéæ™‚é–“ã¾ãŸã¯é€²è¡Œç‡ã€‚é€šå¸¸ã¯0ã‹ã‚‰1ã®ç¯„å›²ã§æ¸¡ã—ã€0ã§é–‹å§‹ã—ã¦1ã§çµ‚äº†ã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸé€²è¡Œã«å¯¾ã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å€¤ï¼ˆé€šå¸¸0ã‹ã‚‰1ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseInExpo(float t);

	/// <summary>
	/// æŒ‡æ•°é–¢æ•°çš„ãªã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆï¼ˆEase-Out-Expoï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã®å€¤ã‚’è¨ˆç®—ã—ã¾ã™ã€‚æ™‚é–“ã®çµŒéã«ä¼´ã„æ€¥é€Ÿã«æ¸›é€Ÿã™ã‚‹è£œé–“ã‚’æä¾›ã™ã‚‹
	/// </summary>
	/// <param name="t">çµŒéæ™‚é–“ã¾ãŸã¯é€²æ—ã‚’è¡¨ã™å€¤ã€‚é€šå¸¸ã¯ 0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1ï¼ˆçµ‚äº†ï¼‰ã®ç¯„å›²ã§æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã•ã‚ŒãŸæ™‚ç‚¹ã«ãŠã‘ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å‡ºåŠ›ã€‚é€šå¸¸ã¯ 0 ã‹ã‚‰ 1 ã®ç¯„å›²ã§ã€é€²è¡Œã«ä¼´ã£ã¦æŒ‡æ•°é–¢æ•°çš„ã«æ¸›é€Ÿã™ã‚‹å€¤ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	float EaseOutExpo(float t);

	/// <summary>
	/// æŒ‡æ•°é–¢æ•°çš„ãªã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ãƒ»ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆè£œé–“ã‚’è¡Œã†é–¢æ•°
	/// </summary>
	/// <param name="t">é€²è¡Œæ™‚é–“ã¾ãŸã¯æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚åˆ»ã€‚é€šå¸¸ã¯ 0.0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1.0ï¼ˆçµ‚äº†ï¼‰ã¾ã§ã®ç¯„å›²ã§æŒ‡å®šã™ã‚‹ã€‚</param>
	/// <returns>æ™‚åˆ» t ã«ãŠã‘ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®å€¤ã€‚é€šå¸¸ã¯ 0.0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1.0ï¼ˆçµ‚äº†ï¼‰ã¾ã§ã®ç¯„å›²ã®å€¤ã‚’è¿”ã™ã€‚</returns>
	float EaseInOutExpo(float t);

	/// <summary>
	/// å††å½¢ï¼ˆcircularï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã® Ease-In å€¤ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼ˆé€šå¸¸ã¯ 0 ã‹ã‚‰ 1ï¼‰ã€‚0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸæ™‚é–“ t ã«å¯¾å¿œã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°æ¸ˆã¿ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚é€šå¸¸ã¯ 0ã€œ1 ã®ç¯„å›²ã®è£œé–“å€¤ã§ã™ã€‚</returns>
	float EaseInCirc(float t);

	/// <summary>
	/// å††å½¢ï¼ˆcircï¼‰ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã® Ease Out é–¢æ•°ã€‚é€²è¡Œåº¦ t ã«å¿œã˜ã¦çµ‚ç«¯ã§æ¸›é€Ÿã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å€¤ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ãƒ»é€²è¡Œåº¦ï¼ˆé€šå¸¸ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ï¼‰ã€‚0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <returns>å…¥åŠ› t ã«å¯¾ã™ã‚‹ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®å€¤ã€‚é€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ã§ã€t ãŒå¢—åŠ ã™ã‚‹ã»ã©å€¤ã‚‚å¢—åŠ ã—ã€çµ‚äº†æ™‚ã«ç·©ã‚„ã‹ã«ãªã‚Šã¾ã™ã€‚</returns>
	float EaseOutCirc(float t);

	/// <summary>
	/// å††å½¢ã®ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ãƒ»ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆè£œé–“ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ã¾ãŸã¯é€²è¡Œåº¦ã€‚é€šå¸¸ã¯ 0ï½1 ã®ç¯„å›²ã§ã€ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°è¨ˆç®—ã®å…¥åŠ›ã¨ãªã‚Šã¾ã™ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®å€¤ã€‚é€²è¡Œåº¦ã«å¿œã˜ã¦åŠ é€Ÿãƒ»æ¸›é€Ÿã™ã‚‹è£œé–“çµæœï¼ˆé€šå¸¸ 0ï½1 ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseInOutCirc(float t);

	/// <summary>
	/// é–‹å§‹æ™‚ã«ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã™ã‚‹ãƒãƒƒã‚¯ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚’é©ç”¨ã—ã¦é€²æ—å€¤ã‚’å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="t">é€²è¡Œæ™‚é–“ã¾ãŸã¯æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚åˆ»ã€‚é€šå¸¸ã¯ 0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1ï¼ˆçµ‚äº†ï¼‰ã®ç¯„å›²ã®å€¤ã‚’å–ã‚Šã¾ã™ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®å€¤ã‚’è¡¨ã™æµ®å‹•å°æ•°ç‚¹æ•°ã€‚ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã«ã‚ˆã‚Š 0â€“1 ã®ç¯„å›²ã‚’è¶…ãˆã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	float EaseInBack(float t);

	/// <summary>
	/// ãƒãƒƒã‚¯ï¼ˆã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆï¼‰åŠ¹æœã‚’æŒã¤ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆé–¢æ•°ã€‚æ™‚é–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«å¿œã˜ã¦æ¸›é€Ÿã—ã¤ã¤ç›®æ¨™ã‚’è¶…ãˆã¦æˆ»ã‚‹è£œé–“å€¤ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé€šå¸¸ã¯ 0ã€œ1ï¼‰ã€‚0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šæ™‚ç‚¹ã®è£œé–“å¾Œã®æµ®å‹•å°æ•°ç‚¹å€¤ã€‚é€šå¸¸ã¯ 0ã€œ1 ã®ç¯„å›²ã§ã™ãŒã€ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆã«ã‚ˆã‚Šç¯„å›²ã‚’è¶…ãˆã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</returns>
	float EaseOutBack(float t);

	/// <summary>
	/// ãƒãƒƒã‚¯ï¼ˆã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆï¼‰ã‚’ä¼´ã†ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ãƒ»ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆè£œé–“ã‚’è¨ˆç®—ã™ã‚‹é–¢æ•°ã€ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚„è£œé–“å‡¦ç†ã§ä½¿ç”¨ã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸé€²è¡Œåº¦ï¼ˆæ™‚é–“ï¼‰ã‚’ç¤ºã™å€¤ã€‚é€šå¸¸ã¯ 0.0ï¼ˆé–‹å§‹ï¼‰ã‹ã‚‰ 1.0ï¼ˆçµ‚äº†ï¼‰ã®ç¯„å›²ã§ä½¿ç”¨ã—ã¾ã™ã€‚</param>
	/// <returns>å¼•æ•° t ã«å¯¾å¿œã™ã‚‹è£œé–“å€¤ã€‚ãƒãƒƒã‚¯åŠ¹æœã«ã‚ˆã‚Šè¿”ã‚Šå€¤ãŒ 0.0ã€œ1.0 ã®ç¯„å›²ã‚’ä¸€æ™‚çš„ã«è¶…ãˆã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	float EaseInOutBack(float t);

	/// <summary>
	/// ãƒã‚¦ãƒ³ã‚¹ï¼ˆè·³ã­è¿”ã‚Šï¼‰åŠ¹æœã‚’æŒã¤ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³é–¢æ•°ã€‚æ™‚é–“ã®é€²è¡Œã«å¿œã˜ã¦è·³ã­è¿”ã‚‹ã‚ˆã†ãªè£œé–“å€¤ã‚’ç”Ÿæˆã™ã‚‹
	/// </summary>
	/// <param name="t">æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚åˆ»ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ï¼ˆé€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0ï¼‰ã€‚0 ãŒé–‹å§‹ã€1 ãŒçµ‚äº†ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <returns>ã‚¤ãƒ¼ã‚ºã•ã‚ŒãŸæµ®å‹•å°æ•°ç‚¹å€¤ã‚’è¿”ã—ã¾ã™ã€‚é€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ã§ã€ãƒã‚¦ãƒ³ã‚¹åŠ¹æœã‚’ä¼´ã†è£œé–“çµæœã¨ãªã‚Šã¾ã™ã€‚</returns>
	float EaseInBounce(float t);

	/// <summary>
	/// ãƒã‚¦ãƒ³ã‚¹ï¼ˆå¼¾ã‚€ï¼‰åŠ¹æœã®ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã€‚ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®é€²è¡Œã«å¿œã˜ã¦å¼¾ã‚€ã‚ˆã†ãªè£œé–“å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="t">é€²è¡Œæ™‚é–“ã¾ãŸã¯æ­£è¦åŒ–ã•ã‚ŒãŸä½ç½®ï¼ˆé€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ï¼‰ã€‚</param>
	/// <returns>ãƒã‚¦ãƒ³ã‚¹åŠ¹æœã‚’é©ç”¨ã—ãŸè£œé–“çµæœï¼ˆé€šå¸¸ã¯ 0.0 ã‹ã‚‰ 1.0 ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseOutBounce(float t);

	/// <summary>
	/// ãƒã‚¦ãƒ³ã‚¹ï¼ˆè·³ã­è¿”ã‚Šï¼‰åŠ¹æœã®ã‚ã‚‹ã‚¤ãƒ¼ã‚ºã‚¤ãƒ³ãƒ»ã‚¤ãƒ¼ã‚ºã‚¢ã‚¦ãƒˆè£œé–“ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="t">è£œé–“ã®é€²è¡Œã‚’è¡¨ã™å€¤ï¼ˆé€šå¸¸ã¯æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ã€0.0ã€œ1.0ï¼‰ã€‚</param>
	/// <returns>ãƒã‚¦ãƒ³ã‚¹åŠ¹æœã‚’é©ç”¨ã—ãŸè£œé–“å€¤ï¼ˆé€šå¸¸ã¯0.0ã€œ1.0ã®ç¯„å›²ï¼‰ã€‚</returns>
	float EaseInOutBounce(float t);
}


============================================================
File Path: Project/Math/Matrix3x3.cpp
============================================================
#include "Matrix3x3.h"

///=====================================================///
///è¡Œåˆ—ã®åŠ æ³•
///=====================================================///
Matrix3x3 Add(const Matrix3x3& m1, const Matrix3x3& m2) {

	Matrix3x3 result{};

	result.m[0][0] = m1.m[0][0] + m2.m[0][0];
	result.m[0][1] = m1.m[0][1] + m2.m[0][1];
	result.m[0][2] = m1.m[0][2] + m2.m[0][2];
	result.m[1][0] = m1.m[1][0] + m2.m[1][0];
	result.m[1][1] = m1.m[1][1] + m2.m[1][1];
	result.m[1][2] = m1.m[1][2] + m2.m[1][2];
	result.m[2][0] = m1.m[2][0] + m2.m[2][0];
	result.m[2][1] = m1.m[2][1] + m2.m[2][1];
	result.m[2][2] = m1.m[2][2] + m2.m[2][2];

	return result;
}

///=====================================================///
///è¡Œåˆ—ã®æ¸›æ³•
///=====================================================///
Matrix3x3 Subject(const Matrix3x3& m1, const Matrix3x3& m2) {

	Matrix3x3 result{};

	result.m[0][0] = m1.m[0][0] - m2.m[0][0];
	result.m[0][1] = m1.m[0][1] - m2.m[0][1];
	result.m[0][2] = m1.m[0][2] - m2.m[0][2];
	result.m[1][0] = m1.m[1][0] - m2.m[1][0];
	result.m[1][1] = m1.m[1][1] - m2.m[1][1];
	result.m[1][2] = m1.m[1][2] - m2.m[1][2];
	result.m[2][0] = m1.m[2][0] - m2.m[2][0];
	result.m[2][1] = m1.m[2][1] - m2.m[2][1];
	result.m[2][2] = m1.m[2][2] - m2.m[2][2];

	return result;
}

///=====================================================///
///è¡Œåˆ—ã®ç©
///=====================================================///
Matrix3x3 Multiply(const Matrix3x3& m1, const Matrix3x3& m2) {

	Matrix3x3 answer = {};
	for (int x = 0; x < 3; ++x) {
		for (int y = 0; y < 3; ++y) {

			answer.m[x][y] = 0;
			for (int z = 0; z < 3; ++z) {

				answer.m[x][y] += m1.m[x][z] * m2.m[z][y];
			}
		}
	}

	return answer;
}

============================================================
File Path: Project/Math/Matrix3x3.h
============================================================
#pragma once

/// <summary>
/// 3x3è¡Œåˆ—
/// </summary>
struct Matrix3x3 final {
	float m[3][3];
};

/// <summary>
/// è¡Œåˆ—ã®åŠ æ³•
/// </summary>
/// <param name="m1"></param>
/// <param name="m2"></param>
/// <returns></returns>
// Matrix3x3
Matrix3x3 Add(const Matrix3x3& m1, const Matrix3x3& m2);

/// <summary>
/// è¡Œåˆ—ã®æ¸›æ³•
/// </summary>
/// <param name="m1"></param>
/// <param name="m2"></param>
/// <returns></returns>
// Matrix3x3
Matrix3x3 Subject(const Matrix3x3& m1, const Matrix3x3& m2);

/// <summary>
/// è¡Œåˆ—ã®ç©
/// </summary>
/// <param name="m1"></param>
/// <param name="m2"></param>
/// <returns></returns>
// Matrix3x3
Matrix3x3 Multiply(const Matrix3x3& m1, const Matrix3x3& m2);

============================================================
File Path: Project/Math/Matrix4x4.cpp
============================================================
#include "Matrix4x4.h"

///=====================================================///
///è¡Œåˆ—ã®åŠ æ³•
///=====================================================///
Matrix4x4 Add(const Matrix4x4& m1, const Matrix4x4& m2) {

	Matrix4x4 result = {};

	result.m[0][0] = m1.m[0][0] + m2.m[0][0];
	result.m[0][1] = m1.m[0][1] + m2.m[0][1];
	result.m[0][2] = m1.m[0][2] + m2.m[0][2];
	result.m[0][3] = m1.m[0][3] + m2.m[0][3];
	result.m[1][0] = m1.m[1][0] + m2.m[1][0];
	result.m[1][1] = m1.m[1][1] + m2.m[1][1];
	result.m[1][2] = m1.m[1][2] + m2.m[1][2];
	result.m[1][3] = m1.m[1][3] + m2.m[1][3];
	result.m[2][0] = m1.m[2][0] + m2.m[2][0];
	result.m[2][1] = m1.m[2][1] + m2.m[2][1];
	result.m[2][2] = m1.m[2][2] + m2.m[2][2];
	result.m[2][3] = m1.m[2][3] + m2.m[2][3];
	result.m[3][0] = m1.m[3][0] + m2.m[3][0];
	result.m[3][1] = m1.m[3][1] + m2.m[3][1];
	result.m[3][2] = m1.m[3][2] + m2.m[3][2];
	result.m[3][3] = m1.m[3][3] + m2.m[3][3];

	return result;
}

///=====================================================///
///è¡Œåˆ—ã®æ¸›æ³•
///=====================================================///
Matrix4x4 Subject(const Matrix4x4& m1, const Matrix4x4& m2) {

	Matrix4x4 result = {};

	result.m[0][0] = m1.m[0][0] - m2.m[0][0];
	result.m[0][1] = m1.m[0][1] - m2.m[0][1];
	result.m[0][2] = m1.m[0][2] - m2.m[0][2];
	result.m[0][3] = m1.m[0][3] - m2.m[0][3];
	result.m[1][0] = m1.m[1][0] - m2.m[1][0];
	result.m[1][1] = m1.m[1][1] - m2.m[1][1];
	result.m[1][2] = m1.m[1][2] - m2.m[1][2];
	result.m[1][3] = m1.m[1][3] - m2.m[1][3];
	result.m[2][0] = m1.m[2][0] - m2.m[2][0];
	result.m[2][1] = m1.m[2][1] - m2.m[2][1];
	result.m[2][2] = m1.m[2][2] - m2.m[2][2];
	result.m[2][3] = m1.m[2][3] - m2.m[2][3];
	result.m[3][0] = m1.m[3][0] - m2.m[3][0];
	result.m[3][1] = m1.m[3][1] - m2.m[3][1];
	result.m[3][2] = m1.m[3][2] - m2.m[3][2];
	result.m[3][3] = m1.m[3][3] - m2.m[3][3];

	return result;
}

///=====================================================///
///è¡Œåˆ—ã®ç©
///=====================================================///
Matrix4x4 Multiply(const Matrix4x4& m1, const Matrix4x4& m2) {

	Matrix4x4 answer = {};
	for (int y = 0; y < 4; ++y) {  // æ­£ã—ãã€Œè¡Œã€ã‚’å›ºå®šã™ã‚‹
		for (int x = 0; x < 4; ++x) {  // ã€Œåˆ—ã€ã‚’å›ã™

			answer.m[y][x] = 0;  // â† ã“ã“ã§ y, x ã®é †ç•ªã‚’åˆã‚ã›ã‚‹
			for (int z = 0; z < 4; ++z) {
				answer.m[y][x] += m1.m[y][z] * m2.m[z][x];  // æ­£ã—ã„æ›ã‘ç®—ã®é †ç•ª
			}
		}
	}
	return answer;
}

============================================================
File Path: Project/Math/Matrix4x4.h
============================================================
#pragma once
/// <summary>
/// 4x4è¡Œåˆ—
/// </summary>
struct Matrix4x4 final {
	float m[4][4];
};

/// <summary>
/// è¡Œåˆ—ã®åŠ æ³•
/// </summary>
/// <param name="m1"></param>
/// <param name="m2"></param>
/// <returns></returns>
Matrix4x4 Add(const Matrix4x4& m1, const Matrix4x4& m2);

/// <summary>
/// è¡Œåˆ—ã®æ¸›æ³•
/// </summary>
/// <param name="m1"></param>
/// <param name="m2"></param>
/// <returns></returns>
Matrix4x4 Subject(const Matrix4x4& m1, const Matrix4x4& m2);

/// <summary>
/// è¡Œåˆ—ã®ç©
/// </summary>
/// <param name="m1"></param>
/// <param name="m2"></param>
/// <returns></returns>
Matrix4x4 Multiply(const Matrix4x4& m1, const Matrix4x4& m2);

============================================================
File Path: Project/Math/MatrixMath.cpp
============================================================
#include "MatrixMath.h"

#define _USE_MATH_DEFINES
#include <cmath>
#include <cassert>

///=====================================================///
/// å¹³è¡Œç§»å‹•è¡Œåˆ—
///=====================================================///
Matrix4x4 Math::MakeTranslateMatrix(const Vector3& translate) {
	// å˜ä½è¡Œåˆ—ã‚’åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	// å¹³è¡Œç§»å‹•æˆåˆ†ã‚’ã‚»ãƒƒãƒˆ
	result.m[3][0] = translate.x;
	result.m[3][1] = translate.y;
	result.m[3][2] = translate.z;

	return result;
}

///=====================================================///
/// æ‹¡å¤§ç¸®å°è¡Œåˆ—
///=====================================================///
Matrix4x4 Math::MakeScaleMatrix(const Vector3& scale) {
	// å˜ä½è¡Œåˆ—ã‚’åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	// æ‹¡å¤§ç¸®å°æˆåˆ†ã‚’ã‚»ãƒƒãƒˆ
	result.m[0][0] = scale.x;
	result.m[1][1] = scale.y;
	result.m[2][2] = scale.z;

	return result;
}

///=====================================================///
/// å›è»¢è¡Œåˆ—
///=====================================================///
// Xè»¸
Matrix4x4 Math::MakeRotateXMatrix(float radian) {
	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	// è¡Œåˆ—ã®è¨ˆç®—
	result.m[1][1] = std::cos(radian);
	result.m[1][2] = std::sin(radian);
	result.m[2][1] = -std::sin(radian);
	result.m[2][2] = std::cos(radian);

	return result;
}
// Yè»¸
Matrix4x4 Math::MakeRotateYMatrix(float radian) {
	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	// è¡Œåˆ—ã®è¨ˆç®—
	result.m[0][0] = std::cos(radian);
	result.m[0][2] = -std::sin(radian);
	result.m[2][0] = std::sin(radian);
	result.m[2][2] = std::cos(radian);

	return result;
}
// Zè»¸
Matrix4x4 Math::MakeRotateZMatrix(float radian) {
	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	// è¡Œåˆ—ã®è¨ˆç®—
	result.m[0][0] = std::cos(radian);
	result.m[0][1] = std::sin(radian);
	result.m[1][0] = -std::sin(radian);
	result.m[1][1] = std::cos(radian);

	return result;
}
// Quaternion
Matrix4x4 Math::MakeRotateQuaternionMatrix(const Quaternion q) {
	float xx = q.x * q.x;
	float yy = q.y * q.y;
	float zz = q.z * q.z;
	float xy = q.x * q.y;
	float xz = q.x * q.z;
	float yz = q.y * q.z;
	float wx = q.w * q.x;
	float wy = q.w * q.y;
	float wz = q.w * q.z;

	Matrix4x4 result = {};
	result.m[0][0] = 1.0f - 2.0f * (yy + zz);
	result.m[0][1] = 2.0f * (xy + wz);
	result.m[0][2] = 2.0f * (xz - wy);
	result.m[0][3] = 0.0f;

	result.m[1][0] = 2.0f * (xy - wz);
	result.m[1][1] = 1.0f - 2.0f * (xx + zz);
	result.m[1][2] = 2.0f * (yz + wx);
	result.m[1][3] = 0.0f;

	result.m[2][0] = 2.0f * (xz + wy);
	result.m[2][1] = 2.0f * (yz - wx);
	result.m[2][2] = 1.0f - 2.0f * (xx + yy);
	result.m[2][3] = 0.0f;

	result.m[3][0] = 0.0f;
	result.m[3][1] = 0.0f;
	result.m[3][2] = 0.0f;
	result.m[3][3] = 1.0f;

	return result;
}

///=====================================================///
/// ä¸‰æ¬¡å…ƒã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›
///=====================================================///
// EulerTransform
Matrix4x4 Math::MakeAffineEulerMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {
	// æ‹¡å¤§ç¸®å°è¡Œåˆ—
	Matrix4x4 scaleMatrix = MakeScaleMatrix(scale);

	// å›è»¢è¡Œåˆ—
	Matrix4x4 rotateXMatrix = MakeRotateXMatrix(rotate.x);
	Matrix4x4 rotateYMatrix = MakeRotateYMatrix(rotate.y);
	Matrix4x4 rotateZMatrix = MakeRotateZMatrix(rotate.z);
	Matrix4x4 rotateMatrix = Multiply(rotateXMatrix, Multiply(rotateYMatrix, rotateZMatrix));

	// å¹³è¡Œç§»å‹•è¡Œåˆ—
	Matrix4x4 translateMatrix = MakeTranslateMatrix(translate);

	// åˆæˆï¼ˆã‚¹ã‚±ãƒ¼ãƒ« -> å›è»¢ -> å¹³è¡Œç§»å‹•ï¼‰
	return Multiply(Multiply(scaleMatrix, rotateMatrix), translateMatrix);
}
// QuaternionTransform
Matrix4x4 Math::MakeAffineQuaternionMatrix(const Vector3& scale, const Quaternion& rotate, const Vector3& translate) {
	// æ‹¡å¤§ç¸®å°è¡Œåˆ—
	Matrix4x4 scaleMatrix = MakeScaleMatrix(scale);

	// å›è»¢è¡Œåˆ—
	Matrix4x4 rotateMatrix = MakeRotateQuaternionMatrix(rotate);

	// å¹³è¡Œç§»å‹•è¡Œåˆ—
	Matrix4x4 translateMatrix = MakeTranslateMatrix(translate);

	// åˆæˆï¼ˆã‚¹ã‚±ãƒ¼ãƒ« -> å›è»¢ -> å¹³è¡Œç§»å‹•ï¼‰
	return Multiply(Multiply(scaleMatrix, rotateMatrix), translateMatrix);
}



///=====================================================///
/// å˜ä½è¡Œåˆ—
///=====================================================///
// Matrix3x3
Matrix3x3 Math::MakeIdentity3x3() {
	// ã‚¼ãƒ­åˆæœŸåŒ–
	Matrix3x3 result = {};

	// å¯¾è§’æˆåˆ†ã‚’1ã«è¨­å®š
	result.m[0][0] = 1.0f;
	result.m[1][1] = 1.0f;
	result.m[2][2] = 1.0f;

	return result;
}
// Matrix4x4
Matrix4x4 Math::MakeIdentity4x4() {
	// ã‚¼ãƒ­åˆæœŸåŒ–
	Matrix4x4 result = {};

	// å¯¾è§’æˆåˆ†ã‚’1ã«è¨­å®š
	result.m[0][0] = 1.0f;
	result.m[1][1] = 1.0f;
	result.m[2][2] = 1.0f;
	result.m[3][3] = 1.0f;

	return result;
}

///=====================================================///
/// è»¢ç½®è¡Œåˆ—
///=====================================================///
Matrix4x4 Math::TransposeMatrix(const Matrix4x4& matrix) {
	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	for (int i = 0; i < 4; ++i) {
		for (int j = 0; j < 4; ++j) {
			result.m[i][j] = matrix.m[j][i];
		}
	}
	return result;
}

///=====================================================///
/// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¡Œåˆ—
///=====================================================///
Matrix4x4 Math::MakeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth) {
	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	float scaleX = width / 2.0f;
	float scaleY = height / 2.0f;
	float scaleZ = (maxDepth - minDepth);
	float offsetX = left + scaleX;
	float offsetY = top + scaleY;
	float offsetZ = minDepth;

	result = {
		{{scaleX, 0, 0, 0},
		 {0, -scaleY, 0, 0}, // - scaleYã¯ã€ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã®Yè»¸ãŒåè»¢ã—ã¦ã„ã‚‹ãŸã‚ã€‚
		 {0, 0, scaleZ, 0},
		 {offsetX, offsetY, offsetZ, 1}}
	};

	return result;
}

///=====================================================///
/// é€è¦–å½±è¡Œåˆ—
///=====================================================///
Matrix4x4 Math::MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip) {

	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	float tanHalfFovY = tan(fovY * 0.5f);
	float scaleX = 1.0f / (aspectRatio * tanHalfFovY);
	float scaleY = 1.0f / tanHalfFovY;
	float nearMinusFar = farClip - nearClip;

	result = {
		{{scaleX, 0, 0, 0}, {0, scaleY, 0, 0}, {0, 0, farClip / nearMinusFar, 1}, {0, 0, (-farClip * nearClip) / nearMinusFar, 0}}
	};

	return result;
}

///=====================================================///
/// æ­£å°„å½±è¡Œåˆ—
///=====================================================///
Matrix4x4 Math::MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip) {
	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();

	// æ­£å°„å½±å¹³é¢ã®ç¯„å›²ã‹ã‚‰æ­£å°„å½±è¡Œåˆ—ã‚’æ§‹ç¯‰ã™ã‚‹
	result.m[0][0] = 2.0f / (right - left);
	result.m[1][1] = 2.0f / (top - bottom);
	result.m[2][2] = -2.0f / (farClip - nearClip);
	result.m[3][0] = -(right + left) / (right - left);
	result.m[3][1] = -(top + bottom) / (top - bottom);
	result.m[3][2] = -(farClip + nearClip) / (farClip - nearClip);

	return result;
}



///=====================================================///
/// é€†è¡Œåˆ—
///=====================================================///
// Matrix3x3
Matrix3x3 Math::Inverse3x3(const Matrix3x3& matrix) {
	Matrix3x3 result = MakeIdentity3x3();

	// è¡Œåˆ—å¼ã‚’è¨ˆç®—
	float det =
		matrix.m[0][0] * (matrix.m[1][1] * matrix.m[2][2] - matrix.m[1][2] * matrix.m[2][1]) -
		matrix.m[0][1] * (matrix.m[1][0] * matrix.m[2][2] - matrix.m[1][2] * matrix.m[2][0]) +
		matrix.m[0][2] * (matrix.m[1][0] * matrix.m[2][1] - matrix.m[1][1] * matrix.m[2][0]);

	// è¡Œåˆ—å¼ãŒã‚¼ãƒ­ãªã‚‰ã°é€†è¡Œåˆ—ã¯å­˜åœ¨ã—ãªã„
	if (det == 0.0f) {
		return result; // å˜ä½è¡Œåˆ—ã‚’è¿”ã™ï¼ˆã¾ãŸã¯ã‚¨ãƒ©ãƒ¼å‡¦ç†ï¼‰
	}

	float invDet = 1.0f / det;

	// ä½™å› å­è¡Œåˆ—ã‚’è¨ˆç®—ã—è»¢ç½®
	result.m[0][0] = invDet * (matrix.m[1][1] * matrix.m[2][2] - matrix.m[1][2] * matrix.m[2][1]);
	result.m[0][1] = invDet * (matrix.m[0][2] * matrix.m[2][1] - matrix.m[0][1] * matrix.m[2][2]);
	result.m[0][2] = invDet * (matrix.m[0][1] * matrix.m[1][2] - matrix.m[0][2] * matrix.m[1][1]);

	result.m[1][0] = invDet * (matrix.m[1][2] * matrix.m[2][0] - matrix.m[1][0] * matrix.m[2][2]);
	result.m[1][1] = invDet * (matrix.m[0][0] * matrix.m[2][2] - matrix.m[0][2] * matrix.m[2][0]);
	result.m[1][2] = invDet * (matrix.m[0][2] * matrix.m[1][0] - matrix.m[0][0] * matrix.m[1][2]);

	result.m[2][0] = invDet * (matrix.m[1][0] * matrix.m[2][1] - matrix.m[1][1] * matrix.m[2][0]);
	result.m[2][1] = invDet * (matrix.m[0][1] * matrix.m[2][0] - matrix.m[0][0] * matrix.m[2][1]);
	result.m[2][2] = invDet * (matrix.m[0][0] * matrix.m[1][1] - matrix.m[0][1] * matrix.m[1][0]);

	return result;
}
// Matrix4x4
Matrix4x4 Math::Inverse4x4(const Matrix4x4& matrix) {
	// å˜ä½è¡Œåˆ—ã§åˆæœŸåŒ–
	Matrix4x4 result = MakeIdentity4x4();
	float det;

	// è¡Œåˆ—ã®è¡Œåˆ—å¼ã‚’è¨ˆç®—
	det =
		matrix.m[0][0] *
		(matrix.m[1][1] * (matrix.m[2][2] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][2]) - matrix.m[1][2] * (matrix.m[2][1] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][1]) + matrix.m[1][3] * (matrix.m[2][1] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][1])) -
		matrix.m[0][1] *
		(matrix.m[1][0] * (matrix.m[2][2] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][2]) - matrix.m[1][2] * (matrix.m[2][0] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][0]) + matrix.m[1][3] * (matrix.m[2][0] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][0])) +
		matrix.m[0][2] *
		(matrix.m[1][0] * (matrix.m[2][1] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][1]) - matrix.m[1][1] * (matrix.m[2][0] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][0]) + matrix.m[1][3] * (matrix.m[2][0] * matrix.m[3][1] - matrix.m[2][1] * matrix.m[3][0])) -
		matrix.m[0][3] *
		(matrix.m[1][0] * (matrix.m[2][1] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][1]) - matrix.m[1][1] * (matrix.m[2][0] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][0]) + matrix.m[1][2] * (matrix.m[2][0] * matrix.m[3][1] - matrix.m[2][1] * matrix.m[3][0]));

	// è¡Œåˆ—å¼ãŒã‚¼ãƒ­ã«è¿‘ã„å ´åˆã¯ç‰¹ç•°è¡Œåˆ—ã¨åˆ¤æ–­ï¼ˆé€†è¡Œåˆ—ã‚’è¨ˆç®—ã§ããªã„ï¼‰
	if (/*fabs(det) < 1e-6f*/ det == 0) {
		// ç‰¹ç•°è¡Œåˆ—ã®å ´åˆã®å‡¦ç†ï¼ˆä¾‹ãˆã°ã€å˜ä½è¡Œåˆ—ã‚’è¿”ã™ã€ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼å‡¦ç†ï¼‰
		return result; // å˜ä½è¡Œåˆ—ã¾ãŸã¯ã‚¨ãƒ©ãƒ¼å€¤
	}

	float invDet = 1.0f / det;

	// ä½™å› å­è¡Œåˆ—ã‚’è¨ˆç®—
	result.m[0][0] = invDet * (matrix.m[1][1] * (matrix.m[2][2] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][2]) - matrix.m[1][2] * (matrix.m[2][1] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][1]) +
		matrix.m[1][3] * (matrix.m[2][1] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][1]));
	result.m[0][1] = -invDet * (matrix.m[0][1] * (matrix.m[2][2] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][2]) - matrix.m[0][2] * (matrix.m[2][1] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][1]) +
		matrix.m[0][3] * (matrix.m[2][1] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][1]));
	result.m[0][2] = invDet * (matrix.m[0][1] * (matrix.m[1][2] * matrix.m[3][3] - matrix.m[1][3] * matrix.m[3][2]) - matrix.m[0][2] * (matrix.m[1][1] * matrix.m[3][3] - matrix.m[1][3] * matrix.m[3][1]) +
		matrix.m[0][3] * (matrix.m[1][1] * matrix.m[3][2] - matrix.m[1][2] * matrix.m[3][1]));
	result.m[0][3] = -invDet * (matrix.m[0][1] * (matrix.m[1][2] * matrix.m[2][3] - matrix.m[1][3] * matrix.m[2][2]) - matrix.m[0][2] * (matrix.m[1][1] * matrix.m[2][3] - matrix.m[1][3] * matrix.m[2][1]) +
		matrix.m[0][3] * (matrix.m[1][1] * matrix.m[2][2] - matrix.m[1][2] * matrix.m[2][1]));

	result.m[1][0] = -invDet * (matrix.m[1][0] * (matrix.m[2][2] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][2]) - matrix.m[1][2] * (matrix.m[2][0] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][0]) +
		matrix.m[1][3] * (matrix.m[2][0] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][0]));
	result.m[1][1] = invDet * (matrix.m[0][0] * (matrix.m[2][2] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][2]) - matrix.m[0][2] * (matrix.m[2][0] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][0]) +
		matrix.m[0][3] * (matrix.m[2][0] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][0]));
	result.m[1][2] = -invDet * (matrix.m[0][0] * (matrix.m[1][2] * matrix.m[3][3] - matrix.m[1][3] * matrix.m[3][2]) - matrix.m[0][2] * (matrix.m[1][0] * matrix.m[3][3] - matrix.m[1][3] * matrix.m[3][0]) +
		matrix.m[0][3] * (matrix.m[1][0] * matrix.m[3][2] - matrix.m[1][2] * matrix.m[3][0]));
	result.m[1][3] = invDet * (matrix.m[0][0] * (matrix.m[1][2] * matrix.m[2][3] - matrix.m[1][3] * matrix.m[2][2]) - matrix.m[0][2] * (matrix.m[1][0] * matrix.m[2][3] - matrix.m[1][3] * matrix.m[2][0]) +
		matrix.m[0][3] * (matrix.m[1][0] * matrix.m[2][2] - matrix.m[1][2] * matrix.m[2][0]));

	result.m[2][0] = invDet * (matrix.m[1][0] * (matrix.m[2][1] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][1]) - matrix.m[1][1] * (matrix.m[2][0] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][0]) +
		matrix.m[1][3] * (matrix.m[2][0] * matrix.m[3][1] - matrix.m[2][1] * matrix.m[3][0]));
	result.m[2][1] = -invDet * (matrix.m[0][0] * (matrix.m[2][1] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][1]) - matrix.m[0][1] * (matrix.m[2][0] * matrix.m[3][3] - matrix.m[2][3] * matrix.m[3][0]) +
		matrix.m[0][3] * (matrix.m[2][0] * matrix.m[3][1] - matrix.m[2][1] * matrix.m[3][0]));
	result.m[2][2] = invDet * (matrix.m[0][0] * (matrix.m[1][1] * matrix.m[3][3] - matrix.m[1][3] * matrix.m[3][1]) - matrix.m[0][1] * (matrix.m[1][0] * matrix.m[3][3] - matrix.m[1][3] * matrix.m[3][0]) +
		matrix.m[0][3] * (matrix.m[1][0] * matrix.m[3][1] - matrix.m[1][1] * matrix.m[3][0]));
	result.m[2][3] = -invDet * (matrix.m[0][0] * (matrix.m[1][1] * matrix.m[2][3] - matrix.m[1][3] * matrix.m[2][1]) - matrix.m[0][1] * (matrix.m[1][0] * matrix.m[2][3] - matrix.m[1][3] * matrix.m[2][0]) +
		matrix.m[0][3] * (matrix.m[1][0] * matrix.m[2][1] - matrix.m[1][1] * matrix.m[2][0]));

	result.m[3][0] = -invDet * (matrix.m[1][0] * (matrix.m[2][1] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][1]) - matrix.m[1][1] * (matrix.m[2][0] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][0]) +
		matrix.m[1][2] * (matrix.m[2][0] * matrix.m[3][1] - matrix.m[2][1] * matrix.m[3][0]));
	result.m[3][1] = invDet * (matrix.m[0][0] * (matrix.m[2][1] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][1]) - matrix.m[0][1] * (matrix.m[2][0] * matrix.m[3][2] - matrix.m[2][2] * matrix.m[3][0]) +
		matrix.m[0][2] * (matrix.m[2][0] * matrix.m[3][1] - matrix.m[2][1] * matrix.m[3][0]));
	result.m[3][2] = -invDet * (matrix.m[0][0] * (matrix.m[1][1] * matrix.m[3][2] - matrix.m[1][2] * matrix.m[3][1]) - matrix.m[0][1] * (matrix.m[1][0] * matrix.m[3][2] - matrix.m[1][2] * matrix.m[3][0]) +
		matrix.m[0][2] * (matrix.m[1][0] * matrix.m[3][1] - matrix.m[1][1] * matrix.m[3][0]));
	result.m[3][3] = invDet * (matrix.m[0][0] * (matrix.m[1][1] * matrix.m[2][2] - matrix.m[1][2] * matrix.m[2][1]) - matrix.m[0][1] * (matrix.m[1][0] * matrix.m[2][2] - matrix.m[1][2] * matrix.m[2][0]) +
		matrix.m[0][2] * (matrix.m[1][0] * matrix.m[2][1] - matrix.m[1][1] * matrix.m[2][0]));

	return result;
}

///=====================================================///
/// åº§æ¨™å¤‰æ›
///=====================================================///
// åº§æ¨™å¤‰æ›ï¼ˆå¹³è¡Œç§»å‹•ã‚’åŠ å‘³ã™ã‚‹ï¼‰
Vector3 Math::TransformCoordinates(const Vector3& vector, const Matrix4x4& matrix) {
	Vector3 result = {};
	result.x = vector.x * matrix.m[0][0] + vector.y * matrix.m[1][0] + vector.z * matrix.m[2][0] + 1.0f * matrix.m[3][0];
	result.y = vector.x * matrix.m[0][1] + vector.y * matrix.m[1][1] + vector.z * matrix.m[2][1] + 1.0f * matrix.m[3][1];
	result.z = vector.x * matrix.m[0][2] + vector.y * matrix.m[1][2] + vector.z * matrix.m[2][2] + 1.0f * matrix.m[3][2];
	float w = vector.x * matrix.m[0][3] + vector.y * matrix.m[1][3] + vector.z * matrix.m[2][3] + 1.0f * matrix.m[3][3];

	assert(w != 0.0f);

	result.x /= w;
	result.y /= w;
	result.z /= w;

	return result;
}
// ãƒ™ã‚¯ãƒˆãƒ«å¤‰æ›ï¼ˆå¹³è¡Œç§»å‹•ã‚’åŠ å‘³ã—ãªã„ï¼‰
Vector3 Math::TransformVector(const Vector3& vector, const Matrix4x4& matrix) {
	Vector3 result = {};
	result.x = vector.x * matrix.m[0][0] + vector.y * matrix.m[1][0] + vector.z * matrix.m[2][0];
	result.y = vector.x * matrix.m[0][1] + vector.y * matrix.m[1][1] + vector.z * matrix.m[2][1];
	result.z = vector.x * matrix.m[0][2] + vector.y * matrix.m[1][2] + vector.z * matrix.m[2][2];
	return result;
}
// æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ã®å¤‰æ›ï¼ˆé€†è»¢ç½®è¡Œåˆ—ã‚’ä½¿ç”¨ï¼‰
Vector3 Math::TransformNormal(const Vector3& normal, const Matrix4x4& matrix) {
	// é€†è»¢ç½®è¡Œåˆ—ã‚’ä½¿ç”¨
	Matrix4x4 inverseTransposeMatrix = TransposeMatrix(Inverse4x4(matrix));
	// ãƒ™ã‚¯ãƒˆãƒ«å¤‰æ›
	return TransformVector(normal, inverseTransposeMatrix);
}

///=====================================================/// 
/// è¡Œåˆ—ã‚’å¤‰æ›ã™ã‚‹ç‚ºã®é–¢æ•°
///=====================================================///
// Quaternion
Quaternion Math::MatrixToQuaternion(const Matrix4x4& m) {
	Quaternion q = {};
	float trace = m.m[0][0] + m.m[1][1] + m.m[2][2];

	if (trace > 0.0f) {
		float s = std::sqrt(trace + 1.0f) * 2.0f;
		q.w = 0.25f * s;
		q.x = (m.m[2][1] - m.m[1][2]) / s;
		q.y = (m.m[0][2] - m.m[2][0]) / s;
		q.z = (m.m[1][0] - m.m[0][1]) / s;
	} else if (m.m[0][0] > m.m[1][1] && m.m[0][0] > m.m[2][2]) {
		float s = std::sqrt(1.0f + m.m[0][0] - m.m[1][1] - m.m[2][2]) * 2.0f;
		q.w = (m.m[2][1] - m.m[1][2]) / s;
		q.x = 0.25f * s;
		q.y = (m.m[0][1] + m.m[1][0]) / s;
		q.z = (m.m[0][2] + m.m[2][0]) / s;
	} else if (m.m[1][1] > m.m[2][2]) {
		float s = std::sqrt(1.0f + m.m[1][1] - m.m[0][0] - m.m[2][2]) * 2.0f;
		q.w = (m.m[0][2] - m.m[2][0]) / s;
		q.x = (m.m[0][1] + m.m[1][0]) / s;
		q.y = 0.25f * s;
		q.z = (m.m[1][2] + m.m[2][1]) / s;
	} else {
		float s = std::sqrt(1.0f + m.m[2][2] - m.m[0][0] - m.m[1][1]) * 2.0f;
		q.w = (m.m[1][0] - m.m[0][1]) / s;
		q.x = (m.m[0][2] + m.m[2][0]) / s;
		q.y = (m.m[1][2] + m.m[2][1]) / s;
		q.z = 0.25f * s;
	}

	return q;
}


============================================================
File Path: Project/Math/MatrixMath.h
============================================================
#pragma once
#include "Vector3.h"
#include "Matrix3x3.h"
#include "Matrix4x4.h"
#include "Quaternion.h"

namespace Math {
	/// ===å¹³è¡Œç§»å‹•è¡Œåˆ—=== ///
	Matrix4x4 MakeTranslateMatrix(const Vector3& translate);
	/// ===æ‹¡ç¸®è¡Œåˆ—=== ///
	Matrix4x4 MakeScaleMatrix(const Vector3& scale);
	/// ===å›è»¢è¡Œåˆ—=== ///
	// Xè»¸
	Matrix4x4 MakeRotateXMatrix(float radian);
	// Yè»¸
	Matrix4x4 MakeRotateYMatrix(float radian);
	// Zè»¸
	Matrix4x4 MakeRotateZMatrix(float radian);
	// Quaternion
	Matrix4x4 MakeRotateQuaternionMatrix(const Quaternion q);
	/// ===ä¸‰æ¬¡å…ƒã‚¢ãƒ•ã‚£ãƒ³å¤‰æ›=== ///
	// EulerTransform(Vector3, Vector3, Vector3)
	Matrix4x4 MakeAffineEulerMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate);
	// QuaternionTransform(Vector3, Quaternion, Vector3)
	Matrix4x4 MakeAffineQuaternionMatrix(const Vector3& scale, const Quaternion& rotate, const Vector3& translate);
	/// ===å˜ä½è¡Œåˆ—=== ///
	Matrix3x3 MakeIdentity3x3();
	Matrix4x4 MakeIdentity4x4();
	/// ==è»¢ç½®è¡Œåˆ—==== ///
	Matrix4x4 TransposeMatrix(const Matrix4x4& m);
	/// ===ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆå¤‰æ›è¡Œåˆ—=== ///
	Matrix4x4 MakeViewportMatrix(float left, float top, float width, float height, float minDepth, float maxDepth);
	/// ===é€è¦–å½±è¡Œåˆ—=== ///
	Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip);
	/// ===æ­£å°„å½±è¡Œåˆ—=== ///
	Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip);
	/// ===é€†è¡Œåˆ—=== ///
	Matrix3x3 Inverse3x3(const Matrix3x3& matrix);
	Matrix4x4 Inverse4x4(const Matrix4x4& matrix);


	/// ===åº§æ¨™å¤‰æ›=== ///
	// åº§æ¨™å¤‰æ›
	Vector3 TransformCoordinates(const Vector3& translate, const Matrix4x4& matrix);
	// ãƒ™ã‚¯ãƒˆãƒ«å¤‰æ›
	Vector3 TransformVector(const Vector3& vector, const Matrix4x4& matrix);
	// æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ã®å¤‰æ›
	Vector3 TransformNormal(const Vector3& normal, const Matrix4x4& matrix);

	/// ===è¡Œåˆ—ã‚’å¤‰æ›ã™ã‚‹ç‚ºã®é–¢æ•°=== ///
	Quaternion MatrixToQuaternion(const Matrix4x4& matrix);
}





============================================================
File Path: Project/Math/Quaternion.cpp
============================================================
#include "Quaternion.h"

#include "Math/sMath.h"

///-------------------------------------------/// 
/// ã‚ªãƒšãƒ¬ãƒ¼ã‚¿
///-------------------------------------------///
 /// === åŠ ç®— === ///
Quaternion Quaternion::operator+(const float& v) { return Quaternion{ x + v, y + v, z + v, w + v }; }
Quaternion& Quaternion::operator+=(const float& v) {
    x += v; y += v; z += v; w += v;
    return *this;
}
Quaternion Quaternion::operator+(const Quaternion& q) { return Quaternion{ x + q.x, y + q.y, z + q.z, w + q.w }; }
Quaternion& Quaternion::operator+=(const Quaternion& q) {
    x += q.x; y += q.y; z += q.z; w += q.w;
    return *this;
}
Quaternion Quaternion::operator+(const float& v) const { return Quaternion{ x + v, y + v, z + v, w + v }; }
Quaternion Quaternion::operator+(const Quaternion& q) const { return Quaternion{ x + q.x, y + q.y, z + q.z, w + q.w }; }

/// === æ¸›ç®— === ///
Quaternion Quaternion::operator-(const float& v) { return Quaternion{ x - v, y - v, z - v, w - v }; }
Quaternion& Quaternion::operator-=(const float& v) {
    x -= v; y -= v; z -= v; w -= v;
    return *this;
}
Quaternion Quaternion::operator-(const Quaternion& q) { return Quaternion{ x - q.x, y - q.y, z - q.z, w - q.w }; }
Quaternion& Quaternion::operator-=(const Quaternion& q) {
    x -= q.x; y -= q.y; z -= q.z; w -= q.w;
    return *this;
}
Quaternion Quaternion::operator-(const float& v) const { return Quaternion{ x - v, y - v, z - v, w - v }; }
Quaternion Quaternion::operator-(const Quaternion& q) const { return Quaternion{ x - q.x, y - q.y, z - q.z, w - q.w }; }

/// === ä¹—ç®— === ///
// ã‚¹ã‚«ãƒ©ãƒ¼å€
Quaternion Quaternion::operator*(const float& v) { return Quaternion{ x * v, y * v, z * v, w * v }; }
Quaternion& Quaternion::operator*=(const float& v) {
    x *= v; y *= v; z *= v; w *= v;
    return *this;
}
Quaternion Quaternion::operator*(const float& v) const { return Quaternion{ x * v, y * v, z * v, w * v }; }

// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ä¹—ç®—
Quaternion Quaternion::operator*(const Quaternion& q) {
    return Quaternion{
        w * q.x + x * q.w + y * q.z - z * q.y,
        w * q.y - x * q.z + y * q.w + z * q.x,
        w * q.z + x * q.y - y * q.x + z * q.w,
        w * q.w - x * q.x - y * q.y - z * q.z
    };
}
Quaternion& Quaternion::operator*=(const Quaternion& q) {
    *this = *this * q;
    return *this;
}
Quaternion Quaternion::operator*(const Quaternion& q) const {
    return Quaternion{
        w * q.x + x * q.w + y * q.z - z * q.y,
        w * q.y - x * q.z + y * q.w + z * q.x,
        w * q.z + x * q.y - y * q.x + z * q.w,
        w * q.w - x * q.x - y * q.y - z * q.z
    };
}

/// === é™¤ç®— === ///
Quaternion Quaternion::operator/(const float& v) { return Quaternion{ x / v, y / v, z / v, w / v }; }
Quaternion& Quaternion::operator/=(const float& v) {
    x /= v; y /= v; z /= v; w /= v;
    return *this;
}
Quaternion Quaternion::operator/(const float& v) const { return Quaternion{ x / v, y / v, z / v, w / v }; }

// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã®é™¤ç®—ï¼ˆé€†ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’ã‹ã‘ã‚‹ï¼‰
Quaternion Quaternion::operator/(const Quaternion& q) {
    return (*this) * Math::Inverse(q);
}
Quaternion& Quaternion::operator/=(const Quaternion& q) {
    *this = *this / q;
    return *this;
}
Quaternion Quaternion::operator/(const Quaternion& q) const {
    return (*this) * Math::Inverse(q);
}

///=====================================================///
/// å†…ç©ã®è¨ˆç®—
///=====================================================///
float Dot(const Quaternion& q) { return q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w; }
float Dot(const Quaternion& q1, const Quaternion& q2) { return q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w; }

///=====================================================///
/// é•·ã•ã®è¨ˆç®—
///=====================================================///
float Length(const Quaternion& q) { return std::sqrtf(Dot(q)); }
float Length(const Quaternion& q1, const Quaternion& q2) { return std::sqrtf(Dot(q1, q2)); }

///-------------------------------------------/// 
/// Quaternionã®ç©
///-------------------------------------------///
Quaternion Multiply(const Quaternion& lhs, const Quaternion& rhs) {
    return {
         lhs.w * rhs.x + lhs.x * rhs.w + lhs.y * rhs.z - lhs.z * rhs.y,
         lhs.w * rhs.y - lhs.x * rhs.z + lhs.y * rhs.w + lhs.z * rhs.x,
         lhs.w * rhs.z + lhs.x * rhs.y - lhs.y * rhs.x + lhs.z * rhs.w,
         lhs.w * rhs.w - lhs.x * rhs.x - lhs.y * rhs.y - lhs.z * rhs.z
    };
}

///-------------------------------------------/// 
/// æ­£è¦åŒ–
///-------------------------------------------///
Quaternion Normalize(const Quaternion& quaternion) {
    // ãƒãƒ«ãƒ ã®äºŒä¹—ã‚’å–å¾—
    float normSquared = Math::NormSquared(quaternion);
    if (normSquared < 1e-6f) { // 0ã§ã¯ãªãéå¸¸ã«å°ã•ã„å€¤ã§ãƒã‚§ãƒƒã‚¯
        return Math::IdentityQuaternion();
    }

    // ãƒãƒ«ãƒ ã‚’è¨ˆç®—
    float norm = sqrtf(normSquared);
    return {
        quaternion.x / norm,
        quaternion.y / norm,
        quaternion.z / norm,
        quaternion.w / norm
    };
}

============================================================
File Path: Project/Math/Quaternion.h
============================================================
#pragma once
/// <summary>
/// Quaternionã®æ§‹é€ ä½“
/// </summary>
struct Quaternion final {
	float x;
	float y;
	float z;
	float w;

	/// ===åŠ æ³•=== ///
	// Quaternion | const
	Quaternion operator+(const float& v);
	Quaternion& operator+=(const float& v);
	Quaternion operator+(const Quaternion& v);
	Quaternion& operator+=(const Quaternion& v);
	// const | const
	Quaternion operator+(const float& v)const;
	Quaternion operator+(const Quaternion& v)const;

	/// ===æ¸›æ³•=== ///
	// Quaternion | const
	Quaternion operator-(const float& v);
	Quaternion& operator-=(const float& v);
	Quaternion operator-(const Quaternion& v);
	Quaternion& operator-=(const Quaternion& v);

	// const | const
	Quaternion operator-(const float& v)const;
	Quaternion operator-(const Quaternion& v)const;

	/// ===ç©=== ///
	// Quaternion | const
	Quaternion operator*(const float& v);
	Quaternion& operator*=(const float& v);
	Quaternion operator*(const Quaternion& v);
	Quaternion& operator*=(const Quaternion& v);
	// const | const
	Quaternion operator*(const float& v)const;
	Quaternion operator*(const Quaternion& v)const;

	/// ===é™¤æ³•=== ///
	// Quaternion | const
	Quaternion operator/(const float& v);
	Quaternion& operator/=(const float& v);
	Quaternion operator/(const Quaternion& v);
	Quaternion& operator/=(const Quaternion& v);
	// const | const
	Quaternion operator/(const float& v)const;
	Quaternion operator/(const Quaternion& v)const;
};

/// ===å†…ç©ã®è¨ˆç®—=== ///
float Dot(const Quaternion& q);
float Dot(const Quaternion& q1, const Quaternion& q2);

/// ===é•·ã•ã®è¨ˆç®—=== ///
float Length(const Quaternion& q);
float Length(const Quaternion& q1, const Quaternion& q2);

/// ===Quaternionã®ç©=== ///
Quaternion Multiply(const Quaternion& lhs, const Quaternion& rhs);

/// ===æ­£è¦åŒ–ã—ãŸQuaternionã‚’è¿”ã™=== ///
Quaternion Normalize(const Quaternion& quaternion);

============================================================
File Path: Project/Math/Vector2.cpp
============================================================
#define _USE_MATH_DEFINES
#include <cmath>

#include "Vector2.h"

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®åŠ æ³•
Vector2 Vector2::operator+(const Vector2& v) { return Vector2(x + v.x, y + v.y); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®åŠ æ³•ï¼ˆ+=ï¼‰
Vector2& Vector2::operator+=(const Vector2& v) {
	x += v.x;
	y += v.y;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®åŠ æ³•
Vector2 Vector2::operator+(const float& v) { return Vector2(x + v, y + v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®åŠ æ³•ï¼ˆ+=ï¼‰
Vector2& Vector2::operator+=(const float& v) {
	x += v;
	y += v;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®æ¸›æ³•
Vector2 Vector2::operator-(const Vector2& v) { return Vector2(x - v.x, y - v.y); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®æ¸›æ³•ï¼ˆ-=ï¼‰
Vector2& Vector2::operator-=(const Vector2& v) {
	x -= v.x;
	y -= v.y;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®æ¸›æ³•
Vector2 Vector2::operator-(const float& v) { return Vector2(x - v, y - v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®æ¸›æ³•ï¼ˆ-=ï¼‰
Vector2& Vector2::operator-=(const float& v) {
	x -= v;
	y -= v;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®ç©ï¼ˆè¦ç´ ã”ã¨ã®ç©ï¼‰
Vector2 Vector2::operator*(const Vector2& v) { return Vector2(x * v.x, y * v.y); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®ç©ï¼ˆ*=ï¼‰
Vector2& Vector2::operator*=(const Vector2& v) {
	x *= v.x;
	y *= v.y;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®ç©
Vector2 Vector2::operator*(const float& v) { return Vector2(x * v, y * v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®ç©ï¼ˆ*=ï¼‰
Vector2& Vector2::operator*=(const float& v) {
	x *= v;
	y *= v;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®é™¤æ³•ï¼ˆè¦ç´ ã”ã¨ã®é™¤æ³•ï¼‰
Vector2 Vector2::operator/(const Vector2& v) { return Vector2(x / v.x, y / v.y); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®é™¤æ³•ï¼ˆ/=ï¼‰
Vector2& Vector2::operator/=(const Vector2& v) {
	x /= v.x;
	y /= v.y;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®é™¤æ³•
Vector2 Vector2::operator/(const float& v) { return Vector2(x / v, y / v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®é™¤æ³•ï¼ˆ/=ï¼‰
Vector2& Vector2::operator/=(const float& v) {
	x /= v;
	y /= v;
	return *this;
}

///-------------------------------------------/// 
/// ç¬¦å·åè»¢
///-------------------------------------------///	
// Vector2 | const
Vector2 Vector2::operator-() const { return Vector2{ -x, -y }; }

///=====================================================///
///å†…ç©ã®è¨ˆç®—
///=====================================================///
float Dot(const Vector2& v) { return v.x * v.x + v.y * v.y; }
float Dot(const Vector2& v1, const Vector2& v2) { return v1.x * v2.x + v1.y * v2.y; }

///=====================================================///
///é•·ã•ã®è¨ˆç®—
///=====================================================///
float Length(const Vector2& v) { return std::sqrtf(Dot(v)); }
float Length(const Vector2& v1, const Vector2& v2) { return std::sqrtf(Dot(v1, v2)); }

///=====================================================///
///æ­£è¦åŒ–
///=====================================================///
Vector2 Normalize(const Vector2& v) {
	float mag = Length(v);
	if (mag != 0.0f) {
		return { v.x / mag, v.y / mag };
	}
	// ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«ã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™
	return v;
}


============================================================
File Path: Project/Math/Vector2.h
============================================================
#pragma once

/// <summary>
/// 2æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
/// </summary>
struct Vector2 final {
	float x;
	float y;

	/// ===åŠ æ³•=== ///
	Vector2 operator+(const Vector2& v);
	Vector2& operator+=(const Vector2& v);
	Vector2 operator+(const float& v);
	Vector2& operator+=(const float& v);

	/// ===æ¸›æ³•=== ///
	Vector2 operator-(const Vector2& v);
	Vector2& operator-=(const Vector2& v);
	Vector2 operator-(const float& v);
	Vector2& operator-=(const float& v);

	/// ===ç©=== ///
	Vector2 operator*(const Vector2& v);
	Vector2& operator*=(const Vector2& v);
	Vector2 operator*(const float& v);
	Vector2& operator*=(const float& v);

	/// ===é™¤æ³•=== ///
	Vector2 operator/(const Vector2& v);
	Vector2& operator/=(const Vector2& v);
	Vector2 operator/(const float& v);
	Vector2& operator/=(const float& v);

	/// ===ç¬¦å·åè»¢=== ///
	// Vector3 | const
	Vector2 operator-() const;
};

/// ===å†…ç©ã®è¨ˆç®—=== ///
float Dot(const Vector2& v);
float Dot(const Vector2& v1, const Vector2& v2);

/// ===é•·ã•ã®è¨ˆç®—=== ///
float Length(const Vector2& v);
float Length(const Vector2& v1, const Vector2& v2);

/// ===æ­£è¦åŒ–=== ///
Vector2 Normalize(const Vector2& v);

============================================================
File Path: Project/Math/Vector3.cpp
============================================================
#define _USE_MATH_DEFINES
#include <cmath>

#include "Vector3.h"

///-------------------------------------------/// 
/// åŠ æ³•
///-------------------------------------------///
// Vector3ãƒ»floatï¼ˆ+ï¼‰
Vector3 Vector3::operator+(const float& v) { return Vector3(x + v, y + v, z + v); }
// Vector3ãƒ»floatï¼ˆ+=ï¼‰
Vector3& Vector3::operator+=(const float& v) {
	x += v;
	y += v;
	z += v;
	return *this;
}
// Vector3ãƒ»Vector3ï¼ˆ+ï¼‰
Vector3 Vector3::operator+(const Vector3& v) { return Vector3(x + v.x, y + v.y, z + v.z); }
// Vector3ãƒ»Vector3ï¼ˆ+=ï¼‰
Vector3& Vector3::operator+=(const Vector3& v) {
	x += v.x;
	y += v.y;
	z += v.z;
	return *this;
}
// const Vector3ãƒ»floatï¼ˆ+ï¼‰
Vector3 Vector3::operator+(const float& v) const { return Vector3(x + v, y + v, z + v); }
// const Vector3ãƒ»Vector3ï¼ˆ+ï¼‰
Vector3 Vector3::operator+(const Vector3& v) const { return Vector3(x + v.x, y + v.y, z + v.z); }


///-------------------------------------------/// 
/// æ¸›æ³•
///-------------------------------------------///
// Vector3ãƒ»floatï¼ˆ-ï¼‰
Vector3 Vector3::operator-(const float& v) { return Vector3(x - v, y - v, z - v); }
// Vector3ãƒ»floatï¼ˆ-=ï¼‰
Vector3& Vector3::operator-=(const float& v) {
	x -= v;
	y -= v;
	z -= v;
	return *this;
}
// Vector3ãƒ»Vector3
Vector3 Vector3::operator-(const Vector3& v) { return Vector3(x - v.x, y - v.y, z - v.z); }
// Vector3ãƒ»Vector3ï¼ˆ-=ï¼‰
Vector3& Vector3::operator-=(const Vector3& v) {
	x -= v.x;
	y -= v.y;
	z -= v.z;
	return *this;
}
// const Vector3ãƒ»floatï¼ˆ-ï¼‰
Vector3 Vector3::operator-(const float& v) const{ return Vector3(x - v, y - v, z - v); }
// const Vector3ãƒ»Vector3ï¼ˆ-ï¼‰
Vector3 Vector3::operator-(const Vector3& v) const { return Vector3(x - v.x, y - v.y, z - v.z); }


///-------------------------------------------/// 
/// ç©
///-------------------------------------------///
// Vector3ãƒ»floatï¼ˆ*ï¼‰
Vector3 Vector3::operator*(const float& v) { return Vector3(x * v, y * v, z * v); }
// Vector3ãƒ»floatï¼ˆ*=ï¼‰
Vector3& Vector3::operator*=(const float& v) {
	x *= v;
	y *= v;
	z *= v;
	return *this;
}
// Vector3ãƒ»Vector3ï¼ˆ*ï¼‰
Vector3 Vector3::operator*(const Vector3& v) { return Vector3(x * v.x, y * v.y, z * v.z); }
// Vector3ãƒ»Vector3ï¼ˆ*=ï¼‰
Vector3& Vector3::operator*=(const Vector3& v) {
	x *= v.x;
	y *= v.y;
	z *= v.z;
	return *this;
}
// const Vector3ãƒ»floatï¼ˆ*ï¼‰
Vector3 Vector3::operator*(const float& v) const { return Vector3(x * v, y * v, z * v); }
// const Vector3ãƒ»Vector3ï¼ˆ*ï¼‰
Vector3 Vector3::operator*(const Vector3& v) const { return Vector3(x * v.x, y * v.y, z * v.z); }


///-------------------------------------------/// 
/// é™¤æ³•
///-------------------------------------------///
// Vector3ãƒ»floatï¼ˆ/ï¼‰
Vector3 Vector3::operator/(const float& v) { return Vector3(x / v, y / v, z / v); }
// Vector3ãƒ»floatï¼ˆ/=ï¼‰
Vector3& Vector3::operator/=(const float& v) {
	x /= v;
	y /= v;
	z /= v;
	return *this;
}
// Vector3ãƒ»Vector3ï¼ˆ/ï¼‰
Vector3 Vector3::operator/(const Vector3& v) { return Vector3(x / v.x, y / v.y, z / v.z); }
// Vector3ãƒ»Vector3ï¼ˆ/=ï¼‰
Vector3& Vector3::operator/=(const Vector3& v) {
	x /= v.x;
	y /= v.y;
	z /= v.z;
	return *this;
}
// const Vector3ãƒ»floatï¼ˆ/ï¼‰
Vector3 Vector3::operator/(const float& v) const { return Vector3(x / v, y / v, z / v); }
// const Vector3ãƒ»Vector3ï¼ˆ/ï¼‰
Vector3 Vector3::operator/(const Vector3& v) const { return Vector3(x / v.x, y / v.y, z / v.z); }

///-------------------------------------------/// 
/// ç¬¦å·åè»¢
///-------------------------------------------///	
// Vector3 | const
Vector3 Vector3::operator-() const {return Vector3{ -x, -y, -z };}

///=====================================================///
/// å†…ç©ã®è¨ˆç®—
///=====================================================///
float Dot(const Vector3& v) { return v.x * v.x + v.y * v.y + v.z * v.z; }
float Dot(const Vector3& v1, const Vector3& v2) { return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z; }

///=====================================================///
/// é•·ã•ã®è¨ˆç®—
///=====================================================///
float Length(const Vector3& v) { return std::sqrtf(Dot(v)); }
float Length(const Vector3& v1, const Vector3& v2) { return std::sqrtf(Dot(v1, v2)); }

///=====================================================///
/// æ­£è¦åŒ–
///=====================================================///
Vector3 Normalize(const Vector3& v) {
	float mag = Length(v);
	if (mag != 0.0f) {
		return { v.x / mag, v.y / mag, v.z / mag };
	}
	// ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«ã®å ´åˆã¯ãã®ã¾ã¾è¿”ã™
	return v;
}

============================================================
File Path: Project/Math/Vector3.h
============================================================
#pragma once

/// <summary>
/// 3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
/// </summary>
struct Vector3 final {
	float x;
	float y;
	float z;

	/// ===åŠ æ³•=== ///
	// Vector3 | const
	Vector3 operator+(const float& v);
	Vector3& operator+=(const float& v);
	Vector3 operator+(const Vector3& v);
	Vector3& operator+=(const Vector3& v);
	// const | const
	Vector3 operator+(const float& v)const;
	Vector3 operator+(const Vector3& v)const;

	/// ===æ¸›æ³•=== ///
	// Vector3 | const
	Vector3 operator-(const float& v);
	Vector3& operator-=(const float& v);
	Vector3 operator-(const Vector3& v);
	Vector3& operator-=(const Vector3& v);

	// const | const
	Vector3 operator-(const float& v)const;
	Vector3 operator-(const Vector3& v)const;

	/// ===ç©=== ///
	// Vector3 | const
	Vector3 operator*(const float& v);
	Vector3& operator*=(const float& v);
	Vector3 operator*(const Vector3& v);
	Vector3& operator*=(const Vector3& v);
	// const | const
	Vector3 operator*(const float& v)const;
	Vector3 operator*(const Vector3& v)const;

	/// ===é™¤æ³•=== ///
	// Vector3 | const
	Vector3 operator/(const float& v);
	Vector3& operator/=(const float& v);
	Vector3 operator/(const Vector3& v);
	Vector3& operator/=(const Vector3& v);
	// const | const
	Vector3 operator/(const float& v)const;
	Vector3 operator/(const Vector3& v)const;

	/// ===ç¬¦å·åè»¢=== ///
	// Vector3 | const
	Vector3 operator-() const;
};

/// ===å†…ç©ã®è¨ˆç®—=== ///
float Dot(const Vector3& v);
float Dot(const Vector3& v1, const Vector3& v2);

/// ===é•·ã•ã®è¨ˆç®—=== ///
float Length(const Vector3& v);
float Length(const Vector3& v1, const Vector3& v2);

/// ===æ­£è¦åŒ–=== ///
Vector3 Normalize(const Vector3& v);

============================================================
File Path: Project/Math/Vector4.cpp
============================================================
#include "Vector4.h"

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®åŠ æ³•
Vector4 Vector4::operator+(const Vector4& v) { return Vector4(x + v.x, y + v.y, z + v.z, w + v.w); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®åŠ æ³•ï¼ˆ+=ï¼‰
Vector4& Vector4::operator+=(const Vector4& v) {
	x += v.x;
	y += v.y;
	z += v.z;
	w += v.w;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®åŠ æ³•
Vector4 Vector4::operator+(const float& v) { return Vector4(x + v, y + v, z + v, w + v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®åŠ æ³•ï¼ˆ+=ï¼‰
Vector4& Vector4::operator+=(const float& v) {
	x += v;
	y += v;
	z += v;
	w += v;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®æ¸›æ³•
Vector4 Vector4::operator-(const Vector4& v) { return Vector4(x - v.x, y - v.y, z - v.z, w - v.w); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®æ¸›æ³•ï¼ˆ-=ï¼‰
Vector4& Vector4::operator-=(const Vector4& v) {
	x -= v.x;
	y -= v.y;
	z -= v.z;
	w -= v.w;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®æ¸›æ³•
Vector4 Vector4::operator-(const float& v) { return Vector4(x - v, y - v, z - v, w - v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®æ¸›æ³•ï¼ˆ-=ï¼‰
Vector4& Vector4::operator-=(const float& v) {
	x -= v;
	y -= v;
	z -= v;
	w -= v;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®ç©ï¼ˆè¦ç´ ã”ã¨ã®ç©ï¼‰
Vector4 Vector4::operator*(const Vector4& v) { return Vector4(x * v.x, y * v.y, z * v.z, w * v.w); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®ç©ï¼ˆ*=ï¼‰
Vector4& Vector4::operator*=(const Vector4& v) {
	x *= v.x;
	y *= v.y;
	z *= v.z;
	w *= v.w;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®ç©
Vector4 Vector4::operator*(const float& v) { return Vector4(x * v, y * v, z * v, w * v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®ç©ï¼ˆ*=ï¼‰
Vector4& Vector4::operator*=(const float& v) {
	x *= v;
	y *= v;
	z *= v;
	w *= v;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®é™¤æ³•ï¼ˆè¦ç´ ã”ã¨ã®é™¤æ³•ï¼‰
Vector4 Vector4::operator/(const Vector4& v) { return Vector4(x / v.x, y / v.y, z / v.z, w / v.w); }

// ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®é™¤æ³•ï¼ˆ/=ï¼‰
Vector4& Vector4::operator/=(const Vector4& v) {
	x /= v.x;
	y /= v.y;
	z /= v.z;
	w /= v.w;
	return *this;
}

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®é™¤æ³•
Vector4 Vector4::operator/(const float& v) { return Vector4(x / v, y / v, z / v, w / v); }

// ãƒ™ã‚¯ãƒˆãƒ«ã¨ float ã®é™¤æ³•ï¼ˆ/=ï¼‰
Vector4& Vector4::operator/=(const float& v) {
	x /= v;
	y /= v;
	z /= v;
	w /= v;
	return *this;
}

============================================================
File Path: Project/Math/Vector4.h
============================================================
#pragma once

/// <summary>
/// 4æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«
/// </summary>
struct Vector4 final {
	float x;
	float y;
	float z;
	float w;

	/// ===åŠ æ³•=== ///
	Vector4 operator+(const Vector4& v);
	Vector4& operator+=(const Vector4& v);
	Vector4 operator+(const float& v);
	Vector4& operator+=(const float& v);

	/// ===æ¸›æ³•=== ///
	Vector4 operator-(const Vector4& v);
	Vector4& operator-=(const Vector4& v);
	Vector4 operator-(const float& v);
	Vector4& operator-=(const float& v);

	/// ===ç©=== ///
	Vector4 operator*(const Vector4& v);
	Vector4& operator*=(const Vector4& v);
	Vector4 operator*(const float& v);
	Vector4& operator*=(const float& v);

	/// ===é™¤æ³•=== ///
	Vector4 operator/(const Vector4& v);
	Vector4& operator/=(const Vector4& v);
	Vector4 operator/(const float& v);
	Vector4& operator/=(const float& v);
};

============================================================
File Path: Project/Math/sMath.cpp
============================================================
#include "sMath.h"
#include <cassert>
#include <numbers>
#include "MatrixMath.h"

///=====================================================///
/// Ï€ï¼ˆÏ€ã‚’ä½¿ç”¨ã™ã‚‹éš›ã«ç”¨ã„ã‚‹é–¢æ•°ï¼‰
///=====================================================///
float Math::Pi() { return std::numbers::pi_v<float>; }

///-------------------------------------------/// 
/// è§’åº¦ã®æ­£è¦åŒ–
///-------------------------------------------/// 
float Math::NormalizeAngle(float angle) {
    // è§’åº¦ã‚’ [-Ï€, Ï€] ã«æ­£è¦åŒ–
    while (angle > std::numbers::pi_v<float>) angle -= 2.0f * std::numbers::pi_v<float>;
    while (angle < -std::numbers::pi_v<float>) angle += 2.0f * std::numbers::pi_v<float>;
    return angle;
}

///=====================================================///
/// ã‚¯ãƒ­ã‚¹ç©ã®è¨ˆç®—
///=====================================================///
Vector3 Math::Cross(const Vector3& v1, const Vector3& v2) {

    Vector3 result{ v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x };

    return result;
}

///-------------------------------------------/// 
/// Quaternion
///-------------------------------------------///
// Quaternionã®Normã‚’è¿”ã™
float Math::Norm(const Quaternion& quaternion) {
    return sqrtf(quaternion.x * quaternion.x +
        quaternion.y * quaternion.y +
        quaternion.z * quaternion.z +
        quaternion.w * quaternion.w);
}
// Quaternionã®Normã®2ä¹—ã‚’è¿”ã™
float Math::NormSquared(const Quaternion& quaternion) {
    return quaternion.x * quaternion.x +
        quaternion.y * quaternion.y +
        quaternion.z * quaternion.z +
        quaternion.w * quaternion.w;
}
// å˜ä½Quaternionã‚’è¿”ã™
Quaternion Math::IdentityQuaternion() {
    return { 0.0f, 0.0f, 0.0f, 1.0f };
}
// å…±å½¹Quaternionã‚’è¿”ã™
Quaternion Math::Conjugate(const Quaternion& quaternion) {
    return {
        -quaternion.x,
        -quaternion.y,
        -quaternion.z,
        quaternion.w
    };
}
// é€†Quaternionã‚’è¿”ã™
Quaternion Math::Inverse(const Quaternion& quaternion) {
    float normSquared = quaternion.x * quaternion.x +
        quaternion.y * quaternion.y +
        quaternion.z * quaternion.z +
        quaternion.w * quaternion.w;
    if (normSquared == 0.0f) {
        // Avoid division by zero
        return IdentityQuaternion();
    }
    Quaternion conjugate = Conjugate(quaternion);
    return {
        conjugate.x / normSquared,
        conjugate.y / normSquared,
        conjugate.z / normSquared,
        conjugate.w / normSquared
    };
}
// ä»»æ„è»¸å›è»¢Quaternionã‚’è¿”ã™
Quaternion Math::MakeRotateAxisAngle(const Vector3& axis, float angle) {
    Quaternion result = {};
    float halfAngle = angle / 2.0f;
    float sinHalfAngle = sinf(halfAngle);
    result.x = axis.x * sinHalfAngle;
    result.y = axis.y * sinHalfAngle;
    result.z = axis.z * sinHalfAngle;
    result.w = cosf(halfAngle);
    return result;
}
// Quaternionã®å›è»¢çµæœã‚’ãƒ™ã‚¯ãƒˆãƒ«ã§è¿”ã™
Vector3 Math::RotateVector(const Vector3& vector, const Quaternion& quaternion) {
    Vector3 result = {};
    Quaternion q = quaternion;
    Quaternion v = { vector.x,vector.y,vector.z,0.0f };
    Quaternion qConjugate = Conjugate(q);
    Quaternion v1 = Multiply(q, v);
    Quaternion v2 = Multiply(v1, qConjugate);
    result.x = v2.x;
    result.y = v2.y;
    result.z = v2.z;
    return result;
}
// Quaternionã‹ã‚‰Xè»¸ã®è§’åº¦ã‚’å–ã‚‹é–¢æ•°
float Math::GetXAngle(const Quaternion& quaternion) {
    // å˜ä½ãƒ™ã‚¯ãƒˆãƒ« (0,0,1) ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§å›è»¢ã•ã›ã‚‹
    Vector3 forward = RotateVector(Vector3(0.0f, 0.0f, 1.0f), quaternion);
    // forward.y ãŒãƒ”ãƒƒãƒè§’åº¦ï¼ˆä¸Šå‘ãã‹ä¸‹å‘ãã‹ï¼‰ã‚’ç¤ºã™
    return std::asin(forward.y); // ãƒ©ã‚¸ã‚¢ãƒ³è§’
}
// Quaternionã‹ã‚‰Yè»¸ã®è§’åº¦ã‚’å–ã‚‹é–¢æ•°
float Math::GetYAngle(const Quaternion& quaternion) {
    // å˜ä½ãƒ™ã‚¯ãƒˆãƒ« (0,0,1) ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§å›è»¢ã•ã›ã‚‹
    Vector3 forward = RotateVector(Vector3(0.0f, 0.0f, 1.0f), quaternion);
    // atan2(forward.x, forward.z) ã§ Yawï¼ˆæ°´å¹³å›è»¢ï¼‰ ã‚’å–å¾—ã€‚
    return std::atan2(forward.x, forward.z); // Yaw è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
}
// Quaternionã‚’EulerAngles(Vector3)ã«å¤‰æ›ã™ã‚‹é–¢æ•°
Vector3 Math::QuaternionToEuler(const Quaternion& quaternion) {
    Vector3 euler = {};

    // Yaw (ãƒ¨ãƒ¼: Yè»¸å›è»¢)
    euler.y = std::atan2(2.0f * (quaternion.w * quaternion.y + quaternion.x * quaternion.z), 1.0f - 2.0f * (quaternion.y * quaternion.y + quaternion.z * quaternion.z));

    // Pitch (ãƒ”ãƒƒãƒ: Xè»¸å›è»¢)
    float sinp = 2.0f * (quaternion.w * quaternion.x - quaternion.y * quaternion.z);
    if (std::abs(sinp) >= 1.0f)
        euler.x = std::copysign(Pi() / 2.0f, sinp); // Â±90åº¦ã«ã‚¯ãƒ©ãƒ³ãƒ—
    else
        euler.x = std::asin(sinp);

    // Roll (ãƒ­ãƒ¼ãƒ«: Zè»¸å›è»¢)
    euler.z = std::atan2(2.0f * (quaternion.w * quaternion.z + quaternion.x * quaternion.y), 1.0f - 2.0f * (quaternion.x * quaternion.x + quaternion.z * quaternion.z));

    return euler;
}
// Vector3ã‹ã‚‰Quaternionã«å¤‰æ›ã™ã‚‹é–¢æ•°
Quaternion Math::QuaternionFromVector(const Vector3& vector) {
    float cx = std::cos(vector.x * 0.5f);
    float sx = std::sin(vector.x * 0.5f);
    float cy = std::cos(vector.y * 0.5f);
    float sy = std::sin(vector.y * 0.5f);
    float cz = std::cos(vector.z * 0.5f);
    float sz = std::sin(vector.z * 0.5f);

    Quaternion q = {};
    q.w = cx * cy * cz + sx * sy * sz;
    q.x = sx * cy * cz - cx * sy * sz;
    q.y = cx * sy * cz + sx * cy * sz;
    q.z = cx * cy * sz - sx * sy * cz;
    return q;
}
// ã‚ã‚‹æ–¹å‘ï¼ˆforwardï¼‰ã‚’å‘ãã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ï¼ˆå›è»¢ï¼‰ã‚’ä½œã‚‹
Quaternion Math::LookRotation(Vector3 forward, Vector3 up) {
    // Zè»¸ï¼ˆå‰æ–¹ãƒ™ã‚¯ãƒˆãƒ«ï¼‰
    Vector3 z = Normalize(forward);
    // Xè»¸ï¼ˆå³æ–¹å‘ï¼‰: forward ã¨ up ã®å¤–ç©
    Vector3 x = Normalize(Cross(up, z));
    // Yè»¸ï¼ˆä¸Šæ–¹å‘ï¼‰: Z ã¨ X ã®å¤–ç©ï¼ˆä¿®æ­£ã•ã‚ŒãŸ upï¼‰
    Vector3 y = Cross(z, x);

    // å›è»¢è¡Œåˆ—ã‚’ä½œæˆ
    Matrix4x4 rotationMatrix = {
        x.x, y.x, z.x, 0.0f,
        x.y, y.y, z.y, 0.0f,
        x.z, y.z, z.z, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
    };

    // è¡Œåˆ—ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›ã—ã¦è¿”ã™
    return MatrixToQuaternion(rotationMatrix);
}

///-------------------------------------------/// 
/// è»¸ã®å›è»¢ã‚’è¡Œã†Quaternionã‚’è¿”ã™é–¢æ•°
///-------------------------------------------///
// Xè»¸å›è»¢Quaternionã‚’è¿”ã™é–¢æ•°
Quaternion Math::RotateX(float angle) {
    float half = angle * 0.5f;
    return Quaternion(
        std::sin(half) * 1.0f, // x
        std::sin(half) * 0.0f, // y
        std::sin(half) * 0.0f, // z
        std::cos(half)         // w
    );
}
// Yè»¸å›è»¢Quaternionã‚’è¿”ã™é–¢æ•°
Quaternion Math::RotateY(float angle) {
    float half = angle * 0.5f;
    return Quaternion(
        std::sin(half) * 0.0f, // x
        std::sin(half) * 1.0f, // y
        std::sin(half) * 0.0f, // z
        std::cos(half)         // w
    );
}
// Zè»¸å›è»¢Quaternionã‚’è¿”ã™é–¢æ•°
Quaternion Math::RotateZ(float angle) {
    float half = angle * 0.5f;
    return Quaternion(
        std::sin(half) * 0.0f, // x
        std::sin(half) * 0.0f, // y
        std::sin(half) * 1.0f, // z
        std::cos(half)         // w
    );
}

///-------------------------------------------/// 
/// ãƒ”ãƒƒãƒå›è»¢ã‚’é©ç”¨ã—ãŸQuaternionã‚’è¿”ã™é–¢æ•°
///-------------------------------------------///
Quaternion Math::ApplyPitchToCurrentRotation(const Quaternion& currentYRotation, float pitchAngleDegrees) {
    // Xè»¸å‘¨ã‚Šã®å›è»¢ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’ä½œæˆ
    float halfAngle = pitchAngleDegrees * 0.5f * (Pi() / 180.0f); // ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›
    Quaternion pitchRotation = {};
    pitchRotation.x = sinf(halfAngle);
    pitchRotation.y = 0.0f;
    pitchRotation.z = 0.0f;
    pitchRotation.w = cosf(halfAngle);

    // ç¾åœ¨ã®Yè»¸å›è»¢ã«ã€Xè»¸å›è»¢ã‚’åˆæˆ
    Quaternion result = {};

    float w1 = currentYRotation.w, x1 = currentYRotation.x;
    float y1 = currentYRotation.y, z1 = currentYRotation.z;
    float w2 = pitchRotation.w, x2 = pitchRotation.x;
    float y2 = pitchRotation.y, z2 = pitchRotation.z;

    result.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
    result.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
    result.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
    result.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;

    return result;
}

///-------------------------------------------/// 
/// Lerpé–¢æ•°
///-------------------------------------------///
// float
float Math::Lerp(float start, float end, float t) {
    return start * (1.0f - t) + end * t;
}
// Vector3
Vector3 Math::Lerp(const Vector3& start, const Vector3& end, float t) {
    Vector3 result = {};

    result.x = (1.0f - t) * start.x + t * end.x;
    result.y = (1.0f - t) * start.y + t * end.y;
    result.z = (1.0f - t) * start.z + t * end.z;

    return result;
}
// Quaternion
Quaternion Math::Lerp(const Quaternion& start, const Quaternion& end, float t) {
    Quaternion result = {};

    result.x = (1.0f - t) * start.x + t * end.x;
    result.y = (1.0f - t) * start.y + t * end.y;
    result.z = (1.0f - t) * start.z + t * end.z;
    result.w = (1.0f - t) * start.w + t * end.w;

    return result;
}

///-------------------------------------------/// 
/// SLerpé–¢æ•°
///-------------------------------------------///
// Vector3
Vector3 Math::SLerp(const Vector3& start, const Vector3& end, float t) {
    // ãªã™è§’ã®è¨ˆç®—
    float angle = std::cosf(Dot(start, end));

    // ç·šå½¢è£œé–“ã‚’è¨ˆç®—ã™ã‚‹
    float scaleStart = std::sinf((1.0f - t) * angle) / std::sinf(angle);

    float scaleEnd = std::sinf(t * angle) / std::sinf(angle);

    Vector3 result = {};

    result.x = scaleStart * start.x + scaleEnd * end.x;
    result.y = scaleStart * start.y + scaleEnd * end.y;
    result.z = scaleStart * start.z + scaleEnd * end.z;

    return result;
}
// Quaternion
Quaternion Math::SLerp(const Quaternion& start, const Quaternion& end, float t) {
    Quaternion q2Modified = end;
    float dot = Dot(start, end);

    // é€†æ–¹å‘è£œé–“ã‚’é˜²ããŸã‚ã«ç¬¦å·ã‚’åè»¢
    if (dot < 0.0f) {
        q2Modified = Quaternion(-q2Modified.x, -q2Modified.y, -q2Modified.z, -q2Modified.w);
        dot = -dot;
    }

    // ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³è£œé–“
    if (dot > 0.9995f) {
        // è§’åº¦ãŒå°ã•ã„å ´åˆã¯ Lerp ã§è¿‘ä¼¼
        return Normalize(start + (q2Modified - start) * t);
    }

    float theta_0 = acosf(dot); // åˆæœŸè§’åº¦
    float theta = theta_0 * t;  // è£œé–“å¾Œã®è§’åº¦

    Quaternion q3 = Normalize(q2Modified - start * dot); // ç›´äº¤æˆåˆ†
    return start * cosf(theta) + q3 * sinf(theta);
}

============================================================
File Path: Project/Math/sMath.h
============================================================
#pragma once
#define _USE_MATH_DEFINES
#include <cmath>

#include "Vector3.h"
#include "Quaternion.h"
#include "Matrix4x4.h"

namespace Math {
	
	/// <summary>
	/// å††å‘¨ç‡ï¼ˆÏ€ï¼‰ã‚’è¿”ã™
	/// </summary>
	/// <returns>å††å‘¨ç‡ Ï€ ã‚’ float å‹ã§è¿”ã—ã¾ã™ã€‚</returns>
	float Pi();

	/// <summary>
	/// è§’åº¦ã‚’æ¨™æº–çš„ãªç¯„å›²ã«æ­£è¦åŒ–
	/// </summary>
	/// <param name="angle">æ­£è¦åŒ–ã™ã‚‹è§’åº¦ã€‚é€šå¸¸ã¯ãƒ©ã‚¸ã‚¢ãƒ³ã§è¡¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>æ­£è¦åŒ–ã•ã‚ŒãŸè§’åº¦ï¼ˆå…¥åŠ›ã¨åŒã˜å˜ä½ï¼‰ã€‚é€šå¸¸ã¯ -Ï€ã€œÏ€ ã¾ãŸã¯ 0ã€œ2Ï€ ã®ç¯„å›²ã«åã¾ã‚‹ã‚ˆã†ã«å¤‰æ›ã•ã‚Œã¾ã™ã€‚</returns>
	float NormalizeAngle(float angle);

	/// <summary>
	/// 2ã¤ã®3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ã®å¤–ç©ï¼ˆã‚¯ãƒ­ã‚¹ç©ï¼‰ã‚’è¨ˆç®—ã—ã¦è¿”ã™
	/// </summary>
	/// <param name="v1">å¤–ç©ã®å·¦ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã¨ãªã‚‹ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconst å‚ç…§ã§æ¸¡ã•ã‚Œã€é–¢æ•°å†…ã§ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚</param>
	/// <param name="v2">å¤–ç©ã®å³ã‚ªãƒšãƒ©ãƒ³ãƒ‰ã¨ãªã‚‹ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconst å‚ç…§ã§æ¸¡ã•ã‚Œã€é–¢æ•°å†…ã§ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ï¼‰ã€‚</param>
	/// <returns>v1 Ã— v2 ã‚’è¡¨ã™ Vector3ã€‚å¤–ç©ã¯é †åºã«ä¾å­˜ã—ã¾ã™ã€‚</returns>
	Vector3 Cross(const Vector3& v1, const Vector3& v2);
	
	/// <summary>
	/// Quaternionã®ãƒãƒ«ãƒ ï¼ˆå¤§ãã•ï¼‰ã‚’è¨ˆç®—ã—ã¦è¿”ã™
	/// </summary>
	/// <param name="quaternion">è¨ˆç®—å¯¾è±¡ã®å››å…ƒæ•°ã€‚constå‚ç…§ã§æ¸¡ã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>å››å…ƒæ•°ã®ãƒãƒ«ãƒ ï¼ˆé•·ã•ï¼‰ã€‚é€šå¸¸ã¯ âˆš(wÂ² + xÂ² + yÂ² + zÂ²) ã®å€¤ã‚’è¿”ã—ã¾ã™ã€‚</returns>
	float Norm(const Quaternion& quaternion);

	/// <summary>
	/// Quaternionã®ãƒãƒ«ãƒ ã®äºŒä¹—ã‚’è¨ˆç®—ã—ã¦è¿”ã™
	/// </summary>
	/// <param name="quaternion">è¨ˆç®—å¯¾è±¡ã®å››å…ƒæ•°ã€‚</param>
	/// <returns>å››å…ƒæ•°ã®ãƒãƒ«ãƒ ã®äºŒä¹—ã‚’ float å‹ã§è¿”ã—ã¾ã™ã€‚</returns>
	float NormSquared(const Quaternion& quaternion);

	/// <summary>
	/// æ’ç­‰ï¼ˆå˜ä½ï¼‰ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’è¿”ã™
	/// </summary>
	/// <returns>æ’ç­‰ï¼ˆå˜ä½ï¼‰ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã€‚é€šå¸¸ã¯ (x=0, y=0, z=0, w=1) ã‚’è¡¨ã—ã€å›è»¢ã‚’è¡¨ã•ãªã„ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã§ã™ã€‚</returns>
	Quaternion IdentityQuaternion();

	/// <summary>
	/// Quaternionã®å…±å½¹ã‚’è¨ˆç®—ã™ã‚‹
	/// </summary>
	/// <param name="quaternion">å…±å½¹ã‚’æ±‚ã‚ã‚‹å…¥åŠ›ã®å››å…ƒæ•°ã€‚const å‚ç…§ã§æ¸¡ã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>ä¸ãˆã‚‰ã‚ŒãŸå››å…ƒæ•°ã®å…±å½¹ã€‚ã‚¹ã‚«ãƒ©ãƒ¼æˆåˆ†ã¯ãã®ã¾ã¾ã§ã€ãƒ™ã‚¯ãƒˆãƒ«æˆåˆ†ï¼ˆi, j, kï¼‰ã¯ç¬¦å·ãŒåè»¢ã—ã¾ã™ã€‚</returns>
	Quaternion Conjugate(const Quaternion& quaternion);

	/// <summary>
	/// ä¸ãˆã‚‰ã‚ŒãŸQuaternionã®é€†ï¼ˆä¹—æ³•é€†å…ƒï¼‰ã‚’è¿”ã™
	/// </summary>
	/// <param name="quaternion">é€†ã‚’æ±‚ã‚ã‚‹å››å…ƒæ•°ã¸ã®å‚ç…§ã€‚é–¢æ•°å†…ã§å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚</param>
	/// <returns>å…¥åŠ›ã®å››å…ƒæ•°ã®ä¹—æ³•é€†å…ƒã‚’è¡¨ã™å››å…ƒæ•°ã€‚å…¥åŠ›ãŒã‚¼ãƒ­å››å…ƒæ•°ã®å ´åˆã¯é€†ãŒå®šç¾©ã•ã‚Œãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
	Quaternion Inverse(const Quaternion& quaternion);

	/// <summary>
	/// æŒ‡å®šã—ãŸè»¸ã¨è§’åº¦ã‹ã‚‰å›è»¢ã‚’è¡¨ã™Quaternionã‚’ä½œæˆã™ã‚‹
	/// </summary>
	/// <param name="axis">å›è»¢è»¸ã‚’è¡¨ã™ãƒ™ã‚¯ãƒˆãƒ«ã€‚é€šå¸¸ã¯æ­£è¦åŒ–ã•ã‚ŒãŸï¼ˆå˜ä½ï¼‰ãƒ™ã‚¯ãƒˆãƒ«ã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	/// <param name="angle">è»¸ã¾ã‚ã‚Šã®å›è»¢è§’ã€‚é€šå¸¸ã¯ãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ã§æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸè»¸ã¨è§’åº¦ã‚’è¡¨ã™å›è»¢ã‚’è¡¨ç¾ã™ã‚‹å››å…ƒæ•°ï¼ˆQuaternionï¼‰ã€‚</returns>
	Quaternion MakeRotateAxisAngle(const Vector3& axis, float angle);

	/// <summary>
	/// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’ä½¿ã£ã¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’å›è»¢ã•ã›ã‚‹
	/// </summary>
	/// <param name="vector">å›è»¢å¯¾è±¡ã®3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ã€‚</param>
	/// <param name="quaternion">é©ç”¨ã™ã‚‹å›è»¢ã‚’è¡¨ã™ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã€‚</param>
	/// <returns>å›è»¢ã‚’é©ç”¨ã—ãŸå¾Œã®3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ã€‚</returns>
	Vector3 RotateVector(const Vector3& vector, const Quaternion& quaternion);

	/// <summary>
	/// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‹ã‚‰Xè»¸å‘¨ã‚Šã®å›è»¢è§’ã‚’å–å¾—
	/// </summary>
	/// <param name="quaternion">å›è»¢ã‚’è¡¨ã™ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã€‚Xè»¸å‘¨ã‚Šã®è§’åº¦ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>Xè»¸å‘¨ã‚Šã®è§’åº¦ã‚’è¡¨ã™floatå€¤ã€‚è§’åº¦ã®å˜ä½ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ã¾ãŸã¯åº¦ï¼‰ã¯å®Ÿè£…ä»•æ§˜ã«ã‚ˆã‚Šã¾ã™ã€‚</returns>
	float GetXAngle(const Quaternion& quaternion);

	/// <summary>
	/// Quaternionã‹ã‚‰Yè»¸å‘¨ã‚Šã®è§’åº¦ã‚’å–å¾—
	/// </summary>
	/// <param name="quaternion">å›è»¢ã‚’è¡¨ã™å››å…ƒæ•°ã€‚Yè»¸å‘¨ã‚Šã®è§’åº¦ã‚’è¨ˆç®—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	/// <returns>Yè»¸å‘¨ã‚Šã®å›è»¢è§’ã‚’floatå‹ã§è¿”ã—ã¾ã™ï¼ˆè§’åº¦ã®å˜ä½ã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ï¼‰ã€‚</returns>
	float GetYAngle(const Quaternion& quaternion);

	/// <summary>
	/// Quaternionã‚’å¯¾å¿œã™ã‚‹ã‚ªã‚¤ãƒ©ãƒ¼è§’ã«å¤‰æ›
	/// </summary>
	/// <param name="quaternion">å¤‰æ›å¯¾è±¡ã®å››å…ƒæ•°ã€‚å›è»¢ã‚’è¡¨ã—ã¾ã™ã€‚</param>
	/// <returns>å¯¾å¿œã™ã‚‹ã‚ªã‚¤ãƒ©ãƒ¼è§’ã‚’æ ¼ç´ã—ãŸ Vector3ã€‚å„æˆåˆ†ã¯è»¸å‘¨ã‚Šã®å›è»¢è§’ï¼ˆé †åºã‚„è§’åº¦ã®å˜ä½ã¯å®Ÿè£…ã«ä¾å­˜ã—ã¾ã™ï¼‰ã€‚</returns>
	Vector3 QuaternionToEuler(const Quaternion& quaternion);

	/// <summary>
	/// 3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ã‹ã‚‰Quaternionã‚’ç”Ÿæˆ
	/// </summary>
	/// <param name="vector">å››å…ƒæ•°ã«å¤‰æ›ã™ã‚‹3æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconstå‚ç…§ï¼‰ã€‚</param>
	/// <returns>å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«ã«åŸºã¥ã„ã¦ç”Ÿæˆã•ã‚ŒãŸå››å…ƒæ•°ã€‚</returns>
	Quaternion QuaternionFromVector(const Vector3& vector);

	/// <summary>
	/// æŒ‡å®šã—ãŸå‰æ–¹ãƒ™ã‚¯ãƒˆãƒ«ã¨ä¸Šæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã«åŸºã¥ã„ã¦å‘ãã‚’è¡¨ã™Quaternionã‚’ç”Ÿæˆ
	/// </summary>
	/// <param name="forward">å¯¾è±¡ãŒå‘ãå‰æ–¹æ–¹å‘ã‚’è¡¨ã™ãƒ™ã‚¯ãƒˆãƒ«ã€‚é€šå¸¸ã¯æ­£è¦åŒ–ã•ã‚ŒãŸãƒ™ã‚¯ãƒˆãƒ«ã‚’æ¸¡ã—ã€ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«ã¯é¿ã‘ã¦ãã ã•ã„ã€‚</param>
	/// <param name="up">ä¸Šæ–¹å‘ã‚’å®šç¾©ã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«ã€‚worldä¸Šæ–¹å‘ã‚„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä¸Šæ–¹å‘ã‚’æŒ‡å®šã—ã¾ã™ã€‚forwardã¨ã»ã¼å¹³è¡Œã«ãªã‚‰ãªã„ã‚ˆã†ã«ã—ã¦ãã ã•ã„ã€‚</param>
	/// <returns>forwardã‚’å‰æ–¹ã€upã‚’ä¸Šå‘ãã¨ã™ã‚‹å›è»¢ã‚’è¡¨ã™å››å…ƒæ•°ã€‚forwardã¨upãŒä¸é©åˆ‡ï¼ˆã‚¼ãƒ­ã¾ãŸã¯åŒä¸€ç›´ç·šä¸Šï¼‰ãªå ´åˆã¯çµæœãŒä¸å®‰å®šã«ãªã‚‹ã‹ã€å®Ÿè£…ä¾å­˜ã®æŒ¯ã‚‹èˆã„ã«ãªã‚Šã¾ã™ã€‚</returns>
	Quaternion LookRotation(Vector3 forward, Vector3 up);

	/// <summary>
	/// Xè»¸ã¾ã‚ã‚Šã®å›è»¢ã‚’è¡¨ã™Quaternionã‚’ç”Ÿæˆ
	/// </summary>
	/// <param name="angle">Xè»¸ã¾ã‚ã‚Šã®å›è»¢è§’ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³å˜ä½ï¼‰ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸè§’åº¦ã®Xè»¸å›è»¢ã‚’è¡¨ã™Quaternionã‚’è¿”ã—ã¾ã™ã€‚</returns>
	Quaternion RotateX(float angle);

	/// <summary>
	/// Yè»¸å‘¨ã‚Šã®å›è»¢ã‚’è¡¨ã™Quaternionã‚’ç”Ÿæˆ
	/// </summary>
	/// <param name="angle">Yè»¸å›è»¢ã®è§’åº¦ï¼ˆé–¢æ•°ã‚„ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ä½¿ç”¨ã•ã‚Œã‚‹å˜ä½ã«å¾“ã„ã¾ã™ã€‚é€šå¸¸ã¯ãƒ©ã‚¸ã‚¢ãƒ³ï¼‰ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸè§’åº¦ã§Yè»¸å‘¨ã‚Šã«å›è»¢ã™ã‚‹å››å…ƒæ•°ã€‚</returns>
	Quaternion RotateY(float angle);

	/// <summary>
	/// æŒ‡å®šã—ãŸè§’åº¦ã§Zè»¸ã¾ã‚ã‚Šã®å›è»¢ã‚’è¡¨ã™Quaternionã‚’è¿”
	/// </summary>
	/// <param name="angle">Zè»¸ã¾ã‚ã‚Šã®å›è»¢è§’ï¼ˆé€šå¸¸ã¯ãƒ©ã‚¸ã‚¢ãƒ³ï¼‰ã€‚</param>
	/// <returns>æŒ‡å®šè§’åº¦ã®Zè»¸å›è»¢ã‚’è¡¨ã™ Quaternionï¼ˆå››å…ƒæ•°ï¼‰ã€‚</returns>
	Quaternion RotateZ(float angle);

	/// <summary>
	/// ä¸ãˆã‚‰ã‚ŒãŸç¾åœ¨ã®Yå›è»¢ã«ãƒ”ãƒƒãƒå›è»¢ï¼ˆXè»¸å‘¨ã‚Šï¼‰ã‚’é©ç”¨ã—ãŸæ–°ã—ã„å››å…ƒæ•°ã‚’ç”Ÿæˆã—ã¦è¿”ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="currentYRotation">ç¾åœ¨ã®Yå›è»¢ã‚’è¡¨ã™å››å…ƒæ•°ï¼ˆconst å‚ç…§ï¼‰ã€‚ã“ã®å››å…ƒæ•°ã«ãƒ”ãƒƒãƒã‚’é©ç”¨ã—ã¦çµæœã‚’ä½œæˆã—ã¾ã™ã€‚</param>
	/// <param name="pitchAngleDegrees">é©ç”¨ã™ã‚‹ãƒ”ãƒƒãƒè§’ï¼ˆåº¦å˜ä½ï¼‰ã€‚æ­£ã®è§’åº¦ã®å‘ãã¯åº§æ¨™ç³»ã®å®šç¾©ã«ä¾å­˜ã—ã¾ã™ã€‚</param>
	/// <returns>ãƒ”ãƒƒãƒãŒé©ç”¨ã•ã‚ŒãŸæ–°ã—ã„ Quaternionã€‚å…ƒã®å››å…ƒæ•°ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚</returns>
	Quaternion ApplyPitchToCurrentRotation(const Quaternion& currentYRotation, float pitchAngleDegrees);

#pragma region Lerpãƒ»SLerp
	/// <summary>
	/// start ã¨ end ã®é–“ã‚’ t ã«å¿œã˜ã¦ç·šå½¢è£œé–“ã—ã¦ãã®å€¤ã‚’è¿”ã™
	/// </summary>
	/// <param name="start">è£œé–“ã®é–‹å§‹å€¤ã€‚t ãŒ 0 ã®ã¨ãã«è¿”ã•ã‚Œã‚‹å€¤ã€‚</param>
	/// <param name="end">è£œé–“ã®çµ‚äº†å€¤ã€‚t ãŒ 1 ã®ã¨ãã«è¿”ã•ã‚Œã‚‹å€¤ã€‚</param>
	/// <param name="t">è£œé–“ä¿‚æ•°ï¼ˆé€šå¸¸ 0ã€œ1ï¼‰ã€‚0 ã§ startã€1 ã§ end ã‚’è¿”ã—ã¾ã™ã€‚ç¯„å›²å¤–ã®å€¤ã¯ãã®ã¾ã¾å¤–æŒ¿ã¨ã—ã¦æ‰±ã‚ã‚Œã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸ t ã«å¯¾å¿œã™ã‚‹ç·šå½¢è£œé–“ï¼ˆfloatï¼‰çµæœã€‚</returns>
	float Lerp(float start, float end, float t);

	/// <summary>
	/// 2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’ç·šå½¢è£œé–“ã—ã¦ã€æŒ‡å®šã—ãŸä¿‚æ•° t ã«å¯¾å¿œã™ã‚‹ä½ç½®ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™
	/// </summary>
	/// <param name="start">è£œé–“ã®é–‹å§‹ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconst å‚ç…§ï¼‰ã€‚</param>
	/// <param name="end">è£œé–“ã®çµ‚äº†ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconst å‚ç…§ï¼‰ã€‚</param>
	/// <param name="t">è£œé–“ä¿‚æ•°ã€‚0 ã¯ startã€1 ã¯ end ã‚’è¡¨ã—ã¾ã™ã€‚ç¯„å›²å¤–ã®å€¤ã§ã¯å¤–æŒ¿ãŒè¡Œã‚ã‚Œã¾ã™ã€‚</param>
	/// <returns>start ã¨ end ã‚’ç·šå½¢è£œé–“ã—ãŸçµæœã® Vector3ï¼ˆt=0 ã§ startã€t=1 ã§ endï¼‰ã€‚</returns>
	Vector3 Lerp(const Vector3& start, const Vector3& end, float t);

	/// <summary>
	/// 2ã¤ã®Quaternionã‚’ç·šå½¢è£œé–“ã™ã‚‹é–¢æ•°
	/// </summary>
	/// <param name="start">è£œé–“ã®é–‹å§‹ã¨ãªã‚‹ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ï¼ˆå…¥åŠ›ï¼‰ã€‚</param>
	/// <param name="end">è£œé–“ã®çµ‚äº†ã¨ãªã‚‹ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ï¼ˆå…¥åŠ›ï¼‰ã€‚</param>
	/// <param name="t">è£œé–“ä¿‚æ•°ã€‚0.0ã§startã€1.0ã§endã‚’è¡¨ã™ã€‚é€šå¸¸ã¯0.0ã€œ1.0ã®ç¯„å›²ã§ä½¿ç”¨ã™ã‚‹ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸè£œé–“ä¿‚æ•°ã«åŸºã¥ã„ã¦å¾—ã‚‰ã‚Œã‚‹è£œé–“æ¸ˆã¿ã®ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã€‚</returns>
	Quaternion Lerp(const Quaternion& start, const Quaternion& end, float t);

	/// <summary>
	/// 2ã¤ã®ãƒ™ã‚¯ãƒˆãƒ«é–“ã‚’çƒé¢ç·šå½¢è£œé–“ï¼ˆSLerpï¼‰ã§è£œé–“
	/// </summary>
	/// <param name="start">è£œé–“ã®é–‹å§‹ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå‚ç…§ï¼‰ã€‚</param>
	/// <param name="end">è£œé–“ã®çµ‚äº†ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆå‚ç…§ï¼‰ã€‚</param>
	/// <param name="t">è£œé–“ä¿‚æ•°ã€‚é€šå¸¸ã¯ 0.0 ãŒ startã€1.0 ãŒ end ã‚’è¡¨ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸ t ã«å¯¾å¿œã™ã‚‹è£œé–“å¾Œã®ãƒ™ã‚¯ãƒˆãƒ«ã€‚å…¥åŠ›ãƒ™ã‚¯ãƒˆãƒ«ãŒæ­£è¦åŒ–ã•ã‚Œã¦ã„ã‚‹å ´åˆã€çµæœã‚‚æ­£è¦åŒ–ã•ã‚Œã¾ã™ã€‚</returns>
	Vector3 SLerp(const Vector3& start, const Vector3& end, float t);

	/// <summary>
	/// æŒ‡å®šã—ãŸè£œé–“ä¿‚æ•°ã«åŸºã¥ãã€2ã¤ã®ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³é–“ã‚’çƒé¢ç·šå½¢è£œé–“ï¼ˆSlerpï¼‰ã—ã¦çµæœã®ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’è¿”ã™
	/// </summary>
	/// <param name="start">è£œé–“ã®é–‹å§‹ã¨ãªã‚‹ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ï¼ˆå‚ç…§ï¼‰ã€‚</param>
	/// <param name="end">è£œé–“ã®çµ‚äº†ã¨ãªã‚‹ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ï¼ˆå‚ç…§ï¼‰ã€‚</param>
	/// <param name="t">è£œé–“ä¿‚æ•°ã€‚é€šå¸¸ã¯ 0.0ï¼ˆstartï¼‰ã‹ã‚‰ 1.0ï¼ˆendï¼‰ã®ç¯„å›²ã§æŒ‡å®šã—ã¾ã™ã€‚ç¯„å›²å¤–ã®å€¤ã¯å¤–æŒ¿ã¨ãªã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚</param>
	/// <returns>æŒ‡å®šã—ãŸä¿‚æ•°ã«å¯¾å¿œã™ã‚‹è£œé–“å¾Œã®ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã€‚é€šå¸¸ã¯æ­£è¦åŒ–ã•ã‚ŒãŸã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ãŒè¿”ã•ã‚Œã¾ã™ã€‚</returns>
	Quaternion SLerp(const Quaternion& start, const Quaternion& end, float t);
#pragma endregion
}




============================================================
File Path: Project/application/Drawing/2d/Sprite.cpp
============================================================
#include "Sprite.h"
// c++
#include <cassert>
// Engine
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/Render.h"
// Math
#include "Math/MatrixMath.h"


///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Sprite::~Sprite() = default;


///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// åº§æ¨™
const Vector2& Sprite::GetPosition() const { return position_; }
// å›è»¢
const float& Sprite::GetRotation() const { return rotation_; }
// ã‚µã‚¤ã‚º
const Vector2& Sprite::GetSize() const { return size_; }
// è‰²
const Vector4& Sprite::GetColor() const { return color_; }


///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// åº§æ¨™
void Sprite::SetPosition(const Vector2& position) { position_ = position; }
// å›è»¢
void Sprite::SetRotation(const float& rotation) { rotation_ = rotation; }
// ã‚µã‚¤ã‚º
void Sprite::SetSize(const Vector2& size) { size_ = size; }
// è‰²
void Sprite::SetColor(const Vector4& color) { color_ = color; }
// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
void Sprite::SetAnchorPoint(const Vector2& anchorPoint) { anchorPoint_ = anchorPoint; }
// ãƒ•ãƒªãƒƒãƒ—
void Sprite::SetFlipX(const bool& flip) { isFlipX_ = flip; }
void Sprite::SetFlipY(const bool& flip) { isFlipY_ = flip; }
// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
void Sprite::SetTextureLeftTop(const Vector2& textureLeftTop) { textureLeftTop_ = textureLeftTop; }
// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
void Sprite::SetTextureSize(const Vector2& textureSize) { textureSize_ = textureSize; }


///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Sprite::Initialize(const std::string textureFilePath) {

	/// ===ãƒ†ã‚¯ã‚¹ãƒãƒ£=== ///
	filePath_ = textureFilePath;

	/// ===SpriteCommonã®åˆæœŸåŒ–=== ///
	SpriteCommon::Initialize(filePath_);

	/// ===WorldTransformã®è¨­å®š=== ///
	worldTransform_ = { {1.0f, 1.0f, 1.0f }, { 0.0f, 0.0f, 0.0f, }, { 0.0f, 0.0f, 0.0f } };
}


///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Sprite::Update() {
	/// ===SpriteCommonã®æ›´æ–°=== ///
	SpriteCommon::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void Sprite::Draw(GroundType type, BlendMode mode) {

	/// ===SpriteCommonã®æç”»=== ///
	SpriteCommon::Draw(type, mode);
}




============================================================
File Path: Project/application/Drawing/2d/Sprite.h
============================================================
#pragma once
/// ===include=== ///
// Engine
#include "Engine/Graphics/2d/Sprite/SpriteCommon.h"

///=====================================================/// 
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
///=====================================================///
class Sprite : public SpriteCommon {
public: /// ===åŸºæœ¬çš„ãªé–¢æ•°=== ///

	Sprite() = default;
	~Sprite();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="textureFilePath">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹ã‚’è¡¨ã™æ–‡å­—åˆ—ã€‚</param>
	void Initialize(const std::string textureFilePath) override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="type">æç”»ã™ã‚‹ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã®ç¨®é¡ã€‚æ—¢å®šå€¤ã¯ GroundType::Frontã€‚</param>
	/// <param name="mode">ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚æ—¢å®šå€¤ã¯ BlendMode::KBlendModeNormalã€‚</param>
	void Draw(GroundType type = GroundType::Front, BlendMode mode = BlendMode::KBlendModeNormal) override;

public:/// ===Getter=== ///

	// åº§æ¨™
	const Vector2& GetPosition() const;
	// å›è»¢
	const float& GetRotation() const;
	// ã‚µã‚¤ã‚º
	const Vector2& GetSize() const;
	// è‰²
	const Vector4& GetColor() const;

public:/// ===Setter=== ///

	// åº§æ¨™
	void SetPosition(const Vector2& position);
	// å›è»¢
	void SetRotation(const float& rotation);
	// ã‚µã‚¤ã‚º
	void SetSize(const Vector2& size);
	// è‰²
	void SetColor(const Vector4& color);
	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	void SetAnchorPoint(const Vector2& anchorPoint);
	// ãƒ•ãƒªãƒƒãƒ—
	void SetFlipX(const bool& flip);
	void SetFlipY(const bool& flip);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
	void SetTextureLeftTop(const Vector2& textureLeftTop);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	void SetTextureSize(const Vector2& textureSize);
};



============================================================
File Path: Project/application/Drawing/3d/Line.cpp
============================================================
#include "Line.h"
#include "Engine/System/Service/ServiceLocator.h"
#include "Engine/Graphics/3d/Line/LineObject3D.h"

#include "Math/MatrixMath.h"
#include "Math/EasingMath.h"
#include "Math/sMath.h"

///-------------------------------------------/// 
/// Line
///-------------------------------------------///
void Line::DrawLine(const Vector3& start, const Vector3& end, const Vector4& color) {
	ServiceLocator::GetLineObject3D()->CreateLine(start, end, color);
}

///-------------------------------------------/// 
/// OBB
///-------------------------------------------///
void Line::DrawOBB(const OBB& obb, const Vector4& color) {
	// OBBã®å„é ‚ç‚¹ã‚’å®šç¾©ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ï¼‰
	Vector3 localVertices[8] = {
		{-obb.halfSize.x, -obb.halfSize.y, -obb.halfSize.z}, {obb.halfSize.x, -obb.halfSize.y, -obb.halfSize.z},
		{obb.halfSize.x,  obb.halfSize.y, -obb.halfSize.z}, {-obb.halfSize.x,  obb.halfSize.y, -obb.halfSize.z},
		{-obb.halfSize.x, -obb.halfSize.y,  obb.halfSize.z}, {obb.halfSize.x, -obb.halfSize.y,  obb.halfSize.z},
		{obb.halfSize.x,  obb.halfSize.y,  obb.halfSize.z}, {-obb.halfSize.x,  obb.halfSize.y,  obb.halfSize.z}
	};

	// ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›ï¼ˆå›è»¢é©ç”¨ & å¹³è¡Œç§»å‹•ï¼‰
	Vector3 worldVertices[8] = {};
	for (int i = 0; i < 8; i++) {
		worldVertices[i] =
			obb.center +
			obb.axis[0] * localVertices[i].x +
			obb.axis[1] * localVertices[i].y +
			obb.axis[2] * localVertices[i].z;
	}

	// OBBã®ã‚¨ãƒƒã‚¸ã‚’çµã¶
	int edges[12][2] = {
		{0, 1}, {1, 2}, {2, 3}, {3, 0}, // åº•é¢
		{4, 5}, {5, 6}, {6, 7}, {7, 4}, // ä¸Šé¢
		{0, 4}, {1, 5}, {2, 6}, {3, 7}  // å´é¢
	};

	for (int i = 0; i < 12; i++) {
		DrawLine(worldVertices[edges[i][0]], worldVertices[edges[i][1]], color);
	}
}

///-------------------------------------------/// 
/// AABB
///-------------------------------------------///
void Line::DrawAABB(const AABB & aabb, const Vector4& color) {
	// ã‚°ãƒªãƒƒãƒ‰ã‚’6é¢æç”»
	Vector3 size = aabb.max - aabb.min;
	Vector3 halfSize = size * 0.5f;
	uint32_t division = 1;

	// AABBã®ä¸­å¿ƒã‚’ç®—å‡º
	Vector3 offset = (aabb.min + aabb.max) * 0.5f;

	// å‰é¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);

	// å¾Œé¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);

	// å·¦é¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);

	// å³é¢
	DrawGridLines(offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);

	// ä¸Šé¢
	DrawGridLines(offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);

	// ä¸‹é¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);
}

///-------------------------------------------/// 
/// Sphere
///-------------------------------------------///
void Line::DrawSphere(const Sphere& sphere, const Vector4 & color) {
	// åˆ†å‰²æ•°
	const uint32_t div = 8;
	// ç·¯åº¦ãƒ»çµŒåº¦ã®ã‚¹ãƒ†ãƒƒãƒ—è§’åº¦
	const float lonStep = 2.0f * Math::Pi() / float(div);
	const float latStep = Math::Pi() / float(div);

	// ç·¯åº¦ãƒ»çµŒåº¦ã«æ²¿ã£ã¦ç·šã‚’æç”»
	for (uint32_t lat = 0; lat < div; ++lat) {
		for (uint32_t lon = 0; lon < div; ++lon) {
			Vector3 a, b, c;

			float lat1 = -Math::Pi() / 2.0f + latStep * lat;
			float lon1 = lonStep * lon;

			a = {
				cos(lat1) * cos(lon1),
				sin(lat1),
				cos(lat1) * sin(lon1)
			};
			b = {
				cos(lat1 + latStep) * cos(lon1),
				sin(lat1 + latStep),
				cos(lat1 + latStep) * sin(lon1)
			};
			c = {
				cos(lat1) * cos(lon1 + lonStep),
				sin(lat1),
				cos(lat1) * sin(lon1 + lonStep)
			};

			// ã‚¹ã‚±ãƒ¼ãƒ« & ä¸­å¿ƒå¤‰æ›
			a = a * sphere.radius + sphere.center;
			b = b * sphere.radius + sphere.center;
			c = c * sphere.radius + sphere.center;

			DrawLine(a, b, color);
			DrawLine(a, c, color);
		}
	}
}

///-------------------------------------------/// 
/// Grid
///-------------------------------------------///
void Line::DrawGrid(const Vector3 & center, const Vector3 & size, uint32_t division, const Vector4& color) {
	Vector3 halfSize = size * 0.5f;
	Vector3 start = center + Vector3(-halfSize.x, 0.0f, -halfSize.z);
	Vector3 end = center + Vector3(halfSize.x, 0.0f, -halfSize.z);

	// æ¨ªç·š
	for (uint32_t i = 0; i <= division; i++) {
		float t = float(i) / float(division);
		Vector3 s = Math::Lerp(start, end, t);
		Vector3 e = s + Vector3(0.0f, 0.0f, size.z);
		DrawLine(s, e, color);
	}
	start = center + Vector3(-halfSize.x, 0.0f, -halfSize.z);
	end = center + Vector3(-halfSize.x, 0.0f, halfSize.z);
	// ç¸¦ç·š
	for (uint32_t i = 0; i <= division; i++) {
		float t = float(i) / float(division);
		Vector3 s = Math::Lerp(start, end, t);
		Vector3 e = s + Vector3(size.x, 0.0f, 0.0f);
		DrawLine(s, e, color);
	}
}

///-------------------------------------------/// 
/// GridBox
///-------------------------------------------///
void Line::DrawGirdBox(const AABB& aabb, uint32_t division, const Vector3& center, const Vector4& color) {
	// ã‚°ãƒªãƒƒãƒ‰ã‚’6é¢æç”»
	Vector3 size = aabb.max - aabb.min;
	Vector3 halfSize = size * 0.5f;

	// ä¸­å¿ƒã‚’åŸºæº–ã«åº§æ¨™ã‚’èª¿æ•´
	Vector3 offset = center;

	// å‰é¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);

	// å¾Œé¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);

	// å·¦é¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);

	// å³é¢
	DrawGridLines(offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, halfSize.z),
		Vector3(0.0f, halfSize.y * 2, 0.0f), division, color);

	// ä¸Šé¢
	DrawGridLines(offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, halfSize.y, halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);

	// ä¸‹é¢
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(halfSize.x, -halfSize.y, -halfSize.z),
		Vector3(0.0f, 0.0f, halfSize.z * 2), division, color);
	DrawGridLines(offset + Vector3(-halfSize.x, -halfSize.y, -halfSize.z),
		offset + Vector3(-halfSize.x, -halfSize.y, halfSize.z),
		Vector3(halfSize.x * 2, 0.0f, 0.0f), division, color);
}

///-------------------------------------------/// 
/// GridLine
///-------------------------------------------///
void Line::DrawGridLines(const Vector3 & start, const Vector3 & end, const Vector3 & offset, uint32_t division, const Vector4 & color) {
	// ç·šã‚’æç”»
	for (uint32_t i = 0; i <= division; i++) {
		float t = float(i) / float(division);
		Vector3 startPos = Math::Lerp(start, end, t);
		Vector3 endPos = startPos + offset;
		DrawLine(startPos, endPos, color);
	}
}


///-------------------------------------------/// 
/// 2æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šã®ä½œæˆ
///-------------------------------------------///
void Line::CreateQuadraticBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector4& color, int segments) {
	// ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°ãŒ0ä»¥ä¸‹ã®å ´åˆã¯æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (segments <= 0) {
		return;
	}

	// å‰ã®ç‚¹ã‚’ä¿å­˜
	Vector3 previousPoint = p0;

	// æ›²ç·šã‚’åˆ†å‰²ã—ã¦æç”»
	for (int i = 1; i <= segments; ++i) {
		float t = static_cast<float>(i) / static_cast<float>(segments);
		Vector3 currentPoint = CalculateQuadraticBezier(p0, p1, p2, t);

		// å‰ã®ç‚¹ã‹ã‚‰ç¾åœ¨ã®ç‚¹ã¾ã§ç·šã‚’å¼•ã
		DrawLine(previousPoint, currentPoint, color);

		// æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã®ãŸã‚ã«æ›´æ–°
		previousPoint = currentPoint;
	}
}

///-------------------------------------------/// 
/// 3æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šã®ä½œæˆ
///-------------------------------------------///
void Line::CreateCubicBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, const Vector4& color, int segments) {
	// ã‚»ã‚°ãƒ¡ãƒ³ãƒˆæ•°ãŒ0ä»¥ä¸‹ã®å ´åˆã¯æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (segments <= 0) {
		return;
	}

	// å‰ã®ç‚¹ã‚’ä¿å­˜
	Vector3 previousPoint = p0;

	// æ›²ç·šã‚’åˆ†å‰²ã—ã¦æç”»
	for (int i = 1; i <= segments; ++i) {
		float t = static_cast<float>(i) / static_cast<float>(segments);
		Vector3 currentPoint = CalculateCubicBezier(p0, p1, p2, p3, t);

		// å‰ã®ç‚¹ã‹ã‚‰ç¾åœ¨ã®ç‚¹ã¾ã§ç·šã‚’å¼•ã
		DrawLine(previousPoint, currentPoint, color);

		// æ¬¡ã®ãƒ«ãƒ¼ãƒ—ã®ãŸã‚ã«æ›´æ–°
		previousPoint = currentPoint;
	}
}

///-------------------------------------------/// 
/// æ»‘ã‚‰ã‹ãªæ›²ç·šã®ä½œæˆ
///-------------------------------------------///
void Line::CreateSmoothCurve(const std::vector<BezierControlPointData>& controlPoints, const Vector4& color, int segments) {
	// åˆ¶å¾¡ç‚¹ãŒ2ã¤æœªæº€ã®å ´åˆã¯æç”»ã—ãªã„
	if (controlPoints.size() < 2) {
		return;
	}

	// åˆ¶å¾¡ç‚¹ã®æ•°ã«å¿œã˜ã¦å‡¦ç†ã‚’åˆ†å²
	size_t n = controlPoints.size();

	// 2ç‚¹ã®å ´åˆã¯ç›´ç·š
	if (n == 2) {
		DrawLine(controlPoints[0].position, controlPoints[1].position, color);
		return;
	}

	// 3ç‚¹ã®å ´åˆã¯2æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·š
	if (n == 3) {
		CreateQuadraticBezier(
			controlPoints[0].position,
			controlPoints[1].position,
			controlPoints[2].position,
			color,
			segments
		);
		return;
	}

	// 4ç‚¹ã®å ´åˆã¯3æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·š
	if (n == 4) {
		CreateCubicBezier(
			controlPoints[0].position,
			controlPoints[1].position,
			controlPoints[2].position,
			controlPoints[3].position,
			color,
			segments
		);
		return;
	}

	// 5ç‚¹ä»¥ä¸Šã®å ´åˆã¯De Casteljauã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’ä½¿ç”¨
	Vector3 previousPoint = CalculateBezierPointDeCasteljau(controlPoints, 0.0f);

	for (int i = 1; i <= segments; ++i) {
		float t = static_cast<float>(i) / static_cast<float>(segments);
		Vector3 currentPoint = CalculateBezierPointDeCasteljau(controlPoints, t);

		DrawLine(previousPoint, currentPoint, color);

		previousPoint = currentPoint;
	}
}

///-------------------------------------------///  
/// ãƒ™ã‚¸ã‚§æ›²ç·šã®è¨ˆç®—
///-------------------------------------------///
Vector3 Line::CalculateQuadraticBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, float t) {
	float u = 1.0f - t;
	float uu = u * u;
	float tt = t * t;

	// (1-t)^2 * P0 + 2(1-t) * t * P1 + t^2 * P2
	Vector3 point = {};
	point.x = uu * p0.x + 2.0f * u * t * p1.x + tt * p2.x;
	point.y = uu * p0.y + 2.0f * u * t * p1.y + tt * p2.y;
	point.z = uu * p0.z + 2.0f * u * t * p1.z + tt * p2.z;

	return point;
}

///-------------------------------------------/// 
/// ãƒ™ã‚¸ã‚§æ›²ç·šã®è¨ˆç®—
///-------------------------------------------///
Vector3 Line::CalculateCubicBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, float t) {
	float u = 1.0f - t;
	float uu = u * u;
	float uuu = uu * u;
	float tt = t * t;
	float ttt = tt * t;

	// (1-t)^3 * P0 + 3(1-t)^2 * t * P1 + 3(1-t) * t^2 * P2 + t^3 * P3
	Vector3 point = {};
	point.x = uuu * p0.x + 3.0f * uu * t * p1.x + 3.0f * u * tt * p2.x + ttt * p3.x;
	point.y = uuu * p0.y + 3.0f * uu * t * p1.y + 3.0f * u * tt * p2.y + ttt * p3.y;
	point.z = uuu * p0.z + 3.0f * uu * t * p1.z + 3.0f * u * tt * p2.z + ttt * p3.z;

	return point;
}

///-------------------------------------------/// 
/// ãƒ™ã‚¸ã‚§æ›²ç·šã®è¨ˆç®—ï¼ˆDe Casteljauã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ï¼‰
///-------------------------------------------///
Vector3 Line::CalculateBezierPointDeCasteljau(const std::vector<BezierControlPointData>& controlPoints, float t) {
	// åˆ¶å¾¡ç‚¹ã®ä½ç½®ã®ã¿ã‚’æŠ½å‡º
	std::vector<Vector3> temp;
	for (const auto& cp : controlPoints) {
		temp.push_back(cp.position);
	}

	// De Casteljauã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
	while (temp.size() > 1) {
		std::vector<Vector3> newTemp;
		for (size_t i = 0; i < temp.size() - 1; ++i) {
			newTemp.push_back(Math::Lerp(temp[i], temp[i + 1], t));
		}
		temp = newTemp;
	}

	return temp[0];
}


============================================================
File Path: Project/application/Drawing/3d/Line.h
============================================================
#pragma once
/// ===Include=== ///
// Data
#include "Engine/DataInfo/ColliderData.h"
#include "Engine/DataInfo/LineObjectData.h"
// C++
#include <vector>
#include <cstdint>

///=====================================================/// 
/// Line
///=====================================================///
class Line {
public:
	/// <summary>
	/// ç·šåˆ†ã®æç”»ã€‚
	/// </summary>
	/// <param name="start">ç·šåˆ†ã®å§‹ç‚¹</param>
	/// <param name="end">ç·šåˆ†ã®çµ‚ç‚¹</param>
	/// <param name="color">ç·šåˆ†ã®è‰²ï¼ˆRGBAï¼‰</param>
	void DrawLine(const Vector3& start, const Vector3& end, const Vector4& color);

	/// <summary>
	/// OBBã‚’ç·šã§æç”»
	/// </summary>
	/// <param name="obb">æç”»ã™ã‚‹OBB</param>
	/// <param name="color">ç·šã®è‰²ï¼ˆRGBAï¼‰</param>
	void DrawOBB(const OBB& obb, const Vector4& color);

	/// <summary>
	/// AABBã‚’ç·šã§æç”»
	/// </summary>
	/// <param name="aabb">æç”»ã™ã‚‹AABB</param>
	/// <param name="color">ç·šã®è‰²ï¼ˆRGBAï¼‰</param>
	void DrawAABB(const AABB& aabb, const Vector4& color);

	/// <summary>
	/// çƒä½“ã‚’ç·šã§æç”»
	/// </summary>
	/// <param name="sphere">æç”»ã™ã‚‹çƒä½“</param>
	/// <param name="color">ç·šã®è‰²ï¼ˆRGBAï¼‰</param>
	void DrawSphere(const Sphere& sphere, const Vector4& color);

	/// <summary>
	/// ã‚°ãƒªãƒƒãƒ‰ã‚’æç”»
	/// </summary>
	/// <param name="center">ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¿ƒåº§æ¨™</param>
	/// <param name="size">ã‚°ãƒªãƒƒãƒ‰å…¨ä½“ã®ã‚µã‚¤ã‚º</param>
	/// <param name="division">åˆ†å‰²æ•°</param>
	/// <param name="color">ç·šã®è‰²ï¼ˆRGBAï¼‰</param>
	void DrawGrid(const Vector3& center, const Vector3& size, uint32_t division, const Vector4& color);

	/// <summary>
	/// AABBã‚’åŸºæº–ã¨ã—ãŸã‚°ãƒªãƒƒãƒ‰ãƒœãƒƒã‚¯ã‚¹ã‚’æç”»
	/// </summary>
	/// <param name="aabb">åŸºæº–ã¨ãªã‚‹AABB</param>
	/// <param name="division">åˆ†å‰²æ•°</param>
	/// <param name="center">ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¿ƒåº§æ¨™</param>
	/// <param name="color">ç·šã®è‰²ï¼ˆRGBAï¼‰</param>
	void DrawGirdBox(const AABB& aabb, uint32_t division, const Vector3& center, const Vector4& color);

	/// <summary>
	/// 1æ–¹å‘ã«å¯¾ã—ã¦åˆ†å‰²ã•ã‚ŒãŸã‚°ãƒªãƒƒãƒ‰ç·šã‚’æç”»ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
	/// </summary>
	/// <param name="start">é–‹å§‹åº§æ¨™</param>
	/// <param name="end">çµ‚äº†åº§æ¨™</param>
	/// <param name="offset">å„ç·šã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡</param>
	/// <param name="division">åˆ†å‰²æ•°</param>
	/// <param name="color">ç·šã®è‰²ï¼ˆRGBAï¼‰</param>
	void DrawGridLines(const Vector3& start, const Vector3& end, const Vector3& offset, uint32_t division, const Vector4& color);

	/// <summary>
	/// 2æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šã‚’æç”»ï¼ˆ3ã¤ã®åˆ¶å¾¡ç‚¹ï¼‰
	/// </summary>
	/// <param name="p0">é–‹å§‹ç‚¹</param>
	/// <param name="p1">åˆ¶å¾¡ç‚¹</param>
	/// <param name="p2">çµ‚äº†ç‚¹</param>
	/// <param name="color">ç·šã®è‰²</param>
	/// <param name="segments">æ›²ç·šã®åˆ†å‰²æ•°ï¼ˆæ»‘ã‚‰ã‹ã•ï¼‰</param>
	void CreateQuadraticBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector4& color, int segments = 20);

	/// <summary>
	/// 3æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šã‚’æç”»ï¼ˆ4ã¤ã®åˆ¶å¾¡ç‚¹ï¼‰
	/// </summary>
	/// <param name="p0">é–‹å§‹ç‚¹</param>
	/// <param name="p1">åˆ¶å¾¡ç‚¹1</param>
	/// <param name="p2">åˆ¶å¾¡ç‚¹2</param>
	/// <param name="p3">çµ‚äº†ç‚¹</param>
	/// <param name="color">ç·šã®è‰²</param>
	/// <param name="segments">æ›²ç·šã®åˆ†å‰²æ•°ï¼ˆæ»‘ã‚‰ã‹ã•ï¼‰</param>
	void CreateCubicBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, const Vector4& color, int segments = 20);

	/// <summary>
	/// è¤‡æ•°ã®åˆ¶å¾¡ç‚¹ã‹ã‚‰æ»‘ã‚‰ã‹ãªæ›²ç·šã‚’æç”»
	/// </summary>
	/// <param name="controlPoints">åˆ¶å¾¡ç‚¹ã®ãƒªã‚¹ãƒˆ</param>
	/// <param name="color">ç·šã®è‰²</param>
	/// <param name="segments">å„ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã®åˆ†å‰²æ•°</param>
	void CreateSmoothCurve(const std::vector<BezierControlPointData>& controlPoints, const Vector4& color, int segments = 20);

private:

	/// <summary>
	/// 2æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ç‚¹ã‚’è¨ˆç®—
	/// </summary>
	Vector3 CalculateQuadraticBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, float t);

	/// <summary>
	/// 3æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ç‚¹ã‚’è¨ˆç®—
	/// </summary>
	Vector3 CalculateCubicBezier(const Vector3& p0, const Vector3& p1, const Vector3& p2, const Vector3& p3, float t);

	/// <summary>
	/// De Casteljauã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ç‚¹ã‚’è¨ˆç®—ï¼ˆä»»æ„ã®åˆ¶å¾¡ç‚¹æ•°ã«å¯¾å¿œï¼‰
	/// </summary>
	Vector3 CalculateBezierPointDeCasteljau(const std::vector<BezierControlPointData>& controlPoints, float t);
};



============================================================
File Path: Project/application/Drawing/3d/Object3d.cpp
============================================================
#include "Object3d.h"

#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Object3d::~Object3d() {
	if (type_ == ObjectType::Model) {
		model_.reset();
	} else {
		animationModel_.reset();
	}
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Object3d::Init(ObjectType type, const std::string& modelName, LightType light) {
	// ã‚¿ã‚¤ãƒ—ã®ç¢ºèª
	type_ = type;
	// ãã‚Œãã‚Œå¯¾å¿œã—ãŸæ–¹ã‚’ç”Ÿæˆ
	if (type_ == ObjectType::Model) {
		model_ = std::make_unique<Model>();
		model_->Initialize(modelName, light);
	} else {
		animationModel_ = std::make_unique<AnimationModel>();
		animationModel_->Initialize(modelName, light);
	}
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Object3d::Update() {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->Update();
	} else {
		animationModel_->Update();
	}
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void Object3d::Draw(BlendMode mode) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->Draw(mode);
	} else {
		animationModel_->Draw(mode);
	}
}

///-------------------------------------------/// 
/// è¦ªå­é–¢ä¿‚
///-------------------------------------------///
// SetParent
void Object3d::SetParent(ModelCommon* parent) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetParent(parent);
	} else {
		animationModel_->SetParent(parent);
	}
}
// ClearParent
void Object3d::ClearParent() {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->ClearParent();
	} else {
		animationModel_->ClearParent();
	}
}
// Offset
void Object3d::SetParentOffset(const Vector3& offset) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetParentOffset(offset);
	} else {
		animationModel_->SetParentOffset(offset);
	}
} 
const Vector3& Object3d::GetParentOffset() const {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		return model_->GetParentOffset();
	} else {
		return animationModel_->GetParentOffset();
	}
}


///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// Translate
const Vector3& Object3d::GetWorldTranslate() const {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		return model_->GetWorldTranslate();
	} else {
		return animationModel_->GetWorldTranslate();
	}
}
// Rotate
const Quaternion& Object3d::GetWorldRotate() const {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		return model_->GetWorldRotate();
	} else {
		return animationModel_->GetWorldRotate();
	}
}
// Scale
const Vector3& Object3d::GetWorldScale() const {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		return model_->GetWorldScale();
	} else {
		return animationModel_->GetWorldScale();
	}
}
// Transform
const QuaternionTransform& Object3d::GetWorldTransform() const {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		return model_->GetWorldTransform();
	} else {
		return animationModel_->GetWorldTransform();
	}
}
// Color
const Vector4& Object3d::GetColor() const {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		return model_->GetColor();
	} else {
		return animationModel_->GetColor();
	}
}
// ModelCommon
ModelCommon* Object3d::GetModelCommon() {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		return model_.get();
	} else {
		return animationModel_.get();
	}
}


///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Translate
void Object3d::SetTranslate(const Vector3& translate) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetTranslate(translate);
	} else {
		animationModel_->SetTranslate(translate);
	}
}
// Rotate
void Object3d::SetRotate(const Quaternion& rotate) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetRotate(rotate);
	} else {
		animationModel_->SetRotate(rotate);
	}
}
// Scale
void Object3d::SetScale(const Vector3& scale) {
	//	ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetScale(scale);
	} else {
		animationModel_->SetScale(scale);
	}
}
// Color
void Object3d::SetColor(const Vector4& color) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetColor(color);
	} else {
		animationModel_->SetColor(color);
	}
}
// LightInfo
void Object3d::SetLightData(LightInfo light) { 
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetLightData(light);
	} else {
		animationModel_->SetLightData(light);
	}
}
// Light
void Object3d::SetLight(LightType type) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetLightType(type);
	} else {
		animationModel_->SetLightType(type);
	}
}
// ç’°å¢ƒãƒãƒƒãƒ—
void Object3d::SetEnvironmentMapData(bool flag, float string) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::Model) {
		model_->SetEnvironmentMapData(flag, string);
	} else {
		animationModel_->SetEnvironmentMapData(flag, string);
	}
}
// Animation
void Object3d::SetAnimation(const std::string& animationName, bool isLoop) {
	// ã‚¿ã‚¤ãƒ—ã§åˆ†å²
	if (type_ == ObjectType::AnimationModel) {
		animationModel_->SetAnimation(animationName, isLoop);
	} else {
		// ã‚¿ã‚¤ãƒ—ãŒã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ‡ãƒ«å‡ºãªã‘ã‚Œã°å¼·åˆ¶çš„ã«æ­¢ã‚ã‚‹
		assert(0);
	}
}


============================================================
File Path: Project/application/Drawing/3d/Object3d.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Graphics/3d/Model/Model.h"
#include "Engine/Graphics/3d/Model/AnimationModel.h"

/// ===ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒ—=== ///
enum class ObjectType {
	Model,
	AnimationModel
};

///=====================================================/// 
/// Object3D
///=====================================================///
class Object3d {
public:
	Object3d() = default;
	~Object3d();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="type">åˆæœŸåŒ–ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="modelName">ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã®åå‰ï¼ˆè­˜åˆ¥ã¾ãŸã¯ãƒ­ãƒ¼ãƒ‰ã«ä½¿ã‚ã‚Œã‚‹æ–‡å­—åˆ—ï¼‰ã€‚</param>
	/// <param name="light">ç…§æ˜ã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ã€‚çœç•¥æ™‚ã¯ LightType::Noneï¼ˆç…§æ˜ãªã—ï¼‰ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Init(ObjectType type, const std::string& modelName, LightType light = LightType::None);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();
	
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚çœç•¥ã—ãŸå ´åˆã¯ BlendMode::KBlendModeNormal ãŒä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal);

public: /// ===è¦ªå­é–¢ä¿‚=== ///
	/// <summary>
	/// ModelCommon å‹ã®è¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	/// </summary>
	/// <param name="parent">è¨­å®šã™ã‚‹è¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void SetParent(ModelCommon* parent);

	/// <summary>
	/// è¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®å‚ç…§ã‚’ã‚¯ãƒªã‚¢
	/// </summary>
	void ClearParent();

	// è¦ªã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨­å®š
	void SetParentOffset(const Vector3& offset);
	// è¦ªã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å–å¾—
	const Vector3& GetParentOffset() const;

public: /// ===Getter=== ///
	// Transformï¼ˆä½ç½®ã€å›è»¢ã€æ‹¡ç¸®ï¼‰ã‚’å–å¾—
	const Vector3& GetWorldTranslate() const;
	const Quaternion& GetWorldRotate() const;
	const Vector3& GetWorldScale() const;
	const QuaternionTransform& GetWorldTransform() const;
	// Colorï¼ˆè‰²ï¼‰ã‚’å–å¾—
	const Vector4& GetColor() const;
	// ModelCommonã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚’å–å¾—
	ModelCommon* GetModelCommon();

public: /// ===Setter=== ///
	// ãƒ¢ãƒ‡ãƒ«Transform
	void SetTranslate(const Vector3& translate);
	void SetRotate(const Quaternion& rotate);
	void SetScale(const Vector3& scale);
	// ãƒ¢ãƒ‡ãƒ«Color
	void SetColor(const Vector4& color);
	// Light
	void SetLight(LightType type);
	// LightData
	void SetLightData(LightInfo light);
	// ç’°å¢ƒãƒãƒƒãƒ—
	void SetEnvironmentMapData(bool flag, float string);
	// Animation
	void SetAnimation(const std::string& animationName, bool isLoop = true);

private: /// ===Variables(å¤‰æ•°)=== ///

	/// ===ã‚¯ãƒ©ã‚¹=== ///
	std::unique_ptr<Model> model_;
	std::unique_ptr<AnimationModel> animationModel_;

	/// ===ãƒ¢ãƒ‡ãƒ«ã‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¢ãƒ‡ãƒ«ã‹ã‚’åˆ¤æ–­ã™ã‚‹ãƒ•ãƒ©ã‚°=== ///
	ObjectType type_ = ObjectType::Model;
};



============================================================
File Path: Project/application/Game/Animation/GameClearAnimation.cpp
============================================================
#include "GameClearAnimation.h"
// Entity
#include "application/Game/Entity/Player/Player.h"
// Camera
#include "application/Game/Camera/GameCamera.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"
#include "Math/MatrixMath.h"
// Service
#include "Engine/System/Service/DeltaTimeSevice.h"

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void GameClearAnimation::Initialize(Player* player, GameCamera* camera) {
	player_ = player;
	camera_ = camera;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢ã‚’ä¿å­˜
	Quaternion playerRotation = player_->GetTransform().rotate;

	/// ===ã‚«ãƒ¡ãƒ©å›è»¢ã®åˆæœŸè¨­å®š=== ///
	cameraInfo_.timer = 0.0f;
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‰æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’å–å¾—
	cameraInfo_.playerForward = Math::TransformNormal({ 0.0f, 0.0f, 1.0f }, Math::MakeRotateQuaternionMatrix(playerRotation));
	// é–‹å§‹ä½ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	Vector3 startOffset = { 0.0f, 0.120f, -94.0f };
	// çµ‚äº†ä½ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	float finalDistance = 30.0f;
	float finalHeight = 0.08f;
	//Vector3 endOffset = {
	//	-cameraInfo_.playerForward.x * finalDistance,
	//	finalHeight,
	//	-cameraInfo_.playerForward.z * finalDistance
	//};
	Vector3 endOffset = { 0.0f, -finalHeight, -finalDistance };
	// é–‹å§‹è§’åº¦ã¨è·é›¢ã‚’è¨ˆç®—
	cameraInfo_.startAngle = atan2f(startOffset.x, startOffset.z);
	cameraInfo_.distance = sqrtf(startOffset.x * startOffset.x + startOffset.z * startOffset.z);
	cameraInfo_.height = startOffset.y;
	// çµ‚äº†è§’åº¦ã‚’è¨ˆç®—
	cameraInfo_.targetAngle = atan2f(endOffset.x, endOffset.z);
	// ã‚«ãƒ¡ãƒ©ã®å›è»¢æƒ…å ±ã¯ç”»åƒã‹ã‚‰å–å¾—ä¸å¯ã®ãŸã‚ã€ç¾åœ¨ã®å›è»¢ã‚’ä½¿ç”¨
	cameraInfo_.startRotation = camera_->GetRotate();
	// çµ‚äº†æ™‚ã®å›è»¢ã‚‚ç¾åœ¨ã®å›è»¢ã‚’ç¶­æŒ
	cameraInfo_.targetRotation = { 0.0f, -0.98f, 0.2f, 0.0f };

	/// ===ã‚¸ãƒ£ãƒ³ãƒ—ã®åˆæœŸè¨­å®š=== ///
	smallJumpInfo_.timer = 0.0f;
	smallJumpInfo_.count = 0;
	smallJumpInfo_.basePlayerPosition = player_->GetTransform().translate;

	/// ===æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ã®åˆæœŸè¨­å®š=== ///
	finalJumpInfo_.timer = 0.0f;

	/// ===ã‚«ãƒ¡ãƒ©ã®è¨­å®š=== ///
	// å›è»¢å¯èƒ½å‹ã«è¨­å®š
	camera_->SetFollowCamera(FollowCameraType::Orbiting); 
	// ã‚«ãƒ¡ãƒ©ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’è¨­å®š
	camera_->SetTarget(&smallJumpInfo_.basePlayerPosition, &playerRotation); 
	// åˆæœŸã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨­å®š
	camera_->SetOrbitingOffset(startOffset); 

	/// ===Playerã®è¨­å®š=== ///
	player_->SetGravity(-2.9f); 
	// åˆæœŸé€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
	player_->SetVelocity({ 0.0f, 0.0f, 0.0f }); 

	/// ===åˆæœŸãƒ•ã‚§ãƒ¼ã‚ºã‚’è¨­å®š=== ///
	currentPhase_ = ClearAnimationPhase::CameraRotation;
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void GameClearAnimation::Update() {
	/// ===DeltaTimeã®å–å¾—=== ///
	deltaTime_ = DeltaTimeSevice::GetDeltaTime();

	/// ===ãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã®æ›´æ–°=== ///
	switch (currentPhase_) {
	case ClearAnimationPhase::CameraRotation:
		UpdateCameraRotation();
		break;
	case ClearAnimationPhase::FinalJump:
		UpdateFinalJump();
		break;
	case ClearAnimationPhase::Completed:
		// å®Œäº†å¾Œã¯ä½•ã‚‚ã—ãªã„
		break;
	}
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void GameClearAnimation::Draw() {}

///-------------------------------------------/// 
/// å®Œäº†ãƒ•ãƒ©ã‚°ã®å–å¾—
///-------------------------------------------///
bool GameClearAnimation::IsCompleted() const {return currentPhase_ == ClearAnimationPhase::Completed;}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©å›è»¢ãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°
///-------------------------------------------///
void GameClearAnimation::UpdateCameraRotation() {
	// ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
	cameraInfo_.timer += deltaTime_;

	// é€²è¡Œåº¦ã‚’è¨ˆç®—(0.0 ~ 1.0)
	float t = cameraInfo_.timer / cameraInfo_.duration;
	t = (std::min)(t, 1.0f);

	// Easingã‚’é©ç”¨ï¼ˆæ»‘ã‚‰ã‹ãªå›è»¢ï¼‰
	float easedT = Easing::EaseInOutCubic(t);

	// ç¾åœ¨ã®è§’åº¦ã‚’è£œé–“
	float currentAngle = Math::Lerp(cameraInfo_.startAngle, cameraInfo_.targetAngle, easedT);

	// è·é›¢ã¨é«˜ã•ã‚‚è£œé–“
	float finalDistance = 30.0f;
	float finalHeight = 0.08f;
	float currentDistance = Math::Lerp(94.0f, finalDistance, easedT);
	float currentHeight = Math::Lerp(0.120f, -finalHeight, easedT);

	// å††å‘¨ä¸Šã®ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’è¨ˆç®—
	Vector3 newOffset;
	newOffset.x = sinf(currentAngle) * currentDistance;
	newOffset.y = currentHeight;
	newOffset.z = cosf(currentAngle) * currentDistance;

	// ã‚«ãƒ¡ãƒ©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’æ›´æ–°
	camera_->SetOrbitingOffset(newOffset);

	// ã‚«ãƒ¡ãƒ©ã®å›è»¢ã‚’è£œé–“
	Quaternion currentRotation = Math::SLerp(cameraInfo_.startRotation, cameraInfo_.targetRotation, easedT);
	camera_->SetRotate(currentRotation);

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å°ã‚¸ãƒ£ãƒ³ãƒ—æ›´æ–°
	UpdatePlayerSmallJump();

	// å›è»¢å®Œäº†ã§æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ãƒ•ã‚§ãƒ¼ã‚ºã¸
	if (cameraInfo_.timer >= cameraInfo_.duration) {
		currentPhase_ = ClearAnimationPhase::FinalJump;
		finalJumpInfo_.timer = 0.0f;
	}
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å°ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
///-------------------------------------------///
void GameClearAnimation::UpdatePlayerSmallJump() {
	// ã‚¸ãƒ£ãƒ³ãƒ—ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
	smallJumpInfo_.timer += deltaTime_;

	// ã‚¸ãƒ£ãƒ³ãƒ—é–“éš”ã”ã¨ã«æ–°ã—ã„ã‚¸ãƒ£ãƒ³ãƒ—é–‹å§‹
	if (smallJumpInfo_.timer >= smallJumpInfo_.interval) {
		smallJumpInfo_.timer = 0.0f;
		smallJumpInfo_.count++;
	}

	// ç¾åœ¨ã®ã‚¸ãƒ£ãƒ³ãƒ—é€²è¡Œåº¦ã‚’è¨ˆç®—
	float localT = smallJumpInfo_.timer / smallJumpInfo_.interval;
	localT = (std::min)(localT, 1.0f);

	// æ”¾ç‰©ç·šã‚’æãã‚¸ãƒ£ãƒ³ãƒ—
	float jumpProgress = -4.0f * smallJumpInfo_.height * (localT - 0.5f) * (localT - 0.5f) + smallJumpInfo_.height;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®Velocityã‚’æ›´æ–°
	Vector3 playerCurrentVelocity = player_->GetVelocity();
	playerCurrentVelocity.y += jumpProgress * deltaTime_;
	player_->SetVelocity(playerCurrentVelocity);
}

///-------------------------------------------/// 
/// æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°
///-------------------------------------------///
void GameClearAnimation::UpdateFinalJump() {
	// ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
	finalJumpInfo_.timer += deltaTime_;

	// é€²è¡Œåº¦ã‚’è¨ˆç®—(0.0 ~ 1.0)
	float t = finalJumpInfo_.timer / finalJumpInfo_.duration;

	if (t <= 1.0f) {
		// å¤§ããªæ”¾ç‰©ç·šã‚’æãã‚¸ãƒ£ãƒ³ãƒ—
		float jumpProgress = -4.0f * finalJumpInfo_.height * (t - 0.5f) * (t - 0.5f) + finalJumpInfo_.height;

		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®Velocityã‚’æ›´æ–°
		Vector3 playerCurrentVelocity = player_->GetVelocity();
		playerCurrentVelocity.y += jumpProgress * deltaTime_;
		player_->SetVelocity(playerCurrentVelocity);
	} else {
		// ã‚¸ãƒ£ãƒ³ãƒ—å®Œäº†
		currentPhase_ = ClearAnimationPhase::Completed;
	}
}

============================================================
File Path: Project/application/Game/Animation/GameClearAnimation.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/CData.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Player;
class GameCamera;

/// ===ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ•ã‚§ãƒ¼ã‚º=== ///
enum class ClearAnimationPhase {
	CameraRotation,  // ã‚«ãƒ¡ãƒ©å›è»¢ãƒ•ã‚§ãƒ¼ã‚º
	FinalJump,       // æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ãƒ•ã‚§ãƒ¼ã‚º
	Completed        // å®Œäº†
};

///=====================================================/// 
/// ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹
///=====================================================///
class GameClearAnimation {
public:
	GameClearAnimation() = default;
	~GameClearAnimation() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="camera">ã‚«ãƒ¡ãƒ©ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void Initialize(Player* player, GameCamera* camera);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ãƒ•ãƒ©ã‚°ã‚’å–å¾—
	/// </summary>
	/// <returns>å®Œäº†ã—ã¦ã„ã‚Œã°true</returns>
	bool IsCompleted() const;

private:
	/// ===ãƒ¡ãƒ³ãƒå¤‰æ•°=== ///
	Player* player_ = nullptr;      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®å‚ç…§
	GameCamera* camera_ = nullptr;  // ã‚«ãƒ¡ãƒ©ã¸ã®å‚ç…§

	// ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚º
	ClearAnimationPhase currentPhase_ = ClearAnimationPhase::CameraRotation;

	/// ===ã‚«ãƒ¡ãƒ©å›è»¢ç”¨=== ///
	struct CameraRotationInfo {
		float timer = 0.0f;			  // ã‚«ãƒ¡ãƒ©å›è»¢ã‚¿ã‚¤ãƒãƒ¼
		float duration = 3.0f;		  // ã‚«ãƒ¡ãƒ©å›è»¢æ™‚é–“
		float startAngle = 0.0f;      // åˆæœŸè§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
		float targetAngle = 0.0f;     // ç›®æ¨™è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
		float height = 0.120f;		  // ã‚«ãƒ¡ãƒ©ã®é«˜ã•ï¼ˆè£œé–“ç”¨ï¼‰
		float distance = 94.0f;		  // ã‚«ãƒ¡ãƒ©ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è·é›¢ï¼ˆè£œé–“ç”¨ï¼‰
		Quaternion startRotation;     // åˆæœŸã‚«ãƒ¡ãƒ©å›è»¢
		Quaternion targetRotation;    // ç›®æ¨™ã‚«ãƒ¡ãƒ©å›è»¢
		Vector3 playerForward;		  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‰æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«
	};
	CameraRotationInfo cameraInfo_;

	/// ===ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¸ãƒ£ãƒ³ãƒ—ç”¨=== ///
	struct PlayerSmallJumpInfo {
		float timer = 0.0f;           // ã‚¸ãƒ£ãƒ³ãƒ—ã‚¿ã‚¤ãƒãƒ¼
		float interval = 0.5f;        // ã‚¸ãƒ£ãƒ³ãƒ—ã®é–“éš”
		Vector3 basePlayerPosition;   // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åŸºæº–ä½ç½®
		float height = 6.0f;          // å°ã‚¸ãƒ£ãƒ³ãƒ—ã®é«˜ã•
		int count = 0;                // ã‚¸ãƒ£ãƒ³ãƒ—å›æ•°
	};
	PlayerSmallJumpInfo smallJumpInfo_;

	/// ===æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ç”¨=== ///
	struct FinalJumpInfo {
		float timer = 0.0f;      // æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ã‚¿ã‚¤ãƒãƒ¼
		float duration = 1.0f;   // æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—æ™‚é–“
		float height = 7.0f;     // æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ã®é«˜ã•
	};
	FinalJumpInfo finalJumpInfo_;

	float deltaTime_ = 0.0f; // deltaTime

private:
	/// <summary>
	/// ã‚«ãƒ¡ãƒ©å›è»¢ãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°
	/// </summary>
	void UpdateCameraRotation();

	/// <summary>
	/// æœ€çµ‚ã‚¸ãƒ£ãƒ³ãƒ—ãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°
	/// </summary>
	void UpdateFinalJump();

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å°ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
	/// </summary>
	void UpdatePlayerSmallJump();
};

============================================================
File Path: Project/application/Game/Animation/GameOverAnimation.cpp
============================================================
#include "GameOverAnimation.h"
#include "application/Game/Camera/GameCamera.h"
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include <cmath>

// å®šæ•°å®šç¾©
namespace {
    // ã‚«ãƒ¡ãƒ©ã‚¢ãƒ—ãƒ­ãƒ¼ãƒãƒ•ã‚§ãƒ¼ã‚º
    constexpr float CAMERA_ZOOM_SPEED = 0.05f;          // ã‚«ãƒ¡ãƒ©ã®ã‚ºãƒ¼ãƒ é€Ÿåº¦
    constexpr float CAMERA_TARGET_OFFSET_Z = -18.0f;     // ç›®æ¨™ã‚ªãƒ•ã‚»ãƒƒãƒˆZ

    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆè¡¨ç¤ºãƒ•ã‚§ãƒ¼ã‚º
    constexpr float SPRITE_FADE_IN_SPEED = 0.03f;       // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é€Ÿåº¦
    constexpr float SPRITE_DISPLAY_TIME = 90.0f;        // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆè¡¨ç¤ºæ™‚é–“(ãƒ•ãƒ¬ãƒ¼ãƒ )

    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚·ã‚§ã‚¤ã‚¯ãƒ•ã‚§ãƒ¼ã‚º
    constexpr float SHAKE_INTENSITY_START = 1.0f;       // ã‚·ã‚§ã‚¤ã‚¯ã®åˆæœŸå¼·ã•
    constexpr float SHAKE_INTENSITY_MAX = 20.0f;        // ã‚·ã‚§ã‚¤ã‚¯ã®æœ€å¤§å¼·ã•
    constexpr float SHAKE_FREQUENCY = 1.2f;             // ã‚·ã‚§ã‚¤ã‚¯ã®å‘¨æ³¢æ•°
    constexpr float FADE_OUT_SPEED = 0.01f;             // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆé€Ÿåº¦
    constexpr float SHAKE_DURATION = 140.0f;            // ã‚·ã‚§ã‚¤ã‚¯æ™‚é–“(ãƒ•ãƒ¬ãƒ¼ãƒ )
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void GameOverAnimation::Initialize(GameCamera* camera) {
    camera_ = camera;

    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
    gameOverSprite_ = std::make_unique<Sprite>();
    gameOverSprite_->Initialize("GameOverAnimation");

    // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã®å–å¾—
    float windowWidth = static_cast<float>(GraphicsResourceGetter::GetWindowWidth());
    float windowHeight = static_cast<float>(GraphicsResourceGetter::GetWindowHeight());

    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸè¨­å®šï¼ˆç”»é¢ä¸­å¤®ï¼‰
    gameOverSprite_->SetPosition({ windowWidth / 2.0f, windowHeight / 2.0f });
    gameOverSprite_->SetSize({ windowWidth + 100.0f, windowHeight + 100.0f }); // ãŠå¥½ã¿ã®ã‚µã‚¤ã‚ºã«èª¿æ•´
    gameOverSprite_->SetAnchorPoint({ 0.5f, 0.5f }); // ä¸­å¿ƒã‚’åŸºæº–ç‚¹ã«
    gameOverSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 0.0f }); // åˆæœŸã¯é€æ˜

    // ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
    blackSprite_ = std::make_unique<Sprite>();
    blackSprite_->Initialize("White"); // 1x1ã®ç™½ãƒ†ã‚¯ã‚¹ãƒãƒ£
    blackSprite_->SetPosition({ windowWidth / 2.0f, windowHeight /2.0f });
    GraphicsResourceGetter::GetWindowWidth();
    blackSprite_->SetSize({ windowWidth, windowHeight }); // ç”»é¢å…¨ä½“
    blackSprite_->SetAnchorPoint({ 0.5f, 0.5f });
    blackSprite_->SetColor({ 0.0f, 0.0f, 0.0f, 0.0f }); // é»’ã€åˆæœŸã¯é€æ˜

    // çŠ¶æ…‹ã®åˆæœŸåŒ–
    phase_ = Phase::ApproceCamera;
    isCompleted_ = false;
    phaseTimer_ = 0.0f;
    spriteAlpha_ = 0.0f;
    blackAlpha_ = 0.0f;
    shakeOffset_ = { 0.0f, 0.0f };
    originalSpritePos_ = gameOverSprite_->GetPosition();

    // ã‚«ãƒ¡ãƒ©ã®åˆæœŸã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ä¿å­˜
    if (camera_) {
        initialCameraOffset_ = camera_->GetOffset();
    }
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void GameOverAnimation::Update() {
    if (isCompleted_) {
        return;
    }

    switch (phase_) {
    case Phase::ApproceCamera:
        UpdateApproachCamera();
        break;

    case Phase::DrawSprite:
        UpdateDrawSprite();
        break;

    case Phase::ShakeSprite:
        UpdateShakeSprite();
        break;
    }

    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
    if (gameOverSprite_) {
        gameOverSprite_->Update();
    }
    if (blackSprite_) {
        blackSprite_->Update();
    }
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void GameOverAnimation::Draw() {
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»ãƒ•ã‚§ãƒ¼ã‚ºä»¥é™ã§ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’æç”»
    if (phase_ == Phase::DrawSprite || phase_ == Phase::ShakeSprite) {
        if (gameOverSprite_) {
            gameOverSprite_->Draw(GroundType::Front, BlendMode::KBlendModeNormal);
        }
    }

    // ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã®æç”»ï¼ˆæœ€å‰é¢ï¼‰
    if (phase_ == Phase::ShakeSprite && blackAlpha_ > 0.0f) {
        if (blackSprite_) {
            blackSprite_->Draw(GroundType::Front, BlendMode::KBlendModeNormal);
        }
    }
}

///-------------------------------------------/// 
/// ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void GameOverAnimation::Reset() {
    phase_ = Phase::ApproceCamera;
    isCompleted_ = false;
    phaseTimer_ = 0.0f;
    spriteAlpha_ = 0.0f;
    blackAlpha_ = 0.0f;
    shakeOffset_ = { 0.0f, 0.0f };

    if (gameOverSprite_) {
        gameOverSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 0.0f });
        gameOverSprite_->SetPosition(originalSpritePos_);
    }

    if (blackSprite_) {
        blackSprite_->SetColor({ 0.0f, 0.0f, 0.0f, 0.0f });
    }

    // ã‚«ãƒ¡ãƒ©ã®ã‚·ã‚§ã‚¤ã‚¯ã‚’åœæ­¢
    if (camera_) {
        camera_->StopShake();
        // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’åˆæœŸå€¤ã«æˆ»ã™
        camera_->SetOffset(initialCameraOffset_);
    }
}

///-------------------------------------------/// 
/// ApproachCameraãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°
///-------------------------------------------///
void GameOverAnimation::UpdateApproachCamera() {
    if (!camera_) {
        phase_ = Phase::DrawSprite;
        phaseTimer_ = 0.0f;
        return;
    }

    // ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å–å¾—
    Vector3 currentOffset = camera_->GetOffset();

    // ç›®æ¨™ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿‘ã¥ãï¼‰
    Vector3 targetOffset = { 0.0f, 20.0f, CAMERA_TARGET_OFFSET_Z };

    // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è£œé–“
    currentOffset.x += (targetOffset.x - currentOffset.x) * CAMERA_ZOOM_SPEED;
    currentOffset.y += (targetOffset.y - currentOffset.y) * CAMERA_ZOOM_SPEED;
    currentOffset.z += (targetOffset.z - currentOffset.z) * CAMERA_ZOOM_SPEED;

    // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨­å®š
    camera_->SetOffset(currentOffset);

    // ç›®æ¨™è·é›¢ã«åˆ°é”ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
    if (std::abs(currentOffset.z - targetOffset.z) < 0.3f) {
        phase_ = Phase::DrawSprite;
        phaseTimer_ = 0.0f;
    }
}

///-------------------------------------------/// 
/// DrawSpriteãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°
///-------------------------------------------///
void GameOverAnimation::UpdateDrawSprite() {
    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
    if (spriteAlpha_ < 1.0f) {
        spriteAlpha_ += SPRITE_FADE_IN_SPEED;
        if (spriteAlpha_ > 1.0f) {
            spriteAlpha_ = 1.0f;
        }
        gameOverSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 1.0f });
    }

    // ä¸€å®šæ™‚é–“è¡¨ç¤º
    phaseTimer_++;
    if (phaseTimer_ >= SPRITE_DISPLAY_TIME) {
        phase_ = Phase::ShakeSprite;
        phaseTimer_ = 0.0f;
    }
}

///-------------------------------------------/// 
/// ShakeSpriteãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°
///-------------------------------------------///
void GameOverAnimation::UpdateShakeSprite() {
    phaseTimer_++;

    // ã‚·ã‚§ã‚¤ã‚¯ã®å¼·åº¦ã‚’æ™‚é–“ã¨ã¨ã‚‚ã«å¢—åŠ 
    float progress = phaseTimer_ / SHAKE_DURATION;
    float currentIntensity = SHAKE_INTENSITY_START +
        (SHAKE_INTENSITY_MAX - SHAKE_INTENSITY_START) * progress;

    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’ã‚·ã‚§ã‚¤ã‚¯ã•ã›ã‚‹
    float shakeX = currentIntensity * std::sin(phaseTimer_ * SHAKE_FREQUENCY);
    float shakeY = currentIntensity * std::cos(phaseTimer_ * SHAKE_FREQUENCY * 1.5f);
    shakeOffset_ = { shakeX, shakeY };

    Vector2 newPos = originalSpritePos_;
    newPos.x += shakeOffset_.x;
    newPos.y += shakeOffset_.y;
    gameOverSprite_->SetPosition(newPos);

    // ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆ
    blackAlpha_ += FADE_OUT_SPEED;
    if (blackAlpha_ > 1.0f) {
        blackAlpha_ = 1.0f;
    }
    blackSprite_->SetColor({ 0.0f, 0.0f, 0.0f, blackAlpha_ });

    // å®Œäº†åˆ¤å®š
    if (phaseTimer_ >= SHAKE_DURATION || blackAlpha_ >= 1.0f) {
        isCompleted_ = true;
    }
}



============================================================
File Path: Project/application/Game/Animation/GameOverAnimation.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Drawing/2d/Sprite.h"
#include <memory>

/// ===å‰æ–¹å®£è¨€=== ///
class GameCamera;

///-------------------------------------------/// 
/// GameOverAnimation 
///-------------------------------------------///
class GameOverAnimation {
public:
	GameOverAnimation() = default;
	~GameOverAnimation() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="camera">åˆæœŸåŒ–ã™ã‚‹ GameCamera ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Initialize(GameCamera* camera);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

	/// <summary>
	/// ãƒªã‚»ãƒƒãƒˆå‡¦ç†
	/// </summary>
	void Reset();

public: /// ===Getter=== ///
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ãƒ•ãƒ©ã‚°ã®å–å¾—
	bool IsCompleted() const { return isCompleted_; }

private:
	/// ===ãƒã‚¤ãƒ³ã‚¿=== ///
	GameCamera* camera_ = nullptr;  // ã‚«ãƒ¡ãƒ©

	/// ===Sprite=== ///
	std::unique_ptr<Sprite> gameOverSprite_;  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> blackSprite_;     // ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆç”¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ

	/// ===ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡=== ///
	bool isCompleted_ = false;
	float phaseTimer_ = 0.0f;        // ãƒ•ã‚§ãƒ¼ã‚ºå†…ã®ã‚¿ã‚¤ãƒãƒ¼

	/// ===ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåˆ¶å¾¡=== ///
	float spriteAlpha_ = 0.0f;       // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®é€æ˜åº¦
	float blackAlpha_ = 0.0f;        // ãƒ–ãƒ©ãƒƒã‚¯ã‚¢ã‚¦ãƒˆã®é€æ˜åº¦
	Vector2 shakeOffset_ = { 0.0f, 0.0f };      // ã‚·ã‚§ã‚¤ã‚¯ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	Vector2 originalSpritePos_ = { 0.0f, 0.0f }; // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®å…ƒã®ä½ç½®

	/// ===ã‚«ãƒ¡ãƒ©åˆ¶å¾¡=== ///
	Vector3 initialCameraOffset_ = { 0.0f, 2.0f, -15.0f }; // ã‚«ãƒ¡ãƒ©ã®åˆæœŸã‚ªãƒ•ã‚»ãƒƒãƒˆ

	/// ===ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†=== ///
	enum class Phase {
		ApproceCamera, // ã‚«ãƒ¡ãƒ©ã‚’è¿‘ã¥ã‘ã‚‹
		DrawSprite,    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’è¡¨ç¤ºã™ã‚‹
		ShakeSprite    // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’ã‚·ã‚§ã‚¤ã‚¯ã•ã›ã‚‹
	};
	Phase phase_ = Phase::ApproceCamera;

private:

	/// <summary>
	/// ApproachCameraãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateApproachCamera();

	/// <summary>
	/// DrawSpriteãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateDrawSprite();

	/// <summary>
	/// ShakeSpriteãƒ•ã‚§ãƒ¼ã‚ºã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateShakeSprite();
};

============================================================
File Path: Project/application/Game/Animation/StartAnimation.cpp
============================================================
#include "StartAnimation.h"
// Player & Camera
#include "application/Game/Entity/Player/Player.h"
#include "application/Game/Camera/GameCamera.h"
// Service
#include "Engine/System/Service/DeltaTimeSevice.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"
// c++
#include <algorithm>
#include <functional>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
StartAnimation::~StartAnimation() {
	player_ = nullptr;
	camera_ = nullptr;
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void StartAnimation::Initialize(Player* player, GameCamera* camera) {
	player_ = player;
	camera_ = camera;

	/// ===å€¤ã®åˆæœŸåŒ–=== ///
	// ã‚¿ã‚¤ãƒãƒ¼ã¨ãƒ•ãƒ©ã‚°
	timer_ = 0.0f;
	isCompleted_ = false;
	currentPhase_ = AnimationPhase::Falling;
	kDeltaTime_ = DeltaTimeSevice::GetDeltaTime();
	// è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±
	fallInfo_.playerStartPos = { 0.0f, 50.0f, 0.0f };
	fallInfo_.playerEndPos = { 0.0f, 1.0f, 0.0f };
	fallInfo_.FallingDuration = 1.5f;
	// ã‚«ãƒ¡ãƒ©å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±
	cameraRotInfo_.cameraStartPos = { 0.0f, 5.0f, 15.0f };
	cameraRotInfo_.cameraEndPos = { 0.0f, 70.0f, -60.0f };
	cameraRotInfo_.cameraStartRot = { 0.0f, 0.0f, 0.0f, 1.0f };
	cameraRotInfo_.cameraEndRot = { 0.5f, 0.0f, 0.0f, 1.1f };
	cameraRotInfo_.rotationDuration = 1.5f;
	cameraRotInfo_.rotationStartTime = 1.5f;

	/// ===Playerã®åˆæœŸä½ç½®ã‚’è¨­å®š=== ///
	/*if (player_) {
		player_->SetTranslate(playerStartPos_);
	}*/

	/// ===ã‚«ãƒ¡ãƒ©ã®åˆæœŸä½ç½®ã‚’è¨­å®š=== ///
	if (camera_) {
		camera_->SetTranslate(cameraRotInfo_.cameraStartPos);
		camera_->SetRotate(cameraRotInfo_.cameraStartRot);
	}
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void StartAnimation::Update() {
	// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (isCompleted_ && !player_ && !camera_) return;

	/// ===ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ å–å¾—=== ///
	kDeltaTime_ = DeltaTimeSevice::GetDeltaTime();

	/// ===ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹=== ///
	timer_ += kDeltaTime_;

	/// ===ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†=== ///
	if (timer_ < cameraRotInfo_.rotationStartTime) {
		currentPhase_ = AnimationPhase::Falling;
		//UpdateFalling();
	} else if (timer_ < cameraRotInfo_.rotationStartTime + cameraRotInfo_.rotationDuration) {
		currentPhase_ = AnimationPhase::CameraRotation;
		UpdateCameraRotation();
	} else if (timer_ < totalDuration_) {
		currentPhase_ = AnimationPhase::FinalSetup;
	} else {
		// ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
		isCompleted_ = true;
	}
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void StartAnimation::Draw() {}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é™ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
///-------------------------------------------///
void StartAnimation::UpdateFalling() {

	// æ­£è¦åŒ–ã•ã‚ŒãŸæ™‚é–“ï¼ˆ0.0 ~ 1.0ï¼‰
	float t = timer_ / fallInfo_.FallingDuration;
	t = std::clamp(t, 0.0f, 1.0f);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
	float easedT = Easing::EaseOutBounce(t);

	// è£œé–“ã—ã¦ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’æ›´æ–°
	Vector3 currentPos = Math::Lerp(fallInfo_.playerStartPos, fallInfo_.playerEndPos, easedT);
	player_->SetTranslate(currentPos);
}

///-------------------------------------------/// 
/// ã‚«ãƒ¡ãƒ©å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
///-------------------------------------------///
void StartAnimation::UpdateCameraRotation() {

	// å›è»¢ãƒ•ã‚§ãƒ¼ã‚ºã§ã®çµŒéæ™‚é–“
	float rotationTime = timer_ - cameraRotInfo_.rotationStartTime;
	float t = rotationTime / cameraRotInfo_.rotationDuration;
	t = std::clamp(t, 0.0f, 1.0f);

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
	float easedT = Easing::EaseInOutCubic(t);

	// ã‚«ãƒ¡ãƒ©ä½ç½®ã®è£œé–“
	Vector3 midPoint = {
		(cameraRotInfo_.cameraStartPos.x + cameraRotInfo_.cameraEndPos.x) * 0.5f,
		(std::max)(cameraRotInfo_.cameraStartPos.y, cameraRotInfo_.cameraEndPos.y) + 10.0f, // å°‘ã—é«˜ã‚ã«
		(cameraRotInfo_.cameraStartPos.z + cameraRotInfo_.cameraEndPos.z) * 0.5f
	};

	Vector3 currentPos;
	if (easedT < 0.5f) {
		// é–‹å§‹ä½ç½®ã‹ã‚‰ä¸­é–“ç‚¹ã¸
		float t1 = easedT * 2.0f;
		currentPos = Math::Lerp(cameraRotInfo_.cameraStartPos, midPoint, t1);
	} else {
		// ä¸­é–“ç‚¹ã‹ã‚‰çµ‚äº†ä½ç½®ã¸
		float t2 = (easedT - 0.5f) * 2.0f;
		currentPos = Math::Lerp(midPoint, cameraRotInfo_.cameraEndPos, t2);
	}

	// ã‚«ãƒ¡ãƒ©å›è»¢ã®è£œé–“
	Quaternion currentRot = Math::SLerp(cameraRotInfo_.cameraStartRot, cameraRotInfo_.cameraEndRot, easedT);

	// ã‚«ãƒ¡ãƒ©æ›´æ–°
	camera_->SetTranslate(currentPos);
	camera_->SetRotate(currentRot);
}

============================================================
File Path: Project/application/Game/Animation/StartAnimation.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/DataInfo/CData.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Player;
class GameCamera;

///=====================================================/// 
/// StartAnimation
///=====================================================///
class StartAnimation {
public:
	StartAnimation() = default;
	~StartAnimation();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="player">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿</param>
	/// <param name="camera">ã‚«ãƒ¡ãƒ©ã®ãƒã‚¤ãƒ³ã‚¿</param>
	void Initialize(Player* player, GameCamera* camera);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

public: /// ===Getter=== ///
	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ãƒ•ãƒ©ã‚°ã‚’å–å¾—
	/// </summary>
	bool IsCompleted() const { return isCompleted_; }

private:
	/// ===ãƒã‚¤ãƒ³ã‚¿=== ///
	Player* player_ = nullptr;
	GameCamera* camera_ = nullptr;

	/// ===ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åˆ¶å¾¡=== ///
	float timer_ = 0.0f;              // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã‚¿ã‚¤ãƒãƒ¼
	float totalDuration_ = 3.5f;      // å…¨ä½“ã®é•·ã•
	bool isCompleted_ = false;        // å®Œäº†ãƒ•ãƒ©ã‚°

	/// ===ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†=== ///
	enum class AnimationPhase {
		Falling,		 // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é™ä¸‹ãƒ•ã‚§ãƒ¼ã‚º
		CameraRotation,  // ã‚«ãƒ¡ãƒ©å›è»¢ãƒ•ã‚§ãƒ¼ã‚º
		FinalSetup       // æœ€çµ‚èª¿æ•´ãƒ•ã‚§ãƒ¼ã‚º
	};
	AnimationPhase currentPhase_ = AnimationPhase::Falling;

	/// ===è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±=== ///
	struct FallingAnimationInfo {
		Vector3 playerStartPos;  // é–‹å§‹ä½ç½®
		Vector3 playerEndPos;    // çµ‚äº†ä½ç½®
		float FallingDuration;   // é™ä¸‹æ™‚é–“
	};
	FallingAnimationInfo fallInfo_;

	/// ===ã‚«ãƒ¡ãƒ©å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æƒ…å ±=== ///
	struct CameraRotationAnimationInfo {
		Vector3 cameraStartPos;      // é–‹å§‹ä½ç½®
		Vector3 cameraEndPos;        // çµ‚äº†ä½ç½®
		Quaternion cameraStartRot;   // é–‹å§‹å›è»¢
		Quaternion cameraEndRot;     // çµ‚äº†å›è»¢
		float rotationDuration;      // å›è»¢æ™‚é–“
		float rotationStartTime;     // å›è»¢é–‹å§‹æ™‚åˆ»
	};
	CameraRotationAnimationInfo cameraRotInfo_;

	/// ===ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ === ///
	float kDeltaTime_ = 0.0f;

private:

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é™ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateFalling();

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateCameraRotation();
};

============================================================
File Path: Project/application/Game/Camera/GameCamera.cpp
============================================================
#include "GameCamera.h"
#include <cassert>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
GameCamera::~GameCamera() {
	if (type_ == CameraType::Normal) {
		normal_.reset();
	} else {
		follow_.reset();
	}
}

///-------------------------------------------/// 
/// Getter
///-------------------------------------------///
// WorldMatrix
const Matrix4x4& GameCamera::GetWorldMatrix() const {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		return normal_->GetWorldMatrix();
	} else {
		// Followã®å‰Šé™¤
		return follow_->GetWorldMatrix();
	}
}
// ViewMatrix
const Matrix4x4& GameCamera::GetViewMatrix() const {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		return normal_->GetViewMatrix();
	} else {
		// Followã®å‰Šé™¤
		return follow_->GetViewMatrix();
	}
}
// ProjectionMatrix
const Matrix4x4& GameCamera::GetProjectionMatrix() const {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		return normal_->GetProjectionMatrix();
	} else {
		// Followã®å‰Šé™¤
		return follow_->GetProjectionMatrix();
	}
}
// ViewProjectionMatrix
const Matrix4x4& GameCamera::GetViewProjectionMatrix() const {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		return normal_->GetViewProjectionMatrix();
	} else {
		// Followã®å‰Šé™¤
		return follow_->GetViewProjectionMatrix();
	}
}
// Translate
const Vector3& GameCamera::GetTranslate() const {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		return normal_->GetTranslate();
	} else {
		// Followã®å‰Šé™¤
		return follow_->GetTranslate();
	}
}
// Rotate
const Quaternion& GameCamera::GetRotate() const {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		return normal_->GetRotate();
	} else {
		// Followã®å‰Šé™¤
		return follow_->GetRotate();
	}
}
// Offset
const Vector3& GameCamera::GetOffset() const {
	assert(type_ == CameraType::Follow);
	return follow_->GetOffset();
}
// OrbitingOffset
const Vector3& GameCamera::GetOrbitingOffset() const {
	assert(type_ == CameraType::Follow);
	return follow_->GetOrbitingOffset();
}


///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Translate
void GameCamera::SetTranslate(const Vector3& translate) {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		normal_->SetTranslate(translate);
	} else {
		// Followã®å‰Šé™¤
		follow_->SetTranslate(translate);
	}
}
// Rotate
void GameCamera::SetRotate(const Quaternion& rotate) {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		normal_->SetRotate(rotate);
	} else {
		// Followã®å‰Šé™¤
		follow_->SetRotate(rotate);
	}
}
// ForY
void GameCamera::SetForY(const float& forY) {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		normal_->SetForY(forY);
	} else {
		// Followã®å‰Šé™¤
		follow_->SetForY(forY);
	}
}
// AspectRatio
void GameCamera::SetAspectRatio(const float& aspect) {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		normal_->SetAspectRatio(aspect);
	} else {
		// Followã®å‰Šé™¤
		follow_->SetAspectRatio(aspect);
	}
}
// NearClip
void GameCamera::SetNearClip(const float& nearClip) {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		normal_->SetNearClip(nearClip);
	} else {
		// Followã®å‰Šé™¤
		follow_->SetNearClip(nearClip);
	}
}
// FarClip
void GameCamera::SetFarClip(const float& farClip) {
	if (type_ == CameraType::Normal) {
		// Normalã®å‰Šé™¤
		normal_->SetFarClip(farClip);
	} else {
		// Followã®å‰Šé™¤
		follow_->SetFarClip(farClip);
	}
}
// FollowCameraã®è¨­å®š
void GameCamera::SetFollowCamera(FollowCameraType type) {
	if (type_ == CameraType::Normal) return;
	follow_->SetFollowCamera(type);
}
// è¿½å¾“å¯¾è±¡ã®åº§æ¨™ã‚’è¨­å®š
void GameCamera::SetTarget(Vector3* position, Quaternion* rotation) {
	if (type_ == CameraType::Normal) return;
	follow_->SetTarget(position, rotation);
}
// è¿½å¾“ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
void GameCamera::SetOffset(const Vector3& offset) {
	if (type_ == CameraType::Normal) return;
	follow_->SetOffset(offset);
}
void GameCamera::SetOrbitingOffset(const Vector3& offset) {
	if (type_ == CameraType::Normal) return;
	follow_->SetOrbitingOffset(offset);
}
// è¿½å¾“é€Ÿåº¦ã‚’è¨­å®š
void GameCamera::SetFollowSpeed(float speed) {
	if (type_ == CameraType::Normal) return;
	follow_->SetFollowSpeed(speed);
}
// å›è»¢è£œé–“é€Ÿåº¦
void GameCamera::SetLerpSpeed(float speed) {
	if (type_ == CameraType::Normal) return;
	follow_->SetLerpSpeed(speed);
}
// å›è»¢ã®é‡ã¿
void GameCamera::SetStick(const Vector2& stickValue) {
	if (type_ == CameraType::Normal) return;
	follow_->SetStick(stickValue);
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void GameCamera::Init(CameraType type) {
	type_ = type;

	if (type_ == CameraType::Normal) {
		normal_ = std::make_shared<NormalCamera>();
		normal_->Initialize();
	} else {
		follow_ = std::make_shared<FollowCamera>();
		follow_->Initialize();
	}
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void GameCamera::Update() {
	if (type_ == CameraType::Normal) {
		normal_->Update();
	} else {
		follow_->Update();
	}
}

///-------------------------------------------/// 
/// æƒ…å ±
///-------------------------------------------///
void GameCamera::ImGuiUpdate() {
#ifdef USE_IMGUI
	if (type_ == CameraType::Normal) {
		normal_->ImGuiUpdate();
	} else {
		follow_->ImGuiUpdate();
	}
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ‡ãƒãƒƒã‚°ç”¨ã®æ›´æ–°
///-------------------------------------------///
void GameCamera::DebugUpdate() {
#ifdef _DEBUG
	if (type_ == CameraType::Normal) {
		normal_->DebugUpdate();
	} else {
		follow_->DebugUpdate();
	}
#endif // _DEBUG
}

///-------------------------------------------/// 
/// ã‚·ã‚§ã‚¤ã‚¯é–‹å§‹å‡¦ç†
///-------------------------------------------///
void GameCamera::StartShake(float intensity, float duration, float frequency) {
	if (type_ == CameraType::Normal) {
		normal_->StartShake(intensity, duration, frequency);
	} else {
		follow_->StartShake(intensity, duration, frequency);
	}
}

///-------------------------------------------/// 
/// ã‚·ã‚§ã‚¤ã‚¯å‡¦ç†çµ‚äº†
///-------------------------------------------///
void GameCamera::StopShake() {
	if (type_ == CameraType::Normal) {
		normal_->StopShake();
	} else {
		follow_->StopShake();
	}
}

============================================================
File Path: Project/application/Game/Camera/GameCamera.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Camera/NormalCamera.h"
#include "Engine/Camera/FollowCamera.h"

/// ===CameraType=== ///
enum class CameraType {
	Normal,   // é€šå¸¸ã‚«ãƒ¡ãƒ©
	Follow,   // è¿½å¾“ã‚«ãƒ¡ãƒ©
};

///-------------------------------------------/// 
/// Gameã§ä½¿ç”¨ã™ã‚‹ã‚«ãƒ¡ãƒ©
///-------------------------------------------///
class GameCamera {
public:

	GameCamera() = default;
	~GameCamera();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="type">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®ç¨®é¡ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Init(CameraType type);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// ImGui
	/// </summary>
	virtual void ImGuiUpdate();

	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°ç”¨ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void DebugUpdate();

	/// <summary>
	/// ã‚·ã‚§ã‚¤ã‚¯å‡¦ç†
	/// </summary>
	/// <param name="intensity">ã‚·ã‚§ã‚¤ã‚¯ã®å¼·åº¦ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="duration">ã‚·ã‚§ã‚¤ã‚¯åŠ¹æœã®æŒç¶šæ™‚é–“ï¼ˆç§’ï¼‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	/// <param name="frequency">ã‚·ã‚§ã‚¤ã‚¯ã®å‘¨æ³¢æ•°ï¼ˆHzï¼‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚çœç•¥æ™‚ã¯ 10.0f ã§ã™ã€‚</param>
	void StartShake(float intensity, float duration, float frequency = 10.0f);
	
	/// <summary>
	/// ã‚·ã‚§ã‚¤ã‚¯å‹•ä½œã‚’åœæ­¢
	/// </summary>
	void StopShake();

public: /// ===Getter=== ///
	// WorldMatrix
	const Matrix4x4& GetWorldMatrix()const;
	// ViewMatrix
	const Matrix4x4& GetViewMatrix()const;
	// ProjectionMatrix
	const Matrix4x4& GetProjectionMatrix()const;
	// ViewProjectionMatrix
	const Matrix4x4& GetViewProjectionMatrix()const;
	// Translate
	const Vector3& GetTranslate()const;
	// Rotate
	const Quaternion& GetRotate()const;
	// Offset
	const Vector3& GetOffset() const;
	// OrbitingOffset
	const Vector3& GetOrbitingOffset() const;


public: /// ===Setter=== ///
	// Translate
	void SetTranslate(const Vector3& translate);
	// Rotate
	void SetRotate(const Quaternion& rotate);
	// ForY
	void SetForY(const float& forY);
	// Aspect
	void SetAspectRatio(const float& aspect);
	// NearClip
	void SetNearClip(const float& nearClip);
	// FarClip
	void SetFarClip(const float& farClip);
	// FollowTypeã®è¨­å®š
	void SetFollowCamera(FollowCameraType type);
	// è¿½å¾“å¯¾è±¡ã®åº§æ¨™ã‚’è¨­å®š
	void SetTarget(Vector3* position, Quaternion* rotation);
	// è¿½å¾“ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	void SetOffset(const Vector3& offset);
	// å›è»¢å‹è¿½å¾“ã‚«ãƒ¡ãƒ©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	void SetOrbitingOffset(const Vector3& offset);
	// è¿½å¾“é€Ÿåº¦ã‚’è¨­å®š
	void SetFollowSpeed(float speed);
	// å›è»¢è£œé–“é€Ÿåº¦ã‚’è¨­å®š
	void SetLerpSpeed(float speed);
	// ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›
	void SetStick(const Vector2& stickValue);

private:

	/// ===ã‚¯ãƒ©ã‚¹=== ///
	std::shared_ptr<NormalCamera> normal_; // é€šå¸¸ã‚«ãƒ¡ãƒ©
	std::shared_ptr<FollowCamera> follow_; // è¿½å¾“ã‚«ãƒ¡ãƒ©

	/// ===ã‚«ãƒ¡ãƒ©ã‚¿ã‚¤ãƒ—=== ///
	CameraType type_ = CameraType::Normal;
};



============================================================
File Path: Project/application/Game/Entity/Enemy/Base/BaseEnemy.cpp
============================================================
#include "BaseEnemy.h"
// Camera
#include "application/Game/Camera/GameCamera.h"
// Player
#include "application/Game/Entity/Player/Player.h"
// State
#include "application/Game/Entity/Enemy/State/EnemyHitReactionState.h"
#include "application/Game/Entity/Enemy/State/EnemyMoveState.h"
// Service
#include "Engine/System/Service/InputService.h"
#include "Engine/System/Service/ParticleService.h"
#include "Engine/System/Service/CameraService.h"
#include "Engine/System/Service/ColliderService.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI


///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
BaseEnemy::~BaseEnemy() {
	// çŠ¶æ…‹ã‚’è§£æ”¾
	currentState_->Finalize();
	currentState_.reset();
	ColliderService::RemoveCollider(this);
	object3d_.reset();
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void BaseEnemy::SetInvincibleTime() {
	invincibleInfo_.timer = invincibleInfo_.time;
	invincibleInfo_.isInvincible = true;
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void BaseEnemy::Initialize() {
	/// ===Componentã®ç”Ÿæˆ=== ///
	moveComponent_ = std::make_unique<EnemyMoveComponent>();
	hitReactionComponent_ = std::make_unique<EnemyHitReactionComponent>();
	// MoveComponentã®åˆæœŸåŒ–
	EnemyMoveComponent::MoveConfig moveConfig{
			.speed = 0.05f,
			.range = 20.0f,
			.interval = 5.0f,
			.waitTime = 1.5f,
			. rotationSpeed = 0.1f
	};
	moveComponent_->Initialize(transform_.translate, moveConfig);
	// HitReactionComponentã®åˆæœŸåŒ–
	EnemyHitReactionComponent::KnockBackConfig hitReactionConfig{
		.knockBackForce = 1.5f,
		.slowdownFactor = 0.5f,
		.slowdownDuration = 0.2f,
		.alphaDuration = 0.2f,
		.hitAlpha = 0.1f,
		.flashSpeed = 10.0f
	};
	hitReactionComponent_->Initialize(hitReactionConfig);

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è‰²è¨­å®š
	color_ = { 1.0f, 0.0f, 1.0f, 1.0f };

	// ã‚«ãƒ¡ãƒ©ã®å–å¾—
	camera_ = CameraService::GetActiveCamera().get();

	// Stateã®è¨­å®š
	ChangeState(std::make_unique<EnemyMoveState>());

	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã«è¿½åŠ 
	ColliderService::AddCollider(this);
	
	// ç„¡æ•µæƒ…å ±ã®åˆæœŸåŒ–
	invincibleInfo_.time = 0.5f;
	invincibleInfo_.timer = 0.0f;
	invincibleInfo_.isInvincible = false;

	// æ¶ˆæ»…ã‚¿ã‚¤ãƒãƒ¼
	disappearTimer_ = 3.0f;
	isTentativeDeath_ = false;

	// HP 
	baseInfo_.HP = 2;

	// object3dã®æ›´æ–°ã‚’ä¸€å›è¡Œã†
	UpdateAnimation();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void BaseEnemy::Update() {
	// æ­»äº¡ã—ã¦ã„ã‚‹å ´åˆã¯æ›´æ–°ã—ãªã„
	if (isTentativeDeath_) return;

	/// ===Timerã®æ›´æ–°=== ///
	advanceTimer();

	/// ===Stateã®æ›´æ–°=== ///
	if (currentState_) {
		// å„Stateã®æ›´æ–°
		currentState_->Update(this);
	}

	UpdateAnimation();
}

///-------------------------------------------/// 
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void BaseEnemy::UpdateAnimation() {
	// GameCharacterã®æ›´æ–°
	GameCharacter::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void BaseEnemy::Draw(BlendMode mode) {
	/// ===GameCharacterã®æç”»=== ///
	GameCharacter::Draw(mode);
}

///-------------------------------------------/// 
/// ImGui
///-------------------------------------------///
void BaseEnemy::Information() {
#ifdef USE_IMGUI
	// MoveComponent
	moveComponent_->Information();

	// AttackInfo
	ImGui::Text("æ”»æ’ƒæƒ…å ±");
	ImGui::DragFloat("æ”»æ’ƒå¯èƒ½è·é›¢", &attackInfo_.distance, 0.1f);
	ImGui::DragFloat("æ”»æ’ƒç¯„å›²", &attackInfo_.range, 0.1f);
	ImGui::DragFloat("æ”»æ’ƒé–“éš”", &attackInfo_.interval, 0.1f);
	ImGui::DragInt("ãƒ‘ãƒ¯ãƒ¼", &attackInfo_.power, 1);

	// HitReactionComponent
	hitReactionComponent_->Information();

	// InvincibleInfo
	ImGui::Separator();
	ImGui::Text("ç„¡æ•µæƒ…å ±");
	ImGui::DragFloat("ç„¡æ•µæ™‚é–“", &invincibleInfo_.time, 0.01f, 0.0f, 5.0f);
	ImGui::Text("ç„¡æ•µã‚¿ã‚¤ãƒãƒ¼: %.2f", invincibleInfo_.timer);
	ImGui::Text("ç„¡æ•µä¸­: %s", invincibleInfo_.isInvincible ? "true" : "false");

#endif // USE_IMGUI
}

#ifdef USE_IMGUI
///-------------------------------------------/// 
/// å¤‰æ›´ã—ãŸå€¤ã‚’ã‚³ãƒ”ãƒ¼
///-------------------------------------------///
void BaseEnemy::CopyTuningTo(BaseEnemy* enemy) const {
	if (!enemy) return;

	// ===== Objectç³» ===== //
	enemy->color_ = color_;

	// ===== Move ç³»(è¨­è¨ˆå€¤) ===== //
	enemy->moveComponent_->ApplyConfig(moveComponent_->GetConfig());

	// ===== Attack ç³»(è¨­è¨ˆå€¤) ===== //
	enemy->attackInfo_.distance = attackInfo_.distance;
	enemy->attackInfo_.range = attackInfo_.range;
	enemy->attackInfo_.interval = attackInfo_.interval;
	enemy->attackInfo_.power = attackInfo_.power;

	// ===== Knockback ç³»(è¨­è¨ˆå€¤) ===== //
	enemy->hitReactionComponent_->ApplyConfig(hitReactionComponent_->GetConfig());

	// å‹å›ºæœ‰ã®å€¤ã‚’æ´¾ç”Ÿå´ã§ã‚³ãƒ”ãƒ¼
	this->CopyTypeTuningFromThisTo(enemy);
}
#endif // USE_IMGUI

///-------------------------------------------/// 
/// å½“ãŸã‚Šåˆ¤å®š
///-------------------------------------------///
void BaseEnemy::OnCollision(Collider* collider) {

	// æ”»æ’ƒç”¨ã®ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	isCollision_ = true;

	/// ===GameCharacterã®è¡çª=== ///
	GameCharacter::OnCollision(collider);

	// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (baseInfo_.isDead) {
		return;
	}

	// Weaponã¨ã®å½“ãŸã‚Šåˆ¤å®š
	if (collider->GetColliderName() == ColliderName::PlayerWeapon) {
		// ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ä¸­ã§ãªã‘ã‚Œã°ãƒãƒƒã‚¯ãƒãƒƒã‚¯å‡¦ç†ã‚’å®Ÿè¡Œ
		if (!invincibleInfo_.isInvincible) {
			// é€šå¸¸æ”»æ’ƒã®æ™‚
			if (player_->GetAttackComponent()->IsAttacking()) {
				// Stateã‚’HitReactionå¤‰æ›´
				ChangeState(std::make_unique<EnemyHitReactionState>());

				// ãƒãƒƒã‚¯ãƒãƒƒã‚¯æ–¹å‘ã®è¨ˆç®—
				Vector3 toWeapon = collider->GetTransform().translate - transform_.translate;
				toWeapon.y = 0.0f; // Yè»¸ã¯ç„¡è¦–
				toWeapon = -Normalize(toWeapon); // åè»¢ã—ã¦æ­£è¦åŒ–
				hitReactionComponent_->OnHit(toWeapon);

				// HPã‚’æ¸›å°‘
				baseInfo_.HP--;
				hitParticle_ = ParticleService::Emit("Game", transform_.translate);

				// ç„¡æ•µæ™‚é–“ã®ã‚»ãƒƒãƒˆ
				SetInvincibleTime();
			}
		}
	}
}

///-------------------------------------------/// 
/// æ”»æ’ƒå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
///-------------------------------------------///
bool BaseEnemy::CheckAttackable() {

	// æ•µã®å‰æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«(Yè»¸å›è»¢ã‚’ä½¿ç”¨)
	float yaw = transform_.rotate.y;
	Vector3 forward = {
		std::sinf(yaw),
		0.0f,
		std::cosf(yaw)
	};

	Vector3 toPlayer = player_->GetTransform().translate - transform_.translate;;
	toPlayer.y = 0.0f;
	float distance = Length(toPlayer);

	// è·é›¢åˆ¤å®š
	if (distance <= attackInfo_.distance) {
		Vector3 dirToPlayer = Normalize(toPlayer);
		float dot = Dot(forward, dirToPlayer);
		float angleToPlayer = std::acos(dot); // ãƒ©ã‚¸ã‚¢ãƒ³

		// è§’åº¦ãŒç¯„å›²å†…ã‹ãƒã‚§ãƒƒã‚¯
		if (angleToPlayer <= attackInfo_.range) {
			return true;
		} else {
			return false;
		}
	} else {
		return false;
	}
}

///-------------------------------------------/// 
/// Stateã®å¤‰æ›´
///-------------------------------------------///
void BaseEnemy::ChangeState(std::unique_ptr<EnemyState> newState) {
	if (currentState_) {
		// å¤ã„çŠ¶æ…‹ã‚’è§£æ”¾
		currentState_->Finalize();
		currentState_.reset();
	}

	// æ–°ã—ã„çŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆ
	currentState_ = std::move(newState);
	// æ–°ã—ã„çŠ¶æ…‹ã‚’åˆæœŸåŒ–
	currentState_->Enter(this);
}

///-------------------------------------------/// 
/// å›è»¢æ›´æ–°é–¢æ•°
///-------------------------------------------///
void BaseEnemy::UpdateRotationTowards(const Vector3& direction, float slerpT) {
	// æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã®Yæˆåˆ†ã‚’0ã«ã—ã¦æ°´å¹³æ–¹å‘ã®ã¿ã‚’è€ƒæ…®
	Vector3 horizontalDir = { direction.x, 0.0f, direction.z };

	// å€¤ãŒå°ã•ã™ãã‚‹å ´åˆã¯ä½•ã‚‚ã—ãªã„
	if (Length(horizontalDir) < 0.01f) return;

	// forwardæ–¹å‘ã‹ã‚‰ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã‚’ä½œæˆ(Yè»¸å›è»¢ã®ã¿)
	Quaternion targetRotation = Math::LookRotation(horizontalDir, Vector3(0.0f, 1.0f, 0.0f));

	// Quaternionã®å†…ç©ã§é¡ä¼¼åº¦ã‚’è¨ˆç®—
	float dotProduct = Dot(transform_.rotate, targetRotation);
	float absDot = std::abs(dotProduct);

	// 0.9999ä»¥ä¸Šãªã‚‰ååˆ†è¿‘ã„
	if (absDot > 0.99f) {
		isRotationComplete_ = true;
		return; // æ—¢ã«å‘ã„ã¦ã„ã‚‹ã®ã§å‡¦ç†çµ‚äº†
	}
	// å›è»¢ãŒå®Œäº†ã—ã¦ã„ãªã„å ´åˆã¯ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
	isRotationComplete_ = false;

	// SLerpè£œé–“
	Quaternion result = Math::SLerp(transform_.rotate, targetRotation, slerpT);
	transform_.rotate = Normalize(result); // æ­£è¦åŒ–ã§ã‚¹ã‚±ãƒ¼ãƒ«å´©ã‚Œé˜²æ­¢
}

///-------------------------------------------/// 
/// æ™‚é–“ã‚’é€²ã‚ã‚‹
///-------------------------------------------///
void BaseEnemy::advanceTimer() {

	if (baseInfo_.isDead) {
		// æ¶ˆãˆã‚‹ã¾ã§ã®æ™‚é–“ã‚’é€²ã‚ã‚‹
		disappearTimer_ -= baseInfo_.deltaTime;
		if (disappearTimer_ <= 0) {
			deathParticle_ = ParticleService::Emit("nakagawa", transform_.translate);
			isTentativeDeath_ = true;
			if (hitParticle_ != nullptr) {
				hitParticle_->Stop();
				hitParticle_ = nullptr;
			}
		}
	} else {
		// æ”»æ’ƒç”¨ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
		if (attackInfo_.timer > 0.0f) {
			attackInfo_.timer -= baseInfo_.deltaTime;
		}

		// ç„¡æ•µã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
		if (invincibleInfo_.timer > 0.0f) {
			invincibleInfo_.timer -= baseInfo_.deltaTime;
			invincibleInfo_.isInvincible = true;
		} else {
			invincibleInfo_.isInvincible = false;
			invincibleInfo_.timer = 0.0f;
		}

	}
}

============================================================
File Path: Project/application/Game/Entity/Enemy/Base/BaseEnemy.h
============================================================
#pragma once
/// ===Include=== ///
// GameCharacter
#include "application/Game/Entity/GameCharacter/GameCharacter.h"
// State
#include "application/Game/Entity/Enemy/State/Base/EnemyState.h"
// Component
#include "application/Game/Entity/Enemy/Component/EnemyMoveComponent.h"
#include "application/Game/Entity/Enemy/Component/EnemyHitReactionComponent.h"

// c++
#include <random>

/// ===å‰æ–¹å®£è¨€=== ///
class Player;
class ParticleGroup;

/// ===StateType=== ///
enum class StateType {
	Attack
};

///=====================================================/// 
/// Enemy
///=====================================================///
class BaseEnemy : public GameCharacter<OBBCollider> {
private: /// ===å‹å®šç¾©=== ///

	/// ===æ”»æ’ƒæƒ…å ±=== ///
	struct AttackInfo {
		float timer;		// ã‚¿ã‚¤ãƒãƒ¼
		float range;		// æ”»æ’ƒç¯„å›²(å›è»¢ã®æƒ…å ±ã‹ã‚‰Â±)
		float distance;		// æ”»æ’ƒå¯èƒ½è·é›¢
		float interval;		// æ”»æ’ƒé–“éš”
		int32_t power;		// å¾…æ©Ÿæ™‚é–“

		Vector3 direction;  // æ”»æ’ƒæ–¹å‘
		Vector3 targetPos;  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®

		bool isAttack;		// æ”»æ’ƒãƒ•ãƒ©ã‚°
	};

	/// ===ç„¡æ•µæ™‚é–“æƒ…å ±=== ///
	struct InvincibleInfo {
		float time = 0.5f;			// ç„¡æ•µæ™‚é–“
		float timer = 0.0f;			// ç„¡æ•µã‚¿ã‚¤ãƒãƒ¼
		bool isInvincible = false;	// ç„¡æ•µãƒ•ãƒ©ã‚°
	};

public:
	BaseEnemy() = default;
	~BaseEnemy();

	/// <summary>
	/// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã§å‘¼ã³å‡ºã™åˆæœŸåŒ–å‡¦ç†ã®ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="translate">ã‚·ãƒ¼ãƒ³ã®ä½ç½®ã‚’æŒ‡å®šã™ã‚‹å¹³è¡Œç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã€‚constå‚ç…§ã§æ¸¡ã•ã‚Œã‚‹ã€‚</param>
	virtual void InitGameScene(const Vector3& translate) = 0;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	virtual void Initialize()override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update()override;

	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateAnimation();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚æ—¢å®šå€¤ã¯ BlendMode::KBlendModeNormalã€‚</param>
	virtual void Draw(BlendMode mode = BlendMode::KBlendModeNormal)override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨stdç¤º
	/// </summary>
	virtual void Information()override;

	/// <summary>
	/// æ”»æ’ƒå‡¦ç†ã®åˆæœŸåŒ–ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	virtual void StartAttack() = 0;

	/// <summary>
	/// æ”»æ’ƒå‡¦ç†ã®ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	virtual void Attack() = 0;

#ifdef USE_IMGUI
	/// <summary>
	/// ã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°è¨­å®šã‚’æŒ‡å®šã—ãŸæƒ…å ±ã‚’ä»–ã®BaseEnemyã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã‚³ãƒ”ãƒ¼
	/// </summary>
	/// <param name="enemy">ã‚³ãƒ”ãƒ¼å…ˆã® BaseEnemy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void CopyTuningTo(BaseEnemy* enemy) const;
#endif // USE_IMGUI

public: /// ===è¡çªåˆ¤å®š=== ///

	/// <summary>
    /// è¡çªæ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã‚’è¡¨ã™ Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void OnCollision(Collider* collider) override;

public: /// ===Stateç”¨é–¢æ•°=== ///
	// æ”»æ’ƒå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
	bool CheckAttackable();
	// Stateã®å¤‰æ›´
	//NOTE:newState = æ¬¡ã®ã‚¹ãƒ†ãƒ¼ãƒˆ
	void ChangeState(std::unique_ptr<EnemyState> nextState);

	/// <summary>
	/// å›è»¢ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="direction">å›è»¢ç›®æ¨™ã®æ–¹å‘</param>
	/// <param name="lerpT">å›è»¢å®Œäº†ã¾ã§ã®æ™‚é–“</param>
	void UpdateRotationTowards(const Vector3& direction, float lerpT);

public: /// ===Getter=== ///
	// Component
	EnemyMoveComponent& GetMovementComponent() const { return *moveComponent_; };
	EnemyHitReactionComponent& GetHitReactionComponent() const { return *hitReactionComponent_; };
	// Player
	Player* GetPlayer() const { return player_; };
	// AttackInfo
	AttackInfo GetAttackInfo()const { return attackInfo_; };
	// tentativeDeath
	bool GetTentativeDeath() const { return isTentativeDeath_; };
	// isRotationComplete
	bool GetIsRotationComplete() const { return isRotationComplete_; };

public: /// ===Setter=== ///
	// Player
	void SetPlayer(Player* player) { player_ = player; };
	// isRotationComplete
	void SetIsRotationComplete(bool flag) { isRotationComplete_ = flag; };
	// AttackDirection
	void SetAttackDirection(const Vector3& dir) { attackInfo_.direction = dir; };
	void SetTargetPos(const Vector3& pos) { attackInfo_.targetPos = pos; };
	// ç„¡æ•µæ™‚é–“ã®è¨­å®š
	void SetInvincibleTime();

protected: /// ===å¤‰æ•°ã®å®£è¨€=== ///

	GameCamera* camera_ = nullptr; // ã‚«ãƒ¡ãƒ©
	Player* player_ = nullptr; // Player

	// æ”»æ’ƒæƒ…å ±
	AttackInfo attackInfo_;

	// ç„¡æ•µæ™‚é–“æƒ…å ±
	InvincibleInfo invincibleInfo_;

	// è¡çªãƒ•ãƒ©ã‚°
	bool isCollision_ = false;

private:
	/// ===State=== ///
	std::unique_ptr<EnemyState> currentState_;

	/// ===ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ=== ///
	std::unique_ptr<EnemyMoveComponent> moveComponent_;
	std::unique_ptr<EnemyHitReactionComponent> hitReactionComponent_;

	// Particle
	ParticleGroup* hitParticle_ = nullptr;
	ParticleGroup* deathParticle_ = nullptr;

	// å›è»¢å®Œäº†ãƒ•ãƒ©ã‚°
	bool isRotationComplete_ = false;

	// æ¶ˆãˆã‚‹ã¾ã§ã®æ™‚é–“
	float disappearTimer_ = 2.0f;
	bool isTentativeDeath_ = false;

protected: /// ===é–¢æ•°ã®å®£è¨€=== ///
#ifdef USE_IMGUI
	/// <summary>
	/// æ´¾ç”Ÿå´ã§å‹å›ºæœ‰ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã®é–¢æ•°
	/// </summary>
	/// <param name="enemy">è¦ªã®BaseEnemy</param>
	virtual void CopyTypeTuningFromThisTo(BaseEnemy* enemy) const = 0;
#endif // USE_IMGUI
private:

	/// <summary>
	/// ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹å‡¦ç†
	/// </summary>
	void advanceTimer();

};

============================================================
File Path: Project/application/Game/Entity/Enemy/CloseRange/CloseRangeEnemy.cpp
============================================================
#include "CloseRangeEnemy.h"
// Player
#include "application/Game/Entity/Player/Player.h"
// Service
#include "Engine/System/Service/ParticleService.h"
// c++
#include <cstdlib>
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
CloseRangeEnemy::~CloseRangeEnemy() {}

///-------------------------------------------/// 
/// GameSceneç”¨åˆæœŸåŒ–
///-------------------------------------------///
void CloseRangeEnemy::InitGameScene(const Vector3& translate) {
	// CloseRangeEnemyã®åˆæœŸåŒ–
	Initialize();
	// ä½ç½®ã®è¨­å®š
	transform_.translate = translate;
	// BaseEnemyã®åˆæœŸåŒ–
	BaseEnemy::Initialize();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void CloseRangeEnemy::Initialize() {

	/// ===Object=== ///
	// Object3dã®åˆæœŸåŒ–
	object3d_ = std::make_unique<Object3d>();
	object3d_->Init(ObjectType::Model, "player");

	/// ===GameCharacter=== ///
	// GameCharacterã®åˆæœŸåŒ–
	GameCharacter::Initialize();
	name_ = ColliderName::Enemy;

	/// ===AttackInfoã®è¨­å®š=== ///
	attackInfo_.range = 4.0f;
	attackInfo_.distance = 15.0f;
	attackInfo_.interval = 6.0f;
	attackInfo_.timer = 0.0f;
	attackInfo_.power = 1;
	attackInfo_.direction = { 0.0f, 0.0f, 0.0f };
	attackInfo_.isAttack = false;

	/// ===ChargeInfo=== ///
	chargeInfo_.moveSpeed = 0.9f;
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void CloseRangeEnemy::Update() {
	// BaseEnemyã®æ›´æ–°
	BaseEnemy::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void CloseRangeEnemy::Draw(BlendMode mode) {
	// BaseEnemyã®æç”»
	BaseEnemy::Draw(mode);
}

///-------------------------------------------/// 
/// æ›´æ–°ï¼ˆImGuiï¼‰
///-------------------------------------------///
void CloseRangeEnemy::Information() {
#ifdef USE_IMGUI
	ImGui::Begin("è¿‘è·é›¢æ”»æ’ƒã®Enemy");
	BaseEnemy::Information();
	ImGui::Text("çªé€²æƒ…å ±");
	ImGui::DragFloat("ç§»å‹•é€Ÿåº¦", &chargeInfo_.moveSpeed, 0.1f);
	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çªåˆ¤å®š
///-------------------------------------------///
void CloseRangeEnemy::OnCollision(Collider* collider) {
	// BaseEnemyã®å½“ãŸã‚Šåˆ¤å®š
	BaseEnemy::OnCollision(collider);
}

///-------------------------------------------/// 
/// æ”»æ’ƒå‡¦ç†ã®åˆæœŸåŒ–
///-------------------------------------------///
void CloseRangeEnemy::StartAttack() {
	// æ”»æ’ƒé–‹å§‹
	attackInfo_.isAttack = true;
	// æ”»æ’ƒæ™‚é–“ã®è¨­å®š
	attackInfo_.timer = 1.0f;
	// ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨­å®š
	baseInfo_.velocity = attackInfo_.direction * chargeInfo_.moveSpeed;
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åœæ­¢
	if (attackParticle_) {
		attackParticle_->Stop();
		attackParticle_ = nullptr;
	}
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å†ç”Ÿ
	attackParticle_ = ParticleService::Emit("CloseEnemyAttack", transform_.translate);
	attackParticle_->SetEmitterPosition(transform_.translate);
}

///-------------------------------------------/// 
/// æ”»æ’ƒå‡¦ç†
///-------------------------------------------///
void CloseRangeEnemy::Attack() {

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®å·®ã‚’è¨ˆç®—
	Vector3 toTarget = attackInfo_.targetPos - transform_.translate;
	float length = Length(toTarget);

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®æ›´æ–°
	if (attackParticle_) {
		attackParticle_->SetEmitterPosition(transform_.translate);
	}

	// æ”»æ’ƒçµ‚äº†åˆ¤å®š
	if (length < 0.5f) { // åˆ°é”åˆ¤å®š

		// æ”»æ’ƒçµ‚äº†ãƒ•ãƒ©ã‚°ã‚’false
		attackInfo_.isAttack = false;
		// ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
		baseInfo_.velocity = { 0.0f, 0.0f, 0.0f };
		// ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³å†è¨­å®š
		attackInfo_.timer = attackInfo_.interval;
	}
}

#ifdef USE_IMGUI
///-------------------------------------------/// 
/// æ´¾ç”Ÿç”¨ã®æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ
///-------------------------------------------///
void CloseRangeEnemy::CopyTypeTuningFromThisTo(BaseEnemy* dst) const {
	if (auto* d = dynamic_cast<CloseRangeEnemy*>(dst)) {
		d->chargeInfo_.moveSpeed = this->chargeInfo_.moveSpeed;
	}
}
#endif // USE_IMGUI

============================================================
File Path: Project/application/Game/Entity/Enemy/CloseRange/CloseRangeEnemy.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Game/Entity/Enemy/Base/BaseEnemy.h"

/// ===å‰æ–¹å®£è¨€=== ///
class ParticleGroup;

///=====================================================/// 
/// è¿‘æ¥æˆ¦é—˜Enemy
///=====================================================///
class CloseRangeEnemy : public BaseEnemy {
public:
	CloseRangeEnemy() = default;
	~CloseRangeEnemy();

	/// <summary>
	/// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã§å‘¼ã³å‡ºã™åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="translate">ã‚·ãƒ¼ãƒ³ã®ä½ç½®ã‚„å¹³è¡Œç§»å‹•ã‚’è¡¨ã™ Vector3 å‹ã® const å‚ç…§ã€‚åˆæœŸåŒ–æ™‚ã®ä½ç½®ã‚„å¤‰æ›ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void InitGameScene(const Vector3& translate)override;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize()override;
	
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">é©ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚çœç•¥ã—ãŸå ´åˆã¯ BlendMode::KBlendModeNormal ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal)override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information()override;

	/// <summary>
	/// æ”»æ’ƒå‡¦ç†ã®åˆæœŸåŒ–
	/// </summary>
	void StartAttack()override;

	/// <summary>
	/// æ”»æ’ƒå‡¦ç†
	/// </summary>
	void Attack()override;

public: /// ===è¡çªåˆ¤å®š=== ///
	/// <summary>
	/// è¡çªæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã‚’è¡¨ã™ Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void OnCollision(Collider* collider) override;

private: /// ===å¤‰æ•°=== ///

	// ParticleGroup
	ParticleGroup* attackParticle_ = nullptr;

	/// ===çªé€²æƒ…å ±=== ///
	struct ChargeInfo {
		float moveSpeed;
	};
	ChargeInfo chargeInfo_;

#ifdef USE_IMGUI
protected:
	/// <summary>
	/// æ´¾ç”Ÿå´ã§å‹å›ºæœ‰ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã®é–¢æ•°
	/// </summary>
	/// <param name="dst"></param>
	void CopyTypeTuningFromThisTo(BaseEnemy* dst) const override;
#endif // USE_IMGUI
};


============================================================
File Path: Project/application/Game/Entity/Enemy/Component/EnemyHitReactionComponent.cpp
============================================================
#include "EnemyHitReactionComponent.h"
// C++
#include <cassert>
#include <numbers>
// Math
#include "Math/sMath.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI

#ifdef USE_IMGUI
///-------------------------------------------/// 
/// è¨­å®šã®é©ç”¨
///-------------------------------------------///
void EnemyHitReactionComponent::ApplyConfig(const KnockBackConfig& newConfig) {
	if (newConfig.knockBackForce < 0.0f) {
		// ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã§ã®ã¿ã‚¨ãƒ©ãƒ¼
		assert(false && "Invalid KnockBackConfig");
	}
	config_ = newConfig;
}
#endif // USE_IMGUI

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
void EnemyHitReactionComponent::Initialize(const KnockBackConfig& config) {

	// è¨­å®šã®åˆæœŸåŒ–
	config_ = config;

	// çŠ¶æ…‹ã®åˆæœŸåŒ–
	state_.slowdownTimer = 0.0f;
	state_.slowdownMultiplier = 1.0f;
	state_.isHit = false;

	// è‰²ã®çŠ¶æ…‹ã‚’åˆæœŸåŒ–
	colorState_.colorTimer = 0.0f;
	colorState_.colorInterval = 0.0f;
	colorState_.isColorChange = false;

	// ãƒ’ãƒƒãƒˆæ–¹å‘ã®åˆæœŸåŒ–
	hitParentDirection_ = { 0.0f, 0.0f, 0.0f };
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
EnemyHitReactionComponent::UpdateResult EnemyHitReactionComponent::Update(const UpdateContext& context) {
	UpdateResult result{};

	/// ===ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°=== ///
	TimerUpdate(context.deltaTime);

	/// ===æ¸›é€Ÿä¿‚æ•°ã®æ›´æ–°=== ///
	UpdateSlowdownMultiplier();

	/// ===è‰²ã®æ›´æ–°å‡¦ç†=== ///
	result.color = UpdateColor(context.currentColor);

	/// ===ãƒãƒƒã‚¯ãƒãƒƒã‚¯å‡¦ç†=== ///
	if (state_.isHit) {
		// ãƒãƒƒã‚¯ãƒãƒƒã‚¯æ–¹å‘ã®è¨ˆç®—(æ”»æ’ƒå…ƒã‹ã‚‰é›¢ã‚Œã‚‹æ–¹å‘)
		Vector3 direction = hitParentDirection_;
		direction.y = 0.0f; // Yè»¸æ–¹å‘ã¯ç„¡è¦–

		// æ­£è¦åŒ–
		float length = Length(direction);
		if (length > 0.001f) {
			direction = Normalize(direction);
			// ãƒãƒƒã‚¯ãƒãƒƒã‚¯é€Ÿåº¦ã‚’è¨­å®š
			result.velocity = direction * config_.knockBackForce;
		}

		// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
		state_.isHit = false;

	} else {
		// ãƒãƒƒã‚¯ãƒãƒƒã‚¯ä¸­ã§ãªã„å ´åˆã¯ã€ç¾åœ¨ã®é€Ÿåº¦ã«æ¸›é€Ÿä¿‚æ•°ã‚’é©ç”¨
		result.velocity = context.currentVelocity * state_.slowdownMultiplier;
	}

	return result;
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®è¡¨ç¤º
///-------------------------------------------///
void EnemyHitReactionComponent::Information() {
#ifdef USE_IMGUI
	if (ImGui::TreeNode("ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³")) {
		ImGui::DragFloat("ãƒãƒƒã‚¯ãƒãƒƒã‚¯ã®å¼·ã•", &config_.knockBackForce, 0.1f, 0.0f, 100.0f);
		ImGui::DragFloat("æ¸›é€Ÿç‡", &config_.slowdownFactor, 0.01f, 0.0f, 1.0f);
		ImGui::DragFloat("æ¸›é€Ÿæ™‚é–“", &config_.slowdownDuration, 0.01f, 0.0f, 2.0f);
		ImGui::DragFloat("é€æ˜åº¦å¤‰åŒ–æ™‚é–“", &config_.alphaDuration, 0.01f, 0.0f, 1.0f);
		ImGui::DragFloat("ãƒ’ãƒƒãƒˆæ™‚ã®é€æ˜åº¦", &config_.hitAlpha, 0.01f, 0.0f, 1.0f);
		ImGui::DragFloat("ç‚¹æ»…é€Ÿåº¦", &config_.flashSpeed, 0.5f, 1.0f, 30.0f);

		ImGui::Separator();
		ImGui::Text("çŠ¶æ…‹");
		ImGui::Text("æ¸›é€Ÿã‚¿ã‚¤ãƒãƒ¼: %.2f", state_.slowdownTimer);
		ImGui::Text("è‰²å¤‰åŒ–ã‚¿ã‚¤ãƒãƒ¼: %.2f", colorState_.colorTimer);
		ImGui::Text("ãƒ’ãƒƒãƒˆã—ãŸã‹ã©ã†ã‹: %s", state_.isHit ? "true" : "false");
		ImGui::Text("è‰²å¤‰åŒ–ä¸­: %s", colorState_.isColorChange ? "true" : "false");
		ImGui::TreePop();
	}
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ãƒ’ãƒƒãƒˆå‡¦ç†ã®é–‹å§‹
///-------------------------------------------///
void EnemyHitReactionComponent::OnHit(const Vector3& hitParentDirection) {
	// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	state_.isHit = true;
	// å½“ãŸã£ã¦ã„ã‚‹æ–¹å‘ã‚’å–å¾—
	hitParentDirection_ = hitParentDirection;
	// æ¸›é€Ÿã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®š
	state_.slowdownTimer = config_.slowdownDuration;
	// è‰²å¤‰åŒ–ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’è¨­å®š
	colorState_.colorTimer = config_.alphaDuration;
	colorState_.colorInterval = 0.0f;
	colorState_.isColorChange = true;
}

///-------------------------------------------/// 
/// ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void EnemyHitReactionComponent::TimerUpdate(const float deltaTime) {
	// æ¸›é€Ÿã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°
	if (state_.slowdownTimer > 0.0f) {
		state_.slowdownTimer -= deltaTime;

		if (state_.slowdownTimer < 0.0f) {
			state_.slowdownTimer = 0.0f;
		}
	}

	// è‰²å¤‰åŒ–ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°
	if (colorState_.colorTimer > 0.0f) {
		colorState_.colorTimer -= deltaTime;
		colorState_.colorInterval += deltaTime;

		if (colorState_.colorTimer < 0.0f) {
			colorState_.colorTimer = 0.0f;
			colorState_.colorInterval = 0.0f;
			colorState_.isColorChange = false;
		}
	}
}

///-------------------------------------------/// 
/// æ¸›é€Ÿä¿‚æ•°ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void EnemyHitReactionComponent::UpdateSlowdownMultiplier() {
	if (state_.slowdownTimer > 0.0f) {
		// æ¸›é€Ÿæ™‚é–“ã«å¿œã˜ã¦ç·šå½¢è£œé–“
		// ã‚¿ã‚¤ãƒãƒ¼ãŒæ¸›ã‚‹ã«ã¤ã‚Œã¦ã€æ¸›é€Ÿç‡ã‹ã‚‰é€šå¸¸é€Ÿåº¦(1.0)ã«æˆ»ã‚‹
		float t = state_.slowdownTimer / config_.slowdownDuration;
		state_.slowdownMultiplier = Math::Lerp(1.0f, config_.slowdownFactor, t);
	} else {
		// æ¸›é€Ÿæ™‚é–“ãŒçµ‚äº†ã—ãŸã‚‰é€šå¸¸é€Ÿåº¦
		state_.slowdownMultiplier = 1.0f;
	}
}

///-------------------------------------------/// 
/// è‰²ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
Vector4 EnemyHitReactionComponent::UpdateColor(const Vector4& currentColor) const {
	Vector4 color = currentColor;

	if (colorState_.isColorChange && colorState_.colorTimer > 0.0f) {
		// ã‚µã‚¤ãƒ³æ³¢ã‚’ä½¿ã£ã¦ç‚¹æ»…åŠ¹æœã‚’ç”Ÿæˆ
		float wave = std::sin(colorState_.colorInterval * config_.flashSpeed * 2.0f * std::numbers::pi_v<float>);

		// ã‚µã‚¤ãƒ³æ³¢ã®å€¤ãŒæ­£ã®æ™‚ã¯åŠé€æ˜ã€è² ã®æ™‚ã¯é€šå¸¸
		if (wave > 0.0f) {
			color.w = config_.hitAlpha;
		} else {
			color.w = 1.0f;
		}
	} else {
		// è‰²å¤‰åŒ–ãŒçµ‚äº†ã—ãŸã‚‰å…ƒã®è‰²ã«æˆ»ã™
		color.w = 1.0f;
	}

	return color;
}


============================================================
File Path: Project/application/Game/Entity/Enemy/Component/EnemyHitReactionComponent.h
============================================================
#pragma once
/// ===Include=== ///
#include "Math/Vector3.h"
#include "Math/Vector4.h"

///=====================================================/// 
/// EnemyHitReactionComponent
///=====================================================///
class EnemyHitReactionComponent {
private:
	/// ===çŠ¶æ…‹ã®æ§‹é€ ä½“=== ///
	struct KnockBackState {
		float slowdownTimer = 0.0f;		 // æ¸›é€Ÿç”¨ã‚¿ã‚¤ãƒãƒ¼
		float slowdownMultiplier = 1.0f; // æ¸›é€Ÿç‡ã®ä¹—æ•°
		bool isHit = false;				 // ãƒ’ãƒƒãƒˆã—ãŸã‹ã©ã†ã‹
	};
	/// ===è‰²ã®çŠ¶æ…‹æ§‹é€ ä½“=== ///
	struct ColorState {
		float colorTimer = 0.0f;    // è‰²å¤‰åŒ–ç”¨ã‚¿ã‚¤ãƒãƒ¼
		float colorInterval = 0.0f; // è‰²å¤‰åŒ–ã®é–“éš”
		bool isColorChange = false; // è‰²å¤‰åŒ–ãƒ•ãƒ©ã‚°
	};

public:
	/// ===è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ§‹é€ ä½“=== ///
	struct KnockBackConfig {
		float knockBackForce = 1.5f;	// ãƒãƒƒã‚¯ãƒãƒƒã‚¯ã®å¼·ã•
		float slowdownFactor = 0.3f;	// æ¸›é€Ÿç‡(0.0~1.0ã€å°ã•ã„ã»ã©é…ããªã‚‹)
		float slowdownDuration = 0.2f;	// æ¸›é€ŸåŠ¹æœã®æŒç¶šæ™‚é–“
		float alphaDuration = 0.2f;		// é€æ˜åº¦å¤‰åŒ–ã®æŒç¶šæ™‚é–“
		float hitAlpha = 0.6f;			// ãƒ’ãƒƒãƒˆæ™‚ã®é€æ˜åº¦
		float flashSpeed = 10.0f;		// ç‚¹æ»…é€Ÿåº¦
	};

	/// ===æ›´æ–°ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ=== ///
	struct UpdateContext {
		Vector3 currentPosition;	// ç¾åœ¨ã®ä½ç½®
		Vector3 currentVelocity;	// ç¾åœ¨ã®é€Ÿåº¦
		Vector4 currentColor;    // ç¾åœ¨ã®è‰²
		float deltaTime;
	};

	/// ===æ›´æ–°çµæœ=== ///
	struct UpdateResult {
		Vector3 velocity = { 0.0f, 0.0f, 0.0f };
		Vector4 color = { 1.0f, 1.0f, 1.0f, 1.0f };
	};

public:

	EnemyHitReactionComponent() = default;
	~EnemyHitReactionComponent() = default;

	// ã‚³ãƒ”ãƒ¼ãƒ»ãƒ ãƒ¼ãƒ–ã¯æ˜ç¤ºçš„ã«åˆ¶å¾¡
	EnemyHitReactionComponent(const EnemyHitReactionComponent&) = delete;
	EnemyHitReactionComponent& operator=(const EnemyHitReactionComponent&) = delete;

	/// <summary>
	/// KnockBack ã®åˆæœŸåŒ–ã‚’è¡Œã„ã¾ã™ã€‚
	/// </summary>
	/// <param name="config">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹è¨­å®šã‚’ const å‚ç…§ã§å—ã‘å–ã‚Šã¾ã™ã€‚å¼•æ•°ã‚’çœç•¥ã—ãŸå ´åˆã¯ KnockBackConfig ã®æ—¢å®šå€¤ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Initialize(const KnockBackConfig& config = KnockBackConfig{});

	/// <summary>
	/// ä¸ãˆã‚‰ã‚ŒãŸæ›´æ–°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã«åŸºã¥ã„ã¦æ›´æ–°å‡¦ç†ã‚’è¡Œã„ã€ãã®çµæœã‚’è¿”ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="context">æ›´æ–°ã«å¿…è¦ãªæƒ…å ±ã‚’ä¿æŒã™ã‚‹å…¥åŠ›ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã€‚å‚ç…§ã§æ¸¡ã•ã‚Œã€é–¢æ•°ã¯ã“ã®æƒ…å ±ã‚’ç”¨ã„ã¦æ›´æ–°ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚</param>
	/// <returns>æ›´æ–°å‡¦ç†ã®çµæœã‚’è¡¨ã™ UpdateResultã€‚æˆåŠŸï¼å¤±æ•—ã‚„çŠ¶æ…‹ã«é–¢ã™ã‚‹æƒ…å ±ã‚’å«ã¿ã¾ã™ã€‚</returns>
	UpdateResult Update(const UpdateContext& context);

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information();

	/// <summary>
	/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒãƒ’ãƒƒãƒˆã•ã‚ŒãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã€‚ãƒ’ãƒƒãƒˆã®æ–¹å‘ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
	/// </summary>
	/// <param name="hitParentDirection">è¦ªåº§æ¨™ç³»ï¼ˆè¦ªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåŸºæº–ï¼‰ã§è¡¨ã•ã‚ŒãŸãƒ’ãƒƒãƒˆã®æ–¹å‘ã‚’ç¤ºã™Vector3ã¸ã®constå‚ç…§ã€‚é–¢æ•°å†…ã§å€¤ã¯å¤‰æ›´ã•ã‚Œã¾ã›ã‚“ã€‚</param>
	void OnHit(const Vector3& hitParentDirection);

public: /// ===Getter=== ///
	// KnockBackConfig
	const KnockBackConfig& GetConfig() const { return config_; }
	// KnockBackState
	const KnockBackState& GetKnockBackState() const { return state_; }
	// ColorState
	const ColorState& GetColorState() const { return colorState_; }

#ifdef USE_IMGUI
public: /// ===Setter=== ///
	// KnockBackConfig
	void ApplyConfig(const KnockBackConfig& newConfig);
#endif // USE_IMGUI
private:
	/// ===æƒ…å ±=== ///
	KnockBackConfig config_;
	KnockBackState state_;
	ColorState colorState_;

	// ãƒ’ãƒƒãƒˆã—ãŸç›¸æ‰‹ã®æ–¹å‘
	Vector3 hitParentDirection_ = {0.0f, 0.0f, 0.0f};

private:

	/// <summary>
	/// ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="deltaTime">ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ </param>
	void TimerUpdate(const float deltaTime);

	/// <summary>
	/// æ¸›é€Ÿä¿‚æ•°ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateSlowdownMultiplier();

	/// <summary>
	/// æ¸¡ã•ã‚ŒãŸè‰²ã‚’å…ƒã«æ›´æ–°ã•ã‚ŒãŸè‰²ã‚’è¿”ã—ã¾ã™ã€‚`
	/// </summary>
	/// <param name="color">æ›´æ–°ã®åŸºã¨ãªã‚‹è‰²ã€‚å‚ç…§æ¸¡ã—ã•ã‚ŒãŸ const Vector4 ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</param>
	/// <returns>æ›´æ–°ã•ã‚ŒãŸè‰²ã‚’è¡¨ã™ Vector4 ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€‚</returns>
	Vector4 UpdateColor(const Vector4& color) const;
};



============================================================
File Path: Project/application/Game/Entity/Enemy/Component/EnemyMoveComponent.cpp
============================================================
#include "EnemyMoveComponent.h"
// C++
#include <cassert>
// Math
#include "Math/sMath.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI

#ifdef USE_IMGUI
///-------------------------------------------/// 
/// è¨­å®šã®é©ç”¨
///-------------------------------------------///
void EnemyMoveComponent::ApplyConfig(const MoveConfig& newconfig) {
	if (newconfig.speed < 0.0f || newconfig.range <= 0.0f) {
		// ãƒ‡ãƒãƒƒã‚°ãƒ“ãƒ«ãƒ‰ã§ã®ã¿ã‚¨ãƒ©ãƒ¼
		assert(false && "Invalid MoveConfig");
	}
	config_ = newconfig;
}
#endif // USE_IMGUI

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
void EnemyMoveComponent::Initialize(const Vector3& center, const MoveConfig& config) {
	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
	std::seed_seq seed{
		static_cast<uint32_t>(std::time(nullptr)),
		static_cast<uint32_t>(reinterpret_cast<uintptr_t>(this)),
	};
	randomEngine_.seed(seed);

	// è¨­å®šã®åˆæœŸåŒ–
	config_ = config;

	// çŠ¶æ…‹ã®åˆæœŸåŒ–
	state_.timer = 1.0f;
	state_.rangeCenter = center;
	state_.direction = { 0.0f, 0.0f, 0.0f };
	state_.isWaiting = false;
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
EnemyMoveComponent::UpdateResult EnemyMoveComponent::Update(const UpdateContext& context) {

	UpdateResult result{};

	/// ===ã‚¿ã‚¤ãƒãƒ¼=== ///
	if (state_.timer > 0.0f) {
		state_.timer -= context.deltaTime;
	}

	/// ===è¨ˆç®—=== ///
	// ç§»å‹•ç¯„å›²ã®ä¸­å¿ƒã¨ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
	Vector3 toCenter = state_.rangeCenter - context.currentPosition;
	// ä¸­å¿ƒã‹ã‚‰ã®è·é›¢ã‚’å–å¾—
	float distanceFromCenter = Length(toCenter);

	// ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨­å®š
	result.velocity = state_.direction * config_.speed;

	/// ===ç§»å‹•å‡¦ç†=== ///
	if (state_.isWaiting) { // å¾…æ©Ÿä¸­ã ã£ãŸã‚‰
		// ç§»å‹•ã—ãªã„
		result.velocity = { 0.0f, 0.0f, 0.0f };

		// æ–¹å‘ã‚’å›è»¢
		if (!context.isRotationComplete) {
			result.targetDirection = state_.direction;
			result.needsRotation = true;
		}
		
		// å›è»¢ã—çµ‚ã‚ã£ãŸã‚‰
		if (context.isRotationComplete && state_.timer <= 0.0f) {
			// ãƒ©ãƒ³ãƒ€ãƒ ãªæ™‚é–“ã‚’è¨­å®š
			std::uniform_real_distribution<float> timeDist(1.0f, config_.interval);
			state_.timer = timeDist(randomEngine_);

			// ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨­å®š
			result.velocity = state_.direction * config_.speed;
			// å¾…æ©Ÿãƒ•ãƒ©ã‚°ã‚’è§£é™¤
			state_.isWaiting = false;
			// å›è»¢å®Œäº†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
			result.shouldResetRotationFlag = true;
			result.needsRotation = false;
		}

	} else if (distanceFromCenter > config_.range) { // ç¯„å›²å¤–ã«å‡ºãŸå ´åˆ
		// æ–¹å‘ã®è¨­å®šã¨å¾…æ©Ÿå‡¦ç†ã®æº–å‚™
		PreparNextMove(toCenter);
		result.velocity = { 0.0f, 0.0f, 0.0f };

	} else if (state_.timer <= 0.0f && !state_.isWaiting) {
		// ãƒ©ãƒ³ãƒ€ãƒ ãªè§’åº¦ã¨è·é›¢ã‚’ç”Ÿæˆ
		std::uniform_real_distribution<float> angleDist(0.0f, 2.0f * Math::Pi());
		std::uniform_real_distribution<float> distanceDist(0.0f, config_.range);
		// ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ã®è¨­å®š
		float angle = angleDist(randomEngine_);
		float distance = distanceDist(randomEngine_);

		// æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’å††ã‹ã‚‰ç®—å‡º
		Vector3 offset = {
			std::cos(angle) * distance,
			0.0f,
			std::sin(angle) * distance
		};

		// ç§»å‹•å…ˆã®åº§æ¨™ã‚’è¨ˆç®—
		Vector3 target = state_.rangeCenter + offset;
		target.y = context.currentPosition.y;

		// æ–¹å‘ã®è¨­å®šã¨å¾…æ©Ÿå‡¦ç†ã®æº–å‚™
		PreparNextMove(target - context.currentPosition);
		result.velocity = { 0.0f, 0.0f, 0.0f };
	}

	return result;
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®è¡¨ç¤º
///-------------------------------------------///
void EnemyMoveComponent::Information() {
#ifdef USE_IMGUI
	if (ImGui::TreeNode("ç§»å‹•æƒ…å ±")) {
		ImGui::DragFloat("ç§»å‹•é€Ÿåº¦", &config_.speed, 0.01f, 0.0f, 10.0f);
		ImGui::DragFloat("ç§»å‹•ç¯„å›²", &config_.range, 0.1f, 0.1f, 100.0f);
		ImGui::DragFloat("ç§»å‹•é–“éš”", &config_.interval, 0.1f, 0.1f, 10.0f);
		ImGui::DragFloat("å¾…æ©Ÿæ™‚é–“", &config_.waitTime, 0.01f, 0.0f, 5.0f);
		ImGui::DragFloat("å›è»¢é€Ÿåº¦", &config_.rotationSpeed, 0.01f, 0.01f, 1.0f);

		ImGui::Separator();
		ImGui::Text("çŠ¶æ…‹");
		ImGui::Text("ã‚¿ã‚¤ãƒãƒ¼:  %.2f", state_.timer);
		ImGui::Text("å¾…æ©Ÿä¸­: %s", state_.isWaiting ? "Yes" : "No");

		ImGui::TreePop();
	}
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ç§»å‹•é–‹å§‹å‡¦ç†
///-------------------------------------------///
void EnemyMoveComponent::StartMove(const Vector3& center) {
	state_.timer = config_.waitTime;
	state_.rangeCenter = center;
}

///-------------------------------------------/// 
/// æ–¹å‘ã®è¨­å®šã¨å¾…æ©Ÿæ™‚é–“ã®è¨­å®š
///-------------------------------------------///
void EnemyMoveComponent::PreparNextMove(const Vector3& vector) {
	Vector3 dir = Normalize(vector);
	dir.y = 0.0f; // Yæˆåˆ†ã‚’0ã«ã—ã¦XZå¹³é¢ã§ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½œæˆ
	state_.direction = Normalize(dir); // æ–¹å‘ã‚’ä¿å­˜

	// å¾…æ©Ÿæ™‚é–“ã‚’è¨­å®š
	state_.timer = config_.waitTime; // å¾…æ©Ÿæ™‚é–“ã‚’è¨­å®š
	// å¾…æ©Ÿãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
	state_.isWaiting = true;
}


============================================================
File Path: Project/application/Game/Entity/Enemy/Component/EnemyMoveComponent.h
============================================================
#pragma once
/// ===Include=== ///
#include "Math/Vector3.h"
#include <random>

///=====================================================/// 
/// EnemyMoveComponent
///=====================================================///
class EnemyMoveComponent {
private:
	/// ===çŠ¶æ…‹ã®æ§‹é€ ä½“=== ///
	struct MoveState {
		float timer = 0.0f;			// ã‚¿ã‚¤ãƒãƒ¼
		Vector3 rangeCenter{};		// ç§»å‹•ç¯„å›²ã®ä¸­å¿ƒ
		Vector3 direction{};		// ç§»å‹•æ–¹å‘
		bool isWaiting = false;		// å¾…æ©Ÿãƒ•ãƒ©ã‚°	
	};
public:
	/// ===è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ§‹é€ ä½“=== ///
	struct MoveConfig {
		float speed = 0.05f;		// ç§»å‹•é€Ÿåº¦
		float range = 20.0f;	    // ç§»å‹•ç¯„å›²
		float interval = 5.0f;	    // ç§»å‹•é–“éš”
		float waitTime = 1.5f;	    // å¾…æ©Ÿæ™‚é–“
		float rotationSpeed = 0.1f; // å›è»¢é€Ÿåº¦
	};

	/// ===æ›´æ–°ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ=== ///
	struct UpdateContext {
		Vector3 currentPosition{};		 // ç¾åœ¨ã®ä½ç½®
		float deltaTime = 0.0f;			 // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
		bool isRotationComplete = false; // å›è»¢å®Œäº†ãƒ•ãƒ©ã‚°
	};

	/// ===æ›´æ–°çµæœ=== ///
	struct UpdateResult {
		Vector3 velocity{};					   // ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«
		Vector3 targetDirection{};			   // ç›®æ¨™æ–¹å‘
		bool needsRotation = false;			   // å›è»¢ãŒå¿…è¦ã‹ã©ã†ã‹
		bool shouldResetRotationFlag = false;  // å›è»¢å®Œäº†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹
	};

public:

	EnemyMoveComponent() = default;
	~EnemyMoveComponent() = default;

	// ã‚³ãƒ”ãƒ¼ãƒ»ãƒ ãƒ¼ãƒ–ã¯æ˜ç¤ºçš„ã«åˆ¶å¾¡
	EnemyMoveComponent(const EnemyMoveComponent&) = delete;
	EnemyMoveComponent& operator=(const EnemyMoveComponent&) = delete;

	/// <summary>
	/// æŒ‡å®šã—ãŸæ•µã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’åˆæœŸåŒ–ã—ã€ä¸­å¿ƒä½ç½®ã‚’è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="center">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ä¸­å¿ƒä½ç½®ã‚’ç¤ºã™ Vector3 ã® const å‚ç…§ã€‚</param>
	void Initialize(const Vector3& center, const MoveConfig& config = MoveConfig{});

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	UpdateResult Update(const UpdateContext& context);

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information();

	/// <summary>
	/// æŒ‡å®šã—ãŸä¸­å¿ƒç‚¹ã‚’åŸºæº–ã«ç§»å‹•ã‚’é–‹å§‹ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="center">ç§»å‹•ã®åŸºæº–ã¨ãªã‚‹ä¸­å¿ƒä½ç½®ã‚’è¡¨ã™ Vector3 å‹ã®åº§æ¨™ï¼ˆconst å‚ç…§ï¼‰ã€‚</param>
	void StartMove(const Vector3& center);

public: /// ===Getter=== ///
	// MoveConfig
	const MoveConfig& GetConfig() const { return config_; }
	// MoveState
	const MoveState& GetState() const { return state_; }

#ifdef USE_IMGUI
public: /// ===Setter=== ///
	// MoveConfig
	void ApplyConfig(const MoveConfig& newconfig);
#endif // USE_IMGUI

private:
	/// ===æƒ…å ±=== ///
	MoveConfig config_;
	MoveState state_;

	// ãƒ©ãƒ³ãƒ€ãƒ ã‚·ãƒ¼ãƒ‰
	std::mt19937 randomEngine_;

private:

	/// <summary>
	/// æ–¹å‘ã®è¨­å®šã¨å¾…æ©Ÿæ™‚é–“ã®è¨­å®š
	/// </summary>
	/// <param name="vector">è¨­å®šã™ã‚‹æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«</param>
	void PreparNextMove(const Vector3& vector);
};



============================================================
File Path: Project/application/Game/Entity/Enemy/LongRange/LongRangeEnemy.cpp
============================================================
#include "LongRangeEnemy.h"
// Player
#include "application/Game/Entity/Player/Player.h"
// Service
#include "Engine/System/Service/ParticleService.h"
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
LongRangeEnemy::~LongRangeEnemy() {
	// Bulletã®ã‚¯ãƒªã‚¢
	bulletInfo_.bullets_.clear();
}

///-------------------------------------------/// 
/// GameSceneç”¨åˆæœŸåŒ–
///-------------------------------------------///
void LongRangeEnemy::InitGameScene(const Vector3& translate) {
	// CloseRangeEnemyã®åˆæœŸåŒ–
	Initialize();
	// ä½ç½®ã®è¨­å®š
	transform_.translate = translate;
	// BaseEnemyã®åˆæœŸåŒ–
	BaseEnemy::Initialize();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void LongRangeEnemy::Initialize() {

	/// ===Object3d=== ///
	// Object3dã®åˆæœŸåŒ–
	object3d_ = std::make_unique<Object3d>();
	object3d_->Init(ObjectType::Model, "player");

	/// ===GameCharacter=== ///
	// GameCharacterã®åˆæœŸåŒ–
	GameCharacter::Initialize();
	name_ = ColliderName::Enemy;

	/// ===AttackInfoã®è¨­å®š=== ///
	attackInfo_.range = 3.0f;
	attackInfo_.distance = 30.0f;
	attackInfo_.interval = 8.0f;
	attackInfo_.timer = 1.0;
	attackInfo_.power = 1;
	attackInfo_.direction = { 0.0f, 0.0f, 0.0f };
	attackInfo_.isAttack = false;
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void LongRangeEnemy::Update() {

	// BaseEnemyã®æ›´æ–°
	BaseEnemy::Update();

	// å¼¾ã‚’æ›´æ–°ï¼ˆnull ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ï¼‰
	for (auto& bullet : bulletInfo_.bullets_) {
		if (bullet) bullet->Update();
	}

	// æ­»ã‚“ã å¼¾ã‚’ãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤
	bulletInfo_.bullets_.remove_if(
		[](const std::unique_ptr<LongRangeEnemyBullet>& b) {
			return !b || !b->GetIsAlive();
		}
	);
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void LongRangeEnemy::Draw(BlendMode mode) {
	// Enemyã®æç”»
	BaseEnemy::Draw(mode);

	// ãƒãƒ¬ãƒƒãƒˆã®æç”»
	for (auto& bullet : bulletInfo_.bullets_) {
		if (bullet) bullet->Draw(mode);
	}
}

///-------------------------------------------/// 
/// æ›´æ–°ï¼ˆImGuiï¼‰
///-------------------------------------------///
void LongRangeEnemy::Information() {
#ifdef USE_IMGUI
	ImGui::Begin("LongRangeEnemy");
	BaseEnemy::Information();
	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çªåˆ¤å®š
///-------------------------------------------///
void LongRangeEnemy::OnCollision(Collider* collider) {
	// BaseEnemyã®å½“ãŸã‚Šåˆ¤å®š
	BaseEnemy::OnCollision(collider);
}

///-------------------------------------------/// 
/// æ”»æ’ƒå‡¦ç†ã®åˆæœŸåŒ–
///-------------------------------------------///
void LongRangeEnemy::StartAttack() {
	// æ”»æ’ƒé–‹å§‹
	attackInfo_.isAttack = true;
	// æ”»æ’ƒæ™‚é–“ã®è¨­å®š
	attackInfo_.timer = 1.0f;
}

///-------------------------------------------/// 
/// æ”»æ’ƒå‡¦ç†
///-------------------------------------------///
void LongRangeEnemy::Attack() {

	// å¼¾ã®ç”Ÿæˆ
	auto bullet = std::make_unique<LongRangeEnemyBullet>();
	bullet->Create(transform_.translate, attackInfo_.direction);
	bulletInfo_.bullets_.push_back(std::move(bullet));

	// ãƒ•ãƒ©ã‚°ã‚’false
	attackInfo_.isAttack = false;
	// ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³å†è¨­å®š
	attackInfo_.timer = attackInfo_.interval; 
}

#ifdef USE_IMGUI
///-------------------------------------------/// 
/// æ´¾ç”Ÿç”¨ã®æ‹¡å¼µãƒã‚¤ãƒ³ãƒˆ
///-------------------------------------------///
void LongRangeEnemy::CopyTypeTuningFromThisTo(BaseEnemy* dst) const {
	if (auto* d = dynamic_cast<LongRangeEnemy*>(dst)) {
		d->bulletInfo_.interval = this->bulletInfo_.interval;
		d->bulletInfo_.reloadTime = this->bulletInfo_.reloadTime;
		// isShot / isHit / bullets_ ã¯ãƒ©ãƒ³ã‚¿ã‚¤ãƒ å€¤ãªã®ã§ã‚³ãƒ”ãƒ¼ã—ãªã„
	}
}
#endif // USE_IMGUI


============================================================
File Path: Project/application/Game/Entity/Enemy/LongRange/LongRangeEnemy.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Game/Entity/Enemy/Base/BaseEnemy.h"
#include "application/Game/Entity/Enemy/LongRange/LongRangeEnemyBullet.h"
#include <list>

///=====================================================/// 
/// é è·é›¢æ”»æ’ƒEnemy
///=====================================================///
class LongRangeEnemy : public BaseEnemy {
public:
	LongRangeEnemy() = default;
	~LongRangeEnemy();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†ï¼ˆGameSceneç”¨ï¼‰
	/// </summary>
	/// <param name="translate">ã‚·ãƒ¼ãƒ³ã®ä½ç½®ã‚’è¨­å®šã™ã‚‹3æ¬¡å…ƒå¹³è¡Œç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«ã¸ã®constå‚ç…§ã€‚ã‚·ãƒ¼ãƒ³ã®åˆæœŸé…ç½®ã‚„ã‚ªãƒ•ã‚»ãƒƒãƒˆã«ä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void InitGameScene(const Vector3& translate)override;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize()override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚çœç•¥ã—ãŸå ´åˆã¯ BlendMode::KBlendModeNormal ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal)override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information()override;

	/// <summary>
	/// æ”»æ’ƒå‡¦ç†ã®åˆæœŸåŒ–
	/// </summary>
	void StartAttack()override;

	/// <summary>
	/// æ”»æ’ƒå‡¦ç†
	/// </summary>
	void Attack()override;

public: /// ===è¡çªåˆ¤å®š=== ///
	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã® Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚è¡çªç›¸æ‰‹ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã—ã¾ã™ã€‚</param>
	void OnCollision(Collider* collider) override;

private: /// ===å¤‰æ•°=== ///

	/// ===Bulletæƒ…å ±=== ///
	struct BulletInfo {
		std::list<std::unique_ptr<LongRangeEnemyBullet>> bullets_;
		float interval = 0.0f;   // ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«
		float reloadTime = 3.0f; // ãƒªãƒ­ãƒ¼ãƒ‰æ™‚é–“
		bool isShot = false;	 // ç™ºå°„ãƒ•ãƒ©ã‚°
		bool isHit = false;		 // ãƒ’ãƒƒãƒˆæ™‚ã®ãƒ•ãƒ©ã‚°
	};
	BulletInfo bulletInfo_;

#ifdef USE_IMGUI
protected:
	/// <summary>
	/// æ´¾ç”Ÿå´ã§å‹å›ºæœ‰ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°å€¤ã‚’ã‚³ãƒ”ãƒ¼ã™ã‚‹ãŸã‚ã®é–¢æ•°
	/// </summary>
	/// <param name="dst">ã‚³ãƒ”ãƒ¼å…ˆã® BaseEnemy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚nullptr ã§ãªã„ã“ã¨ãŒæœŸå¾…ã•ã‚Œã¾ã™ã€‚</param>
	void CopyTypeTuningFromThisTo(BaseEnemy* dst) const override;
#endif // USE_IMGUI
};


============================================================
File Path: Project/application/Game/Entity/Enemy/LongRange/LongRangeEnemyBullet.cpp
============================================================
#include "LongRangeEnemyBullet.h"
// Service
#include "Engine/System/Service/ParticleService.h"
#include "Engine/System/Service/ColliderService.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
LongRangeEnemyBullet::~LongRangeEnemyBullet() {
	ColliderService::RemoveCollider(this);
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void LongRangeEnemyBullet::Initialize() {
	// Object3dã®åˆæœŸåŒ–
	object3d_ = std::make_unique<Object3d>();
	object3d_->Init(ObjectType::Model, "player");
	// Object3dã®åˆæœŸè¨­å®š
	object3d_->SetTranslate(transform_.translate);

	// Sphereã®è¨­å®š
	SphereCollider::Initialize();
	name_ = ColliderName::EnemyBullet;
	SphereCollider::SetRadius(0.5f);

	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã«è¿½åŠ 
	ColliderService::AddCollider(this);

	object3d_->Update();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void LongRangeEnemyBullet::Update() {
	if (isAlive_) {
		/// ===ç§»å‹•å‡¦ç†=== ///
		Move();

		/// ===ã‚¿ã‚¤ãƒãƒ¼=== ///
		PromoteTimer();

		// ä½ç½®æ›´æ–°
		transform_.translate += info_.velocity;
		
		// Particleã®ä½ç½®æ›´æ–°
		if (bulletParticle_) {
			bulletParticle_->SetEmitterPosition(transform_.translate);
		}

		// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®æ›´æ–°
		SphereCollider::Update();
	}
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void LongRangeEnemyBullet::Draw(BlendMode mode) {
	if (isAlive_) {
		SphereCollider::Draw(mode);
	}
}

///-------------------------------------------/// 
/// ç”Ÿæˆ
///-------------------------------------------///
void LongRangeEnemyBullet::Create(const Vector3& pos, const Vector3& vel) {
	// åˆæœŸåŒ–å‡¦ç†
	Initialize();
	// ä½ç½®ã¨æ–¹å‘ã®è¨­å®š
	transform_.translate = pos;
	info_.direction = vel;

	// ç”Ÿå­˜ãƒ•ãƒ©ã‚°ã‚’true
	isAlive_ = true;
	// ç”Ÿå­˜æ™‚é–“ã®è¨­å®š
	lifeTimer_ = lifeTime_;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åœæ­¢
	if (bulletParticle_) {
		bulletParticle_->Stop();
		bulletParticle_ = nullptr;
	}
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å†ç”Ÿ
	bulletParticle_ = ParticleService::Emit("LongEnemyAttack", transform_.translate);
	bulletParticle_->SetEmitterPosition(transform_.translate);
}

///-------------------------------------------///  
/// è¡çªåˆ¤å®š
///-------------------------------------------///
void LongRangeEnemyBullet::OnCollision(Collider* collider) {
	collider;
}

///-------------------------------------------/// 
/// ç§»å‹•å‡¦ç†
///-------------------------------------------///
void LongRangeEnemyBullet::Move() {
	info_.velocity = info_.direction * speed_;
}

///-------------------------------------------/// 
/// ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
///-------------------------------------------///
void LongRangeEnemyBullet::PromoteTimer() {
	// ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒãƒ¼ã®æ¸›å°‘
	lifeTimer_ -= 1.0f / 60.0f;
	if (lifeTimer_ <= 0.0f) {
		// ç”Ÿå­˜æ™‚é–“ãŒ0.0fã«ãªã£ãŸã‚‰å‰Šé™¤ã€‚
		isAlive_ = false;
	}
}

============================================================
File Path: Project/application/Game/Entity/Enemy/LongRange/LongRangeEnemyBullet.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Collider/SphereCollider.h"

/// ===å‰æ–¹å®£è¨€=== ///
class ParticleGroup;

///=====================================================/// 
/// é è·é›¢æ”»æ’ƒEnemyã®å¼¾
///=====================================================///
class LongRangeEnemyBullet : public SphereCollider{
public:

	LongRangeEnemyBullet() = default;
	~LongRangeEnemyBullet();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize()override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»æ™‚ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚çœç•¥æ™‚ã¯ BlendMode::KBlendModeNormal ãŒä½¿ã‚ã‚Œã¾ã™ã€‚</param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal)override;

	/// <summary>
	/// ç”Ÿæˆå‡¦ç†
	/// </summary>
	/// <param name="pos">ä½œæˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½ç½®ã‚’è¡¨ã™ 3 æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconst å‚ç…§ï¼‰ã€‚</param>
	/// <param name="direction">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‘ãã¾ãŸã¯é€²è¡Œæ–¹å‘ã‚’è¡¨ã™ 3 æ¬¡å…ƒãƒ™ã‚¯ãƒˆãƒ«ï¼ˆconst å‚ç…§ï¼‰ã€‚</param>
	void Create(const Vector3& pos, const Vector3& direction);

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information() override {};

public: /// ===è¡çªåˆ¤å®š=== ///
	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ã™ Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è¡çªå‡¦ç†ã«ä½¿ç”¨ã•ã‚Œã‚‹å¯¾è±¡ã‚’ç¤ºã—ã¾ã™ã€‚</param>
	void OnCollision(Collider* collider) override;

public: /// ===Getter=== ///
	// ç”Ÿå­˜ãƒ•ãƒ©ã‚°ã®å–å¾—
	bool GetIsAlive() const { return isAlive_; };

private: /// ===å¤‰æ•°=== ///

	/// ===åŸºæœ¬æƒ…å ±=== ///
	struct BaseInfo {
		Vector3 direction = { 0.0f, 0.0f, 0.0f }; // æ–¹å‘
		Vector3 velocity = { 0.0f, 0.0f, 0.0f }; // ãƒ™ã‚¯ãƒˆãƒ«
	};
	BaseInfo info_;

	// ParticleGroup
	ParticleGroup* bulletParticle_ = nullptr;

	// é€Ÿåº¦
	float speed_ = 1.5f;
	// ç”Ÿå­˜ã‚¿ã‚¤ãƒãƒ¼
	float lifeTimer_ = 0.0f;
	// ç”Ÿå­˜æ™‚é–“
	float lifeTime_ = 3.0f;
	// ç”Ÿå­˜ãƒ•ãƒ©ã‚°
	bool isAlive_ = true;

private:

	/// <summary>
	/// ç§»å‹•å‡¦ç†
	/// </summary>
	void Move();

	/// <summary>
	/// ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void PromoteTimer();
};



============================================================
File Path: Project/application/Game/Entity/Enemy/Manager/EnemyManager.cpp
============================================================
#include "EnemyManager.h"
#include "application/Game/Entity/Enemy/CloseRange/CloseRangeEnemy.h"
#include "application/Game/Entity/Enemy/LongRange/LongRangeEnemy.h"
// c++
#include <algorithm> 
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void EnemyManager::SetPlayer(Player* player) {
	player_ = player;
	for (auto& e : enemies_) {
		if (e) e->SetPlayer(player_);
	}
}

///-------------------------------------------/// 
/// ç”Ÿæˆ
///-------------------------------------------///
BaseEnemy* EnemyManager::Spawn(EnemyType type, const Vector3& pos, const Quaternion& rot, const Vector3& halfSize) {
	std::unique_ptr<BaseEnemy> enemy; // æœ€çµ‚çš„ã« enemies_ ã¸ move ã™ã‚‹å™¨

	switch (type) {
	case EnemyType::CloseRange: {
		auto e = std::make_unique<CloseRangeEnemy>();
		if (player_) { // åˆãƒ•ãƒ¬ãƒ¼ãƒ ã‹ã‚‰ Update ãŒé€²ã‚€ã‚ˆã†ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ³¨å…¥
			e->SetPlayer(player_);
		}
		// åˆæœŸåŒ–
		e->InitGameScene(pos);		// å‡ºç¾ä½ç½®ã‚’æ¸¡ã—ã¦ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ç”¨åˆæœŸåŒ–
		e->SetRotate(rot);			// å›è»¢ã‚’è¨­å®š
		e->SetHalfSize(halfSize);	// ã‚µã‚¤ã‚ºã‚’è¨­å®š
		enemy = std::move(e);		// æ‰€æœ‰æ¨©ç§»å‹•
		break;
	}
	case EnemyType::LongRange: {
		auto e = std::make_unique<LongRangeEnemy>();
		if (player_) {
			e->SetPlayer(player_);
		}
		// åˆæœŸåŒ–
		e->InitGameScene(pos);
		e->SetRotate(rot); 
		e->SetHalfSize(halfSize);
		enemy = std::move(e);
		break;
	}
	default:
		return nullptr; // æœªçŸ¥ã® enum ãªã‚‰ç”Ÿæˆã—ãªã„
	}


	BaseEnemy* raw = enemy.get(); // å‘¼ã³å‡ºã—å´ãŒç›´å¾Œã«è§¦ã‚Œã‚‹ã‚ˆã†ã«ç”Ÿãƒã‚¤ãƒ³ã‚¿ã‚’ä¿æŒ
	enemies_.push_back(std::move(enemy));
	return raw;
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void EnemyManager::Update() {
	for (auto& e : enemies_) {
		if (e) e->Update();
	}

	// æ­»äº¡ã—ãŸæ•µã‚’å‰Šé™¤
	auto it = std::remove_if(enemies_.begin(), enemies_.end(),
		[](const std::unique_ptr<BaseEnemy>& e) {
			return !e || e->GetTentativeDeath();
		});
	enemies_.erase(it, enemies_.end());
}

///-------------------------------------------/// 
/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void EnemyManager::UpdateAnimation() {
	for (auto& e : enemies_) {
		if (e) e->UpdateAnimation();
	}
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void EnemyManager::Draw(BlendMode mode) {
	for (auto& e : enemies_) {
		if (e) e->Draw(mode);
	}
}

///-------------------------------------------/// 
/// ImGui
///-------------------------------------------///
void EnemyManager::UpdateImGui() {
#ifdef USE_IMGUI

	// EnemyMangerã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦(ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’é–‰ã˜ãŸæ™‚ã«ä¸­èº«ã‚’æ›¸ã‹ãªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚)
	if (ImGui::Begin("EnemyManager")) {

		// ===== çµ±è¨ˆæƒ…å ± ===== //
		int closeCount = GetEnemyCount(EnemyType::CloseRange);
		int longCount = GetEnemyCount(EnemyType::LongRange);
		int totalCount = GetTotalEnemyCount();

		ImGui::Text("Enemy Statistics:");
		ImGui::Text("  CloseRange: %d", closeCount);
		ImGui::Text("  LongRange : %d", longCount);
		ImGui::Text("  Total     : %d", totalCount);
		ImGui::Separator();

		// ===== CloseRangeEnemy ã®èª¿æ•´ ===== //
		BaseEnemy* closeRep = GetRepresentative(EnemyType::CloseRange);
		if (closeRep) {
			ImGui::Text("CloseRange Enemy Settings:");
			closeRep->Information(); // ä»£è¡¨1ä½“ã®ImGuiã‚’è¡¨ç¤º

			if (ImGui::Button("Apply to All CloseRange")) {
				ApplySettingsToType(EnemyType::CloseRange, closeRep);
			}
			ImGui::SameLine();
			if (ImGui::Button("Apply CloseRange to ALL Enemies")) {
				ApplySettingsToAll(closeRep);
			}
		} else {
			ImGui::TextDisabled("No CloseRange enemies exist.");
		}

		ImGui::Separator();

		// ===== LongRangeEnemy ã®èª¿æ•´ ===== //
		BaseEnemy* longRep = GetRepresentative(EnemyType::LongRange);
		if (longRep) {
			ImGui::Text("LongRange Enemy Settings:");
			longRep->Information(); // ä»£è¡¨1ä½“ã®ImGuiã‚’è¡¨ç¤º

			if (ImGui::Button("Apply to All LongRange")) {
				ApplySettingsToType(EnemyType::LongRange, longRep);
			}
			ImGui::SameLine();
			if (ImGui::Button("Apply LongRange to ALL Enemies")) {
				ApplySettingsToAll(longRep);
			}
		} else {
			ImGui::TextDisabled("No LongRange enemies exist.");
		}

		ImGui::Separator();

		// ===== å…¨ä½“æ“ä½œ ===== //
		ImGui::Text("Bulk Operations:");
		if (ImGui::Button("Clear All Enemies")) {
			Clear();
		}
	}
	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// ã‚¯ãƒªã‚¢
///-------------------------------------------///
void EnemyManager::Clear() {
	enemies_.clear(); // unique_ptr ç ´æ£„ã§å„Enemyã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ãƒˆã¸
}

///-------------------------------------------/// 
/// æŒ‡å®šã‚¿ã‚¤ãƒ—ã®æ•µæ•°ã‚’å–å¾—
///-------------------------------------------///
int EnemyManager::GetEnemyCount(EnemyType type) const {
	int count = 0;
	for (const auto& e : enemies_) {
		if (!e) continue;

		if (GetEnemyType(e.get()) == type) {
			count++;
		}
	}
	return count;
}

///-------------------------------------------/// 
/// å…¨æ•µæ•°ã‚’å–å¾—
///-------------------------------------------///
int EnemyManager::GetTotalEnemyCount() const {
	int count = 0;
	for (const auto& e : enemies_) {
		if (e) count++;
	}
	return count;
}

///-------------------------------------------/// 
/// ã‚¿ã‚¤ãƒ—åˆ¤å®š
///-------------------------------------------///
EnemyType EnemyManager::GetEnemyType(BaseEnemy* enemy) const {
	if (dynamic_cast<CloseRangeEnemy*>(enemy)) {
		return EnemyType::CloseRange;
	} else if (dynamic_cast<LongRangeEnemy*>(enemy)) {
		return EnemyType::LongRange;
	}
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆæœ¬æ¥ã“ã“ã¯é€šã‚‰ãªã„æƒ³å®šï¼‰
	return EnemyType::CloseRange;
}

#ifdef USE_IMGUI
//-------------------------------------------/// 
/// æŒ‡å®šã‚¿ã‚¤ãƒ—ã®å…¨æ•µã«è¨­å®šã‚’ã‚³ãƒ”ãƒ¼
///-------------------------------------------///
void EnemyManager::ApplySettingsToType(EnemyType type, const BaseEnemy* sourceEnemy) {
	if (!sourceEnemy) return;

	for (auto& e : enemies_) {
		if (!e) continue;

		// åŒã˜ã‚¿ã‚¤ãƒ—ã‹ãƒã‚§ãƒƒã‚¯
		if (GetEnemyType(e.get()) == type) {
			// ã‚½ãƒ¼ã‚¹ã¨åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é™¤å¤–
			if (e.get() != sourceEnemy) {
				sourceEnemy->CopyTuningTo(e.get());
			}
		}
	}
}

///-------------------------------------------/// 
/// å…¨æ•µã«è¨­å®šã‚’ã‚³ãƒ”ãƒ¼
///-------------------------------------------///
void EnemyManager::ApplySettingsToAll(const BaseEnemy* sourceEnemy) {
	if (!sourceEnemy) return;

	for (auto& e : enemies_) {
		if (!e) continue;

		// ã‚½ãƒ¼ã‚¹ã¨åŒã˜ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯é™¤å¤–
		if (e.get() != sourceEnemy) {
			sourceEnemy->CopyTuningTo(e.get());
		}
	}
}

///-------------------------------------------/// 
/// æŒ‡å®šã‚¿ã‚¤ãƒ—ã®ä»£è¡¨æ•µã‚’å–å¾—
///-------------------------------------------///
BaseEnemy* EnemyManager::GetRepresentative(EnemyType type) {
	for (auto& e : enemies_) {
		if (!e) continue;

		if (GetEnemyType(e.get()) == type) {
			return e.get();
		}
	}
	return nullptr;
}
#endif // USE_IMGUI



============================================================
File Path: Project/application/Game/Entity/Enemy/Manager/EnemyManager.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Game/Entity/Enemy/Base/BaseEnemy.h"
#include <memory>
#include <vector>

// å‰æ–¹å®£è¨€
class Player;

/// ===enum=== ///
enum class EnemyType {
    CloseRange,
    LongRange
};

///=====================================================/// 
/// EnemyManager
///=====================================================///
class EnemyManager {
public:
    EnemyManager() = default;
    ~EnemyManager() = default;

    /// <summary>
    /// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¨­å®š
    /// </summary>
    /// <param name="player">è¨­å®šã™ã‚‹ Player ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    void SetPlayer(Player* player);

    /// <summary>
    /// æŒ‡å®šã—ãŸã‚¿ã‚¤ãƒ—ãƒ»ä½ç½®ãƒ»å›è»¢ã§æ•µã‚’ç”Ÿæˆã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="type">ç”Ÿæˆã™ã‚‹æ•µã®ç¨®é¡ã€‚EnemyType å‹ã€‚</param>
    /// <param name="pos">ç”Ÿæˆä½ç½®ã€‚Vector3 ã® const ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã€‚</param>
    /// <param name="rot">ç”Ÿæˆæ™‚ã®å›è»¢ã€‚Quaternion ã® const ãƒªãƒ•ã‚¡ãƒ¬ãƒ³ã‚¹ã€‚</param>
    /// <returns>ç”Ÿæˆã•ã‚ŒãŸæ•µã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ (BaseEnemy*)ã€‚</returns>
    BaseEnemy* Spawn(EnemyType type, const Vector3& pos, const Quaternion& rot, const Vector3& halfSize);

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();

	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateAnimation();

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    /// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚çœç•¥ã—ãŸå ´åˆã¯ BlendMode::KBlendModeNormal ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
    void Draw(BlendMode mode = BlendMode::KBlendModeNormal);

    /// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
    /// </summary>
    void UpdateImGui();

    /// <summary>
    /// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å†…éƒ¨çŠ¶æ…‹ã‚„ä¿æŒã—ã¦ã„ã‚‹ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢
    /// </summary>
    void Clear();

public: /// ===Getter=== ///
    
    // æŒ‡å®šã‚¿ã‚¤ãƒ—ã®æ•µæ•°ã‚’å–å¾—
    int GetEnemyCount(EnemyType type) const;
    // å…¨æ•µæ•°ã‚’å–å¾—
    int GetTotalEnemyCount() const;

private:
    // Player
    Player* player_ = nullptr;

	// BaseEnemyã®é…åˆ—
    std::vector<std::unique_ptr<BaseEnemy>> enemies_;

    // ã‚¿ã‚¤ãƒ—åˆ¤å®š
    EnemyType GetEnemyType(BaseEnemy* enemy) const;

#ifdef USE_IMGUI
private:

    /// <summary>
    /// æŒ‡å®šã—ãŸæ•µã®ç¨®é¡ã«ã‚½ãƒ¼ã‚¹æ•µã®è¨­å®šã‚’é©ç”¨
    /// </summary>
    /// <param name="type">è¨­å®šã‚’é©ç”¨ã™ã‚‹å¯¾è±¡ã®æ•µã®ç¨®é¡ã‚’è¡¨ã™å€¤ã€‚</param>
    /// <param name="sourceEnemy">è¨­å®šã‚’å–å¾—ã™ã‚‹å…ƒã¨ãªã‚‹æ•µã‚’æŒ‡ã™ const ãƒã‚¤ãƒ³ã‚¿ï¼ˆã“ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰è¨­å®šãŒã‚³ãƒ”ãƒ¼ã•ã‚Œã¾ã™ï¼‰ã€‚</param>
    void ApplySettingsToType(EnemyType type, const BaseEnemy* sourceEnemy);

    /// <summary>
    /// ç¾å­˜ã™ã‚‹å…¨ã¦ã®æ•µã«ã‚½ãƒ¼ã‚¹æ•µã®è¨­å®šã‚’é©ç”¨
    /// </summary>
    /// <param name="sourceEnemy">è¨­å®šã‚’å–å¾—ã™ã‚‹å…ƒã¨ãªã‚‹æ•µã‚’æŒ‡ã™ const ãƒã‚¤ãƒ³ã‚¿</param>
    void ApplySettingsToAll(const BaseEnemy* sourceEnemy);

    /// <summary>
    /// æŒ‡å®šã—ãŸæ•µã‚¿ã‚¤ãƒ—ã«å¯¾å¿œã™ã‚‹ä»£è¡¨çš„ãª BaseEnemy ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã‚’å–å¾—ã—ã¾ã™ã€‚
    /// </summary>
    /// <param name="type">å–å¾—ã—ãŸã„æ•µã®ç¨®é¡ã‚’è¡¨ã™ EnemyType å€¤ã€‚</param>
    /// <returns>æŒ‡å®šã—ãŸã‚¿ã‚¤ãƒ—ã«å¯¾å¿œã™ã‚‹ BaseEnemy ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è©²å½“ã™ã‚‹æ•µãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ nullptr ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚</returns>
    BaseEnemy* GetRepresentative(EnemyType type);

public:
    // === ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆé–¢æ•°ã®å®Ÿè£… === //
    /// <summary>
    /// æŒ‡å®šã—ãŸæ•µã‚¿ã‚¤ãƒ—ã®ä»£è¡¨çš„ãªæ•µã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¯¾ã—ã¦èª¿æ•´é–¢æ•°ã‚’å®Ÿè¡Œã—ã€ãã®å¤‰æ›´ã‚’åŒã‚¿ã‚¤ãƒ—å…¨ä½“ã«åæ˜ ã—ã¾ã™ã€‚
    /// </summary>
    /// <typeparam name="Func">ä»£è¡¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ï¼ˆBaseEnemy*ï¼‰ã‚’å—ã‘å–ã£ã¦è¨­å®šã‚’å¤‰æ›´ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½å‹ã€‚æˆ»ã‚Šå€¤ã¯é€šå¸¸ä¸è¦ï¼ˆvoid ã§ã‚‚å¯ï¼‰ã€‚</typeparam>
    /// <param name="type">æ“ä½œå¯¾è±¡ã®æ•µã‚¿ã‚¤ãƒ—ã€‚GetRepresentativeã‚’ä½¿ã£ã¦ä»£è¡¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãŒå–å¾—ã•ã‚Œã¾ã™ã€‚</param>
    /// <param name="adjustFunction">ä»£è¡¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’å—ã‘å–ã£ã¦è¨­å®šã‚’å¤‰æ›´ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆä¾‹: ãƒ©ãƒ ãƒ€ã‚„é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰ã€‚</param>
    template<typename Func>
    void ModifyAndApplyToType(EnemyType type, Func adjustFunction) {
        BaseEnemy* representative = GetRepresentative(type);
        if (representative) {
            // èª¿æ•´é–¢æ•°ã‚’å®Ÿè¡Œ
            adjustFunction(representative);
            // åŒã‚¿ã‚¤ãƒ—å…¨ä½“ã«é©ç”¨
            ApplySettingsToType(type, representative);
        }
    }

    /// <summary>
    /// æŒ‡å®šã—ãŸæ•µã‚¿ã‚¤ãƒ—ã®ä»£è¡¨å€‹ä½“ã«å¯¾ã—ã¦èª¿æ•´é–¢æ•°ã‚’å®Ÿè¡Œã—ã€ãã®è¨­å®šã‚’å…¨ã¦ã®æ•µã«é©ç”¨ã™ã‚‹ã€‚ä»£è¡¨ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„ã€‚
    /// </summary>
    /// <typeparam name="Func">ä»£è¡¨å€‹ä½“ã‚’å¼•æ•°ã«å–ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ãªå‹ï¼ˆä¾‹: void(BaseEnemy*)ï¼‰ã€‚ä»£è¡¨ã«å¯¾ã™ã‚‹å¤‰æ›´ãƒ»èª¿æ•´ã‚’è¡Œã†ãŸã‚ã®å‹ã€‚</typeparam>
    /// <param name="sourceType">è¨­å®šã®åŸºæº–ã¨ãªã‚‹æ•µã‚¿ã‚¤ãƒ—ã€‚ä»£è¡¨å€‹ä½“ãŒã“ã®ã‚¿ã‚¤ãƒ—ã‹ã‚‰å–å¾—ã•ã‚Œã‚‹ã€‚</param>
    /// <param name="adjustFunction">ä»£è¡¨å€‹ä½“ï¼ˆBaseEnemy*ï¼‰ã‚’å—ã‘å–ã‚Šã€ãã®è¨­å®šã‚’å¤‰æ›´ã™ã‚‹å‘¼ã³å‡ºã—å¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆé–¢æ•°ã€é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã€ãƒ©ãƒ ãƒ€ãªã©ï¼‰ã€‚æˆ»ã‚Šå€¤ã¯ç„¡è¦–ã•ã‚Œã‚‹ã€‚</param>
    template<typename Func>
    void ModifyAndApplyToAll(EnemyType sourceType, Func adjustFunction) {
        BaseEnemy* representative = GetRepresentative(sourceType);
        if (representative) {
            // èª¿æ•´é–¢æ•°ã‚’å®Ÿè¡Œ
            adjustFunction(representative);
            // å…¨æ•µã«é©ç”¨
            ApplySettingsToAll(representative);
        }
    }
#endif // USE_IMGUI
};

============================================================
File Path: Project/application/Game/Entity/Enemy/State/Base/EnemyState.cpp
============================================================
#include "EnemyState.h"

///-------------------------------------------/// 
/// çµ‚äº†å‡¦ç†
///-------------------------------------------///
void EnemyState::Finalize() {
	enemy_ = nullptr;
}


============================================================
File Path: Project/application/Game/Entity/Enemy/State/Base/EnemyState.h
============================================================
#pragma once
/// ===å‰æ–¹å®£è¨€=== ///
class BaseEnemy;

///=====================================================/// 
/// ã‚¨ãƒãƒŸãƒ¼ã®ãƒ™ãƒ¼ã‚¹ã‚¹ãƒ†ãƒ¼ãƒˆ
///=====================================================///
class EnemyState {
public:
	virtual ~EnemyState() = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="enemy">å‡¦ç†å¯¾è±¡ã® BaseEnemy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ã‚¹ãƒ†ãƒ¼ãƒˆã¸å…¥ã‚‹å¯¾è±¡ã¨ãªã‚‹æ•µã‚’æŒ‡ã™</param>
	virtual void Enter(BaseEnemy* enemy) = 0;

	/// <summary>
	/// æ›´æ–°å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="enemy">æ›´æ–°å¯¾è±¡ã® BaseEnemy å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	virtual void Update(BaseEnemy* enemy) = 0;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	virtual void Finalize();

protected:

	BaseEnemy* enemy_ = nullptr;
};



============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyAttackState.cpp
============================================================
#include "EnemyAttackState.h"
// BaseEnemy
#include "application/Game/Entity/Enemy/Base/BaseEnemy.h"
#include "application/Game/Entity/Enemy/LongRange/LongRangeEnemy.h"
// Service
#include "Engine/System/Service/ParticleService.h"
// State
#include "EnemyMoveState.h"


///-------------------------------------------/// 
/// é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void EnemyAttackState::Enter(BaseEnemy* enemy) {
	enemy_ = enemy;
	// ç§»å‹•é‡ã‚’åˆæœŸåŒ–
	enemy_->SetVelocity({ 0.0f, 0.0f, 0.0f });
	// è‰²ã®è¨­å®š
	enemy_->SetColor({ 0.0f, 1.0f, 0.0f, 1.0f });
	// æ”»æ’ƒé–‹å§‹å‡¦ç†
	enemy_->StartAttack();
}

///-------------------------------------------/// 
/// æ›´æ–°æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void EnemyAttackState::Update(BaseEnemy * enemy) {
	enemy_ = enemy;

	// Attackã®å‡¦ç†
	enemy_->Attack();

	/// ===Stateã®å¤‰æ›´=== ///
	if (!enemy_->GetAttackInfo().isAttack) {
		// è‰²ã®è¨­å®š
		enemy_->SetColor({ 1.0f, 0.0f, 1.0f, 1.0f }); // å…ƒã®è‰²ã«æˆ»ã™
		// MoveStateã«ç§»è¡Œ
		enemy_->ChangeState(std::make_unique<EnemyMoveState>());
		return;
	}
}

///-------------------------------------------/// 
/// çµ‚äº†æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void EnemyAttackState::Finalize() {
	EnemyState::Finalize();
}


============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyAttackState.h
============================================================
#pragma once
/// ===Include=== ///
#include "Base/EnemyState.h"

///=====================================================/// 
/// MoveState
///=====================================================///
class EnemyAttackState : public EnemyState {
public:

	~EnemyAttackState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="enemy">å‡¦ç†å¯¾è±¡ã® BaseEnemy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ã‚¹ãƒ†ãƒ¼ãƒˆã¸å…¥ã‚‹å¯¾è±¡ã¨ãªã‚‹æ•µã‚’æŒ‡ã™</param>
	void Enter(BaseEnemy* enemy) override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="enemy">æ›´æ–°å¯¾è±¡ã® BaseEnemy å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(BaseEnemy* enemy) override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;
};



============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyHitReactionState.cpp
============================================================
#include "EnemyHitReactionState.h"
// BaseEnemy
#include "application/Game/Entity/Enemy/Base/BaseEnemy.h"
// State
#include "EnemyMoveState.h"

///-------------------------------------------/// 
/// é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void EnemyHitReactionState::Enter(BaseEnemy* enemy) {
	enemy_ = enemy;
}

///-------------------------------------------/// 
/// æ›´æ–°æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void EnemyHitReactionState::Update(BaseEnemy* enemy) {
	enemy_ = enemy;

	/// ===HitReactionComponentã®æ›´æ–°=== ///
	// æ›´æ–°ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ä½œæˆ
	EnemyHitReactionComponent::UpdateContext hitContext{
		.currentPosition = enemy_->GetTransform().translate,
		.currentVelocity = enemy_->GetVelocity(),
		.currentColor = enemy_->GetColor(),
		.deltaTime = enemy_->GetDeltaTime()
	};

	// ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æ›´æ–°
	auto result = enemy_->GetHitReactionComponent().Update(hitContext);

	// çµæœã®åæ˜ 
	enemy_->SetVelocity(result.velocity);
	enemy_->SetColor(result.color);

	/// ===ãƒ’ãƒƒãƒˆãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒçµ‚äº†ã—ãŸã‚‰MoveStateã¸é·ç§»=== ///
	float slowdownTimer = enemy_->GetHitReactionComponent().GetKnockBackState().slowdownTimer;
	float colorTimer = enemy_->GetHitReactionComponent().GetColorState().colorTimer;
	if (slowdownTimer <= 0.0f && colorTimer <= 0.0f) {
		enemy_->ChangeState(std::make_unique<EnemyMoveState>());
	}
}

///-------------------------------------------/// 
/// çµ‚äº†æ™‚ã«å‘¼ã³ã ã™
///-------------------------------------------///
void EnemyHitReactionState::Finalize() {
	EnemyState::Finalize();
}


============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyHitReactionState.h
============================================================
#pragma once
/// ===Include=== ///
#include "Base/EnemyState.h"

///-------------------------------------------/// 
/// EnemyHitReactionState
///-------------------------------------------///
class EnemyHitReactionState : public EnemyState {
public:

	~EnemyHitReactionState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="enemy">å‡¦ç†å¯¾è±¡ã® BaseEnemy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ã‚¹ãƒ†ãƒ¼ãƒˆã¸å…¥ã‚‹å¯¾è±¡ã¨ãªã‚‹æ•µã‚’æŒ‡ã™</param>
	void Enter(BaseEnemy* enemy) override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="enemy">æ›´æ–°å¯¾è±¡ã® BaseEnemy å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(BaseEnemy* enemy) override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;
};



============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyMoveState.cpp
============================================================
#include "EnemyMoveState.h"
// BaseEnemy
#include "application/Game/Entity/Enemy/Base/BaseEnemy.h"
// State
#include "EnemyPrePareAttackState.h"


///-------------------------------------------/// 
/// é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void EnemyMoveState::Enter(BaseEnemy* enemy) {
	enemy_ = enemy;
	// ç§»å‹•ç¯„å›²ã®ä¸­å¿ƒã‚’è¨­å®š
	enemy_->SetVelocity({ 0.0f, 0.0f, 0.0f });
    // ç§»å‹•é–‹å§‹å‡¦ç†
    enemy_->GetMovementComponent().StartMove(enemy_->GetTransform().translate);
}

///-------------------------------------------/// 
/// æ›´æ–°æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void EnemyMoveState::Update(BaseEnemy * enemy) {
	enemy_ = enemy;

    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®æº–å‚™
    EnemyMoveComponent::UpdateContext context{
        .currentPosition = enemy_->GetTransform().translate,
        .deltaTime = enemy_->GetDeltaTime(),
        .isRotationComplete = enemy_->GetIsRotationComplete()
    };
    // ç§»å‹•ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æ›´æ–°
    auto result = enemy_->GetMovementComponent().Update(context);

    // çµæœã®é©ç”¨
    enemy_->SetVelocity(result.velocity);

	// å›è»¢ã®æ›´æ–°
    if (result.needsRotation) {
        float rotationSpeed = enemy_->GetMovementComponent().GetConfig().rotationSpeed;
        enemy_->UpdateRotationTowards(result.targetDirection, rotationSpeed);
    }

	// å›è»¢å®Œäº†ãƒ•ãƒ©ã‚°ã®ãƒªã‚»ãƒƒãƒˆ
    if (result.shouldResetRotationFlag) {
        enemy_->SetIsRotationComplete(false);
    }

	/// ===Stateã®å¤‰æ›´=== ///
	if (enemy_->CheckAttackable() && enemy_->GetAttackInfo().timer <= 0.0f && !enemy_->GetAttackInfo().isAttack) {
		// Attackã«
		enemy_->ChangeState(std::make_unique<EnemyPrePareAttackState>());
	}
}

///-------------------------------------------/// 
/// çµ‚äº†æ™‚ã«å‘¼ã³ã ã™
///-------------------------------------------///
void EnemyMoveState::Finalize() {
	EnemyState::Finalize();
}

============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyMoveState.h
============================================================
#pragma once
/// ===Include=== ///
#include "Base/EnemyState.h"
// Math
#include "Math/Vector3.h"

///=====================================================/// 
/// MoveState
///=====================================================///
class EnemyMoveState : public EnemyState {
public:

	~EnemyMoveState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="enemy">å‡¦ç†å¯¾è±¡ã® BaseEnemy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ã‚¹ãƒ†ãƒ¼ãƒˆã¸å…¥ã‚‹å¯¾è±¡ã¨ãªã‚‹æ•µã‚’æŒ‡ã™</param>
	void Enter(BaseEnemy* enemy) override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="enemy">æ›´æ–°å¯¾è±¡ã® BaseEnemy å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(BaseEnemy* enemy) override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;
};



============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyPrePareAttackState.cpp
============================================================
#include "EnemyPrePareAttackState.h"
// BaseEnemy
#include "application/Game/Entity/Enemy/Base/BaseEnemy.h"
// Player
#include "application/Game/Entity/Player/Player.h"
// Service
#include "Engine/System/Service/ParticleService.h"
// State
#include "EnemyAttackState.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"

///-------------------------------------------/// 
/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
///-------------------------------------------///
void EnemyPrePareAttackState::Enter(BaseEnemy* enemy) {
	enemy_ = enemy;
	// ç§»å‹•é‡ã‚’åˆæœŸåŒ–
	enemy_->SetVelocity({ 0.0f, 0.0f, 0.0f });
	// è‰²ã®è¨­å®š
	enemy_->SetColor({ 0.0f, 0.0f, 1.0f, 1.0f });
	// å®Ÿè¡Œæ™‚é–“ã®è¨­å®š
	activeTimer_ = activeTime;
	// å‘ãã®åˆæœŸåŒ–
	attackDirection_ = { 0.0f, 0.0f, 0.0f };
	playerPos_ = { 0.0f, 0.0f, 0.0f };
	// ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
	enemy_->SetIsRotationComplete(false);
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å†ç”Ÿ
	activeParticle_ = ParticleService::Emit("EnemyPrePareAttack", enemy_->GetTransform().translate);
	prePareAttackParticle_ = ParticleService::Emit("EnemyPrePareAttackCharge", enemy_->GetTransform().translate);
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
void EnemyPrePareAttackState::Update(BaseEnemy* enemy) {
	enemy_ = enemy;

	// ã‚¿ã‚¤ãƒãƒ¼ãŒæ®‹ã£ã¦ã„ã‚‹å ´åˆ
	if (activeTimer_ > 0.0f) {
		// ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°
		activeTimer_ -= enemy_->GetDeltaTime();

		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
		playerPos_ = enemy_->GetPlayer()->GetTransform().translate; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’å–å¾—
		Vector3 dir = playerPos_ - enemy_->GetTransform().translate;
		attackDirection_ = Normalize(dir); // æ­£è¦åŒ–ã—ã¦æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’å¾—ã‚‹

	} else { // ã‚¿ã‚¤ãƒãƒ¼ãŒçµ‚äº†ã—ãŸå ´åˆ

		/// ===Stateã®å¤‰æ›´=== ///
		if (enemy_->GetIsRotationComplete()) {
			// Particleã®åœæ­¢
			activeParticle_->Stop();
			activeParticle_ = nullptr;
			prePareAttackParticle_->Stop();
			prePareAttackParticle_ = nullptr;
			// å›è»¢å®Œäº†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
			enemy_->SetIsRotationComplete(false);
			// æ”»æ’ƒæ–¹å‘ã‚’è¨­å®š
			enemy_->SetAttackDirection(attackDirection_);
			// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã‚’è¨­å®š
			enemy_->SetTargetPos(playerPos_);
			// AttackStateã«ç§»è¡Œ
			enemy_->ChangeState(std::make_unique<EnemyAttackState>());
			return;
		}
	}

	//NOTE:å¾Œã«ã®ã‘ãã‚ŠãªãŒã‚‰å›è»¢ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´äºˆå®š,Particleã‚‚è¿½åŠ äºˆå®š

	// å›è»¢ã®æ›´æ–°
	enemy_->UpdateRotationTowards(attackDirection_, rotationSpeed_);

	// å°‘ã—å‚¾ã‘ã‚‹
	Quaternion enemyRot = Math::MakeRotateAxisAngle(Math::Cross(attackDirection_, { 0.0f, 1.0f, 0.0f }), 0.05f);
	enemy_->SetRotate(enemyRot * enemy_->GetTransform().rotate);
}

///-------------------------------------------/// 
/// çµ‚äº†å‡¦ç†
///-------------------------------------------///
void EnemyPrePareAttackState::Finalize() {
	EnemyState::Finalize();
	if (activeParticle_) {
		activeParticle_->Stop();
		activeParticle_ = nullptr;
	}

	if (prePareAttackParticle_) {
		prePareAttackParticle_->Stop();
		prePareAttackParticle_ = nullptr;
	}
}


============================================================
File Path: Project/application/Game/Entity/Enemy/State/EnemyPrePareAttackState.h
============================================================
#pragma once
/// ===Include=== ///
#include "Base/EnemyState.h"
#include "Math/Vector3.h"

class ParticleGroup;

///-------------------------------------------/// 
/// PrePareAttackState
///-------------------------------------------///
class EnemyPrePareAttackState : public EnemyState {
public:

	~EnemyPrePareAttackState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="enemy">å‡¦ç†å¯¾è±¡ã® BaseEnemy ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚ã‚¹ãƒ†ãƒ¼ãƒˆã¸å…¥ã‚‹å¯¾è±¡ã¨ãªã‚‹æ•µã‚’æŒ‡ã™</param>
	void Enter(BaseEnemy* enemy) override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="enemy">æ›´æ–°å¯¾è±¡ã® BaseEnemy å‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(BaseEnemy* enemy) override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;

private:
	ParticleGroup* activeParticle_ = nullptr;
	ParticleGroup* prePareAttackParticle_ = nullptr;

	/// ===ã‚¿ã‚¤ãƒãƒ¼=== ///
	float activeTimer_ = 0.0f;	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¿ã‚¤ãƒãƒ¼
	float activeTime = 1.6f;	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚é–“

	/// ===æ”»æ’ƒæ–¹å‘é–¢é€£=== /
	Vector3 attackDirection_ = { 0.0f, 0.0f, 0.0f }; // æ”»æ’ƒæ–¹å‘
	Vector3 playerPos_ = { 0.0f, 0.0f, 0.0f }; 		 // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
	
	// å›è»¢é€Ÿåº¦
	float rotationSpeed_ = 0.2f;
};



============================================================
File Path: Project/application/Game/Entity/GameCharacter/GameCharacter.cpp
============================================================
#include "GameCharacter.h"
// DeltaTime
#include "Engine/System/Service/DeltaTimeSevice.h"
#include "Engine/Collider/AABBCollider.h"
// C++
#include <algorithm>
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

/// ===ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå€™è£œ=== ///
template class GameCharacter<OBBCollider>;
template class GameCharacter<SphereCollider>;

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
GameCharacter<TCollider>::~GameCharacter() {
	this->object3d_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameCharacter<TCollider>::Initialize() {
	/// ===ColliderCollision=== ///
	collision_ = std::make_unique<ColliderCollision>();
	gCollision_ = std::make_unique<GameCharacterCollision>();

	/// ===BaseInfoã®åˆæœŸåŒ–è¨­å®š=== ///
	baseInfo_.velocity = { 0.0f, 0.0f, 0.0f };
	baseInfo_.deltaTime = DeltaTimeSevice::GetDeltaTime();
	baseInfo_.gravity = -9.8f;
	baseInfo_.isDead = false;

	/// ===GroundInfo=== ///
	groundInfo_.isGrounded = false;

	/// ===TCollider=== ///
	TCollider::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameCharacter<TCollider>::Update() {

	/// ===æ­»äº¡å‡¦ç†=== ///
	if (baseInfo_.HP <= 0 || this->transform_.translate.y < -50.0f) {
		baseInfo_.isDead = true;
	}

	/// ===ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ã®å–å¾—=== ///
	baseInfo_.deltaTime = DeltaTimeSevice::GetDeltaTime();

	/// ===ä½ç½®ã®æ›´æ–°=== ///
	this->transform_.translate += baseInfo_.velocity;

	/// ===åœ°é¢ã¨ã®è¡çªå‡¦ç†=== ///
	GroundCollision();

	/// ===TCollider=== ///
	TCollider::Update();

	/// ===ãƒ•ãƒ©ã‚°ã®ãƒªã‚»ãƒƒãƒˆ=== ///
	if (this->transform_.translate.y > groundInfo_.currentGroundYPos) {
		groundInfo_.isGrounded = false;
	}
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameCharacter<TCollider>::Draw(BlendMode mode) {
	/// ===TCollider=== ///
	TCollider::Draw(mode);
}

///-------------------------------------------/// 
/// ImGui
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameCharacter<TCollider>::Information() {
#ifdef USE_IMGUI
	TCollider::Information();
	ImGui::Text("ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±");
	ImGui::DragFloat("ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ ", &baseInfo_.deltaTime, 0.01f, 0.0f, 1.0f);
	ImGui::DragFloat3("é€Ÿåº¦", &baseInfo_.velocity.x, 0.1f);
	ImGui::DragFloat("é‡åŠ›", &baseInfo_.gravity, 0.1f, -20.0f, 0.0f);
	ImGui::Checkbox("æ­»äº¡ãƒ•ãƒ©ã‚°", &baseInfo_.isDead);
	ImGui::Checkbox("æ¥åœ°ãƒ•ãƒ©ã‚°", &groundInfo_.isGrounded);
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çª
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameCharacter<TCollider>::OnCollision(Collider* collider) {
	// === æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³ === //
	if (!collider) return;

	/// ===Colliderã¨ã®è¡çªå‡¦ç†=== ///
	if (collider->GetColliderName() == ColliderName::Ground) {

		// isGroundãŒfalseã®å ´åˆã®ã¿å‡¦ç†ã‚’å®Ÿè¡Œ
		if (!groundInfo_.isGrounded) {
			
			// åœ°é¢ã«æ¥åœ°
			groundInfo_.isGrounded = true;

			// åœ°é¢ã«è¡çªã—ãŸéš›ã®å‡¦ç†
			GroundOnCollision(collider);
		}

	} else if (collider->GetColliderName() == ColliderName::Object) {
		// Objectã¨ã®è¡çªå‡¦ç†
		//NOTE:thisã‚’100%æŠ¼ã—æˆ»ã—
		collision_->ProcessCollision(this, collider, 0.0f);

	} else if (auto otherCharacter = dynamic_cast<GameCharacter<TCollider>*>(collider)) { //ã€€ã“ã‚Œã ã¨å½“ãŸã‚Šåˆ¤å®šãŒé€šã£ãŸæ™‚ã«å…¨ã¦é€šã£ã¦ã—ã¾ã†ã€‚

		// GameCharacterã®å ´åˆã®è¡çªå‡¦ç†
		//NOTE: OBBã ã‘ã©Sphereã®æŠ¼ã—æˆ»ã—ã¨åŒã˜å‡¦ç†
		gCollision_->ProcessCollision(this, otherCharacter, 0.0f);
	}
}

///-------------------------------------------/// 
/// åœ°é¢ã¨ã®è¡çªå‡¦ç†
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameCharacter<TCollider>::GroundCollision() {

	/// ===åœ°é¢ã‹ã‚‰é›¢ã‚Œã¦ã„ã‚‹å ´åˆã®å‡¦ç†=== ///
	if (!groundInfo_.isGrounded) {
		// é‡åŠ›ã®é©ç”¨
		baseInfo_.velocity.y += baseInfo_.gravity * baseInfo_.deltaTime;

		// Yæ–¹å‘ã®é€Ÿåº¦ã®æœ€å¤§å€¤ã‚’åˆ¶é™
		const float kMaxFullSpeed = -10.0f;
		// ä¸‹æ–¹å‘ã¸ã®é€Ÿåº¦ã‚’åˆ¶é™
		baseInfo_.velocity.y = std::clamp(baseInfo_.velocity.y, kMaxFullSpeed, 0.0f);

		// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
		return;
	}

	/// ===åœ°é¢ã‚ˆã‚Šä¸‹ã«è¡Œã‹ãªã„ã‚ˆã†ã«ã™ã‚‹=== ///
	if (this->transform_.translate.y < groundInfo_.currentGroundYPos) {

		// ã¯ã¿å‡ºã—åˆ†ã‚’è¨ˆç®—
		//float overlap = groundInfo_.currentGroundYPos - this->transform_.translate.y;

		// ã¯ã¿å‡ºã—åˆ†ã‚’æŠ¼ã—æˆ»ã™
		this->transform_.translate.y = groundInfo_.currentGroundYPos;

		// ä¸‹é™ä¸­ãªã‚‰é€Ÿåº¦ã‚’0ã«ã™ã‚‹
		if (baseInfo_.velocity.y < 0.0f) {
			baseInfo_.velocity.y = 0.0f;
		}
	}

	/// ===åœ°é¢ã®ç¯„å›²ã‚’å‡ºãŸã‹ãƒã‚§ãƒƒã‚¯=== ///
	bool isOutOfRange = false;

	if (groundInfo_.currentGroundType == ColliderType::AABB) {
		// minï½maxã®ç¯„å›²
		float minX = groundInfo_.currentGroundFirst.x;
		float maxX = groundInfo_.currentGroundSecond.x;
		float minZ = groundInfo_.currentGroundFirst.z;
		float maxZ = groundInfo_.currentGroundSecond.z;

		isOutOfRange = (this->transform_.translate.x > maxX || this->transform_.translate.x < minX ||
			this->transform_.translate.z > maxZ || this->transform_.translate.z < minZ);

	} else if (groundInfo_.currentGroundType == ColliderType::OBB) {
		// center +- halfSize
		float centerX = groundInfo_.currentGroundFirst.x;
		float halfSizeX = groundInfo_.currentGroundSecond.x;
		float centerZ = groundInfo_.currentGroundFirst.z;
		float halfSizeZ = groundInfo_.currentGroundSecond.z;

		isOutOfRange = (this->transform_.translate.x > centerX + halfSizeX || this->transform_.translate.x < centerX - halfSizeX ||
			this->transform_.translate.z > centerZ + halfSizeZ || this->transform_.translate.z < centerZ - halfSizeZ);
	}

	// åœ°é¢ã®ç¯„å›²ã‹ã‚‰å‡ºãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
	if (isOutOfRange) {
		groundInfo_.isGrounded = false;
	}
}

///-------------------------------------------/// 
/// åœ°é¢ã«è¡çªã—ãŸéš›ã®å‡¦ç†
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameCharacter<TCollider>::GroundOnCollision(Collider* collider) {

	// ã‚¿ã‚¤ãƒ—ã®å–å¾—
	groundInfo_.currentGroundType = collider->GetColliderType();

	/// ===ã‚¿ã‚¤ãƒ—åˆ¥ã®åœ°é¢æƒ…å ±ã®å–å¾—=== ///
	if (groundInfo_.currentGroundType == ColliderType::AABB) { // AABBã®å ´åˆ
		AABBCollider* aabbCollider = dynamic_cast<AABBCollider*>(collider);
		if (aabbCollider) {
			AABB groundAABB = aabbCollider->GetAABB();
			// åœ°é¢ã®æƒ…å ±ã‚’ä¿å­˜(Min, Max)
			groundInfo_.currentGroundFirst = groundAABB.min;
			groundInfo_.currentGroundSecond = groundAABB.max;
		}
	} else if (groundInfo_.currentGroundType == ColliderType::OBB) { // OBBã®å ´åˆ
		OBBCollider* obbCollider = dynamic_cast<OBBCollider*>(collider);
		if (obbCollider) {
			OBB groundOBB = obbCollider->GetOBB();
			// åœ°é¢ã®æƒ…å ±ã‚’ä¿å­˜(Center, HalfSize)
			groundInfo_.currentGroundFirst = groundOBB.center;
			groundInfo_.currentGroundSecond = groundOBB.halfSize;
		}
	}

	/// ===GameCharacterã®æƒ…å ±ã‚’å–å¾—=== ///
	if (this->GetColliderType() == ColliderType::OBB) {
		OBB obb = dynamic_cast<OBBCollider*>(this)->GetOBB();
		characterHalfSize_ = obb.halfSize;
		
	} else if (this->GetColliderType() == ColliderType::Sphere) {
		Sphere sphere = dynamic_cast<SphereCollider*>(this)->GetSphere();
		characterHalfSize_ = { sphere.radius, sphere.radius, sphere.radius };
	}

	/// ===åœ°é¢ã®Yåº§æ¨™ã‚’è¨ˆç®—ï¼ˆåœ°é¢ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ï¼‰=== ///
	float groundTopY = 0.0f;
	if (groundInfo_.currentGroundType == ColliderType::AABB) {
		// AABBã®å ´åˆ: maxãŒãã®ã¾ã¾ä¸Šç«¯
		groundTopY = groundInfo_.currentGroundSecond.y;

	} else if (groundInfo_.currentGroundType == ColliderType::OBB) {
		// OBBã®å ´åˆ: center + halfSize
		groundTopY = groundInfo_.currentGroundFirst.y + groundInfo_.currentGroundSecond.y;
	}

	/// ===æŠ¼ã—æˆ»ã—å¾Œã®Yåº§æ¨™ã‚’è¨ˆç®—=== ///
	groundInfo_.currentGroundYPos = groundTopY + characterHalfSize_.y;
}


============================================================
File Path: Project/application/Game/Entity/GameCharacter/GameCharacter.h
============================================================
#pragma once
/// ===Include=== ///
// Collider
#include "Engine/Collider/OBBCollider.h"
#include "Engine/Collider/SphereCollider.h"
#include "Engine/Collider/ColliderConcept.h"

#include "GameCharacterCollision.h"

///-------------------------------------------/// 
/// GameCharacterBase
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
class GameCharacter : public TCollider {
public:

    GameCharacter() = default;
    virtual ~GameCharacter();

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    virtual void Initialize() override;

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    virtual void Update() override;

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    /// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚</param>
    virtual void Draw(BlendMode mode) override;

    /// <summary>
    /// ImGuiæƒ…å ±ã®è¡¨ç¤º
    /// </summary>
    virtual void Information() override;

public: /// ===è¡çªåˆ¤å®š=== ///
    /// <summary>
    /// è¡çªæ™‚ã®å‡¦ç†
    /// </summary>
    /// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã‚’è¡¨ã™ Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
    virtual void OnCollision(Collider* collider) override;

public: /// ===Getter=== ///
    // Velocity
    Vector3 GetVelocity() const { return baseInfo_.velocity; }
    // isDead
    bool GetIsDead() const { return baseInfo_.isDead; };
    // deltaTime
    float GetDeltaTime() const { return baseInfo_.deltaTime; };
    // HP
    uint32_t GetHP() const { return baseInfo_.HP; }
   
public: /// ===Setter=== ///
    // Velocity
    void SetVelocity(const Vector3 vel) { baseInfo_.velocity = vel; };
    // isDead
    void SetIsDead(const bool isDead) { baseInfo_.isDead = isDead; };

protected:
    // Collisionã‚¯ãƒ©ã‚¹
    std::unique_ptr<ColliderCollision> collision_;
    std::unique_ptr<GameCharacterCollision> gCollision_;

    /// ===åŸºæœ¬æƒ…å ±=== ///
    struct BaseInfo {
        Vector3 velocity{};     // é€Ÿåº¦
        float deltaTime = 0.0f; // æ™‚é–“
		float gravity = -9.8f;  // é‡åŠ›
		uint32_t HP = 10;       // ä½“åŠ›
        bool isDead = false;    // æ­»äº¡ãƒ•ãƒ©ã‚°
    };
    BaseInfo baseInfo_;

private: /// ===åœ°é¢ã¨ã®è¡çªå‡¦ç†=== ///

    /// ===GroundInfo=== ///
    struct GroundInfo {
		ColliderType currentGroundType;    // ç¾åœ¨ã®åœ°é¢ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¿ã‚¤ãƒ—
        Vector3 currentGroundFirst{};      // ç¾åœ¨ã®åœ°é¢ã®æƒ…å ±1
		Vector3 currentGroundSecond{};     // ç¾åœ¨ã®åœ°é¢ã®æƒ…å ±2
        float currentGroundYPos = 0.0f;    // ç¾åœ¨ã®åœ°é¢ã®Yè»¸
        bool isGrounded = false;		   // åœ°é¢æ¥åœ°ãƒ•ãƒ©ã‚°
    };
	GroundInfo groundInfo_;

    // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®åŠã‚µã‚¤ã‚ºYè»¸
    Vector3 characterHalfSize_{};

    /// <summary>
    /// æŒ‡å®šã—ãŸä¸­å¿ƒä½ç½®ã¨åŠã‚µã‚¤ã‚ºã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åœ°é¢ã¨ã®è¡çªã‚’æ¤œå‡ºã—ã¦å‡¦ç†ã—ã¾ã™ã€‚
    /// </summary>
    void GroundCollision();
  
    /// <summary>
    ///  åœ°é¢ã«è¡çªã—ãŸéš›ã®å‡¦ç†
    /// </summary>
    /// <param name="collider">è¡çªã—ãŸã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    void GroundOnCollision(Collider* collider);

};



============================================================
File Path: Project/application/Game/Entity/GameCharacter/GameCharacterCollision.cpp
============================================================
#include "GameCharacterCollision.h"
// GameCharacter
#include "GameCharacter.h"
// C++
#include <algorithm>
// Math
#include "Math/sMath.h"

///-------------------------------------------/// 
/// ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå€™è£œã®æ˜ç¤ºçš„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹åŒ–
///-------------------------------------------///
// çƒä½“ã¨OBBã®GameCharacterè¡çªå‡¦ç†
template void GameCharacterCollision::HandleSphereOBBCollision<SphereCollider, OBBCollider>(GameCharacter<SphereCollider>*, GameCharacter<OBBCollider>*, float);
template void GameCharacterCollision::HandleSphereOBBCollision<OBBCollider, SphereCollider>(GameCharacter<OBBCollider>*, GameCharacter<SphereCollider>*, float);
// æ±ç”¨è¡çªå‡¦ç†
template void GameCharacterCollision::ProcessCollision<SphereCollider, SphereCollider>(GameCharacter<SphereCollider>*, GameCharacter<SphereCollider>*, float);
template void GameCharacterCollision::ProcessCollision<SphereCollider, OBBCollider>(GameCharacter<SphereCollider>*, GameCharacter<OBBCollider>*, float);
template void GameCharacterCollision::ProcessCollision<OBBCollider, OBBCollider>(GameCharacter<OBBCollider>*, GameCharacter<OBBCollider>*, float);
template void GameCharacterCollision::ProcessCollision<OBBCollider, SphereCollider>(GameCharacter<OBBCollider>*, GameCharacter<SphereCollider>*, float);

///-------------------------------------------/// 
/// çƒä½“GameCharacteråŒå£«ã®è¡çªå‡¦ç†
///-------------------------------------------///
void GameCharacterCollision::HandleSphereSphereCollision(GameCharacter<SphereCollider>* characterA, GameCharacter<SphereCollider>* characterB, const float pushBackRatio) {

	Vector3 posA = characterA->GetTransform().translate;
	Vector3 posB = characterB->GetTransform().translate;

	// ä¸­å¿ƒç‚¹é–“ã®è·é›¢ãƒ™ã‚¯ãƒˆãƒ«
	Vector3 direction = posA - posB;
	float distance = Length(direction);

	// è·é›¢ãŒ0ã«è¿‘ã„å ´åˆã¯é©å½“ãªæ–¹å‘ã«è¨­å®š
	if (distance < 1e-6f) {
		direction = Vector3(1.0f, 0.0f, 0.0f);
		distance = 1e-6f;
	} else {
		direction = Normalize(direction);
	}

	// åŠå¾„ã®åˆè¨ˆ
	float radiusA = characterA->GetSphere().radius;
	float radiusB = characterB->GetSphere().radius;
	float totalRadius = radiusA + radiusB;

	// é‡ãªã‚Šåˆ†
	float overlap = totalRadius - distance;
	if (overlap > 0.0f) {
		// æŠ¼ã—æˆ»ã—å‡¦ç†
		float pushBackDistanceA = overlap * pushBackRatio;
		float pushBackDistanceB = overlap * (1.0f - pushBackRatio);

		posA += direction * pushBackDistanceA;
		posB -= direction * pushBackDistanceB;

		characterA->SetTranslate(posA);
		characterB->SetTranslate(posB);
	}
}

///-------------------------------------------/// 
/// OBBGameCharacteråŒå£«ã®è¡çªå‡¦ç†
///-------------------------------------------///
void GameCharacterCollision::HandleOBBOBBCollision(GameCharacter<OBBCollider>* characterA, GameCharacter<OBBCollider>* characterB, const float pushBackRatio) {

	Vector3 posA = characterA->GetTransform().translate;
	Vector3 posB = characterB->GetTransform().translate;

	// ç°¡ç•¥åŒ–ã•ã‚ŒãŸæŠ¼ã—æˆ»ã—å‡¦ç†ï¼ˆä¸­å¿ƒç‚¹é–“ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’ä½¿ç”¨ï¼‰
	Vector3 direction = posA - posB;
	float distance = Length(direction);

	if (distance < EPSILON_) {
		direction = Vector3(1.0f, 0.0f, 0.0f);
		distance = EPSILON_;
	} else {
		direction = Normalize(direction);
	}

	// OBBã®ã‚µã‚¤ã‚ºã‹ã‚‰æ¨å®šã•ã‚Œã‚‹æœ€å°æŠ¼ã—æˆ»ã—è·é›¢
	Vector3 sizeA = characterA->GetOBB().halfSize * 2.0f;
	Vector3 sizeB = characterB->GetOBB().halfSize * 2.0f;
	float avgSizeA = (sizeA.x + sizeA.y + sizeA.z) / 3.0f;
	float avgSizeB = (sizeB.x + sizeB.y + sizeB.z) / 3.0f;

	float minDistance = (avgSizeA + avgSizeB) * 0.5f;
	float overlap = minDistance - distance;

	if (overlap > 0.0f) {
		// æŠ¼ã—æˆ»ã—å‡¦ç†
		float pushA = overlap * (1.0f - pushBackRatio);;
		float pushB = overlap * pushBackRatio;

		posA += direction * pushA;
		posB -= direction * pushB;

		characterA->SetTranslate(posA);
		characterB->SetTranslate(posB);
	}
}

///-------------------------------------------/// 
/// çƒä½“ã¨OBBã®GameCharacterè¡çªå‡¦ç†
///-------------------------------------------///
template<typename TColliderA, typename TColliderB> requires IsCollider<TColliderA>&& IsCollider<TColliderB>
void GameCharacterCollision::HandleSphereOBBCollision(GameCharacter<TColliderA>* characterA, GameCharacter<TColliderB>* characterB, const float pushBackRatio) {

	GameCharacter<OBBCollider>* obbCharacter = nullptr;
	GameCharacter<SphereCollider>* sphereCharacter = nullptr;
	/// ===ã‚­ãƒ£ã‚¹ãƒˆ=== ///
	if (GetColliderTypeFromCharacter(characterA) == ColliderType::OBB) {
		obbCharacter = dynamic_cast<GameCharacter<OBBCollider>*>(characterA);
		sphereCharacter = dynamic_cast<GameCharacter<SphereCollider>*>(characterB);

	} else if (GetColliderTypeFromCharacter(characterA) == ColliderType::Sphere) {
		sphereCharacter = dynamic_cast<GameCharacter<SphereCollider>*>(characterA);
		obbCharacter = dynamic_cast<GameCharacter<OBBCollider>*>(characterB);
	}

	/// ===Nullãƒã‚§ãƒƒã‚¯=== ///
	if (!obbCharacter || !sphereCharacter) {
		return;
	}

	// ä½ç½®æƒ…å ±ã®å–å¾—
	Vector3 obbPos = obbCharacter->GetTransform().translate;
	Vector3 spherePos = sphereCharacter->GetTransform().translate;

	// çƒã®åŠå¾„
	float sphereRadius = sphereCharacter->GetSphere().radius;
	Vector3 closestPoint = CalculateClosestPointOnOBBFromCharacter(spherePos, obbCharacter);

	// çƒä½“ã®ä¸­å¿ƒã‹ã‚‰æœ€ã‚‚è¿‘ã„ç‚¹ã¸ã®æ–¹å‘
	Vector3 direction = spherePos - closestPoint;
	float distance = Length(direction);

	// è·é›¢ãŒ0ã«è¿‘ã„å ´åˆã¯é©å½“ãªæ–¹å‘ã«è¨­å®š
	if (distance < 1e-6f) {
		direction = Vector3(0.0f, 1.0f, 0.0f);
		distance = 1e-6f;
	} else {
		direction = Normalize(direction);
	}

	// é‡ãªã‚Šåˆ†
	float overlap = sphereRadius - distance;
	if (overlap > 0.0f) {
		// æŠ¼ã—æˆ»ã—å‡¦ç†
		float pushBackDistanceSphere = overlap * pushBackRatio;
		float pushBackDistanceOBB = overlap * (1.0f - pushBackRatio);

		spherePos += direction * pushBackDistanceSphere;
		obbPos -= direction * pushBackDistanceOBB;

		// ä½ç½®ã®æ›´æ–°
		obbCharacter->SetTranslate(obbPos);
		sphereCharacter->SetTranslate(spherePos);
	}
}

///-------------------------------------------/// 
/// æ±ç”¨è¡çªå‡¦ç†ï¼ˆè‡ªå‹•åˆ¤å®šï¼‰
///-------------------------------------------///
template<typename TColliderA, typename TColliderB> requires IsCollider<TColliderA>&& IsCollider<TColliderB>
void GameCharacterCollision::ProcessCollision(GameCharacter<TColliderA>* characterA, GameCharacter<TColliderB>* characterB, const float pushBackRatio) {

	ColliderType typeA = GetColliderTypeFromCharacter(characterA);
	ColliderType typeB = GetColliderTypeFromCharacter(characterB);

	// åŒã˜å‹ã®å ´åˆ
	if (typeA == typeB) {

		if (typeA == ColliderType::Sphere) {
			GameCharacter<SphereCollider>* sphereA = dynamic_cast<GameCharacter<SphereCollider>*>(characterA);
			GameCharacter<SphereCollider>* sphereB = dynamic_cast<GameCharacter<SphereCollider>*>(characterB);
			HandleSphereSphereCollision(sphereA, sphereB, pushBackRatio);
		} else if (typeA == ColliderType::OBB) {
			GameCharacter<OBBCollider>* obbA = dynamic_cast<GameCharacter<OBBCollider>*>(characterA);
			GameCharacter<OBBCollider>* obbB = dynamic_cast<GameCharacter<OBBCollider>*>(characterB);
			HandleOBBOBBCollision(obbA, obbB, pushBackRatio);
		}
		// åŒã˜ã§ãªã„å ´åˆ
	} else if (typeA != typeB) {
		HandleSphereOBBCollision(characterA, characterB, pushBackRatio);
	}

}

///-------------------------------------------/// 
/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼å‹ã®åˆ¤å®š
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
ColliderType GameCharacterCollision::GetColliderTypeFromCharacter(GameCharacter<TCollider>* character) const {
	return character->GetColliderType();
}

///-------------------------------------------/// 
/// OBBä¸Šã®æœ€è¿‘ç‚¹è¨ˆç®—ï¼ˆGameCharacterç”¨ï¼‰
///-------------------------------------------///
Vector3 GameCharacterCollision::CalculateClosestPointOnOBBFromCharacter(const Vector3& point, GameCharacter<OBBCollider>* obbCharacter) const {
	if (obbCharacter->GetColliderType() != ColliderType::OBB) {
		return point; // OBBã§ãªã„å ´åˆã¯å…ƒã®ç‚¹ã‚’è¿”ã™
	}

	OBBCollider* obb = static_cast<OBBCollider*>(obbCharacter);
	OBB obbData = obb->GetOBB();

	return CalculateClosestPointOnOBB(point, obbData);
}

///-------------------------------------------/// 
/// OBBä¸Šã®æœ€è¿‘ç‚¹è¨ˆç®—
///-------------------------------------------///
Vector3 GameCharacterCollision::CalculateClosestPointOnOBB(const Vector3& point, const OBB& obb) const {
	Vector3 dir = point - obb.center;
	Vector3 closest = obb.center;

	// OBBç©ºé–“ã«ãŠã‘ã‚‹æœ€è¿‘ç‚¹ã‚’è¨ˆç®—
	for (int i = 0; i < 3; ++i) {
		float axisExtent = 0.0f;

		if (i == 0) axisExtent = obb.halfSize.x;
		else if (i == 1) axisExtent = obb.halfSize.y;
		else if (i == 2) axisExtent = obb.halfSize.z;

		float dist = Dot(dir, obb.axis[i]);
		dist = std::clamp(dist, -axisExtent, axisExtent);

		closest += obb.axis[i] * dist;
	}

	return closest;
}

///-------------------------------------------/// 
/// OBBã®è»¸ä¸Šã§ã®é‡ãªã‚Šã‚’è¨ˆç®—
///-------------------------------------------///
float GameCharacterCollision::CalculateOverlapOnAxis(const OBB& obb1, const OBB& obb2, const Vector3& axis) const {
	// å„OBBã®è»¸ã¸ã®å°„å½±ã®åŠå¾„ã‚’è¨ˆç®—
	float r1 = 0.0f;
	for (int i = 0; i < 3; ++i) {
		r1 += fabs(Dot(obb1.axis[i] * obb1.halfSize, axis));
	}

	float r2 = 0.0f;
	for (int i = 0; i < 3; ++i) {
		r2 += fabs(Dot(obb2.axis[i] * obb2.halfSize, axis));
	}

	// ä¸­å¿ƒé–“è·é›¢ã®å°„å½±
	Vector3 centerDiff = obb1.center - obb2.center;
	float distance = fabs(Dot(centerDiff, axis));

	// é‡ãªã‚Šé‡ã‚’è¿”ã™ï¼ˆæ­£ã®å€¤ãªã‚‰é‡ãªã£ã¦ã„ã‚‹ï¼‰
	return (r1 + r2) - distance;
}

============================================================
File Path: Project/application/Game/Entity/GameCharacter/GameCharacterCollision.h
============================================================
#pragma once
/// ===Include=== ///
// Collider
#include "Engine/Collider/OBBCollider.h"
#include "Engine/Collider/SphereCollider.h"
#include "Engine/Collider/ColliderConcept.h"

/// ===å‰æ–¹å®£è¨€=== ///
template<typename TCollider> requires IsCollider<TCollider>
class GameCharacter;

///=====================================================/// 
/// GameCharacterCollision - GameCharacterå°‚ç”¨ã®è¡çªå‡¦ç†ã‚¯ãƒ©ã‚¹
/// GameCharacterã‚¯ãƒ©ã‚¹ã®OnCollisionå†…ã§ä½¿ç”¨ã•ã‚Œã‚‹
///=====================================================///
class GameCharacterCollision {
public:
    GameCharacterCollision() = default;
    ~GameCharacterCollision() = default;

    //NOTE:pushBackRatioã¯æŠ¼ã—æˆ»ã—ã®æ¯”ç‡ã‚’èª¿æ•´ã™ã‚‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§ã€0.0fã‹ã‚‰1.0fã®ç¯„å›²ã§è¨­å®šã—ã¾ã™ã€‚0.0ã¯CharacterBã®ã¿æŠ¼ã—æˆ»ã—ã€1.0ã¯CharacterAã®ã¿æŠ¼ã—æˆ»ã—ã€0.5ã¯ä¸¡æ–¹å‡ç­‰ã«æŠ¼ã—æˆ»ã—ã¾ã™ã€‚

    /// <summary>
    /// çƒå½¢ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æŒã¤2ã¤ã®ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é–“ã®è¡çªå‡¦ç†
    /// </summary>
    /// <param name="sphereCharacterA">è¡çªã™ã‚‹1ã¤ç›®ã®ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆSphereCollider ã‚’æŒã¤ï¼‰ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    /// <param name="sphereCharacterB">è¡çªã™ã‚‹2ã¤ç›®ã®ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆSphereCollider ã‚’æŒã¤ï¼‰ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    /// <param name="pushBackRatio">è¡çªæ™‚ã®æŠ¼ã—æˆ»ã—ã«é©ç”¨ã™ã‚‹æ¯”ç‡ã€‚æ—¢å®šå€¤ã¯ 1.0fã€‚</param>
    void HandleSphereSphereCollision(GameCharacter<SphereCollider>* sphereCharacterA, GameCharacter<SphereCollider>* sphereCharacterB, const float pushBackRatio = 1.0f);

    /// <summary>
    /// 2ã¤ã®OBBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æŒã¤ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é–“ã®è¡çªå‡¦ç†
    /// </summary>
    /// <param name="obbCharacterA">è¡çªã®å¯¾è±¡ã¨ãªã‚‹1ã¤ç›®ã®OBBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æŒã¤ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
    /// <param name="obbCharacterB">è¡çªã®å¯¾è±¡ã¨ãªã‚‹2ã¤ç›®ã®OBBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æŒã¤ã‚²ãƒ¼ãƒ ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
    /// <param name="pushBackRatio">è¡çªæ™‚ã«é©ç”¨ã™ã‚‹æŠ¼ã—æˆ»ã—ã®å¼·ã•ã‚’ç¤ºã™ä¿‚æ•°ï¼ˆæ—¢å®šå€¤ã¯1.0fï¼‰ã€‚å€¤ãŒå¤§ãã„ã»ã©å¼·ãæŠ¼ã—æˆ»ã—ã¾ã™ã€‚</param>
    void HandleOBBOBBCollision(GameCharacter<OBBCollider>* obbCharacterA, GameCharacter<OBBCollider>* obbCharacterB, const float pushBackRatio = 1.0f);

    /// <summary>
    /// çƒã¨OBBé–“ã®è¡çªå‡¦ç†
    /// </summary>
    /// <typeparam name="TColliderA">characterA ãŒä½¿ç”¨ã™ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ã®å‹ã€‚</typeparam>
    /// <typeparam name="TColliderB">characterB ãŒä½¿ç”¨ã™ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ã®å‹ã€‚</typeparam>
    /// <param name="characterA">è¡çªå¯¾è±¡ã®æœ€åˆã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã€‚ã‚³ãƒ©ã‚¤ãƒ€å‹ TColliderA ã‚’æŒã¤ GameCharacter ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    /// <param name="characterB">è¡çªå¯¾è±¡ã®äºŒç•ªç›®ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã€‚ã‚³ãƒ©ã‚¤ãƒ€å‹ TColliderB ã‚’æŒã¤ GameCharacter ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    /// <param name="pushBackRatio">è¡çªè§£æ±ºæ™‚ã«é©ç”¨ã™ã‚‹æŠ¼ã—æˆ»ã—ï¼ˆpush-backï¼‰ã®å€ç‡ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ 1.0fã€‚å€¤ã‚’å°ã•ãã™ã‚‹ã¨æŠ¼ã—æˆ»ã—ãŒå¼±ããªã‚Šã€0 ã«ã™ã‚‹ã¨æŠ¼ã—æˆ»ã—ã‚’è¡Œã‚ãªã„ã€‚</param>
    template<typename TColliderA, typename TColliderB> requires IsCollider<TColliderA>&& IsCollider<TColliderB>
    void HandleSphereOBBCollision(GameCharacter<TColliderA>* characterA, GameCharacter<TColliderB>* characterB, const float pushBackRatio = 1.0f);

    /// <summary>
    /// 2ã¤ã®GameCharacteré–“ã®è¡çªå‡¦ç†
    /// </summary>
    /// <typeparam name="TColliderA">characterAã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚³ãƒ©ã‚¤ãƒ€ã®å‹ã€‚</typeparam>
    /// <typeparam name="TColliderB">characterBã«ä½¿ç”¨ã•ã‚Œã‚‹ã‚³ãƒ©ã‚¤ãƒ€ã®å‹ã€‚</typeparam>
    /// <param name="characterA">è¡çªã™ã‚‹æœ€åˆã®GameCharacterã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    /// <param name="characterB">è¡çªã™ã‚‹2ç•ªç›®ã®GameCharacterã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
    /// <param name="pushBackRatio">è¡çªæ™‚ã«é©ç”¨ã™ã‚‹æŠ¼ã—æˆ»ã—é‡ã®æ¯”ç‡ã€‚æ—¢å®šå€¤ã¯1.0fã€‚</param>
	template<typename TColliderA, typename TColliderB> requires IsCollider<TColliderA>&& IsCollider<TColliderB>
    void ProcessCollision(GameCharacter<TColliderA>* characterA, GameCharacter<TColliderB>* characterB, const float pushBackRatio = 1.0f);

private:

    // å®šæ•°å®šç¾©
	const float EPSILON_ = 1e-6f;

    /// <summary>
    /// GameCharacter ã‹ã‚‰ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ç¨®é¡ (ColliderType) ã‚’å–å¾—
    /// </summary>
    /// <typeparam name="TCollider">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒä½¿ç”¨ã™ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®å‹ã€‚</typeparam>
    /// <param name="character">TCollider å‹ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æŒã¤ GameCharacter ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚å¯¾è±¡ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
    /// <returns>æŒ‡å®šã—ãŸã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«é–¢é€£ä»˜ã‘ã‚‰ã‚ŒãŸ ColliderType ã‚’è¿”ã—ã¾ã™ã€‚</returns>
    template<typename TCollider> requires IsCollider<TCollider>
    ColliderType GetColliderTypeFromCharacter(GameCharacter<TCollider>* character) const;

    /// <summary>
    /// ä¸ãˆã‚‰ã‚ŒãŸç‚¹ã‹ã‚‰ã€OBBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æŒã¤ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ä¸Šã®æœ€ã‚‚è¿‘ã„ç‚¹ï¼ˆæœ€æ¥è¿‘ç‚¹ï¼‰ã‚’è¨ˆç®—ã—ã¦è¿”ã™å‡¦ç†
    /// </summary>
    /// <param name="point">åŸºæº–ã¨ãªã‚‹ç‚¹ï¼ˆå…¥åŠ›ã€å‚ç…§æ¸¡ã—ï¼‰ã€‚ã“ã®ç‚¹ã‹ã‚‰ OBB ã¸ã®æœ€çŸ­ç‚¹ã‚’æ±‚ã‚ã¾ã™ã€‚</param>
    /// <param name="obbCharacter">OBBCollider ã‚’æŒã¤ GameCharacter ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚è¨ˆç®—å¯¾è±¡ã¨ãªã‚‹ OBB ã®ä½ç½®ãƒ»å‘ããƒ»åŠå¾„ãªã©ã®æƒ…å ±ã‚’æä¾›ã—ã¾ã™ã€‚</param>
    /// <returns>OBB ä¸Šã®æœ€ã‚‚è¿‘ã„ç‚¹ã‚’è¡¨ã™ Vector3ã€‚</returns>
    Vector3 CalculateClosestPointOnOBBFromCharacter(const Vector3& point, GameCharacter<OBBCollider>* obbCharacter) const;

    /// <summary>
    /// ä¸ãˆã‚‰ã‚ŒãŸç‚¹ã‹ã‚‰OBBä¸Šã®æœ€ã‚‚è¿‘ã„ç‚¹ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="point">åŸºæº–ã¨ãªã‚‹ç‚¹ã€‚</param>
    /// <param name="obb">è¨ˆç®—å¯¾è±¡ã®OBBã€‚</param>
    /// <returns>OBBä¸Šã®æœ€ã‚‚è¿‘ã„ç‚¹ã‚’è¡¨ã™Vector3ã€‚</returns>
    Vector3 CalculateClosestPointOnOBB(const Vector3& point, const OBB& obb) const;

    /// <summary>
    /// OBBã®æŒ‡å®šè»¸ä¸Šã§ã®é‡ãªã‚Šé‡ã‚’è¨ˆç®—
    /// </summary>
    /// <param name="obb1">1ã¤ç›®ã®OBBã€‚</param>
    /// <param name="obb2">2ã¤ç›®ã®OBBã€‚</param>
    /// <param name="axis">åˆ†é›¢è»¸ã€‚</param>
    /// <returns>é‡ãªã‚Šé‡ï¼ˆæ­£ã®å€¤ãªã‚‰é‡ãªã£ã¦ã„ã‚‹ï¼‰ã€‚</returns>
    float CalculateOverlapOnAxis(const OBB& obb1, const OBB& obb2, const Vector3& axis) const;
};

============================================================
File Path: Project/application/Game/Entity/Player/Component/PlayerAttackComponent.cpp
============================================================
#include "PlayerAttackComponent.h"
// PlayerWeapon
#include "application/Game/Entity/Player/Weapon/PlayerWeapon.h"
#include "application/Game/Entity/Player/Editor/AttackDataSerializer.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI


///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
void PlayerAttackComponent::Initialize() {
    // ã‚³ãƒ³ãƒœã®èª­ã¿è¾¼ã¿
    LoadAttackData(0, "Resource/Json/Attacks/Attack_0.json");
    LoadAttackData(1, "Resource/Json/Attacks/Attack_1.json");
    LoadAttackData(2, "Resource/Json/Attacks/Attack_2.json");
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
void PlayerAttackComponent::Update(const float deltaTime) {
    // ã‚¿ã‚¤ãƒãƒ¼ã‚’æ›´æ–°
    UpdateTimers(deltaTime);

    // æ”»æ’ƒä¸­ã®å‡¦ç†
    if (state_.isActive) {
        // æ”»æ’ƒæ™‚é–“ãŒçµ‚äº†ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
        const AttackData* currentData = GetAttackData(state_.currentAttackID);

        if (currentData && state_.timer >= currentData->activeDuration) {
            state_.isActive = false;
            state_.previousAttackID = state_.currentAttackID;  // â† å‰ã®æ”»æ’ƒIDã‚’ä¿å­˜
            state_.currentAttackID = -1;

            // ã‚³ãƒ³ãƒœå—ä»˜é–‹å§‹
            if (currentData->canComboToNext) {
                state_.canCombo = true;
                state_.comboTimer = 0.0f;
            }
        }
    }

    // ã‚³ãƒ³ãƒœå—ä»˜æ™‚é–“ã®ç®¡ç†
    if (state_.canCombo) {
        // â˜… å‰ã®æ”»æ’ƒIDã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
        const AttackData* previousData = GetAttackData(state_.previousAttackID);

        if (previousData && state_.comboTimer >= previousData->comboWindowTime) {
            state_.canCombo = false;
            state_.comboCount = 0;
            state_.previousAttackID = -1;  // â† ãƒªã‚»ãƒƒãƒˆ
        }
    }
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®è¡¨ç¤º
///-------------------------------------------///
void PlayerAttackComponent::Information() {
#ifdef USE_IMGUI
    ImGui::SeparatorText("PlayerAttackComponent");

    ImGui::Text("æ”»æ’ƒä¸­: %s", state_.isActive ? "true" : "false");
    ImGui::Text("ç¾åœ¨ã®æ”»æ’ƒID: %d", state_.currentAttackID);
    ImGui::Text("å‰ã®æ”»æ’ƒID: %d", state_.previousAttackID);  // â† è¿½åŠ 
    ImGui::Text("ã‚³ãƒ³ãƒœå¯èƒ½: %s", state_.canCombo ? "true" : "false");
    ImGui::Text("ã‚³ãƒ³ãƒœæ•°: %d", state_.comboCount);
    ImGui::Text("æ”»æ’ƒã‚¿ã‚¤ãƒãƒ¼: %.3f", state_.timer);
    ImGui::Text("ã‚³ãƒ³ãƒœã‚¿ã‚¤ãƒãƒ¼: %.3f", state_.comboTimer);
    ImGui::Text("æ”»æ’ƒé€²è¡Œåº¦: %. 1f%%", GetAttackProgress() * 100.0f);

    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
    ImGui::Separator();

    if (state_.isActive) {
        const AttackData* currentData = GetAttackData(state_.currentAttackID);
        if (currentData) {
            ImGui::TextColored(ImVec4(0, 1, 0, 1), "ç¾åœ¨ã®æ”»æ’ƒ:  %s", currentData->attackName.c_str());
            ImGui::Text("æ”»æ’ƒæ™‚é–“: %.2fç§’", currentData->activeDuration);
            ImGui::Text("çµ‚äº†ã¾ã§: %. 2fç§’", currentData->activeDuration - state_.timer);
        }
    }

    if (state_.canCombo) {
        const AttackData* previousData = GetAttackData(state_.previousAttackID);
        if (previousData) {
            ImGui::TextColored(ImVec4(1, 1, 0, 1), "ã‚³ãƒ³ãƒœå—ä»˜ä¸­ï¼");
            ImGui::Text("å‰ã®æ”»æ’ƒ:  %s", previousData->attackName.c_str());
            ImGui::Text("æ¬¡ã®æ”»æ’ƒID: %d", previousData->nextComboID);
            ImGui::Text("å—ä»˜æ™‚é–“: %.2fç§’", previousData->comboWindowTime);
            ImGui::Text("æ®‹ã‚Šæ™‚é–“: %.2fç§’", previousData->comboWindowTime - state_.comboTimer);
        }
    }

    ImGui::Separator();
    ImGui::Text("ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹æ”»æ’ƒæ•°: %zu", attackDataMap_.size());
#endif
}

///-------------------------------------------/// 
/// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’Jsonã‹ã‚‰èª­ã¿è¾¼ã¿
///-------------------------------------------///
bool PlayerAttackComponent::LoadAttackData(int attackID, const std::string& filepath) {
    AttackData data;
    if (AttackDataSerializer::LoadFromJson(data, filepath)) {
        data.attackID = attackID;  // IDã‚’ç¢ºå®Ÿã«è¨­å®š
        attackDataMap_[attackID] = data;
        return true;
    }
    return false;
}

///-------------------------------------------/// 
/// æ”»æ’ƒã‚’é–‹å§‹
///-------------------------------------------///
bool PlayerAttackComponent::StartAttack(int attackID, PlayerWeapon* weapon) {
    // æ—¢ã«æ”»æ’ƒä¸­ã®å ´åˆã¯å¤±æ•—
    if (state_.isActive) {
        return false;
    }

	CancelAttack(); // çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ

    // æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    auto it = attackDataMap_.find(attackID);
    if (it == attackDataMap_.end()) {
        return false;
    }

    const AttackData& attackData = it->second;

    // æ­¦å™¨ã«æ”»æ’ƒã‚’é©ç”¨
    ApplyAttackToWeapon(attackData, weapon);

    // çŠ¶æ…‹ã‚’æ›´æ–°
    state_.isActive = true;
    state_.currentAttackID = attackID;
    state_.timer = 0.0f;
    state_.canCombo = false;
    state_.comboCount = 0;

    return true;
}

///-------------------------------------------/// 
/// ã‚³ãƒ³ãƒœæ”»æ’ƒã‚’è©¦è¡Œ
///-------------------------------------------///
bool PlayerAttackComponent::TryCombo(PlayerWeapon* weapon) {
    // ã‚³ãƒ³ãƒœå¯èƒ½çŠ¶æ…‹ã§ãªã„å ´åˆã¯å¤±æ•—
    if (!state_.canCombo) {
        return false;
    }

    // â˜… å‰ã®æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const AttackData* previousData = GetAttackData(state_.previousAttackID);
    if (!previousData || !previousData->canComboToNext) {
        return false;
    }

    // æ¬¡ã®ã‚³ãƒ³ãƒœIDã‚’å–å¾—
    int nextAttackID = previousData->nextComboID;
    if (nextAttackID < 0) {
        return false;
    }

    // æ¬¡ã®æ”»æ’ƒã‚’é–‹å§‹
    state_.canCombo = false;
    state_.comboCount++;

    return StartAttack(nextAttackID, weapon);
}

///-------------------------------------------/// 
/// æ”»æ’ƒã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
///-------------------------------------------///
void PlayerAttackComponent::CancelAttack() {
    state_.isActive = false;
    state_.canCombo = false;
    state_.currentAttackID = -1;
    state_.previousAttackID = -1;  // â† ãƒªã‚»ãƒƒãƒˆ
    state_.comboCount = 0;
    state_.timer = 0.0f;
    state_.comboTimer = 0.0f;
}

///-------------------------------------------/// 
/// ç¾åœ¨ã®æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
///-------------------------------------------///
const AttackData* PlayerAttackComponent::GetCurrentAttackData() const {
    return GetAttackData(state_.currentAttackID);
}

///-------------------------------------------/// 
/// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’IDã§å–å¾—
///-------------------------------------------///
const AttackData* PlayerAttackComponent::GetAttackData(int attackID) const {
    auto it = attackDataMap_.find(attackID);
    if (it != attackDataMap_.end()) {
        return &it->second;
    }
    return nullptr;
}

///-------------------------------------------/// 
/// ç¾åœ¨ã®æ”»æ’ƒé€²è¡Œåº¦ã‚’å–å¾—
///-------------------------------------------///
float PlayerAttackComponent::GetAttackProgress() const {
    const AttackData* data = GetCurrentAttackData();
    if (!data || !state_.isActive) {
        return 0.0f;
    }

    return (std::min)(state_.timer / data->activeDuration, 1.0f);
}

///-------------------------------------------/// 
/// æ­¦å™¨ã«æ”»æ’ƒè»Œé“ã‚’è¨­å®š
///-------------------------------------------///
void PlayerAttackComponent::ApplyAttackToWeapon(const AttackData& data, PlayerWeapon* weapon) {
    if (!weapon || data.trajectoryPoints.size() < 2) {
        return;
    }

    // ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹ã‚’ãã®ã¾ã¾æ¸¡ã™
    weapon->StartAttack(
        data.trajectoryPoints,     // ãƒ™ã‚¸ã‚§æ›²ç·šã®å…¨åˆ¶å¾¡ç‚¹
        data.activeDuration,
        data.startRotation,
        data.endRotation
    );
}

///-------------------------------------------/// 
/// ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°
///-------------------------------------------///
void PlayerAttackComponent::UpdateTimers(float deltaTime) {
    if (state_.isActive) {
        state_.timer += deltaTime;
    }

    if (state_.canCombo) {
        state_.comboTimer += deltaTime;
    }
}

============================================================
File Path: Project/application/Game/Entity/Player/Component/PlayerAttackComponent.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Game/Entity/Player/Editor/Data/AttackData.h"
// C++
#include <memory>
#include <unordered_map>
#include <string>

/// ===å‰æ–¹å®£è¨€=== ///
class PlayerWeapon;

///-------------------------------------------/// 
/// PlayerAttackComponent
///-------------------------------------------///
class PlayerAttackComponent {
private:
	/// ===æ”»æ’ƒçŠ¶æ…‹ã®æ§‹é€ ä½“=== ///
	struct AttackState {
		float timer = 0.0f;         // æ”»æ’ƒã‚¿ã‚¤ãƒãƒ¼
		float comboTimer = 0.0f;    // ã‚³ãƒ³ãƒœã‚¿ã‚¤ãƒãƒ¼
		bool isActive = false;      // æ”»æ’ƒä¸­ãƒ•ãƒ©ã‚°
		bool canCombo = false;      // ã‚³ãƒ³ãƒœå¯èƒ½ãƒ•ãƒ©ã‚°
		int currentAttackID = -1;   // ç¾åœ¨ã®æ”»æ’ƒID
		int previousAttackID = -1;  // â† è¿½åŠ ï¼šå‰ã®æ”»æ’ƒIDï¼ˆã‚³ãƒ³ãƒœå—ä»˜ç”¨ï¼‰
		int comboCount = 0;         // ã‚³ãƒ³ãƒœã‚«ã‚¦ãƒ³ãƒˆ
	};

public:

	PlayerAttackComponent() = default;
	~PlayerAttackComponent() = default;

	// ã‚³ãƒ”ãƒ¼ãƒ»ãƒ ãƒ¼ãƒ–ã¯æ˜ç¤ºçš„ã«åˆ¶å¾¡
	PlayerAttackComponent(const PlayerAttackComponent&) = delete;
	PlayerAttackComponent& operator=(const PlayerAttackComponent&) = delete;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update(const float deltaTime);

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information();

	/// <summary>
	/// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’JSONã‹ã‚‰èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="attackID">æ”»æ’ƒID</param>
	/// <param name="filepath">JSONãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
	/// <returns>èª­ã¿è¾¼ã¿æˆåŠŸã—ãŸã‚‰true</returns>
	bool LoadAttackData(int attackID, const std::string& filepath);

	/// <summary>
	/// æ”»æ’ƒã‚’é–‹å§‹
	/// </summary>
	/// <param name="attackID">å®Ÿè¡Œã™ã‚‹æ”»æ’ƒID</param>
	/// <param name="weapon">ä½¿ç”¨ã™ã‚‹æ­¦å™¨</param>
	/// <param name="playerPosition">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®</param>
	/// <param name="playerRotation">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢</param>
	/// <returns>æ”»æ’ƒé–‹å§‹ã«æˆåŠŸã—ãŸã‚‰true</returns>
	bool StartAttack(int attackID, PlayerWeapon* weapon);

	/// <summary>
	/// ã‚³ãƒ³ãƒœæ”»æ’ƒã‚’è©¦è¡Œ
	/// </summary>
	/// <param name="weapon">ä½¿ç”¨ã™ã‚‹æ­¦å™¨</param>
	/// <param name="playerPosition">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®</param>
	/// <param name="playerRotation">ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢</param>
	/// <returns>ã‚³ãƒ³ãƒœæˆåŠŸã—ãŸã‚‰true</returns>
	bool TryCombo(PlayerWeapon* weapon);

	/// <summary>
	/// æ”»æ’ƒã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
	/// </summary>
	void CancelAttack();

public: /// ===Getter=== ///

	// ç¾åœ¨ã®æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	const AttackData* GetCurrentAttackData() const;
	// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’IDã§å–å¾—
	const AttackData* GetAttackData(int attackID) const;
	// æ”»æ’ƒçŠ¶æ…‹
	const AttackState& GetState() const { return state_; }
	// æ”»æ’ƒä¸­ã‹
	bool IsAttacking() const { return state_.isActive; }
	// ã‚³ãƒ³ãƒœå¯èƒ½ã‹
	bool CanCombo() const { return state_.canCombo; }
	// ç¾åœ¨ã®æ”»æ’ƒé€²è¡Œåº¦
	float GetAttackProgress() const;

private:
	// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã®ç®¡ç†
	std::unordered_map<int, AttackData> attackDataMap_;

	// æ”»æ’ƒçŠ¶æ…‹
	AttackState state_;

private:

	/// <summary>
	/// ã‚¿ã‚¤ãƒãƒ¼ã‚’æ›´æ–°ã—ã¾ã™ã€‚
	/// </summary>
	/// <param name="deltaTime">å‰å›ã®æ›´æ–°ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼ˆç§’ï¼‰</param>
	void UpdateTimers(const float deltaTime);

	/// <summary>
	/// æ­¦å™¨ã«æ”»æ’ƒè»Œé“ã‚’è¨­å®š
	/// </summary>
	/// <param name="data">é©ç”¨ã™ã‚‹æ”»æ’ƒæƒ…å ±ã‚’ä¿æŒã™ã‚‹å‚ç…§ã€‚ãƒ€ãƒ¡ãƒ¼ã‚¸å€¤ã‚„æ”»æ’ƒç¨®åˆ¥ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãªã©ã‚’å«ã¿ã¾ã™ã€‚</param>
	/// <param name="weapon">æ”»æ’ƒã‚’å—ã‘ã‚‹å¯¾è±¡ã®æ­¦å™¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="basePosition">æ”»æ’ƒé©ç”¨æ™‚ã®åŸºæº–ã¨ãªã‚‹ä½ç½®ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰ã€‚</param>
	/// <param name="baseRotation">æ”»æ’ƒé©ç”¨æ™‚ã®åŸºæº–ã¨ãªã‚‹å›è»¢ï¼ˆã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ï¼‰ã€‚</param>
	void ApplyAttackToWeapon(const AttackData& data, PlayerWeapon* weapon);
};



============================================================
File Path: Project/application/Game/Entity/Player/Component/PlayerAvoidanceComponent.cpp
============================================================
#include "PlayerAvoidanceComponent.h"
// Math
#include "Math/sMath.h"
// C++
#include <cassert>
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
void PlayerAvoidanceComponent::Initialize(const AvoidanceConfig& config) {
	// è¨­å®šã®åˆæœŸåŒ–
	config_ = config;

	// åˆæœŸåŒ–
	acceleration_ = 0.1f;
	direction_ = { 0.0f, 0.0f, 0.0f };
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
PlayerAvoidanceComponent::UpdateResult PlayerAvoidanceComponent::Update(const UpdateContext& context) {
	
	UpdateResult result{};

	// åŠ é€Ÿåº¦ã®æ¸›å°‘
	acceleration_ -= context.deltaTime * config_.activeTime;
	// é€Ÿåº¦ã®è¨­å®š
	float speed = config_.speed * acceleration_;

	/// ===Velocityã«åæ˜ === ///
	result.velocity.x += context.inputDirection.x * speed;
	result.velocity.z += context.inputDirection.z * speed;

	return result;
}

///-------------------------------------------/// 
/// ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void PlayerAvoidanceComponent::UpdateTimer(const float deltaTime) {
	if (state_.timer > 0.0f) {
		state_.timer -= deltaTime;
	} else {
		state_.isPreparation = true;
	}
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®è¡¨ç¤º
///-------------------------------------------///
void PlayerAvoidanceComponent::Information() {
#ifdef USE_IMGUI
	if (ImGui::TreeNode("å›é¿æƒ…å ±")) {
		ImGui::DragFloat("å›é¿é€Ÿåº¦", &config_.speed, 0.01f);
		ImGui::DragFloat("æœ‰åŠ¹æ™‚é–“", &config_.activeTime, 0.01f);
		ImGui::DragFloat("ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ ", &config_.coolTime, 0.01f);
		ImGui::DragFloat("ç„¡æ•µæ™‚é–“", &config_.invincibleTime, 0.01f);
		ImGui::Separator();
		ImGui::TreePop();
	}
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// å›é¿å‡¦ç†ã®é–‹å§‹
///-------------------------------------------///
void PlayerAvoidanceComponent::StartAvoidance() {
	// çŠ¶æ…‹ã®åˆæœŸåŒ–
	acceleration_ = 0.1f;
	state_.timer = config_.activeTime;
	state_.isActive = true;
}

///-------------------------------------------/// 
/// çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void PlayerAvoidanceComponent::ResetState() {
	state_.isActive = false;
	state_.timer = config_.coolTime;
	state_.isPreparation = false;
}


============================================================
File Path: Project/application/Game/Entity/Player/Component/PlayerAvoidanceComponent.h
============================================================
#pragma once
/// ===Include=== ///
#include "Math/Vector3.h"

///=====================================================/// 
/// PlayerAvoidanceComponentï¼ˆå›é¿ï¼‰
///=====================================================///
class PlayerAvoidanceComponent {
private:
	/// ===çŠ¶æ…‹ã®æ§‹é€ ä½“=== ///
	struct AvoidanceState {
		float timer = 0.0f;	 // ã‚¿ã‚¤ãƒãƒ¼
		bool isActive = false;      // å›é¿ä¸­ãƒ•ãƒ©ã‚°
		bool isPreparation = false; // æº–å‚™ãƒ•ãƒ©ã‚°
	};
public:
	/// ===å›é¿è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ§‹é€ ä½“=== ///
	struct AvoidanceConfig {
		float speed = 0.4f;           // å›é¿é€Ÿåº¦
		float activeTime = 0.3f;     // å›é¿ã®æœ‰åŠ¹æ™‚é–“
		float coolTime = 1.0f;       // å›é¿ã®ã‚¯ãƒ¼ãƒ«ã‚¿ã‚¤ãƒ 
		float invincibleTime = 0.01f; // å›é¿æ™‚ã®ç„¡æ•µæ™‚é–“
	};

	/// ===æ›´æ–°ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ=== ///
	struct UpdateContext {
		Vector3 inputDirection; // å…¥åŠ›æ–¹å‘
		float deltaTime;        // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	};

	/// ===æ›´æ–°çµæœ=== ///
	struct UpdateResult {
		Vector3 velocity; // å›é¿ãƒ™ã‚¯ãƒˆãƒ«
	};

public:

	PlayerAvoidanceComponent() = default;
	~PlayerAvoidanceComponent() = default;

	// ã‚³ãƒ”ãƒ¼ãƒ»ãƒ ãƒ¼ãƒ–ã¯æ˜ç¤ºçš„ã«åˆ¶å¾¡
	PlayerAvoidanceComponent(const PlayerAvoidanceComponent&) = delete;
	PlayerAvoidanceComponent& operator=(const PlayerAvoidanceComponent&) = delete;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="config">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹è¨­å®šã‚’ const å‚ç…§ã§å—ã‘å–ã‚‹ã€‚çœç•¥ã—ãŸå ´åˆã¯ AvoidanceConfig{} ã«ã‚ˆã‚‹æ—¢å®šè¨­å®šãŒä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	void Initialize(const AvoidanceConfig& config = AvoidanceConfig{});

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="context">æ›´æ–°ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¤ºã™ UpdateContext ã® const å‚ç…§ã€‚</param>
	/// <returns>æ›´æ–°çµæœã‚’å«ã‚€ UpdateResult æ§‹é€ ä½“ã€‚</returns>
	UpdateResult Update(const UpdateContext& context);

	/// <summary>
	///ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="deltaTime">å‰å›ã®æ›´æ–°ã‹ã‚‰ã®çµŒéæ™‚é–“ï¼ˆç§’å˜ä½ï¼‰</param>
	void UpdateTimer(const float deltaTime);

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information();

	/// <summary>
	/// å›é¿å‡¦ç†ã®é–‹å§‹
	/// </summary>
	void StartAvoidance();

	/// <summary>
	/// çŠ¶æ…‹ã®ãƒªã‚»ãƒƒãƒˆ
	/// </summary>
	void ResetState();

public: /// ===Getter=== ///

	// AvoidanceConfig
	const AvoidanceConfig& GetConfig() const { return config_; }
	// AvoidanceState
	const AvoidanceState& GetState() const { return state_; }

private:

	/// ===æƒ…å ±=== ///
	AvoidanceConfig config_;
	AvoidanceState state_;

	// åŠ é€Ÿåº¦
	float acceleration_ = 0.0f;
	// æ–¹å‘
	Vector3 direction_{ 0.0f, 0.0f, 0.0f };
};



============================================================
File Path: Project/application/Game/Entity/Player/Component/PlayerMoveComponent.cpp
============================================================
#include "PlayerMoveComponent.h"
// Math
#include "Math/sMath.h"
// C++
#include <cassert>
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
void PlayerMoveComponent::Initialize(const MoveConfig& config) {
	// è¨­å®šã®åˆæœŸåŒ–
	config_ = config;

	// ç¾åœ¨ã®ç§»å‹•æ–¹å‘ã®åˆæœŸåŒ–
	currentDirection_ = { 0.0f, 0.0f, 0.0f };
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
PlayerMoveComponent::UpdateResult PlayerMoveComponent::Update(const UpdateContext & context) {
	
	UpdateResult result{};

	/// ===å€¤ã®å–å¾—=== ///
	currentDirection_ = context.inputDirection;

	/// ===Velocityã«åæ˜ === ///
	result.velocity = currentDirection_ * config_.speed;

	/// ===ç§»å‹•æ–¹å‘ã«æ²¿ã£ã¦å›è»¢=== ///
	// æ–¹å‘ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰
	if (Length(currentDirection_) > 0.01f) {
		// ç¾åœ¨ã®Yawè§’(Yè»¸ã®å›è»¢)ã‚’å–å¾—
		float currentYaw = Math::GetYAngle(context.currentRotation);
		// å…¥åŠ›æ–¹å‘ã‹ã‚‰ç›®æ¨™ã®Yawè§’ã‚’å–å¾—
		float targetYaw = std::atan2(currentDirection_.x, currentDirection_.z);
		// å·®åˆ†ã‚’ [-Ï€, Ï€] ã«æ­£è¦åŒ– 
		float diff = Math::NormalizeAngle(targetYaw - currentYaw);
		// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°è£œé–“ï¼ˆçŸ­ã„æ–¹å‘ã¸å›è»¢ï¼‰
		float easedYaw = currentYaw + diff * (context.deltaTime * 10.0f);
		// Quaternionã«å†å¤‰æ›
		result.targetRotation = Math::MakeRotateAxisAngle({ 0, 1, 0 }, easedYaw);
	} else {
		// å…¥åŠ›ãŒãªã„å ´åˆã¯ç¾åœ¨ã®å›è»¢ã‚’ç¶­æŒ
		result.targetRotation = context.currentRotation;
	}

	return result;
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®è¡¨ç¤º
///-------------------------------------------///
void PlayerMoveComponent::Information() {
#ifdef USE_IMGUI
	if (ImGui::TreeNode("ç§»å‹•æƒ…å ±")) {
		ImGui::DragFloat("ç§»å‹•é€Ÿåº¦", &config_.speed, 0.01f);
		ImGui::DragFloat("å›è»¢é€Ÿåº¦", &config_.rotationSpeed, 0.01f);
		ImGui::DragFloat("æ¸›é€Ÿç‡", &config_.deceleration, 0.01f, 0.0f, 1.0f);

		ImGui::Separator();
		ImGui::Text("ç¾åœ¨ã®ç§»å‹•æ–¹å‘");
		ImGui::Text("X: %.2f", currentDirection_.x);
		ImGui::Text("Y: %.2f", currentDirection_.y);
		ImGui::Text("Z: %.2f", currentDirection_.z);
		ImGui::TreePop();
	}
#endif // USE_IMGUI
}

============================================================
File Path: Project/application/Game/Entity/Player/Component/PlayerMoveComponent.h
============================================================
#pragma once
/// ===Include=== ///
#include "Math/Vector3.h"
#include "Math/Quaternion.h"

///=====================================================/// 
/// PlayerMoveComponentï¼ˆç§»å‹•ï¼‰
///=====================================================///
class PlayerMoveComponent {
public:
	/// ===ç§»å‹•è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®æ§‹é€ ä½“=== ///
	struct MoveConfig {
		float speed = 0.5f;			 // ç§»å‹•é€Ÿåº¦
		float rotationSpeed = 0.15f; // å›è»¢é€Ÿåº¦
		float deceleration = 0.95f;   // æ¸›é€Ÿç‡
	};

	/// ===æ›´æ–°ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ=== ///
	struct UpdateContext {
		Vector3 inputDirection;		// å…¥åŠ›æ–¹å‘
		Vector3 currentPosition;	// ç¾åœ¨ã®ä½ç½®
		Quaternion currentRotation; // ç¾åœ¨ã®å›è»¢
		float deltaTime;			// ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	};

	/// ===æ›´æ–°çµæœ=== ///
	struct UpdateResult {
		Vector3 velocity;		    // ç§»å‹•ãƒ™ã‚¯ãƒˆãƒ«
		Quaternion targetRotation; // ç›®æ¨™å›è»¢
	};

public:

	PlayerMoveComponent() = default;
	~PlayerMoveComponent() = default;

	// ã‚³ãƒ”ãƒ¼ãƒ»ãƒ ãƒ¼ãƒ–ã¯æ˜ç¤ºçš„ã«åˆ¶å¾¡
	PlayerMoveComponent(const PlayerMoveComponent&) = delete;
	PlayerMoveComponent& operator=(const PlayerMoveComponent&) = delete;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="config">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹è¨­å®šã‚’ const å‚ç…§ã§å—ã‘å–ã‚‹ã€‚çœç•¥ã—ãŸå ´åˆã¯ MoveConfig{} ã«ã‚ˆã‚‹æ—¢å®šè¨­å®šãŒä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	void Initialize(const MoveConfig& config = MoveConfig{});

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="context">æ›´æ–°ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç¤ºã™ UpdateContext ã® const å‚ç…§ã€‚</param>
	/// <returns>æ›´æ–°çµæœã‚’å«ã‚€ UpdateResult æ§‹é€ ä½“ã€‚</returns>
	UpdateResult Update(const UpdateContext& contex);

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information();

public: /// ===Getter=== ///
	// MoveConfig
	const MoveConfig& GetConfig() const { return config_; }
	// CurrentDirection
	const Vector3& GetCurrentDirection() const { return currentDirection_; }

private:

	/// ===æƒ…å ±=== ///
	MoveConfig config_;
	// ç¾åœ¨ã®ç§»å‹•æ–¹å‘
	Vector3 currentDirection_ = { 0.0f, 0.0f, 0.0f };
};



============================================================
File Path: Project/application/Game/Entity/Player/Editor/AttackDataSerializer.cpp
============================================================
#include "AttackDataSerializer.h"
#include <fstream>
#include <json.hpp>

using json = nlohmann::json;

///-------------------------------------------/// 
/// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã®Jsonä¿å­˜ãƒ»èª­ã¿è¾¼ã¿
///-------------------------------------------///
bool AttackDataSerializer::SaveToJson(const AttackData& data, const std::string& filepath) {
    try {
        json j;

        // åŸºæœ¬æƒ…å ±
        j["attackName"] = data.attackName;
        j["description"] = data.description;
        j["attackID"] = data.attackID;

        // ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®š
        j["activeDuration"] = data.activeDuration;
        j["comboWindowTime"] = data.comboWindowTime;
        j["cooldownTime"] = data.cooldownTime;

        // è»Œé“è¨­å®š
        j["curveSegments"] = data.curveSegments;
        j["weaponLength"] = data.weaponLength;

        // ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹
        json trajectoryArray = json::array();
        for (const auto& point : data.trajectoryPoints) {
            json pointJson;
            pointJson["position"] = { point.position.x, point.position.y, point.position.z };
            pointJson["time"] = point.time;
            trajectoryArray.push_back(pointJson);
        }
        j["trajectoryPoints"] = trajectoryArray;

        // å›è»¢è¨­å®š
        j["startRotation"] = { data.startRotation.x, data.startRotation.y, data.startRotation.z, data.startRotation.w };
        j["endRotation"] = { data.endRotation.x, data.endRotation.y, data.endRotation.z, data.endRotation.w };
        j["useRotationCurve"] = data.useRotationCurve;

        // ã‚³ãƒ³ãƒœè¨­å®š
        j["canComboToNext"] = data.canComboToNext;
        j["nextComboID"] = data.nextComboID;
        j["branchComboIDs"] = data.branchComboIDs;

        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š
        j["particleEffectName"] = data.particleEffectName;
        j["particleOffset"] = { data.particleOffset.x, data.particleOffset.y, data.particleOffset.z };
        j["cameraShakeIntensity"] = data.cameraShakeIntensity;
        j["cameraShakeDuration"] = data.cameraShakeDuration;

        // ã‚µã‚¦ãƒ³ãƒ‰è¨­å®š
        j["swingSoundName"] = data.swingSoundName;
        j["hitSoundName"] = data.hitSoundName;

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹•ã
        j["moveSpeedMultiplier"] = data.moveSpeedMultiplier;
        j["rootMotion"] = { data.rootMotion.x, data.rootMotion.y, data.rootMotion.z };

        // ãƒ‡ãƒãƒƒã‚°
        j["showTrajectory"] = data.showTrajectory;
        j["trajectoryColor"] = { data.trajectoryColor.x, data.trajectoryColor.y, data.trajectoryColor.z };

        // ãƒ•ã‚¡ã‚¤ãƒ«ã«æ›¸ãè¾¼ã¿
        std::ofstream file(filepath);
        if (!file.is_open()) {
            return false;
        }
        file << j.dump(4); // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ4ã§ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
        file.close();

        return true;

    } catch (const std::exception&) {
        return false;
    }
}

///-------------------------------------------/// 
/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
///-------------------------------------------///
bool AttackDataSerializer::LoadFromJson(AttackData& data, const std::string& filepath) {
    try {
        std::ifstream file(filepath);
        if (!file.is_open()) {
            return false;
        }

        json j;
        file >> j;
        file.close();

        // åŸºæœ¬æƒ…å ±
        data.attackName = j.value("attackName", "Unknown");
        data.description = j.value("description", "");
        data.attackID = j.value("attackID", 0);

        // ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®š
        data.activeDuration = j.value("activeDuration", 0.4f);
        data.comboWindowTime = j.value("comboWindowTime", 1.0f);
        data.cooldownTime = j.value("cooldownTime", 0.3f);

        // è»Œé“è¨­å®š
        data.curveSegments = j.value("curveSegments", 20);
        data.weaponLength = j.value("weaponLength", 8.0f);

        // ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹
        data.trajectoryPoints.clear();
        if (j.contains("trajectoryPoints")) {
            for (const auto& pointJson : j["trajectoryPoints"]) {
                BezierControlPointData point;
                point.position.x = pointJson["position"][0];
                point.position.y = pointJson["position"][1];
                point.position.z = pointJson["position"][2];
                point.time = pointJson["time"];
                data.trajectoryPoints.push_back(point);
            }
        }

        // å›è»¢è¨­å®š
        if (j.contains("startRotation")) {
            data.startRotation.x = j["startRotation"][0];
            data.startRotation.y = j["startRotation"][1];
            data.startRotation.z = j["startRotation"][2];
            data.startRotation.w = j["startRotation"][3];
        }
        if (j.contains("endRotation")) {
            data.endRotation.x = j["endRotation"][0];
            data.endRotation.y = j["endRotation"][1];
            data.endRotation.z = j["endRotation"][2];
            data.endRotation.w = j["endRotation"][3];
        }
        data.useRotationCurve = j.value("useRotationCurve", false);

        // ã‚³ãƒ³ãƒœè¨­å®š
        data.canComboToNext = j.value("canComboToNext", false);
        data.nextComboID = j.value("nextComboID", -1);
        if (j.contains("branchComboIDs")) {
            data.branchComboIDs = j["branchComboIDs"].get<std::vector<int>>();
        }

        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š
        data.particleEffectName = j.value("particleEffectName", "");
        if (j.contains("particleOffset")) {
            data.particleOffset.x = j["particleOffset"][0];
            data.particleOffset.y = j["particleOffset"][1];
            data.particleOffset.z = j["particleOffset"][2];
        }
        data.cameraShakeIntensity = j.value("cameraShakeIntensity", 0.0f);
        data.cameraShakeDuration = j.value("cameraShakeDuration", 0.0f);

        // ã‚µã‚¦ãƒ³ãƒ‰è¨­å®š
        data.swingSoundName = j.value("swingSoundName", "");
        data.hitSoundName = j.value("hitSoundName", "");

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹•ã
        data.moveSpeedMultiplier = j.value("moveSpeedMultiplier", 0.4f);
        if (j.contains("rootMotion")) {
            data.rootMotion.x = j["rootMotion"][0];
            data.rootMotion.y = j["rootMotion"][1];
            data.rootMotion.z = j["rootMotion"][2];
        }

        // ãƒ‡ãƒãƒƒã‚°
        data.showTrajectory = j.value("showTrajectory", true);
        if (j.contains("trajectoryColor")) {
            data.trajectoryColor.x = j["trajectoryColor"][0];
            data.trajectoryColor.y = j["trajectoryColor"][1];
            data.trajectoryColor.z = j["trajectoryColor"][2];
        }

        return true;

    } catch (const std::exception&) {
        return false;
    }
}


============================================================
File Path: Project/application/Game/Entity/Player/Editor/AttackDataSerializer.h
============================================================
#pragma once
/// ===Include=== ///
#include "Data/AttackData.h"
#include <string>

///=====================================================/// 
/// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã®Jsonä¿å­˜ãƒ»èª­ã¿è¾¼ã¿ã‚¯ãƒ©ã‚¹
///=====================================================///
class AttackDataSerializer {
public:

    /// <summary>
    /// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    /// </summary>
    /// <param name="data">ä¿å­˜ã™ã‚‹æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã¸ã® const å‚ç…§</param>
    /// <param name="filepath">ä¿å­˜å…ˆã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <returns>ä¿å­˜ã«æˆåŠŸã—ãŸã‚‰ trueã€å¤±æ•—ã—ãŸã‚‰ false</returns>
	static bool SaveToJson(const AttackData& data, const std::string& filepath);

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
    /// </summary>
    /// <param name="data">èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‚’æ ¼ç´ã™ã‚‹ AttackData ã¸ã®å‚ç…§</param>
    /// <param name="filepath">èª­ã¿è¾¼ã¿å…ƒã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹</param>
    /// <returns>èª­ã¿è¾¼ã¿ã«æˆåŠŸã—ãŸã‚‰ trueã€å¤±æ•—ã—ãŸã‚‰ false</returns>
    static bool LoadFromJson(AttackData& data, const std::string& filepath);
};



============================================================
File Path: Project/application/Game/Entity/Player/Editor/AttackEditor.cpp
============================================================
#include "AttackEditor.h"
// PlayerWeapon
#include "application/Game/Entity/Player/Weapon/PlayerWeapon.h"
// Service
#include "Engine/System/Service/ServiceLocator.h"
// Line
#include "Engine/Graphics/3d/Line/LineObject3D.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif

#include <filesystem>

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
AttackEditor::~AttackEditor() {
    line_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void AttackEditor::Initialize() {
    // Lineã®åˆæœŸåŒ–
    line_ = std::make_unique<Line>();

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¨­å®š
    strcpy_s(filePathBuffer_, kDefaultSavePath);

    // åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆã‚’æ›´æ–°
    UpdateAvailablePresets();

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
    CreateNew();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void AttackEditor::Update(const float deltaTime) {
    if (!isVisible_) return;

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®æ›´æ–°
    if (isPlaying_) {
        UpdateTrajectoryPreview(deltaTime);
    }
}

///-------------------------------------------/// 
/// ImGuiæç”»
///-------------------------------------------///
void AttackEditor::Render() {
#ifdef USE_IMGUI
    if (!isVisible_) return;

    ImGui::Begin("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ”»æ’ƒã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼", &isVisible_, ImGuiWindowFlags_MenuBar);

    // ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼
    RenderMenuBar();

    // å·¦å´ï¼šæ”»æ’ƒãƒªã‚¹ãƒˆ
    ImGui::BeginChild("AttackList", ImVec2(250, 0), true);
    RenderAttackList();
    ImGui::EndChild();

    ImGui::SameLine();

    // å³å´ï¼šç·¨é›†ãƒ‘ãƒãƒ«
    ImGui::BeginChild("EditPanel", ImVec2(0, 0), true);
    if (selectedAttackIndex_ >= 0 && selectedAttackIndex_ < static_cast<int>(attacks_.size())) {
        AttackData& currentAttack = attacks_[selectedAttackIndex_];

        // ã‚¿ãƒ–ã§åˆ†å‰²
        if (ImGui::BeginTabBar("AttackEditorTabs")) {

            if (ImGui::BeginTabItem("åŸºæœ¬è¨­å®š")) {
                RenderBasicSettings(currentAttack);
                ImGui::EndTabItem();
            }

            if (ImGui::BeginTabItem("ã‚¿ã‚¤ãƒŸãƒ³ã‚°")) {
                RenderTimingSettings(currentAttack);
                ImGui::EndTabItem();
            }

            if (ImGui::BeginTabItem("è»Œé“")) {
                RenderTrajectorySettings(currentAttack);
                ImGui::EndTabItem();
            }

            if (ImGui::BeginTabItem("ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ")) {
                RenderEffectSettings(currentAttack);
                ImGui::EndTabItem();
            }

            if (ImGui::BeginTabItem("ã‚³ãƒ³ãƒœ")) {
                RenderComboSettings(currentAttack);
                ImGui::EndTabItem();
            }

            ImGui::EndTabBar();
        }

        ImGui::Separator();

        // ä¿å­˜ãƒœã‚¿ãƒ³ç¾¤
        if (ImGui::Button("ä¸Šæ›¸ãä¿å­˜ (Ctrl+S)", ImVec2(-1, 0))) {
            SaveCurrent();
        }

        if (ImGui::Button("åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜", ImVec2(-1, 0))) {
            SaveCurrentAs();
        }

        // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹è¡¨ç¤º
        auto it = attackFilePaths_.find(currentAttack.attackID);
        if (it != attackFilePaths_.end()) {
            ImGui::Separator();
            ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), "ä¿å­˜å…ˆ:");
            ImGui::TextWrapped("%s", it->second.c_str());
        } else {
            ImGui::Separator();
            ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "æœªä¿å­˜");
        }

    } else {
        ImGui::Text("æ”»æ’ƒã‚’é¸æŠã—ã¦ãã ã•ã„");
    }
    ImGui::EndChild();

    ImGui::End();

    // ===ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ç¾¤=== ///

    // ä¿å­˜ã‚¨ãƒ©ãƒ¼
    if (ImGui::BeginPopupModal("ä¿å­˜ã‚¨ãƒ©ãƒ¼", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("ã‚¨ãƒ©ãƒ¼: æ”»æ’ƒåãŒå…¥åŠ›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚");
        ImGui::Separator();
        ImGui::Text("æ”»æ’ƒã‚’ä¿å­˜ã™ã‚‹ã«ã¯ã€ã€ŒåŸºæœ¬è¨­å®šã€ã‚¿ãƒ–ã§");
        ImGui::Text("æ”»æ’ƒåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚");

        ImGui::Spacing();
        if (ImGui::Button("OK", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }

    // ä¿å­˜æˆåŠŸ
    if (ImGui::BeginPopupModal("ä¿å­˜æˆåŠŸ", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
        if (selectedAttackIndex_ >= 0 && selectedAttackIndex_ < static_cast<int>(attacks_.size())) {
            AttackData& currentAttack = attacks_[selectedAttackIndex_];

            ImGui::Text("ä¿å­˜ãŒå®Œäº†ã—ã¾ã—ãŸã€‚");

            auto it = attackFilePaths_.find(currentAttack.attackID);
            if (it != attackFilePaths_.end()) {
                ImGui::Separator();
                ImGui::TextWrapped("ãƒ•ã‚¡ã‚¤ãƒ«:  %s", it->second.c_str());
            }
        }

        ImGui::Spacing();
        if (ImGui::Button("OK", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }

    // ä¿å­˜å¤±æ•—
    if (ImGui::BeginPopupModal("ä¿å­˜å¤±æ•—", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«ã®ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸã€‚");
        ImGui::Separator();
        ImGui::Text("ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚");

        ImGui::Spacing();
        if (ImGui::Button("OK", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }

    // ä¸Šæ›¸ãç¢ºèª
    if (ImGui::BeginPopupModal("ä¸Šæ›¸ãç¢ºèª", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™ã€‚");
        ImGui::Text("ä¸Šæ›¸ãã—ã¾ã™ã‹ï¼Ÿ");

        ImGui::Spacing();
        if (ImGui::Button("ã¯ã„", ImVec2(120, 0))) {
            if (selectedAttackIndex_ >= 0 && selectedAttackIndex_ < static_cast<int>(attacks_.size())) {
                AttackData& currentAttack = attacks_[selectedAttackIndex_];
                std::string savePath = std::string(kDefaultSavePath) + currentAttack.attackName + ".json";

                if (serializer_->SaveToJson(currentAttack, savePath)) {
                    attackFilePaths_[currentAttack.attackID] = savePath;
                    ImGui::OpenPopup("ä¿å­˜æˆåŠŸ");
                } else {
                    ImGui::OpenPopup("ä¿å­˜å¤±æ•—");
                }
            }
            ImGui::CloseCurrentPopup();
        }
        ImGui::SameLine();
        if (ImGui::Button("ã„ã„ãˆ", ImVec2(120, 0))) {
            ImGui::CloseCurrentPopup();
        }
        ImGui::EndPopup();
    }

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    RenderPreviewControl();
#endif
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»
///-------------------------------------------///
void AttackEditor::DrawPreview() {
    if (!isVisible_ || selectedAttackIndex_ < 0 || selectedAttackIndex_ >= static_cast<int>(attacks_.size())) {
        return;
    }

    AttackData& currentAttack = attacks_[selectedAttackIndex_];

    if (!currentAttack.showTrajectory) {
        return;
    }

    // æ­¦å™¨ä½ç½®ã‚’åŸºæº–ã«ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›
    Vector3 weaponPos = previewWeaponPosition_;
    std::vector<BezierControlPointData> worldPoints;

    for (const auto& point : currentAttack.trajectoryPoints) {
        BezierControlPointData worldPoint = {};
        worldPoint.position = weaponPos + point.position;
        worldPoint.time = point.time;
        worldPoints.push_back(worldPoint);
    }

    // ãƒ™ã‚¸ã‚§æ›²ç·šã‚’æç”»
    Vector4 trajectoryColor{ currentAttack.trajectoryColor.x, currentAttack.trajectoryColor.y, currentAttack.trajectoryColor.z, 1.0f };
    line_->CreateSmoothCurve(worldPoints, trajectoryColor, currentAttack.curveSegments);

    // åˆ¶å¾¡ç‚¹ã‚’å¯è¦–åŒ–
    ServiceLocator::GetLineObject3D()->DrawBezierControlPoints(
        worldPoints,
        Vector4{ 1.0f, 1.0f, 0.0f, 1.0f },  // é»„è‰²
        Vector4{ 0.5f, 0.5f, 0.5f, 0.5f },  // åŠé€æ˜ã‚°ãƒ¬ãƒ¼
        0.3f
    );

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨æ­¦å™¨ã®æç”»ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    if (previewWeapon_ && isPlaying_) {
        previewWeapon_->Draw(BlendMode::KBlendModeNormal);
    }
}

///-------------------------------------------/// 
/// è¡¨ç¤º/éè¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
///-------------------------------------------///
void AttackEditor::ToggleVisibility() {
    isVisible_ = !isVisible_;
}

///-------------------------------------------/// 
/// è¡¨ç¤ºçŠ¶æ…‹ã‚’è¨­å®š
///-------------------------------------------///
void AttackEditor::SetVisible(bool visible) {
    isVisible_ = visible;
}

///-------------------------------------------/// 
/// é¸æŠä¸­ã®æ”»æ’ƒã‚’ä¸Šæ›¸ãä¿å­˜
///-------------------------------------------///
void AttackEditor::SaveCurrent() {
#ifdef USE_IMGUI
    if (selectedAttackIndex_ < 0 || selectedAttackIndex_ >= static_cast<int>(attacks_.size())) {
        return;
    }

    AttackData& currentAttack = attacks_[selectedAttackIndex_];

    // åå‰ãƒã‚§ãƒƒã‚¯
    if (currentAttack.attackName.empty()) {
        ImGui::OpenPopup("ä¿å­˜ã‚¨ãƒ©ãƒ¼");
        return;
    }

    // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’å–å¾—ã¾ãŸã¯ç”Ÿæˆ
    std::string savePath;

    auto it = attackFilePaths_.find(currentAttack.attackID);
    if (it != attackFilePaths_.end()) {
        // æ—¢å­˜ã®ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ãŒã‚ã‚Œã°ä¸Šæ›¸ã
        savePath = it->second;
    } else {
        // æ–°è¦ã®å ´åˆã¯æ–°ã—ã„ãƒ‘ã‚¹ã‚’ç”Ÿæˆ
        savePath = std::string(kDefaultSavePath) + currentAttack.attackName + ".json";
        attackFilePaths_[currentAttack.attackID] = savePath;
    }

    // ä¿å­˜å®Ÿè¡Œ
    if (serializer_->SaveToJson(currentAttack, savePath)) {
        ImGui::OpenPopup("ä¿å­˜æˆåŠŸ");
    } else {
        ImGui::OpenPopup("ä¿å­˜å¤±æ•—");
    }
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// é¸æŠä¸­ã®æ”»æ’ƒã‚’åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜
///-------------------------------------------///
void AttackEditor::SaveCurrentAs() {
#ifdef USE_IMGUI
    if (selectedAttackIndex_ < 0 || selectedAttackIndex_ >= static_cast<int>(attacks_.size())) {
        return;
    }

    AttackData& currentAttack = attacks_[selectedAttackIndex_];

    // åå‰ãƒã‚§ãƒƒã‚¯
    if (currentAttack.attackName.empty()) {
        ImGui::OpenPopup("ä¿å­˜ã‚¨ãƒ©ãƒ¼");
        return;
    }

    // å¸¸ã«æ–°ã—ã„ãƒ•ã‚¡ã‚¤ãƒ«åã§ä¿å­˜
    std::string savePath = std::string(kDefaultSavePath) + currentAttack.attackName + ".json";

    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ç¢ºèª
    if (std::filesystem::exists(savePath)) {
        ImGui::OpenPopup("ä¸Šæ›¸ãç¢ºèª");
        return;
    }

    // ä¿å­˜å®Ÿè¡Œ
    if (serializer_->SaveToJson(currentAttack, savePath)) {
        // æ–°ã—ã„ãƒ‘ã‚¹ã‚’è¨˜éŒ²
        attackFilePaths_[currentAttack.attackID] = savePath;
        ImGui::OpenPopup("ä¿å­˜æˆåŠŸ");
    } else {
        ImGui::OpenPopup("ä¿å­˜å¤±æ•—");
    }
#endif // USE_IMGUI
}


///-------------------------------------------/// 
/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
///-------------------------------------------///
void AttackEditor::SaveToJson() {
    SaveCurrent();
}

///-------------------------------------------/// 
/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
///-------------------------------------------///
void AttackEditor::LoadFromJson() {

}

///-------------------------------------------/// 
/// æ–°è¦ä½œæˆ
///-------------------------------------------///
void AttackEditor::CreateNew() {
    AttackData newAttack;
    newAttack.attackName = "NewAttack_" + std::to_string(static_cast<int>(attacks_.size()));
    newAttack.attackID = static_cast<int>(attacks_.size());
    attacks_.push_back(newAttack);
    selectedAttackIndex_ = static_cast<int>(attacks_.size()) - 1;
}

///-------------------------------------------/// 
/// å…¨ã¦ã®æ”»æ’ƒã‚’ä¿å­˜
///-------------------------------------------///
void AttackEditor::SaveAllAttacks() {
    int successCount = 0;
    int failCount = 0;

    for (const auto& attack : attacks_) {
        // åå‰ãŒç©ºã®æ”»æ’ƒã¯ã‚¹ã‚­ãƒƒãƒ—
        if (attack.attackName.empty()) {
            failCount++;
            continue;
        }

        std::string savePath = std::string(kDefaultSavePath) + attack.attackName + ".json";
        if (serializer_->SaveToJson(attack, savePath)) {
            successCount++;
        } else {
            failCount++;
        }
    }

#ifdef USE_IMGUI
    // çµæœã‚’è¡¨ç¤º
    if (failCount > 0) {
        ImGui::OpenPopup("ä¸€æ‹¬ä¿å­˜çµæœ");
    }
#endif
}

///-------------------------------------------/// 
/// ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å…¨JSONã‚’èª­ã¿è¾¼ã¿
///-------------------------------------------///
void AttackEditor::LoadAllAttacks() {
    attacks_.clear();
    attackFilePaths_.clear();  // â† ã‚¯ãƒªã‚¢

    if (!std::filesystem::exists(kDefaultSavePath)) {
        return;
    }

    for (const auto& entry : std::filesystem::directory_iterator(kDefaultSavePath)) {
        if (entry.path().extension() == ".json") {
            AttackData data;
            std::string filepath = entry.path().string();

            if (serializer_->LoadFromJson(data, filepath)) {
                attacks_.push_back(data);

                // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’è¨˜éŒ²
                attackFilePaths_[data.attackID] = filepath;
            }
        }
    }
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿé–‹å§‹
///-------------------------------------------///
void AttackEditor::PlayPreview() {
    isPlaying_ = true;
    previewTimer_ = 0.0f;
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åœæ­¢
///-------------------------------------------///
void AttackEditor::StopPreview() {
    isPlaying_ = false;
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ
///-------------------------------------------///
void AttackEditor::ResetPreview() {
    previewTimer_ = 0.0f;
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
///-------------------------------------------///
void AttackEditor::RenderMenuBar() {
#ifdef USE_IMGUI
    if (ImGui::BeginMenuBar()) {
        if (ImGui::BeginMenu("ãƒ•ã‚¡ã‚¤ãƒ«")) {
            if (ImGui::MenuItem("æ–°è¦ä½œæˆ", "Ctrl+N")) {
                CreateNew();
            }

            ImGui::Separator();

            // ä¸Šæ›¸ãä¿å­˜
            bool canSave = (selectedAttackIndex_ >= 0 &&
                selectedAttackIndex_ < static_cast<int>(attacks_.size()) &&
                !attacks_[selectedAttackIndex_].attackName.empty());

            if (ImGui::MenuItem("ä¸Šæ›¸ãä¿å­˜", "Ctrl+S", false, canSave)) {
                SaveCurrent();
            }

            if (!canSave && ImGui::IsItemHovered()) {
                ImGui::SetTooltip("ä¿å­˜ã™ã‚‹ã«ã¯æ”»æ’ƒåã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
            }

            // åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜
            if (ImGui::MenuItem("åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜", "Ctrl+Shift+S", false, canSave)) {
                SaveCurrentAs();
            }

            ImGui::Separator();

            if (ImGui::MenuItem("å…¨ã¦ä¿å­˜")) {
                SaveAllAttacks();
            }

            ImGui::Separator();

            if (ImGui::MenuItem("é–‹ã", "Ctrl+O")) {
                LoadFromJson();
            }
            if (ImGui::MenuItem("å…¨ã¦èª­ã¿è¾¼ã¿")) {
                LoadAllAttacks();
            }

            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("ç·¨é›†")) {
            if (ImGui::MenuItem("å‰Šé™¤", nullptr, false, selectedAttackIndex_ >= 0)) {
                DeleteSelectedAttack();
            }
            if (ImGui::MenuItem("è¤‡è£½", nullptr, false, selectedAttackIndex_ >= 0)) {
                DuplicateSelectedAttack();
            }
            ImGui::EndMenu();
        }

        ImGui::EndMenuBar();
    }
#endif
}

///-------------------------------------------/// 
/// æ”»æ’ƒãƒªã‚¹ãƒˆã®æç”»
///-------------------------------------------///
void AttackEditor::RenderAttackList() {
#ifdef USE_IMGUI
    ImGui::Text("æ”»æ’ƒãƒªã‚¹ãƒˆ");
    ImGui::Separator();

    for (int i = 0; i < static_cast<int>(attacks_.size()); ++i) {
        bool isSelected = (selectedAttackIndex_ == i);
        if (ImGui::Selectable(attacks_[i].attackName.c_str(), isSelected)) {
            selectedAttackIndex_ = i;
        }
    }

    ImGui::Separator();
    if (ImGui::Button("+ æ–°è¦è¿½åŠ ", ImVec2(-1, 0))) {
        CreateNew();
    }
#endif
}

///-------------------------------------------/// 
/// åŸºæœ¬è¨­å®šUIã®æç”»
///-------------------------------------------///
void AttackEditor::RenderBasicSettings(AttackData& data) {
    data;
#ifdef USE_IMGUI
    ImGui::SeparatorText("åŸºæœ¬æƒ…å ±");

    char nameBuffer[256];
    strncpy_s(nameBuffer, data.attackName.c_str(), sizeof(nameBuffer));

    // åå‰ãŒç©ºã®å ´åˆã¯è­¦å‘Šè‰²ã§è¡¨ç¤º
    if (data.attackName.empty()) {
        ImGui::PushStyleColor(ImGuiCol_FrameBg, ImVec4(0.6f, 0.2f, 0.2f, 0.5f)); // èµ¤ã£ã½ã„èƒŒæ™¯
        ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(1.0f, 1.0f, 0.0f, 1.0f));    // é»„è‰²ã„ãƒ†ã‚­ã‚¹ãƒˆ
    }

    if (ImGui::InputText("æ”»æ’ƒå", nameBuffer, sizeof(nameBuffer))) {
        data.attackName = nameBuffer;
    }

    if (data.attackName.empty()) {
        ImGui::PopStyleColor(2);

        // ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆ
        ImGui::SameLine();
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "(*)");
        if (ImGui::IsItemHovered()) {
            ImGui::SetTooltip("ä¿å­˜ã™ã‚‹ã«ã¯æ”»æ’ƒåãŒå¿…è¦ã§ã™");
        }
    }

    char descBuffer[512];
    strncpy_s(descBuffer, data.description.c_str(), sizeof(descBuffer));
    if (ImGui::InputTextMultiline("èª¬æ˜", descBuffer, sizeof(descBuffer), ImVec2(-1, 60))) {
        data.description = descBuffer;
    }

    ImGui::InputInt("æ”»æ’ƒID", &data.attackID);

    ImGui::SeparatorText("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹•ã");
    ImGui::SliderFloat("ç§»å‹•é€Ÿåº¦å€ç‡", &data.moveSpeedMultiplier, 0.0f, 1.0f, "%.2f");
    ImGui::DragFloat3("ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³", &data.rootMotion.x, 0.1f);
#endif
}

///-------------------------------------------/// 
/// ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®šUIã®æç”»
///-------------------------------------------///
void AttackEditor::RenderTimingSettings(AttackData& data) {
    data;
#ifdef USE_IMGUI
    ImGui::SeparatorText("ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®š");
    ImGui::DragFloat("æ”»æ’ƒæ™‚é–“ (ç§’)", &data.activeDuration, 0.01f, 0.01f, 10.0f, "%.2f");
    ImGui::DragFloat("ã‚³ãƒ³ãƒœå—ä»˜æ™‚é–“ (ç§’)", &data.comboWindowTime, 0.01f, 0.0f, 5.0f, "%.2f");
    ImGui::DragFloat("ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ (ç§’)", &data.cooldownTime, 0.01f, 0.0f, 5.0f, "%.2f");
#endif
}

///-------------------------------------------/// 
/// è»Œé“è¨­å®šUIã®æç”»
///-------------------------------------------///
void AttackEditor::RenderTrajectorySettings(AttackData& data) {
    data;
#ifdef USE_IMGUI
    ImGui::SeparatorText("ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹");

    ImGui::DragFloat("æ­¦å™¨ã®è·é›¢", &data.weaponLength, 0.1f, 1.0f, 50.0f);
    ImGui::DragInt("æ›²ç·šã®åˆ†å‰²æ•°", &data.curveSegments, 1, 5, 100);

    // åˆ¶å¾¡ç‚¹ãƒªã‚¹ãƒˆ
    for (int i = 0; i < static_cast<int>(data.trajectoryPoints.size()); ++i) {
        ImGui::PushID(i);

        ImGui::Text("åˆ¶å¾¡ç‚¹ %d", i);
        ImGui::DragFloat3("ä½ç½®", &data.trajectoryPoints[i].position.x, 0.1f);
        ImGui::SliderFloat("æ™‚é–“", &data.trajectoryPoints[i].time, 0.0f, 1.0f, "%.2f");

        ImGui::SameLine();
        if (ImGui::Button("å‰Šé™¤") && data.trajectoryPoints.size() > 2) {
            data.trajectoryPoints.erase(data.trajectoryPoints.begin() + i);
            ImGui::PopID();
            break;
        }

        ImGui::Separator();
        ImGui::PopID();
    }

    if (ImGui::Button("+ åˆ¶å¾¡ç‚¹ã‚’è¿½åŠ ")) {
        BezierControlPointData newPoint = {};
        newPoint.position = Vector3{ 0.0f, 0.0f, 0.0f };
        newPoint.time = 0.5f;
        data.trajectoryPoints.push_back(newPoint);
    }

    // ç·¨é›†ç”¨ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã¾ãŸã¯åˆæœŸåŒ–
    if (rotationEditMap_.find(data.attackID) == rotationEditMap_.end()) {
        // åˆå›ï¼šQuaternionã‹ã‚‰Vector3ã«å¤‰æ›
        RotationEditData editData;
        editData.startEuler = Math::QuaternionToEuler(data.startRotation);
        editData.endEuler = Math::QuaternionToEuler(data.endRotation);
        rotationEditMap_[data.attackID] = editData;
    }

    RotationEditData& editData = rotationEditMap_[data.attackID];

    // Vector3ï¼ˆåº¦æ•°æ³•ï¼‰ã§ç·¨é›†
    ImGui::Text("é–‹å§‹å›è»¢ (åº¦æ•°æ³•)");
    if (ImGui::DragFloat3("StartEuler", &editData.startEuler.x, 0.5f, -360.0f, 360.0f)) {
        // ç·¨é›†ã•ã‚ŒãŸã‚‰Quaternionã«å¤‰æ›
        data.startRotation = Math::QuaternionFromVector(editData.startEuler);
    }

    // ç¾åœ¨ã®Quaternionå€¤ã‚‚è¡¨ç¤º
    ImGui::SameLine();
    if (ImGui::TreeNode("StartQuaternion")) {
        ImGui::Text("x: %.3f, y: %.3f", data.startRotation.x, data.startRotation.y);
        ImGui::Text("z: %.3f, w: %. 3f", data.startRotation.z, data.startRotation.w);
        ImGui::TreePop();
    }

    ImGui::Spacing();

    ImGui::Text("çµ‚äº†å›è»¢ (åº¦æ•°æ³•)");
    if (ImGui::DragFloat3("EndEuler", &editData.endEuler.x, 0.5f, -360.0f, 360.0f)) {
        // ç·¨é›†ã•ã‚ŒãŸã‚‰Quaternionã«å¤‰æ›
        data.endRotation = Math::QuaternionFromVector(editData.endEuler);
    }

    // ç¾åœ¨ã®Quaternionå€¤ã‚‚è¡¨ç¤º
    ImGui::SameLine();
    if (ImGui::TreeNode("EndQuaternion")) {
        ImGui::Text("x:  %.3f, y: %.3f", data.endRotation.x, data.endRotation.y);
        ImGui::Text("z: %.3f, w: %.3f", data.endRotation.z, data.endRotation.w);
        ImGui::TreePop();
    }

    ImGui::Spacing();

    // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
    if (ImGui::Button("å›è»¢ã‚’ãƒªã‚»ãƒƒãƒˆ")) {
        editData.startEuler = { 0.0f, 0.0f, 0.0f };
        editData.endEuler = { 0.0f, 0.0f, 0.0f };
        data.startRotation = Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f };
        data.endRotation = Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f };
    }

    ImGui::Checkbox("å›è»¢ã‚‚ãƒ™ã‚¸ã‚§æ›²ç·šã§è£œé–“", &data.useRotationCurve);

    ImGui::SeparatorText("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼");
    ImGui::Checkbox("è»Œé“ã‚’è¡¨ç¤º", &data.showTrajectory);
    ImGui::ColorEdit3("è»Œé“ã®è‰²", &data.trajectoryColor.x);
#endif
}

///-------------------------------------------/// 
/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®šUIã®æç”»
///-------------------------------------------///
void AttackEditor::RenderEffectSettings(AttackData& data) {
    data;
#ifdef USE_IMGUI
    ImGui::SeparatorText("ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ");

    char particleBuffer[256];
    strncpy_s(particleBuffer, data.particleEffectName.c_str(), sizeof(particleBuffer));
    if (ImGui::InputText("ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå", particleBuffer, sizeof(particleBuffer))) {
        data.particleEffectName = particleBuffer;
    }

    ImGui::DragFloat3("ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚ªãƒ•ã‚»ãƒƒãƒˆ", &data.particleOffset.x, 0.1f);

    ImGui::SeparatorText("ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯");
    ImGui::DragFloat("ã‚·ã‚§ã‚¤ã‚¯å¼·åº¦", &data.cameraShakeIntensity, 0.01f, 0.0f, 10.0f);
    ImGui::DragFloat("ã‚·ã‚§ã‚¤ã‚¯æ™‚é–“", &data.cameraShakeDuration, 0.01f, 0.0f, 5.0f);

    ImGui::SeparatorText("ã‚µã‚¦ãƒ³ãƒ‰");

    char swingBuffer[256];
    strncpy_s(swingBuffer, data.swingSoundName.c_str(), sizeof(swingBuffer));
    if (ImGui::InputText("æŒ¯ã‚Šã‚µã‚¦ãƒ³ãƒ‰", swingBuffer, sizeof(swingBuffer))) {
        data.swingSoundName = swingBuffer;
    }

    char hitBuffer[256];
    strncpy_s(hitBuffer, data.hitSoundName.c_str(), sizeof(hitBuffer));
    if (ImGui::InputText("ãƒ’ãƒƒãƒˆã‚µã‚¦ãƒ³ãƒ‰", hitBuffer, sizeof(hitBuffer))) {
        data.hitSoundName = hitBuffer;
    }
#endif
}

///-------------------------------------------/// 
/// ã‚³ãƒ³ãƒœè¨­å®šUIã®æç”»
///-------------------------------------------///
void AttackEditor::RenderComboSettings(AttackData& data) {
    data;
#ifdef USE_IMGUI
    ImGui::SeparatorText("ã‚³ãƒ³ãƒœé€£æº");

    ImGui::Checkbox("æ¬¡ã®ã‚³ãƒ³ãƒœã«ã¤ãªã’ã‚‹", &data.canComboToNext);

    if (data.canComboToNext) {
        ImGui::InputInt("æ¬¡ã®ã‚³ãƒ³ãƒœID", &data.nextComboID);

        ImGui::SeparatorText("åˆ†å²ã‚³ãƒ³ãƒœ");
        ImGui::Text("åˆ†å²å¯èƒ½ãªã‚³ãƒ³ãƒœID:");

        for (int i = 0; i < static_cast<int>(data.branchComboIDs.size()); ++i) {
            ImGui::PushID(i);
            ImGui::InputInt("branchID", &data.branchComboIDs[i]);
            ImGui::SameLine();
            if (ImGui::Button("å‰Šé™¤")) {
                data.branchComboIDs.erase(data.branchComboIDs.begin() + i);
                ImGui::PopID();
                break;
            }
            ImGui::PopID();
        }

        if (ImGui::Button("+ åˆ†å²ã‚’è¿½åŠ ")) {
            data.branchComboIDs.push_back(-1);
        }
    }
#endif
}

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®æç”»
///-------------------------------------------///
void AttackEditor::RenderPreviewControl() {
#ifdef USE_IMGUI
    ImGui::Begin("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«");

    if (ImGui::Button("å†ç”Ÿ")) {
        PlayPreview();
    }
    ImGui::SameLine();
    if (ImGui::Button("åœæ­¢")) {
        StopPreview();
    }
    ImGui::SameLine();
    if (ImGui::Button("ãƒªã‚»ãƒƒãƒˆ")) {
        ResetPreview();
    }

    ImGui::Checkbox("è‡ªå‹•ãƒªãƒ—ãƒ¬ã‚¤", &autoReplay_);

    ImGui::SeparatorText("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¨­å®š");
    ImGui::DragFloat3("æ­¦å™¨ä½ç½®", &previewWeaponPosition_.x, 0.1f);

    // å®Ÿéš›ã®æ”»æ’ƒã‚’ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
    if (ImGui::Button("æ”»æ’ƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ", ImVec2(-1, 0)) && previewWeapon_) {
        if (selectedAttackIndex_ >= 0 && selectedAttackIndex_ < static_cast<int>(attacks_.size())) {
            AttackData& currentAttack = attacks_[selectedAttackIndex_];

            // ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹ãŒ2ç‚¹ä»¥ä¸Šã‚ã‚‹ã‹ç¢ºèª
            if (currentAttack.trajectoryPoints.size() >= 2) {

                // å…¨ã¦ã®åˆ¶å¾¡ç‚¹ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’é©ç”¨
                std::vector<BezierControlPointData> worldPoints;
                for (const auto& point : currentAttack.trajectoryPoints) {
                    BezierControlPointData worldPoint = {};
                    worldPoint.position = previewWeaponPosition_ + point.position;
                    worldPoint.time = point.time;
                    worldPoints.push_back(worldPoint);
                }

                // æ­¦å™¨ã«æ”»æ’ƒã‚’å®Ÿè¡Œã•ã›ã‚‹ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šç‰ˆï¼‰
                previewWeapon_->StartAttack(
                    worldPoints,                    // â† å…¨åˆ¶å¾¡ç‚¹ã‚’æ¸¡ã™
                    currentAttack.activeDuration,
                    currentAttack.startRotation,
                    currentAttack.endRotation
                );

                // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿé–‹å§‹
                PlayPreview();
            }
        }
    }

    // ãƒ˜ãƒ«ãƒ—ãƒ†ã‚­ã‚¹ãƒˆ
    ImGui::Separator();
    ImGui::TextColored(ImVec4(0.5f, 0.5f, 0.5f, 1.0f), "ãƒ’ãƒ³ãƒˆ:");
    ImGui::BulletText("ã€Œå†ç”Ÿã€ã§è»Œé“ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼è¡¨ç¤º");
    ImGui::BulletText("ã€Œæ”»æ’ƒãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œã€ã§å®Ÿéš›ã®æ”»æ’ƒãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³");

    ImGui::End();
#endif
}

///-------------------------------------------/// 
/// é¸æŠä¸­ã®æ”»æ’ƒã‚’å‰Šé™¤
///-------------------------------------------///
void AttackEditor::DeleteSelectedAttack() {
    if (selectedAttackIndex_ >= 0 && selectedAttackIndex_ < static_cast<int>(attacks_.size())) {
        attacks_.erase(attacks_.begin() + selectedAttackIndex_);
        selectedAttackIndex_ = -1;
    }
}

///-------------------------------------------/// 
/// é¸æŠä¸­ã®æ”»æ’ƒã‚’è¤‡è£½
///-------------------------------------------///
void AttackEditor::DuplicateSelectedAttack() {
    if (selectedAttackIndex_ >= 0 && selectedAttackIndex_ < static_cast<int>(attacks_.size())) {
        AttackData copy = attacks_[selectedAttackIndex_];
        copy.attackName += "_Copy";
        copy.attackID = static_cast<int>(attacks_.size());
        attacks_.push_back(copy);
    }
}

///-------------------------------------------/// 
/// åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°
///-------------------------------------------///
void AttackEditor::UpdateAvailablePresets() {
    availablePresets_.clear();

    if (!std::filesystem::exists(kDefaultSavePath)) {
        std::filesystem::create_directories(kDefaultSavePath);
        return;
    }

    for (const auto& entry : std::filesystem::directory_iterator(kDefaultSavePath)) {
        if (entry.path().extension() == ".json") {
            availablePresets_.push_back(entry.path().filename().string());
        }
    }
}

///-------------------------------------------/// 
/// è»Œé“ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
///-------------------------------------------///
void AttackEditor::UpdateTrajectoryPreview(const float deltaTime) {
    if (selectedAttackIndex_ < 0 || selectedAttackIndex_ >= static_cast<int>(attacks_.size())) {
        return;
    }

    AttackData& currentAttack = attacks_[selectedAttackIndex_];

    // ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
    previewTimer_ += deltaTime;

    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨æ­¦å™¨ã®æ›´æ–°
    if (previewWeapon_) {
        previewWeapon_->Update();
    }

    // æ”»æ’ƒæ™‚é–“ã‚’è¶…ãˆãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
    if (previewTimer_ >= currentAttack.activeDuration) {
        if (autoReplay_) {
            previewTimer_ = 0.0f;
        } else {
            isPlaying_ = false;
        }
    }
}

============================================================
File Path: Project/application/Game/Entity/Player/Editor/AttackEditor.h
============================================================
#pragma once
/// ===Include=== ///
#include "Data/AttackData.h"
#include "application/Drawing/3d/Line.h"
// Serializer
#include "AttackDataSerializer.h"
// c++
#include <memory>
#include <string>
#include <vector>
#include <unordered_map>

/// ===å‰æ–¹å®£è¨€=== ///
class PlayerWeapon;

///=====================================================/// 
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ”»æ’ƒã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
/// ImGuiã‚’ä½¿ç”¨ã—ãŸæ”»æ’ƒç·¨é›†UI
///=====================================================///
class AttackEditor {
public:

    AttackEditor() = default;
    ~AttackEditor();

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize();

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update(const float deltaTime);

    /// <summary>
    /// ImGUIæç”»å‡¦ç†
    /// </summary>
    void Render();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æç”»å‡¦ç†ï¼ˆã‚²ãƒ¼ãƒ ç”»é¢ã«è¡¨ç¤ºï¼‰
    /// </summary>
    void DrawPreview();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆ
    /// </summary>
    void ToggleVisibility();

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®è¡¨ç¤ºçŠ¶æ…‹ã‚’è¨­å®š
    /// </summary>
    void SetVisible(bool visible);

    /// <summary>
    /// ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹
    /// </summary>
    bool IsVisible() const { return isVisible_; }

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¨­å®š
    /// </summary>
    void SetPreviewPlayer(PlayerWeapon* player) { previewWeapon_ = player; }

private:
    /// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼çŠ¶æ…‹=== ///
    bool isVisible_ = false;                      // è¡¨ç¤ºãƒ•ãƒ©ã‚°
    std::vector<AttackData> attacks_;             // æ”»æ’ƒãƒ‡ãƒ¼ã‚¿ãƒªã‚¹ãƒˆ
    int selectedAttackIndex_ = -1;                // é¸æŠä¸­ã®æ”»æ’ƒã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹

    /// ===ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†=== ///
    static constexpr const char* kDefaultSavePath = "Resource/Json/Attacks";
    char filePathBuffer_[256];                    // ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹å…¥åŠ›ãƒãƒƒãƒ•ã‚¡
    std::vector<std::string> availablePresets_;   // åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆãƒªã‚¹ãƒˆ
    std::unordered_map<int, std::string> attackFilePaths_; // 

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼=== ///
    bool isPlaying_ = false;                      // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿä¸­ãƒ•ãƒ©ã‚°
    bool autoReplay_ = false;                     // è‡ªå‹•ãƒªãƒ—ãƒ¬ã‚¤ãƒ•ãƒ©ã‚°
    float previewTimer_ = 0.0f;                   // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¿ã‚¤ãƒãƒ¼
    Vector3 previewWeaponPosition_{ 0.0f, 0.0f, 0.0f };  // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®

    PlayerWeapon* previewWeapon_ = nullptr;             // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼

    /// ===Lineæç”»=== ///
    std::unique_ptr<Line> line_;                  // ç·šæç”»ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
    
    /// ===Serializer=== ///
	std::unique_ptr<AttackDataSerializer> serializer_; // ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚¶

    /// ===å›è»¢ç·¨é›†ç”¨ï¼ˆã‚ªã‚¤ãƒ©ãƒ¼è§’ï¼‰=== ///  
    struct RotationEditData {
        Vector3 startEuler = { 0.0f, 0.0f, 0.0f };  // é–‹å§‹å›è»¢ï¼ˆåº¦æ•°æ³•ï¼‰
        Vector3 endEuler = { 0.0f, 0.0f, 0.0f };    // çµ‚äº†å›è»¢ï¼ˆåº¦æ•°æ³•ï¼‰
    };
    std::unordered_map<int, RotationEditData> rotationEditMap_;  

private:

    /// ===ãƒ•ã‚¡ã‚¤ãƒ«æ“ä½œ=== ///

    /// <summary>
    /// é¸æŠä¸­ã®æ”»æ’ƒã‚’ä¸Šæ›¸ãä¿å­˜
    /// </summary>
    void SaveCurrent();

    /// <summary>
    /// é¸æŠä¸­ã®æ”»æ’ƒã‚’åå‰ã‚’ä»˜ã‘ã¦ä¿å­˜
    /// </summary>
    void SaveCurrentAs();

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
    /// </summary>
    void SaveToJson();

    /// <summary>
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
    /// </summary>
    void LoadFromJson();

    /// <summary>
    /// æ–°è¦ä½œæˆ
    /// </summary>
    void CreateNew();

    /// <summary>
    /// å…¨ã¦ã®æ”»æ’ƒã‚’ä¿å­˜
    /// </summary>
    void SaveAllAttacks();

    /// <summary>
    /// ãƒ—ãƒªã‚»ãƒƒãƒˆãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰å…¨JSONã‚’èª­ã¿è¾¼ã¿
    /// </summary>
    void LoadAllAttacks();

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ¶å¾¡=== ///

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼å†ç”Ÿé–‹å§‹
    /// </summary>
    void PlayPreview();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼åœæ­¢
    /// </summary>
    void StopPreview();

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒªã‚»ãƒƒãƒˆ
    /// </summary>
    void ResetPreview();

    /// ===ImGuiæç”»é–¢æ•°ç¾¤=== ///

    /// <summary>
    /// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
    /// </summary>
    void RenderMenuBar();

    /// <summary>
    /// æ”»æ’ƒãƒªã‚¹ãƒˆã®æç”»
    /// </summary>
    void RenderAttackList();

    /// <summary>
    /// åŸºæœ¬è¨­å®šUIã®æç”»
    /// </summary>
    void RenderBasicSettings(AttackData& data);

    /// <summary>
    /// ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®šUIã®æç”»
    /// </summary>
    void RenderTimingSettings(AttackData& data);

    /// <summary>
    /// è»Œé“è¨­å®šUIã®æç”»
    /// </summary>
    void RenderTrajectorySettings(AttackData& data);

    /// <summary>
    /// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®šUIã®æç”»
    /// </summary>
    void RenderEffectSettings(AttackData& data);

    /// <summary>
    /// ã‚³ãƒ³ãƒœè¨­å®šUIã®æç”»
    /// </summary>
    void RenderComboSettings(AttackData& data);

    /// <summary>
    /// ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®æç”»
    /// </summary>
    void RenderPreviewControl();

    /// ===ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°=== ///

    /// <summary>
    /// é¸æŠä¸­ã®æ”»æ’ƒã‚’å‰Šé™¤
    /// </summary>
    void DeleteSelectedAttack();

    /// <summary>
    /// é¸æŠä¸­ã®æ”»æ’ƒã‚’è¤‡è£½
    /// </summary>
    void DuplicateSelectedAttack();

    /// <summary>
    /// åˆ©ç”¨å¯èƒ½ãªãƒ—ãƒªã‚»ãƒƒãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°
    /// </summary>
    void UpdateAvailablePresets();

    /// <summary>
    /// è»Œé“ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°
    /// </summary>
    void UpdateTrajectoryPreview(const float deltaTime);
};

============================================================
File Path: Project/application/Game/Entity/Player/Editor/Data/AttackData.h
============================================================
#pragma once
/// ===Include=== ///
// Math
#include "Math/Vector3.h"
#include "Math/Quaternion.h"
#include "Engine/DataInfo/LineObjectData.h"
// C++
#include <vector>
#include <string>

///-------------------------------------------/// 
/// æ”»æ’ƒãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
///-------------------------------------------///
struct AttackData {
    // ===åŸºæœ¬æƒ…å ±=== //
    std::string attackName;              // æ”»æ’ƒå
    std::string description;             // èª¬æ˜
    int attackID;                        // æ”»æ’ƒIDï¼ˆãƒ¦ãƒ‹ãƒ¼ã‚¯ï¼‰

    // ===ã‚¿ã‚¤ãƒŸãƒ³ã‚°è¨­å®š=== //
    float activeDuration;                // æ”»æ’ƒã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚é–“ï¼ˆç§’ï¼‰
    float comboWindowTime;               // ã‚³ãƒ³ãƒœå—ä»˜æ™‚é–“ï¼ˆç§’ï¼‰
    float cooldownTime;                  // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ™‚é–“ï¼ˆç§’ï¼‰

    // ===è»Œé“è¨­å®šï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šï¼‰=== //
    std::vector<BezierControlPointData> trajectoryPoints;  // ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹ãƒªã‚¹ãƒˆ
    int curveSegments;                   // æ›²ç·šã®åˆ†å‰²æ•°ï¼ˆæ»‘ã‚‰ã‹ã•ï¼‰
    float weaponLength;                  // æ­¦å™¨ã®è·é›¢

    // ===å›è»¢è¨­å®š=== //
    Quaternion startRotation;            // é–‹å§‹å›è»¢
    Quaternion endRotation;              // çµ‚äº†å›è»¢
    bool useRotationCurve;               // å›è»¢ã‚‚ãƒ™ã‚¸ã‚§æ›²ç·šã§è£œé–“ã™ã‚‹ã‹

    // ===ã‚³ãƒ³ãƒœè¨­å®š=== //
    bool canComboToNext;                 // æ¬¡ã®ã‚³ãƒ³ãƒœã«ç¹‹ã’ã‚‹ã‹
    int nextComboID;                     // æ¬¡ã®ã‚³ãƒ³ãƒœã®IDï¼ˆ-1ã§ç„¡ã—ï¼‰
    std::vector<int> branchComboIDs;     // åˆ†å²å¯èƒ½ãªã‚³ãƒ³ãƒœIDï¼ˆè¤‡æ•°é¸æŠè‚¢ï¼‰

    // ===ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š=== //
    std::string particleEffectName;      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå
    Vector3 particleOffset;              // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    float cameraShakeIntensity;          // ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ã®å¼·åº¦
    float cameraShakeDuration;           // ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ã®æŒç¶šæ™‚é–“

    // ===ã‚µã‚¦ãƒ³ãƒ‰è¨­å®š=== //
    std::string swingSoundName;          // æŒ¯ã‚Šã‚µã‚¦ãƒ³ãƒ‰å
    std::string hitSoundName;            // ãƒ’ãƒƒãƒˆæ™‚ã‚µã‚¦ãƒ³ãƒ‰å

    // ===ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹•ã=== //
    float moveSpeedMultiplier;           // æ”»æ’ƒä¸­ã®ç§»å‹•é€Ÿåº¦å€ç‡ï¼ˆ0.0ï½1.0ï¼‰
    Vector3 rootMotion;                  // ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå‰é€²ãªã©ï¼‰

    // ===ãƒ‡ãƒãƒƒã‚°/ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨=== //
    bool showTrajectory;                 // è»Œé“ã‚’è¡¨ç¤ºã™ã‚‹ã‹
    Vector3 trajectoryColor;             // è»Œé“ã®è‰²ï¼ˆRGBï¼‰

    /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    AttackData()
        : attackName("NewAttack")
        , description("")
        , attackID(0)
        , activeDuration(0.4f)
        , comboWindowTime(1.0f)
        , cooldownTime(0.3f)
        , curveSegments(20)
        , weaponLength(8.0f)
        , startRotation(Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f })
        , endRotation(Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f })
        , useRotationCurve(false)
        , canComboToNext(false)
        , nextComboID(-1)
        , particleEffectName("WeaponAttack")
        , particleOffset(Vector3{ 0.0f, 0.0f, 0.0f })
        , cameraShakeIntensity(0.0f)
        , cameraShakeDuration(0.0f)
        , swingSoundName("")
        , hitSoundName("")
        , moveSpeedMultiplier(0.4f)
        , rootMotion(Vector3{ 0.0f, 0.0f, 0.0f })
        , showTrajectory(true)
        , trajectoryColor(Vector3{ 1.0f, 0.0f, 0.0f })
    {
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§3ç‚¹ã®ãƒ™ã‚¸ã‚§æ›²ç·šã‚’è¨­å®šï¼ˆå·¦â†’ä¸­å¤®â†’å³ï¼‰
        trajectoryPoints.push_back({ Vector3{-8.0f, 0.0f, 0.0f}, 0.0f });
        trajectoryPoints.push_back({ Vector3{0.0f, 0.0f, 8.0f}, 0.5f });
        trajectoryPoints.push_back({ Vector3{8.0f, 0.0f, 0.0f}, 1.0f });
    }
};

============================================================
File Path: Project/application/Game/Entity/Player/Player.cpp
============================================================
#include "Player.h"
// Camera
#include "application/Game/Camera/GameCamera.h"
// State
#include "State/RootState.h"
// Service
#include "Engine/System/Service/InputService.h"
#include "Engine/System/Service/CameraService.h"
#include "Engine/System/Service/ColliderService.h"
// Math
#include "Math/sMath.h"
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Player::~Player() {
	weapon_.reset();
	object3d_.reset();
}

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
// Cameraã®è¿½å¾“å¯¾è±¡ã¨ã—ã¦Playerã‚’è¨­å®š
void Player::SetCameraTargetPlayer() { camera_->SetTarget(&transform_.translate, &transform_.rotate); }
// ç„¡æ•µæ™‚é–“ã®è¨­å®š
void Player::SetInvincibleTime(const float& time) {
	invincibleInfo_.time = time;
	invincibleInfo_.timer = invincibleInfo_.time;
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Player::Initialize() {
	// Cameraã®è¨­å®š
	camera_ = CameraService::GetActiveCamera().get();

	// Object3dã®åˆæœŸåŒ–
	object3d_ = std::make_unique<Object3d>();
	object3d_->Init(ObjectType::Model, "player");

	// GameCharacterã®è¨­å®š
	GameCharacter::Initialize();
	name_ = ColliderName::Player;
	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã«è¿½åŠ 
	ColliderService::AddCollider(this);

	// Weaponã®åˆæœŸåŒ–
	weapon_ = std::make_unique<PlayerWeapon>();
	weapon_->Initialize();
	weapon_->SetUpParent(this);

	/// ===Component=== ///
	// Componentã®ç”Ÿæˆ
	moveComponent_ = std::make_unique<PlayerMoveComponent>();
	avoidanceComponent_ = std::make_unique<PlayerAvoidanceComponent>();
	attackComponent_ = std::make_unique<PlayerAttackComponent>();

	// MoveComponentã®åˆæœŸåŒ–
	PlayerMoveComponent::MoveConfig moveConfig{
		.speed = 0.4f,
		.rotationSpeed = 10.0f,
		.deceleration = 0.85f
	};
	moveComponent_->Initialize(moveConfig);

	// AvoidanceComponentã®åˆæœŸåŒ–
	PlayerAvoidanceComponent::AvoidanceConfig avoidanceConfig{
		.speed = 15.0f,
		.activeTime = 0.3f,
		.coolTime = 1.0f,
		.invincibleTime = 0.01f
	};
	avoidanceComponent_->Initialize(avoidanceConfig);

	// AttackComponentã®åˆæœŸåŒ–
	attackComponent_->Initialize();

	// ç„¡æ•µæƒ…å ±ã®è¨­å®š
	SetInvincibleTime(1.0f);
	invincibleInfo_.isFlag = true;

	// HPã®è¨­å®š
	baseInfo_.HP = 5;

	// åˆæœŸè¨­å®š
	ChangState(std::make_unique<RootState>());

	// Updateã‚’ä¸€å›è¡Œã†
	UpdateAnimation();
}


///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Player::Update() {
	// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (baseInfo_.isDead) {
		ApplyDeceleration(0.7f);
		UpdateAnimation();
		return;
	}

	/// ===ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å–å¾—=== ///
	StickState leftStick = InputService::GetLeftStickState(0);
	StickState rightStick = InputService::GetRightStickState(0);
	// ã‚¹ãƒ†ã‚£ãƒƒã‚¯æƒ…å ±ã‚’ä¿å­˜
	stickState_ = {
		.leftStick = { leftStick.x, leftStick.y },
		.rightStick = { rightStick.x, rightStick.y }
	};
	// ã‚«ãƒ¡ãƒ©ã«ã‚¹ãƒ†ã‚£ãƒƒã‚¯æƒ…å ±ã‚’æ¸¡ã™
	camera_->SetStick(stickState_.rightStick);

	/// ===ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹=== ///
	advanceTimer();

	/// ===Stateã®ç®¡ç†=== ///
	if (currentState_) {
		// å„Stateã®æ›´æ–°
		currentState_->Update(this, camera_);
	}

	/// ===æ›´æ–°å‡¦ç†=== ///
	UpdateAnimation();
}

///-------------------------------------------/// 
/// é–‹å§‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°
///-------------------------------------------///
void Player::UpdateAnimation() {

	/// ===Weapon=== ///
	weapon_->Update();

	/// ===SphereColliderã®æ›´æ–°=== ///
	GameCharacter::Update();
}

///-------------------------------------------///  
/// æç”»
///-------------------------------------------///
void Player::Draw(BlendMode mode) {

	/// ===Weapon=== ///
	weapon_->Draw(mode);

	/// ===SphereColliderã®æç”»=== ///
	GameCharacter::Draw(mode);
}


///-------------------------------------------/// 
/// ImGui
///-------------------------------------------///
void Player::Information() {
#ifdef USE_IMGUI
	ImGui::Begin("Player");
	GameCharacter::Information();		// è¦ªã‚¯ãƒ©ã‚¹ã®æƒ…å ±è¡¨ç¤º
	moveComponent_->Information();		// ç§»å‹•ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æƒ…å ±è¡¨ç¤º
	avoidanceComponent_->Information(); // å›é¿ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æƒ…å ±è¡¨ç¤º
	attackComponent_->Information();    // æ”»æ’ƒã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æƒ…å ±è¡¨ç¤º
	ImGui::DragFloat("ç„¡æ•µæ™‚é–“", &invincibleInfo_.timer, 0.01f);
	weapon_->Information();         // Weaponã®æƒ…å ±è¡¨ç¤º
	ImGui::End();
#endif // USE_IMGUI
}


///-------------------------------------------/// 
/// è¡çª
///-------------------------------------------///
void Player::OnCollision(Collider* collider) {

	/// ===GameCharacterã®è¡çª=== ///
	GameCharacter::OnCollision(collider);

	// Colliderã«ã‚ˆã£ã¦å‡¦ç†ã‚’å¤‰æ›´
	if (collider->GetColliderName() == ColliderName::Enemy || collider->GetColliderName() == ColliderName::EnemyBullet) {

		// ç„¡æ•µçŠ¶æ…‹ã§ãªã‘ã‚Œã°ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹
		if (!invincibleInfo_.isFlag) {

			/// ===ã‚«ãƒ¡ãƒ©ã®ã‚·ã‚§ã‚¤ã‚¯=== ///
			camera_->StartShake(1.2f, 1.0f);

			// ===ãƒãƒƒã‚¯ãƒãƒƒã‚¯å‡¦ç†=== ///
			// æ•µã®ä½ç½®ã‚’å–å¾—
			Vector3 enemyPos = collider->GetTransform().translate;
			// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰æ•µã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
			Vector3 knockbackDirection = transform_.translate - enemyPos;
			// Yè»¸ã¯ç„¡è¦–(æ°´å¹³æ–¹å‘ã®ã¿ãƒãƒƒã‚¯ãƒãƒƒã‚¯)
			knockbackDirection.y = 0.0f;
			// æ­£è¦åŒ–
			if (knockbackDirection.x != 0.0f || knockbackDirection.z != 0.0f) {
				knockbackDirection = Normalize(knockbackDirection);
			}
			// ãƒãƒƒã‚¯ãƒãƒƒã‚¯ã®é€Ÿåº¦ã‚’è¨­å®š(é©åˆ‡ãªå€¤ã«èª¿æ•´ã—ã¦ãã ã•ã„)
			const float knockbackSpeed = 1.5f;
			baseInfo_.velocity = knockbackDirection * knockbackSpeed;

			// Stateã‚’ Root ã«å¤‰æ›´
			attackComponent_->CancelAttack(); // æ”»æ’ƒã‚­ãƒ£ãƒ³ã‚»ãƒ«
			ChangState(std::make_unique<RootState>());

			// ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
			//baseInfo_.HP--;
			// ç„¡æ•µçŠ¶æ…‹ã«ã™ã‚‹
			SetInvincibleTime(0.5f);
		}
	}
}

///-------------------------------------------/// 
/// æ™‚é–“ã‚’é€²ã‚ã‚‹
///-------------------------------------------///
void Player::advanceTimer() {

	// ç„¡æ•µã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
	if (invincibleInfo_.timer > 0.0f) {
		invincibleInfo_.timer -= baseInfo_.deltaTime;
		//color_ = { 1.0f, 0.0f, 0.0f, 0.5f }; // åŠé€æ˜ã«ã™ã‚‹
		invincibleInfo_.isFlag = true;
	} else {
		invincibleInfo_.isFlag = false;
		//color_ = { 1.0f, 1.0f, 1.0f, 1.0f }; // å…ƒã®è‰²ã«æˆ»ã™
	}

	// å›é¿ã‚¿ã‚¤ãƒãƒ¼ã®æ›´æ–°
	avoidanceComponent_->UpdateTimer(baseInfo_.deltaTime);
}

///-------------------------------------------/// 
/// æ¸›é€Ÿå‡¦ç†
///-------------------------------------------///
void Player::ApplyDeceleration(const float& develeration) {
	// VelocityãŒ0ã§ãªã„ãªã‚‰å¾ã€…ã«0ã«ã™ã‚‹
	if (baseInfo_.velocity.x != 0.0f) {
		// å„è»¸ã«å¯¾ã—ã¦æ¸›é€Ÿé©ç”¨
		baseInfo_.velocity.x *= develeration;
		// å°ã•ã™ãã‚‹å€¤ã¯å®Œå…¨ã«0ã«ã‚¹ãƒŠãƒƒãƒ—
		if (std::abs(baseInfo_.velocity.x) < 0.01f) {
			baseInfo_.velocity.x = 0.0f;
		}
	}
	if (baseInfo_.velocity.z != 0.0f) {
		baseInfo_.velocity.z *= develeration;
		if (std::abs(baseInfo_.velocity.z) < 0.01f) {
			baseInfo_.velocity.z = 0.0f;
		}
	}
}

///-------------------------------------------/// 
/// Stateã®å¤‰æ›´
///-------------------------------------------///
void Player::ChangState(std::unique_ptr<PlayerState> newState) {
	if (currentState_) {
		// å¤ã„çŠ¶æ…‹ã‚’è§£æ”¾  
		currentState_->Finalize();
		currentState_.reset();
	}

	// æ–°ã—ã„çŠ¶æ…‹ã‚’ã‚»ãƒƒãƒˆ  
	currentState_ = std::move(newState);
	// æ–°ã—ã„çŠ¶æ…‹ã®åˆæœŸåŒ–  
	currentState_->Enter(this, camera_);
}


============================================================
File Path: Project/application/Game/Entity/Player/Player.h
============================================================
#pragma once
/// ===Include=== ///
// GameCharacter
#include "application/Game/Entity/GameCharacter/GameCharacter.h"
// Component
#include "Component/PlayerMoveComponent.h"
#include "Component/PlayerAvoidanceComponent.h"
#include "Component/PlayerAttackComponent.h"
// State
#include "State/Base/PlayerState.h"
// Weapon
#include "application/Game/Entity/Player/Weapon/PlayerWeapon.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Enemy;

///=====================================================/// 
/// Player
///=====================================================///
class Player : public GameCharacter<OBBCollider> {
public:

	Player() = default;
	~Player();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize()override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateAnimation();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode"></param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal)override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information() override;

public: /// ===è¡çªåˆ¤å®š=== ///
	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã® Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void OnCollision(Collider* collider) override;

public: /// ===Getter=== ///

	// Weapon
	PlayerWeapon* GetWeapon() const { return weapon_.get(); };

	// Component
	PlayerMoveComponent* GetMoveComponent() const { return moveComponent_.get(); };
	PlayerAvoidanceComponent* GetAvoidanceComponent() const { return avoidanceComponent_.get(); };
	PlayerAttackComponent* GetAttackComponent() const { return attackComponent_.get(); };

	// StickState
	Vector2 GetLeftStickState() const { return stickState_.leftStick; };
	Vector2 GetRightStickState() const { return stickState_.rightStick; };

public: /// ===Setter=== ///

	// Camera
	void SetCameraTargetPlayer();
	// ç„¡æ•µæ™‚é–“ã®è¨­å®š
	void SetInvincibleTime(const float& time);
	// Gravityã®è¨­å®š
	void SetGravity(const float& gravity) { baseInfo_.gravity = gravity; };

public: /// ===Stateç”¨é–¢æ•°=== ///

	/// <summary>
	/// æ¸›é€Ÿå‡¦ç†
	/// </summary>
	/// <param name="deceleration">é©ç”¨ã™ã‚‹æ¸›é€Ÿé‡ã‚’è¡¨ã™æµ®å‹•å°æ•°ç‚¹æ•°ã¸ã® const å‚ç…§ã€‚</param>
	void ApplyDeceleration(const float& deceleration);

	/// <summary>
	/// Stateã®å¤‰æ›´å‡¦ç†
	/// </summary>
	/// <param name="newState">æ–°ã—ã„çŠ¶æ…‹ã‚’è¡¨ã™ std::unique_ptr<PlayerState>ã€‚ã“ã®å¼•æ•°ã¯å‘¼ã³å‡ºã—å´ã‹ã‚‰ãƒ ãƒ¼ãƒ–ã•ã‚Œã€æ‰€æœ‰æ¨©ã¯é–¢æ•°ã«ç§»ã‚Šã¾ã™ã€‚</param>
	void ChangState(std::unique_ptr<PlayerState> newState);

private: /// ===å¤‰æ•°ã®å®£è¨€=== ///
	// ã‚«ãƒ¡ãƒ©
	GameCamera* camera_ = nullptr; 

	/// ===Weapon=== ///
	std::unique_ptr<PlayerWeapon> weapon_;

	/// ===Component=== ///
	std::unique_ptr<PlayerMoveComponent> moveComponent_;
	std::unique_ptr<PlayerAvoidanceComponent> avoidanceComponent_;
	std::unique_ptr<PlayerAttackComponent> attackComponent_;

	/// ===State=== ///
	std::unique_ptr<PlayerState> currentState_;

	/// ===ç„¡æ•µæ™‚é–“ã®æƒ…å ±=== ///
	struct InvincibleInfo {
		float time = 1.0f;   // ç„¡æ•µæ™‚é–“
		float timer = 0.0f;  // ç„¡æ•µã‚¿ã‚¤ãƒãƒ¼
		bool isFlag = false; // ç„¡æ•µãƒ•ãƒ©ã‚°
	};
	InvincibleInfo invincibleInfo_;

	/// ===StickState=== ///
	struct ControllerStickState {
		Vector2 leftStick = {0.0f, 0.0f};
		Vector2 rightStick = {0.0f, 0.0f};
	};
	ControllerStickState stickState_;

private:

	/// <summary>
	/// ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹é–¢æ•°
	/// </summary>
	void advanceTimer();
};

============================================================
File Path: Project/application/Game/Entity/Player/State/AttackState.cpp
============================================================
#include "AttackState.h"
// Service
#include "Engine/System/Service/InputService.h"
// Player
#include "application/Game/Entity/Player/Player.h"
#include "application/Game/Entity/Player/Weapon/PlayerWeapon.h"
// State
#include "RootState.h"
// Math
#include "Math/sMath.h"

///-------------------------------------------/// 
/// çŠ¶æ…‹ã«å…¥ã£ãŸã¨ãã«å‘¼ã°ã‚Œã‚‹
///-------------------------------------------///
void AttackState::Enter(Player* player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;

	// æ”»æ’ƒã®é–‹å§‹
	player_->GetAttackComponent()->StartAttack(0, player_->GetWeapon());
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void AttackState::Update(Player* player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;

	PlayerAttackComponent* attackComp = player_->GetAttackComponent();
	// æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (!attackComp) return;

	// æ¸›é€Ÿå‡¦ç†
	player_->ApplyDeceleration(0.4f);

	// æ”»æ’ƒã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®æ›´æ–°
	attackComp->Update(player_->GetDeltaTime());

	// æ”»æ’ƒãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰ã‚³ãƒ³ãƒœã‚’è©¦è¡Œ
	if (InputService::TriggerButton(0, ControllerButtonType::X)) {
		if (attackComp->CanCombo()) {
			attackComp->TryCombo(player_->GetWeapon());
		}
	}

	// æ”»æ’ƒãŒçµ‚äº†ã—ãŸã‚‰RootStateã¸é·ç§»
	if (!attackComp->IsAttacking() && !attackComp->CanCombo()) {
		player_->ChangState(std::make_unique<RootState>());
	}
}

///-------------------------------------------/// 
/// çµ‚äº†å‡¦ç†
///-------------------------------------------///
void AttackState::Finalize() {
	PlayerState::Finalize();
}

============================================================
File Path: Project/application/Game/Entity/Player/State/AttackState.h
============================================================
/// ===Include=== ///
#include "Base/PlayerState.h"
// Math
#include "Math/Vector3.h"

///=====================================================/// 
/// AttackState
///=====================================================///
class AttackState : public PlayerState {
public:

	~AttackState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="player">çŠ¶æ…‹ã«å…¥ã‚‹å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">çŠ¶æ…‹ã§ä½¿ç”¨ã™ã‚‹ã‚²ãƒ¼ãƒ ã‚«ãƒ¡ãƒ©ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Enter(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆæ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="player">æ›´æ–°å¯¾è±¡ã® Player ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚nullptr ã®æ‰±ã„ã¯å®Ÿè£…ã«ä¾å­˜ã™ã‚‹ã€‚</param>
	/// <param name="camera">æ›´æ–°å‡¦ç†ã§å‚ç…§ã™ã‚‹ GameCamera ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã®çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;
};

============================================================
File Path: Project/application/Game/Entity/Player/State/AvoidanceState.cpp
============================================================
#include "AvoidanceState.h"
// Player, Camera
#include "application/Game/Entity/Player/Player.h"
// State
#include "RootState.h"

///-------------------------------------------/// 
/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
AvoidanceState::AvoidanceState(const Vector3& direction) { direction_ = direction;}

///-------------------------------------------/// 
/// é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void AvoidanceState::Enter(Player * player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;

	// å›é¿å‡¦ç†ã‚’é–‹å§‹
	player_->GetAvoidanceComponent()->StartAvoidance();
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
void AvoidanceState::Update(Player * player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;

	/// ===å›é¿å‡¦ç†=== ///
	PlayerAvoidanceComponent::UpdateContext context{
		.inputDirection = direction_,
		.deltaTime = player_->GetDeltaTime()
	};
	// æ›´æ–°
	auto result = player_->GetAvoidanceComponent()->Update(context);

	// çµæœã‚’åæ˜ 
	player_->SetVelocity(result.velocity);

	/// ===ã‚¿ã‚¤ãƒãƒ¼ãŒæ™‚é–“ã‚’è¶…ãˆãŸã‚‰=== ///
	if (player_->GetAvoidanceComponent()->GetState().timer <= 0.0f) {
		// çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
		player_->GetAvoidanceComponent()->ResetState();
		// Stateã®å¤‰æ›´
		player_->ChangState(std::make_unique<RootState>());
	}
}

///-------------------------------------------/// 
/// çµ‚äº†æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void AvoidanceState::Finalize() {
	PlayerState::Finalize();	
}


============================================================
File Path: Project/application/Game/Entity/Player/State/AvoidanceState.h
============================================================
#pragma once
/// ===Include=== ///
#include "Base/PlayerState.h"
// Math
#include "Math/Vector3.h"

///=====================================================/// 
/// AvoidanceState
///=====================================================///
class AvoidanceState : public PlayerState {
public:
	AvoidanceState(const Vector3& direction);
	~AvoidanceState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="player">å‡¦ç†å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ã‚«ãƒ¡ãƒ©ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚ã‚¨ãƒ³ãƒˆãƒªå‡¦ç†ã§ã‚«ãƒ¡ãƒ©ã®çŠ¶æ…‹ã‚„è¦–ç‚¹ã‚’ä½¿ç”¨ã™ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚</param>
	void Enter(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆæ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="player">æ›´æ–°å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">æ›´æ–°å‡¦ç†ã«ä½¿ç”¨ã™ã‚‹ã‚²ãƒ¼ãƒ ã‚«ãƒ¡ãƒ©ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã®çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;

private:
	/// ===å›é¿æ–¹å‘=== ///
	Vector3 direction_; // å›é¿æ–¹å‘
};



============================================================
File Path: Project/application/Game/Entity/Player/State/Base/PlayerState.cpp
============================================================
#include "PlayerState.h"

///-------------------------------------------/// 
/// çµ‚äº†å‡¦ç†
///-------------------------------------------///
void PlayerState::Finalize() {
	player_ = nullptr;
	camera_ = nullptr;
}


============================================================
File Path: Project/application/Game/Entity/Player/State/Base/PlayerState.h
============================================================
#pragma once
/// ===å‰æ–¹å®£è¨€=== ///
class Player;
class GameCamera;

///=====================================================/// 
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ™ãƒ¼ã‚¹ã‚¹ãƒ†ãƒ¼ãƒˆ
///=====================================================///
class PlayerState {
public:
	virtual ~PlayerState() = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="player">Enter å‡¦ç†ã®å¯¾è±¡ã¨ãªã‚‹ Player ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">å‡¦ç†æ™‚ã«å‚ç…§ã¾ãŸã¯æ“ä½œã™ã‚‹ GameCamera ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	virtual void Enter(Player* player, GameCamera* camera) = 0;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆæ™‚ã®æ›´æ–°å‡¦ç†ã€ç´”ç²‹ä»®æƒ³é–¢æ•°
	/// </summary>
	/// <param name="player">æ›´æ–°å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ã‚«ãƒ¡ãƒ©ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	virtual void Update(Player* player, GameCamera* camera) = 0;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã®çµ‚äº†å‡¦ç†
	/// </summary>
	virtual void Finalize();

protected:

	Player* player_ = nullptr; // Player
	GameCamera* camera_ = nullptr; // Camera
};


============================================================
File Path: Project/application/Game/Entity/Player/State/MoveState.cpp
============================================================
#include "MoveState.h"
// Service
#include "Engine/System/Service/InputService.h"
#include "Engine/System/Service/ParticleService.h"
// Player, Camera
#include "application/Game/Entity/Player/Player.h"
#include "application/Game/Camera/GameCamera.h"
// State
#include "RootState.h"
#include "AvoidanceState.h"
#include "AttackState.h"
// Math
#include "Math/sMath.h"


///-------------------------------------------/// 
/// é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void MoveState::Enter(Player* player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;

	// ç§»å‹•ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¼·åˆ¶åœæ­¢
	if (moveParticle_) {
		moveParticle_->Stop();
		moveParticle_ = nullptr;
	}
	// ç§»å‹•ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å†ç”Ÿ
	moveParticle_ = ParticleService::Emit("PlayerWarke", player_->GetTransform().translate);
	moveParticle_->SetEmitterPosition(player_->GetTransform().translate);
}

///-------------------------------------------/// 
/// æ›´æ–°æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void MoveState::Update(Player * player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;

	/// ===ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å–å¾—=== ///
	Vector2 leftStick = player_->GetLeftStickState();

	/// ===ç§»å‹•å‡¦ç†=== ///
	PlayerMoveComponent::UpdateContext context{
		.inputDirection = { leftStick.x, 0.0f, leftStick.y},
		.currentPosition = player_->GetTransform().translate,
		.currentRotation = player_->GetTransform().rotate,
		.deltaTime = player_->GetDeltaTime()
	};
	// æ›´æ–°
	auto result = player_->GetMoveComponent()->Update(context);

	// çµæœã‚’åæ˜ 
	player_->SetVelocity(result.velocity);
	player_->SetRotate(result.targetRotation);

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ä½ç½®æ›´æ–°
	if (moveParticle_) {
		moveParticle_->SetEmitterPosition(player_->GetTransform().translate);
	}

	/// ===Stateã®å¤‰æ›´=== ///
	// æ”»æ’ƒãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰æ”»æ’ƒçŠ¶æ…‹ã¸
	if (InputService::TriggerButton(0, ControllerButtonType::X)) {
		// æ”»æ’ƒã®æº–å‚™ãŒã§ãã¦ã„ã‚Œã°
		if (!player_->GetAttackComponent()->GetState().isActive) {
			// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åœæ­¢
			//StopMoveParticle();
			// AttackStateã¸ç§»è¡Œ
			player_->ChangState(std::make_unique<AttackState>());
		}
	// RBãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰é€²ã‚“ã§ã„ã‚‹çªé€²çŠ¶æ…‹ã¸
	} else if (InputService::TriggerButton(0, ControllerButtonType::RB)) {

	// Aãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰å›é¿çŠ¶æ…‹ã¸
	} else if (InputService::TriggerButton(0, ControllerButtonType::A)) {
		// å›é¿ã®æº–å‚™ãŒã§ãã¦ã„ã‚Œã°
		if (player_->GetAvoidanceComponent()->GetState().isPreparation) {
			// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åœæ­¢
			//StopMoveParticle();
			// AvoidanceStateã¸ç§»è¡Œ
			player_->ChangState(std::make_unique<AvoidanceState>(Normalize(player_->GetMoveComponent()->GetCurrentDirection())));
		}
	// ç§»å‹•ãŒç„¡ã‘ã‚Œã°é€šå¸¸çŠ¶æ…‹ã¸
	} else if (std::abs(leftStick.x) < 0.1f && std::abs(leftStick.y) < 0.1f) {
		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åœæ­¢
		//StopMoveParticle();
		// RootStateã¸ç§»è¡Œ
		player_->ChangState(std::make_unique<RootState>());
	}
}

///-------------------------------------------/// 
/// çµ‚äº†æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void MoveState::Finalize() {
	PlayerState::Finalize();
}

///-------------------------------------------/// 
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åœæ­¢
///-------------------------------------------///
void MoveState::StopMoveParticle() {
	if (moveParticle_) {
		moveParticle_->Stop();
		moveParticle_ = nullptr;
	}
}


============================================================
File Path: Project/application/Game/Entity/Player/State/MoveState.h
============================================================
#pragma once
/// ===Include=== ///
#include "Base/PlayerState.h"
// Math
#include "Math/Vector3.h"

/// ===å‰æ–¹å®£è¨€=== ///
class ParticleGroup;

///=====================================================/// 
/// MoveState
///=====================================================///
class MoveState : public PlayerState{
public:

	~MoveState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="player">å‡¦ç†å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚çŠ¶æ…‹é·ç§»æ™‚ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å¯¾ã™ã‚‹åˆæœŸåŒ–ã‚„è¨­å®šã‚’è¡Œã†ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	/// <param name="camera">çŠ¶æ…‹ã§ä½¿ç”¨ã™ã‚‹ã‚²ãƒ¼ãƒ ã‚«ãƒ¡ãƒ©ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚è¡¨ç¤ºã‚„è¦–ç‚¹ã®åˆæœŸè¨­å®šã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	void Enter(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆæ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="player">æ›´æ–°å¯¾è±¡ã® Player ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">æ›´æ–°å‡¦ç†ã«ä½¿ç”¨ã™ã‚‹ GameCamera ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã®çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;	

private:
	ParticleGroup* moveParticle_ = nullptr;

private:

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åœæ­¢
	/// </summary>
	void StopMoveParticle();
};



============================================================
File Path: Project/application/Game/Entity/Player/State/RootState.cpp
============================================================
#include "RootState.h"
// Service
#include "Engine/System/Service/InputService.h"
// Player, Camera
#include "application/Game/Entity/Player/Player.h"
// State
#include "MoveState.h"
#include "AvoidanceState.h"
#include "AttackState.h"

///-------------------------------------------/// 
/// é–‹å§‹æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void RootState::Enter(Player* player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;
}

///-------------------------------------------/// 
/// æ›´æ–°æ™‚ã«å‘¼ã³å‡ºã™
///-------------------------------------------///
void RootState::Update(Player * player, GameCamera* camera) {
	// å¼•æ•°ã®å–å¾—
	player_ = player;
	camera_ = camera;

	/// ===å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å–å¾—=== ///
	StickState leftStick = InputService::GetLeftStickState(0);

	/// ===æ¸›é€Ÿå‡¦ç†(æ•°å€¤ã‚’ä¸‹ã’ã‚‹ã»ã©ã‚†ã£ãã‚Šæ­¢ã¾ã‚‹)=== ///
	player_->ApplyDeceleration(player_->GetMoveComponent()->GetConfig().deceleration);

	/// ===æ­»äº¡ã—ã¦ã„ãªã‘ã‚Œã°=== ///
	if (!player_->GetIsDead()) {
		/// ===Stateã®å¤‰æ›´=== ///
		// æ”»æ’ƒãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰æ”»æ’ƒçŠ¶æ…‹ã¸
		if (InputService::TriggerButton(0, ControllerButtonType::X)) {
			// æ”»æ’ƒã®æº–å‚™ãŒã§ãã¦ã„ã‚Œã°
			if (!player_->GetAttackComponent()->GetState().isActive) {
				player_->ChangState(std::make_unique<AttackState>());
			}
			// RBãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰é€²ã‚“ã§ã„ã‚‹çªé€²çŠ¶æ…‹ã¸
		} else if (InputService::TriggerButton(0, ControllerButtonType::RB)) {

			// Aãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã‚‰å›é¿çŠ¶æ…‹ã¸
		} else if (InputService::TriggerButton(0, ControllerButtonType::A)) {
			// å›é¿ã®æº–å‚™ãŒã§ãã¦ã„ã‚Œã°
			if (player_->GetAvoidanceComponent()->GetState().isPreparation) {
				// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿ
				player_->ChangState(std::make_unique<AvoidanceState>(Normalize(player_->GetVelocity())));
			}
			// ç§»å‹•ãŒæœ‰ã‚Œã°
		} else if (std::abs(leftStick.x) > 0.1f || std::abs(leftStick.y) > 0.1f) {
			// Stateã‚’ç§»å‹•çŠ¶æ…‹ã¸
			player_->ChangState(std::make_unique<MoveState>());
		}
	}
}

///-------------------------------------------/// 
/// çµ‚äº†æ™‚ã«å‘¼ã³ã ã™
///-------------------------------------------///
void RootState::Finalize() {
	PlayerState::Finalize();
}


============================================================
File Path: Project/application/Game/Entity/Player/State/RootState.h
============================================================
#pragma once
/// ===Include=== ///
#include "Base/PlayerState.h"

///=====================================================/// 
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€šå¸¸çŠ¶æ…‹ã®ã‚¹ãƒ†ãƒ¼ãƒˆ
///=====================================================///
class RootState : public PlayerState {
public:

	~RootState() override = default;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã«å…¥ã£ãŸæ™‚ã«å‘¼ã°ã‚Œã‚‹å‡¦ç†
	/// </summary>
	/// <param name="player">å‡¦ç†å¯¾è±¡ã® Player ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">ä½¿ç”¨ã™ã‚‹ GameCamera ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Enter(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆæ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	/// <param name="player">æ›´æ–°å¯¾è±¡ã® Player ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	/// <param name="camera">æ›´æ–°å¯¾è±¡ã® GameCamera ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ã€‚</param>
	void Update(Player* player, GameCamera* camera) override;

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ãƒˆã®çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize() override;
};



============================================================
File Path: Project/application/Game/Entity/Player/Weapon/PlayerWeapon.cpp
============================================================
#include "PlayerWeapon.h"
// Player
#include "application/Game/Entity/Player/Player.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"
// Service
#include "Engine/System/Service/ColliderService.h"
#include "Engine/System/Service/DeltaTimeSevice.h"
#include "Engine/System/Service/ParticleService.h"
// ImGui
#ifdef USE_IMGUI
#include "imgui.h"
#endif // USE_IMGUI

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
PlayerWeapon::~PlayerWeapon() {
	object3d_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void PlayerWeapon::Initialize() {

	// Object3dã®åˆæœŸåŒ–
	object3d_ = std::make_unique<Object3d>();
	object3d_->Init(ObjectType::Model, "PlayerWeapon");
	object3d_->SetRotate({ 0.0f, 30.0f, 0.0f, 1.0f });

	/// ===OBBCollider=== ///
	OBBCollider::Initialize();
	name_ = ColliderName::PlayerWeapon;
	OBBCollider::SetHalfSize({ 0.5f, 0.5f, 3.0f });

	// DeltaTimeåˆæœŸåŒ–
	baseInfo_.deltaTime = DeltaTimeSevice::GetDeltaTime();

	// åˆæœŸçŠ¶æ…‹ã§ã¯éã‚¢ã‚¯ãƒ†ã‚£ãƒ–
	SetActive(false);
	attackInfo_.isAttacking = false;

	// æ›´æ–°
	Update();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void PlayerWeapon::Update() {

	// DeltaTimeæ›´æ–°
	baseInfo_.deltaTime = DeltaTimeSevice::GetDeltaTime();

	// æ”»æ’ƒä¸­ã§ãªã„å ´åˆã¯æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
	if (!attackInfo_.isAttacking) {
		SetActive(false);
		OBBCollider::Update();
		return;
	}

	// ã‚¿ã‚¤ãƒãƒ¼ã‚’é€²ã‚ã‚‹
	attackInfo_.timer += baseInfo_.deltaTime;
	attackInfo_.progress = attackInfo_.timer / attackInfo_.duration;

	// æ”»æ’ƒçµ‚äº†ãƒã‚§ãƒƒã‚¯
	if (attackInfo_.progress >= 1.0f) {
		attackInfo_.isAttacking = false;
		attackInfo_.progress = 1.0f;
		SetActive(false);
		ColliderService::RemoveCollider(this);
		OBBCollider::Update();
		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å‰Šé™¤
		attackParticle_->Stop();
		attackParticle_ = nullptr;
		return;
	}

	// ãƒ™ã‚¸ã‚§æ›²ç·šã«æ²¿ã£ãŸè»Œé“æ›´æ–°
	UpdateBezierTrajectory();

	// Particleã®è»Œé“æ›´æ–°
	if (attackParticle_) {
		attackParticle_->SetEmitterPosition(object3d_->GetWorldTranslate());
	}
	

	/// ===OBBCollider=== ///
	OBBCollider::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void PlayerWeapon::Draw(BlendMode mode) {
	// æ”»æ’ƒä¸­ã®ã¿æç”»
	if (attackInfo_.isAttacking) {
		OBBCollider::Draw(mode);
	}
}

///-------------------------------------------/// 
/// ImGui
///-------------------------------------------///
void PlayerWeapon::Information() {
#ifdef USE_IMGUI
	ImGui::Begin("PlayerWeapon");

	ImGui::SeparatorText("æ”»æ’ƒæƒ…å ±");
	ImGui::Checkbox("æ”»æ’ƒãƒ•ãƒ©ã‚°", &attackInfo_.isAttacking);
	ImGui::DragFloat("ã‚¿ã‚¤ãƒãƒ¼", &attackInfo_.timer, 0.01f);
	ImGui::DragFloat("é€²è¡Œåº¦", &attackInfo_.progress, 0.01f, 0.0f, 1.0f);
	ImGui::DragFloat("æŒç¶šæ™‚é–“", &attackInfo_.duration, 0.01f);

	ImGui::SeparatorText("ãƒ™ã‚¸ã‚§æ›²ç·š");
	ImGui::Text("åˆ¶å¾¡ç‚¹æ•°: %zu", attackInfo_.trajectoryPoints.size());

	for (size_t i = 0; i < attackInfo_.trajectoryPoints.size(); ++i) {
		ImGui::PushID(static_cast<int>(i));
		ImGui::Text("åˆ¶å¾¡ç‚¹ %zu", i);
		ImGui::Text("  ä½ç½®: (%.2f, %.2f, %.2f)",
			attackInfo_.trajectoryPoints[i].position.x,
			attackInfo_.trajectoryPoints[i].position.y,
			attackInfo_.trajectoryPoints[i].position.z);
		ImGui::Text("  æ™‚é–“: %.2f", attackInfo_.trajectoryPoints[i].time);
		ImGui::PopID();
	}

	ImGui::End();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çªåˆ¤å®š
///-------------------------------------------///
void PlayerWeapon::OnCollision(Collider* collider) {
	// æ”»æ’ƒä¸­ã§ãªã„ã€ã¾ãŸã¯æ—¢ã«ãƒ’ãƒƒãƒˆæ¸ˆã¿ã®å ´åˆã¯å‡¦ç†ã—ãªã„
	if (!baseInfo_.isActive) {
		return;
	}

	// æ•µã«å½“ãŸã£ãŸå ´åˆ
	if (collider->GetColliderName() == ColliderName::Enemy) {
		// ãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹ï¼ˆ1å›ã®æ”»æ’ƒã§è¤‡æ•°ãƒ’ãƒƒãƒˆã‚’é˜²ãï¼‰
		attackInfo_.hasHit = true;
		// ã“ã“ã§ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚„ã‚µã‚¦ãƒ³ãƒ‰ã®å†ç”Ÿãªã©ã‚’è¡Œã†
	}
}

///-------------------------------------------/// 
/// è¦ªå­é–¢ä¿‚ã®è¨­å®š
///-------------------------------------------///
void PlayerWeapon::SetUpParent(Player* parent) {
	player_ = parent;
	// è¦ªå­é–¢ä¿‚ã®è¨­å®š
	object3d_->SetParent(player_->GetModelCommon());
}

//-------------------------------------------/// 
/// æ”»æ’ƒé–‹å§‹å‡¦ç†ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šç‰ˆï¼‰
///-------------------------------------------///
void PlayerWeapon::StartAttack(
	const std::vector<BezierControlPointData>& trajectoryPoints,
	float duration,
	const Quaternion& startRotation,
	const Quaternion& endRotation) {

	// åˆ¶å¾¡ç‚¹ãŒ2ç‚¹æœªæº€ã®å ´åˆã¯ã‚¨ãƒ©ãƒ¼
	if (trajectoryPoints.size() < 2) {
		return;
	}

	// æ”»æ’ƒæƒ…å ±ã®è¨­å®š
	attackInfo_.isAttacking = true;
	attackInfo_.timer = 0.0f;
	attackInfo_.duration = duration;
	attackInfo_.progress = 0.0f;

	// ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹ã‚’ä¿å­˜
	attackInfo_.trajectoryPoints = trajectoryPoints;

	// å›è»¢ã®è¨­å®š
	attackInfo_.startRotation = startRotation;
	attackInfo_.endRotation = endRotation;

	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã«è¿½åŠ 
	ColliderService::AddCollider(this);

	// å½“ãŸã‚Šåˆ¤å®šãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
	attackInfo_.hasHit = false;

	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æœ‰åŠ¹åŒ–
	SetActive(true);

	// Particleã®é–‹å§‹
	if (attackParticle_) {
		attackParticle_->Stop();
		attackParticle_ = nullptr;
	}
	attackParticle_ = ParticleService::Emit("WeaponAttack", trajectoryPoints.front().position);
	attackParticle_->SetEmitterPosition(object3d_->GetWorldTranslate());

	// åˆæœŸä½ç½®ã‚’è¨­å®š
	transform_.translate = trajectoryPoints.front().position;
	transform_.rotate = startRotation;
}

///-------------------------------------------/// 
/// ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ä½ç½®ã‚’è¨ˆç®—
///-------------------------------------------///
Vector3 PlayerWeapon::CalculateBezierPoint(const std::vector<BezierControlPointData>& controlPoints, float t) {
	size_t n = controlPoints.size();

	// åˆ¶å¾¡ç‚¹ãŒ2ç‚¹ã®å ´åˆã¯ç·šå½¢è£œé–“
	if (n == 2) {
		return Math::Lerp(controlPoints[0].position, controlPoints[1].position, t);
	}

	// åˆ¶å¾¡ç‚¹ãŒ3ç‚¹ã®å ´åˆã¯2æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·š
	if (n == 3) {
		float u = 1.0f - t;
		float uu = u * u;
		float tt = t * t;

		Vector3 point = {};
		point.x = uu * controlPoints[0].position.x +
			2.0f * u * t * controlPoints[1].position.x +
			tt * controlPoints[2].position.x;
		point.y = uu * controlPoints[0].position.y +
			2.0f * u * t * controlPoints[1].position.y +
			tt * controlPoints[2].position.y;
		point.z = uu * controlPoints[0].position.z +
			2.0f * u * t * controlPoints[1].position.z +
			tt * controlPoints[2].position.z;

		return point;
	}

	// åˆ¶å¾¡ç‚¹ãŒ4ç‚¹ã®å ´åˆã¯3æ¬¡ãƒ™ã‚¸ã‚§æ›²ç·š
	if (n == 4) {
		float u = 1.0f - t;
		float uu = u * u;
		float uuu = uu * u;
		float tt = t * t;
		float ttt = tt * t;

		Vector3 point = {};
		point.x = uuu * controlPoints[0].position.x +
			3.0f * uu * t * controlPoints[1].position.x +
			3.0f * u * tt * controlPoints[2].position.x +
			ttt * controlPoints[3].position.x;
		point.y = uuu * controlPoints[0].position.y +
			3.0f * uu * t * controlPoints[1].position.y +
			3.0f * u * tt * controlPoints[2].position.y +
			ttt * controlPoints[3].position.y;
		point.z = uuu * controlPoints[0].position.z +
			3.0f * uu * t * controlPoints[1].position.z +
			3.0f * u * tt * controlPoints[2].position.z +
			ttt * controlPoints[3].position.z;

		return point;
	}

	// 5ç‚¹ä»¥ä¸Šã®å ´åˆã¯De Casteljauã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
	std::vector<Vector3> temp;
	for (const auto& cp : controlPoints) {
		temp.push_back(cp.position);
	}

	while (temp.size() > 1) {
		std::vector<Vector3> newTemp;
		for (size_t i = 0; i < temp.size() - 1; ++i) {
			newTemp.push_back(Math::Lerp(temp[i], temp[i + 1], t));
		}
		temp = newTemp;
	}

	return temp[0];
}

///-------------------------------------------/// 
/// ãƒ™ã‚¸ã‚§æ›²ç·šã«æ²¿ã£ãŸè»Œé“æ›´æ–°
///-------------------------------------------///
void PlayerWeapon::UpdateBezierTrajectory() {
	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ã‚’é©ç”¨ï¼ˆæ»‘ã‚‰ã‹ãªåŠ é€Ÿãƒ»æ¸›é€Ÿï¼‰
	float t = attackInfo_.progress;
	float easedT = Easing::EaseInOutQuad(t);

	// ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ä½ç½®ã‚’è¨ˆç®—
	transform_.translate = CalculateBezierPoint(attackInfo_.trajectoryPoints, easedT);

	// å›è»¢ã®è£œé–“ï¼ˆæ»‘ã‚‰ã‹ã«å›è»¢ï¼‰
	transform_.rotate = Math::SLerp(
		attackInfo_.startRotation,
		attackInfo_.endRotation,
		easedT
	);
}

============================================================
File Path: Project/application/Game/Entity/Player/Weapon/PlayerWeapon.h
============================================================
#pragma once
/// ===Include=== ///
// OBB
#include "Engine/Collider/OBBCollider.h"
// AttackData
#include "application/Game/Entity/Player/Editor/Data/AttackData.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Player;
class ParticleGroup;

///=====================================================/// 
/// PlayerWeapon
///=====================================================///
class PlayerWeapon : public OBBCollider {
public:
	PlayerWeapon() = default;
	~PlayerWeapon() override;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚</param>
	void Draw(BlendMode mode) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void Information() override;

	/// <summary>
	/// è¦ªå­é–¢ä¿‚ã‚’è¨­å®šã—ã€æŒ‡å®šã—ãŸã‚ªãƒ•ã‚»ãƒƒãƒˆã§å­ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½ç½®ã‚’èª¿æ•´
	/// </summary>
	/// <param name="parent">è¦ªã¨ãªã‚‹ Player ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚å­ã‚’ã“ã®è¦ªã«é–¢é€£ä»˜ã‘ã¾ã™ã€‚</param>
	void SetUpParent(Player* parent);

	/// <summary>
	/// æ”»æ’ƒã‚’é–‹å§‹ã™ã‚‹ï¼ˆãƒ™ã‚¸ã‚§æ›²ç·šï¼‰
	/// </summary>
	/// <param name="trajectoryPoints">ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹ãƒªã‚¹ãƒˆ</param>
	/// <param name="duration">æ”»æ’ƒã«ã‹ã‘ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰</param>
	/// <param name="startRotation">é–‹å§‹æ™‚ã®å›è»¢</param>
	/// <param name="endRotation">çµ‚äº†æ™‚ã®å›è»¢</param>
	void StartAttack(
		const std::vector<BezierControlPointData>& trajectoryPoints,
		float duration,
		const Quaternion& startRotation = Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f },
		const Quaternion& endRotation = Quaternion{ 0.0f, 0.0f, 0.0f, 1.0f }
	);

public: /// ===è¡çª=== ///
	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã® Collider ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	void OnCollision(Collider* collider) override;

public: /// ===Getter=== ///
	// æ”»æ’ƒä¸­ã‹ã©ã†ã‹
	bool GetIsAttack() const { return attackInfo_.isAttacking; }
	// æ”»æ’ƒã®é€²è¡Œåº¦ã‚’å–å¾—
	float GetAttackProgress() const { return attackInfo_.progress; }

public: /// ===Setter=== ///

	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–çŠ¶æ…‹ã®è¨­å®š
	void SetActive(bool flag) { baseInfo_.isActive = flag; }

private:
	// Player
	Player* player_ = nullptr;

	// Particle
	ParticleGroup* attackParticle_ = nullptr;

	/// ===åŸºæœ¬æƒ…å ±=== ///
	struct BaseInfo {
		bool isActive = false;					 // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°
		Vector3 offset = { 0.0f, 0.0f, 0.0f };   // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
		Vector3 velocity = { 0.0f, 0.0f, 0.0f }; // é€Ÿåº¦
		float deltaTime = 0.0f;					 // ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	};
	BaseInfo baseInfo_;

	/// ===æ”»æ’ƒæƒ…å ±=== ///
	struct AttackInfo {
		bool isAttacking = false;      // æ”»æ’ƒä¸­ãƒ•ãƒ©ã‚°
		bool hasHit = false;            // ãƒ’ãƒƒãƒˆæ¸ˆã¿ãƒ•ãƒ©ã‚°

		float timer = 0.0f;             // æ”»æ’ƒã‚¿ã‚¤ãƒãƒ¼
		float duration = 0.0f;          // æ”»æ’ƒã®æŒç¶šæ™‚é–“
		float progress = 0.0f;          // æ”»æ’ƒã®é€²è¡Œåº¦ï¼ˆ0.0ï½1.0ï¼‰

		// ãƒ™ã‚¸ã‚§æ›²ç·šã®åˆ¶å¾¡ç‚¹
		std::vector<BezierControlPointData> trajectoryPoints;

		Quaternion startRotation;      // é–‹å§‹æ™‚ã®å›è»¢
		Quaternion endRotation;        // çµ‚äº†æ™‚ã®å›è»¢
	};
	AttackInfo attackInfo_;

private:
	/// <summary>
	/// ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ä½ç½®ã‚’è¨ˆç®—
	/// </summary>
	/// <param name="controlPoints">åˆ¶å¾¡ç‚¹ã®ãƒªã‚¹ãƒˆ</param>
	/// <param name="t">é€²è¡Œåº¦ï¼ˆ0.0ï½1.0ï¼‰</param>
	/// <returns>ãƒ™ã‚¸ã‚§æ›²ç·šä¸Šã®ä½ç½®</returns>
	Vector3 CalculateBezierPoint(const std::vector<BezierControlPointData>& controlPoints, float t);

	/// <summary>
	/// ãƒ™ã‚¸ã‚§æ›²ç·šã«æ²¿ã£ãŸæ”»æ’ƒè»Œé“ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateBezierTrajectory();
};

============================================================
File Path: Project/application/Game/Object/GameGround/Ground.cpp
============================================================
#include "Ground.h"
// Service
#include "Engine/System/Service/ColliderService.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
Ground::~Ground() {
	object3d_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†ï¼ˆå‘¼ã³å‡ºã—ç”¨ï¼‰
///-------------------------------------------///
void Ground::GameInit(const std::string& modelName) {
	// Object3dã®ç”Ÿæˆ
	object3d_ = std::make_unique<Object3d>();
	// åˆæœŸåŒ–
	object3d_->Init(ObjectType::Model, modelName);
	// åˆæœŸåŒ–å‡¦ç†
	GameObject::Initialize();
	name_ = ColliderName::Ground; // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼åã‚’è¨­å®š
	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã«ç™»éŒ²
	ColliderService::AddCollider(this);
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void Ground::Initialize() {
	// GameObjectã®åˆæœŸåŒ–
	GameObject::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void Ground::Update() {
	// GameObjectã®æ›´æ–°
	GameObject::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void Ground::Draw(BlendMode mode) {
	// GameObjectã®æç”»
	GameObject::Draw(mode);
}

///-------------------------------------------/// 
/// è¡çªåˆ¤å®š
///-------------------------------------------///
void Ground::OnCollision(Collider* collider) {
	collider;
}

============================================================
File Path: Project/application/Game/Object/GameGround/Ground.h
============================================================

#pragma once
/// ===Include=== ///
#include "application/Game/Object/GameObject/GameObject.h"

///=====================================================/// 
/// Ground
///=====================================================///
class Ground : public GameObject<AABBCollider> {
public:
	Ground() = default;
	~Ground();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="modelName">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã®åå‰ã€‚</param>
	void GameInit(const std::string& modelName);

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize()override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">BlendModeã®é©ç”¨</param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal)override;

public:
	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªå…ˆã®Collider</param>
	void OnCollision(Collider* collider)override;
};


============================================================
File Path: Project/application/Game/Object/GameGround/GroundOcean.cpp
============================================================
#include "GroundOcean.h"
// Service
#include "Engine/System/Service/InputService.h"


///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
GroundOcean::~GroundOcean() {
	ocean_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void GroundOcean::Initialize() {

	// AABBã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®åˆæœŸåŒ–ã¨è¨­å®š
	GameObject::Initialize();
	GameObject::SetAABB({ { -500.0f, -2.0f, -500.0f }, { 500.0f, 0.0f, 500.0f } });

	// ã‚ªãƒ¼ã‚·ãƒ£ãƒ³ã®åˆæœŸåŒ–
	ocean_ = std::make_unique<Ocean>();
	ocean_->Initialize(500);
	ocean_->SetTranslate({ 0.0f, -1.0f, 0.0f });
	ocean_->SetScale({ 0.5f, 0.5f, 0.5f });

	// åˆå›æ›´æ–°
	ocean_->Update();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void GroundOcean::Update() {

#ifdef _DEBUG
	// ãƒ‡ãƒãƒƒã‚°ç”¨
	if (InputService::TriggerKey(DIK_SPACE)) {
		// æ³¢ç´‹ã‚’è¿½åŠ 
		Vector3 ripplePos = { 0.0f, 0.0f, 0.0f };
		ocean_->AddCircularRipple(ripplePos, 1.0f, 1.0f, 4.0f);
	}

#endif // _DEBUG

	// ã‚ªãƒ¼ã‚·ãƒ£ãƒ³ã®æ›´æ–°
	ocean_->Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void GroundOcean::Draw(BlendMode mode) {
	// ã‚ªãƒ¼ã‚·ãƒ£ãƒ³ã®æç”»
	ocean_->Draw(mode);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®è¡¨ç¤º
///-------------------------------------------///
void GroundOcean::ShowImGui() {
#ifdef USE_IMGUI
	// ã‚ªãƒ¼ã‚·ãƒ£ãƒ³ã®ImGuiè¡¨ç¤º
	ocean_->ShowImGui();
#endif // USE_IMGUI
}

///-------------------------------------------/// 
/// è¡çªåˆ¤å®š
///-------------------------------------------///
void GroundOcean::OnCollision(Collider* collider) {
	// ã‚ªãƒ¼ã‚·ãƒ£ãƒ³ã«æ³¢ç´‹ã‚’è¿½åŠ 
	Vector3 collisionPos = collider->GetTransform().translate;
	ocean_->AddCircularRipple(collisionPos, 2.0f, 1.0f, 4.0f);
}


============================================================
File Path: Project/application/Game/Object/GameGround/GroundOcean.h
============================================================
#pragma once
/// ===Include=== ///
// Collider
#include "application/Game/Object/GameObject/GameObject.h"
// Ocean
#include "Engine/Graphics/3d/Ocean/Ocean.h"

///=====================================================/// 
/// GroundOcean
///=====================================================///
class GroundOcean : public GameObject<AABBCollider> {
public: 

	GroundOcean() = default;
	~GroundOcean();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize()override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">BlendModeã®é©ç”¨</param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal)override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	void ShowImGui();

public: /// ===è¡çªå‡¦ç†=== ///

	/// <summary>
	/// è¡çªå‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªå…ˆã®Collider</param>
	void OnCollision(Collider* collider)override;

private:

	/// ===ã‚ªãƒ¼ã‚·ãƒ£ãƒ³=== ///
	std::unique_ptr<Ocean> ocean_;
};



============================================================
File Path: Project/application/Game/Object/GameObject/GameObject.cpp
============================================================
#include "GameObject.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI

/// ===ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå€™è£œ=== ///
template class GameObject<AABBCollider>;
template class GameObject<OBBCollider>;
template class GameObject<SphereCollider>;

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
GameObject<TCollider>::~GameObject() {
	this->object3d_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameObject<TCollider>::Initialize() {
	/// ===TCollider=== ///
	TCollider::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameObject<TCollider>::Update() {
	/// ===TCollider=== ///
	TCollider::Update();
}

///-------------------------------------------/// 
/// æç”»å‡¦ç†
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameObject<TCollider>::Draw(BlendMode mode) {
	/// ===TCollider=== ///
	TCollider::Draw(mode);
}

///-------------------------------------------/// 
/// ImGuiæƒ…å ±ã®è¡¨ç¤º
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameObject<TCollider>::Information() {}

///-------------------------------------------/// 
/// è¡çªåˆ¤å®š
///-------------------------------------------///
template<typename TCollider> requires IsCollider<TCollider>
void GameObject<TCollider>::OnCollision(Collider* collider) {
	collider;
}



============================================================
File Path: Project/application/Game/Object/GameObject/GameObject.h
============================================================
#pragma once
/// ===Include=== ///
// Collider
#include "Engine/Collider/OBBCollider.h"
#include "Engine/Collider/AABBCollider.h"
#include "Engine/Collider/SphereCollider.h"
#include "Engine/Collider/ColliderConcept.h"

///=====================================================/// 
/// GameObject
///=====================================================///
template<typename TCollider> requires IsCollider<TCollider>
class GameObject : public TCollider {
public:

	GameObject() = default;
	virtual ~GameObject();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	virtual void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚</param>
	virtual void Draw(BlendMode mode) override;

	/// <summary>
	/// ImGuiæƒ…å ±ã®è¡¨ç¤º
	/// </summary>
	virtual void Information() override;

public: /// ===è¡çªåˆ¤å®š=== ///
	/// <summary>
	/// è¡çªæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã‚’è¡¨ã™ Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã€‚</param>
	virtual void OnCollision(Collider* collider) override;
};



============================================================
File Path: Project/application/Game/Object/GameStage.cpp
============================================================
#include "GameStage.h"
// Service
#include "Engine/System/Service/GraphicsResourceGetter.h"
// Math
#include "Math/sMath.h"
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI


///-------------------------------------------/// 
/// åˆæœŸåŒ–ã€€
///-------------------------------------------///
void GameStage::Initialize(const std::string& levelData) {

	// ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	LoadStageData(levelData);
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void GameStage::Update() {

	// Groundã®æ›´æ–°
	for (const auto& ground : grounds_) {
		if (ground) {
			ground->Update();
		}
	}

	// Groundã®æ›´æ–°
	for (const auto& ocean : Oceans_) {
		if (ocean) {
#ifdef USE_IMGUI
			ocean->ShowImGui();
#endif // USE_IMGUI
			ocean->Update();
		}
	}

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æ›´æ–°
	for (const auto& obj : objects_) {
		if (obj) {
			obj->Update();
		}
	}
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void GameStage::Draw(BlendMode mode) {

	// GroundOceanã®æ›´æ–°
	for (const auto& ground : grounds_) {
		if (ground) {
			ground->Draw(mode);
		}
	}

	// GroundOceanã®æ›´æ–°
	for (const auto& ocean : Oceans_) {
		if (ocean) {
			ocean->Draw(mode);
		}
	}

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»
	for (const auto& obj : objects_) {
		if (obj) {
			obj->Draw(mode);
		}
	}
}

///-------------------------------------------/// 
/// ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°
///-------------------------------------------///
void GameStage::LoadStageData(const std::string& stageData) {
	// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	LevelData* levelData = GraphicsResourceGetter::GetLevelData(stageData);

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåˆ†å›ã™
	for (const auto& stage : levelData->objects) {
		if (stage.classType == LevelData::ClassTypeLevel::Ground1) {
			// Object3dã®ç”Ÿæˆ
			std::shared_ptr<Ground> ground = std::make_shared<Ground>();
			// åˆæœŸåŒ–
			//ground->Initialize();
			ground->GameInit(stage.fileName);

			// AABBè¨­å®š
			Vector3 min = stage.translation + stage.colliderInfo1;
			Vector3 max = stage.translation + stage.colliderInfo2;
			ground->SetAABB({ min, max });

			// åº§æ¨™è¨­å®š
			ground->SetTranslate(stage.translation);
			ground->SetRotate(Math::QuaternionFromVector(stage.rotation));
			ground->SetScale(stage.scaling);

			// ä¸€å›æ›´æ–°ã‚’å…¥ã‚Œã‚‹
			ground->Update();

			// é…åˆ—ã«è¿½åŠ 
			grounds_.emplace_back(ground);
		} else if (stage.classType == LevelData::ClassTypeLevel::Object1) {

			// Object3dã®ç”Ÿæˆ
			std::shared_ptr<StageObject> object = std::make_shared<StageObject>();
			// åˆæœŸåŒ–
			object->GameInit(stage.fileName);

			// AABBè¨­å®š
			Vector3 min = stage.translation + stage.colliderInfo1;
			Vector3 max = stage.translation + stage.colliderInfo2;
			object->SetAABB({ min, max });

			// åº§æ¨™è¨­å®š
			object->SetTranslate(stage.translation);
			object->SetRotate(Math::QuaternionFromVector(stage.rotation));
			object->SetScale(stage.scaling);

			// ä¸€å›æ›´æ–°ã‚’å…¥ã‚Œã‚‹
			object->Update();

			// é…åˆ—ã«è¿½åŠ 
			objects_.emplace_back(object);
		} else if (stage.classType == LevelData::ClassTypeLevel::Object2){

			// Object3dã®ç”Ÿæˆ
			std::shared_ptr<StageObject> object = std::make_shared<StageObject>();
			// åˆæœŸåŒ–
			object->GameInit(stage.fileName);
			Vector3 min = stage.translation + stage.colliderInfo1;
			Vector3 max = stage.translation + stage.colliderInfo2;
			object->SetAABB({ min, max });

			// åº§æ¨™è¨­å®š
			object->SetTranslate(stage.translation);
			object->SetRotate(Math::QuaternionFromVector(stage.rotation));
			object->SetScale(stage.scaling);

			// ä¸€å›æ›´æ–°ã‚’å…¥ã‚Œã‚‹
			object->Update();

			// é…åˆ—ã«è¿½åŠ 
			objects_.emplace_back(object);
		} else {
			// ãã®ä»–ã®ã‚¯ãƒ©ã‚¹ã¯ç„¡è¦–
			continue;
		}
	}
}


============================================================
File Path: Project/application/Game/Object/GameStage.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Game/Object/StageObject/StageObject.h"
#include "application/Game/Object/GameGround/Ground.h"
#include "application/Game/Object/GameGround/GroundOcean.h"
//C++
#include <string>
#include <vector>
#include <memory>

///-------------------------------------------/// 
/// GameStage
///-------------------------------------------///
class GameStage {
public:

	GameStage() = default;
	~GameStage() = default;

	/// <summary>
	/// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã—ã¦åˆæœŸåŒ–ã‚’è¡Œã„ã¾ã™ã€‚
	/// </summary>
	/// <param name="levelData">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€æ–‡å­—åˆ—ã¸ã® const å‚ç…§ã€‚</param>
	void Initialize(const std::string& levelData);

	/// <summary>
	/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚„ã‚·ã‚¹ãƒ†ãƒ ã®çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã®é–¢æ•°ã€‚
	/// </summary>
	void Update();

	/// <summary>
	/// æŒ‡å®šã—ãŸãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã§æç”»ã‚’è¡Œã†é–¢æ•°ã€‚ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ BlendMode::kBlendModeAddã€‚
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã€‚çœç•¥ã—ãŸå ´åˆã¯ BlendMode::kBlendModeAdd ãŒä½¿ç”¨ã•ã‚Œã¾ã™ã€‚</param>
	void Draw(BlendMode mode = BlendMode::KBlendModeNormal);

private:
	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆ
	std::vector<std::shared_ptr<StageObject>> objects_; 
	std::vector<std::shared_ptr<GroundOcean>> Oceans_;
	std::vector<std::shared_ptr<Ground>> grounds_;

private:

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€é–¢æ•°ã€‚
	/// </summary>
	/// <param name="stageData">èª­ã¿è¾¼ã‚€ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’å«ã‚€æ–‡å­—åˆ—ã¸ã®å‚ç…§ã€‚ã‚¹ãƒ†ãƒ¼ã‚¸å®šç¾©ã‚„æ§‹æˆã‚’è¡¨ã™ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¸¡ã—ã¾ã™ã€‚</param>
	void LoadStageData(const std::string& stageData);
};



============================================================
File Path: Project/application/Game/Object/StageObject/StageObject.cpp
============================================================
#include "StageObject.h"
// Service
#include "Engine/System/Service/ColliderService.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
StageObject::~StageObject() {
	object3d_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†ï¼ˆå‘¼ã³å‡ºã—ç”¨ï¼‰
///-------------------------------------------///
void StageObject::GameInit(const std::string& modelName) {
	// Object3dã®ç”Ÿæˆ
	object3d_ = std::make_unique<Object3d>();
	// åˆæœŸåŒ–
	object3d_->Init(ObjectType::Model, modelName);
	// åˆæœŸåŒ–å‡¦ç†
	GameObject::Initialize();
	name_ = ColliderName::Object; // ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼åã‚’è¨­å®š
	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹ã«ç™»éŒ²
	ColliderService::AddCollider(this);
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void StageObject::Initialize() {
	// GameObjectã®åˆæœŸåŒ–
	GameObject::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void StageObject::Update() {
	// GameObjectã®æ›´æ–°
	GameObject::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void StageObject::Draw(BlendMode mode) {
	// GameObjectã®æç”»
	GameObject::Draw(mode);
}

///-------------------------------------------/// 
/// è¡çªå‡¦ç†
///-------------------------------------------///
void StageObject::OnCollision(Collider* collider) {
	collider;
}



============================================================
File Path: Project/application/Game/Object/StageObject/StageObject.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Game/Object/GameObject/GameObject.h"
// C++
#include <string>
#include <memory>

///=====================================================/// 
/// StageObject
///=====================================================///
class StageObject : public GameObject<AABBCollider> {
public:
	StageObject() = default;
	~StageObject();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="modelName">åˆæœŸåŒ–ã«ä½¿ç”¨ã™ã‚‹ãƒ¢ãƒ‡ãƒ«ã®åå‰ã€‚</param>
	void GameInit(const std::string& modelName);

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	/// <param name="mode">æç”»ã«ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’æŒ‡å®šã—ã¾ã™ã€‚</param>
	void Draw(BlendMode mode) override;

public: /// ===OnCollision=== ///
	/// <summary>
	/// ä»–ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã¨ã®è¡çªãŒç™ºç”Ÿã—ãŸã¨ãã«å‘¼ã³å‡ºã•ã‚Œã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã•ã‚ŒãŸãƒãƒ³ãƒ‰ãƒ©ã€‚
	/// </summary>
	/// <param name="collider">è¡çªã—ãŸç›¸æ‰‹ã® Collider ã¸ã®ãƒã‚¤ãƒ³ã‚¿ã€‚è¡çªã®è©³ç´°ã‚’å•ã„åˆã‚ã›ã—ãŸã‚Šã€è¡çªå¿œç­”ã‚’å‡¦ç†ã™ã‚‹ãŸã‚ã«ä½¿ç”¨ã•ã‚Œã‚‹ã€‚</param>
	void OnCollision(Collider* collider) override;
};



============================================================
File Path: Project/application/Game/UI/Game/GameSceneUI.cpp
============================================================
#include "GameSceneUI.h"
// Player
#include "application/Game/Entity/Player/Player.h"

///-------------------------------------------/// 
/// Setter
///-------------------------------------------///
void GameSceneUI::SetPlayer(Player* player) {
	// PlayerUI
	playerUI_->SetPlayer(player);
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
void GameSceneUI::Initialize() {
	// PlayerUIã®ç”Ÿæˆã¨åˆæœŸåŒ–
	playerUI_ = std::make_unique<PlayerUI>();
	playerUI_->Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
void GameSceneUI::Update() {
	// PlayerUIã®æ›´æ–°
	playerUI_->Update();
}

///-------------------------------------------/// 
/// æç”»å‡¦ç†
///-------------------------------------------///
void GameSceneUI::Draw() {
	// PlayerUIã®æç”»
	playerUI_->Draw();
}

============================================================
File Path: Project/application/Game/UI/Game/GameSceneUI.h
============================================================
#pragma once
/// ===Include=== ///
#include "PlayerUI.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Player;

///=====================================================/// 
/// GameSceneUI
///=====================================================///
class GameSceneUI {
public:

	GameSceneUI() = default;
	~GameSceneUI() = default;

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

public: /// ===Setter=== ///
	// Playerã®ã‚»ãƒƒãƒˆ
	void SetPlayer(Player* player);

private:

	/// ===Class=== ///
	// PlayerUI
	std::unique_ptr<PlayerUI> playerUI_;
};



============================================================
File Path: Project/application/Game/UI/Game/PlayerUI.cpp
============================================================
#include "PlayerUI.h"
// Player
#include "application/Game/Entity/Player/Player.h"
// Service
#include "Engine/System/Service/GraphicsResourceGetter.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
PlayerUI::~PlayerUI() {
	moveUI_.reset();
	cameraUI_.reset();
	attackUI_.reset();
	avoidanceUI_.reset();
	xButton_.reset();
	aButton_.reset();
	leftStick_.reset();
	rightStick_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–å‡¦ç†
///-------------------------------------------///
void PlayerUI::Initialize() {
	// windowã‚µã‚¤ã‚ºã®å–å¾—
	Vector2 windowSize = {
		static_cast<float>(GraphicsResourceGetter::GetWindowWidth()),
		static_cast<float>(GraphicsResourceGetter::GetWindowHeight())
	};
	
	/// ===Scale=== ///
	// åŸºæº–è§£åƒåº¦
	constexpr float BASE_WIDTH = 1920.0f;
	constexpr float BASE_HEIGHT = 1080.0f;
	// Scale
	scale_ = { windowSize.x / BASE_WIDTH, windowSize.y / BASE_HEIGHT };

	/// ===ä½ç½®=== ///
	// åŸºæº–ç‚¹
	Vector2 point = {
		windowSize.x * (3.0f / 4.0f) - (20.0f * scale_.x),
		windowSize.y * (7.0f / 8.0f)
	};
	// é–“éš”
	float spaceX = (windowSize.x - point.x) / 8.0f + (2.0f * scale_.x);
	// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼UIã®Yåº§æ¨™
	float controllerPosY = point.y + (90.0f * scale_.y);

	// ç§»å‹•UIã®åˆæœŸåŒ–
	moveUI_ = std::make_shared<Sprite>();
	moveUI_->Initialize("MoveUI");
	moveUI_->SetPosition({ point.x + spaceX, point.y });
	moveUIPos_ = moveUI_->GetPosition();
	moveUI_->SetSize({ 80.0f * scale_.x, 80.0f * scale_.y });
	moveUI_->SetAnchorPoint({ 0.5f, 0.5f });
	moveUI_->SetColor({ 0.0f, 0.0f, 0.0f, 1.0f });
	// å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯UIã®åˆæœŸåŒ–
	leftStick_ = std::make_shared<Sprite>();
	leftStick_->Initialize("leftStick");
	leftStick_->SetPosition({ moveUI_->GetPosition().x, controllerPosY });
	leftStick_->SetSize({ 50.0f * scale_.x, 50.0f * scale_.y });
	leftStick_->SetAnchorPoint({ 0.5f, 0.5f });

	// ã‚«ãƒ¡ãƒ©UIã®åˆæœŸåŒ–
	cameraUI_ = std::make_shared<Sprite>();
	cameraUI_->Initialize("CameraUI");
	cameraUI_->SetPosition({ point.x + (spaceX * 3.0f), point.y });
	cameraUI_->SetSize({ 80.0f * scale_.x, 80.0f * scale_.y });
	cameraUI_->SetAnchorPoint({ 0.5f, 0.5f });
	cameraUI_->SetColor({ 0.0f, 0.0f, 0.0f, 1.0f });
	// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯UIåˆæœŸåŒ–
	rightStick_ = std::make_shared<Sprite>();
	rightStick_->Initialize("rightStick");
	rightStick_->SetPosition({ cameraUI_->GetPosition().x, controllerPosY });
	rightStick_->SetSize({ 50.0f * scale_.x, 50.0f * scale_.y });
	rightStick_->SetAnchorPoint({ 0.5f, 0.5f });

	// æ”»æ’ƒUIã®åˆæœŸåŒ–
	attackUI_ = std::make_shared<Sprite>();
	attackUI_->Initialize("AttackUI");
	attackUI_->SetPosition({ point.x + (spaceX * 5.0f), point.y });
	attackUI_->SetSize({ 80.0f * scale_.x, 80.0f * scale_.y });
	attackUI_->SetAnchorPoint({ 0.5f, 0.5f });
	attackUI_->SetColor({ 0.0f, 0.0f, 0.0f, 1.0f });
	// Xãƒœã‚¿ãƒ³UIã®åˆæœŸåŒ–
	xButton_ = std::make_shared<Sprite>();
	xButton_->Initialize("xButton");
	xButton_->SetPosition({ attackUI_->GetPosition().x,  controllerPosY });
	xButton_->SetSize({ 50.0f * scale_.x, 50.0f * scale_.y });
	xButton_->SetAnchorPoint({ 0.5f, 0.5f });

	// å›é¿UIã®åˆæœŸåŒ–
	avoidanceUI_ = std::make_shared<Sprite>();
	avoidanceUI_->Initialize("AvoidanceUI");
	avoidanceUI_->SetPosition({ point.x + (spaceX * 7.0f), point.y });
	avoidanceUI_->SetSize({ 80.0f * scale_.x, 80.0f * scale_.y });
	avoidanceUI_->SetAnchorPoint({ 0.5f, 0.5f });
	avoidanceUI_->SetColor({ 0.0f, 0.0f, 0.0f, 1.0f });
	// Aãƒœã‚¿ãƒ³UIã®åˆæœŸåŒ–
	aButton_ = std::make_shared<Sprite>();
	aButton_->Initialize("aButton");
	aButton_->SetPosition({ avoidanceUI_->GetPosition().x, controllerPosY });
	aButton_->SetSize({ 50.0f * scale_.x, 50.0f * scale_.y });
	aButton_->SetAnchorPoint({ 0.5f, 0.5f });

	// UIã®ä½ç½®ã®ä¿å­˜
	moveUIPos_ = moveUI_->GetPosition();
	cameraUIPos_ = cameraUI_->GetPosition();
}

///-------------------------------------------/// 
/// æ›´æ–°å‡¦ç†
///-------------------------------------------///
void PlayerUI::Update() {
	// ãƒ•ãƒ©ã‚°ã¨è‰²ã®ãƒªã‚»ãƒƒãƒˆ
	if (colorChange_.attackUI) {
		colorChange_.attackUI = false;
		attackUI_->SetColor({ 0.0f, 0.0f, 0.0f, 1.0f });
	} else if (colorChange_.avoidanceUI) {
		colorChange_.avoidanceUI = false;
		avoidanceUI_->SetColor({ 0.0f, 0.0f, 0.0f, 1.0f });
	}

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°å‡¦ç†
	SpriteUpdate();

	// è‰²ã®æ›´æ–°å‡¦ç†
	ColorUpdate();

	// ç§»å‹•UIã®æ›´æ–°
	moveUI_->Update();
	// ã‚«ãƒ¡ãƒ©UIã®æ›´æ–°
	cameraUI_->Update();
	// æ”»æ’ƒUIã®æ›´æ–°
	attackUI_->Update();
	// å›é¿UIã®æ›´æ–°
	avoidanceUI_->Update();
	// Xãƒœã‚¿ãƒ³Uiã®æ›´æ–°
	xButton_->Update();
	// Aãƒœã‚¿ãƒ³UIã®æ›´æ–°
	aButton_->Update();
	// å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯UIã®æ›´æ–°
	leftStick_->Update();
	// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯UIã®æ›´æ–°
	rightStick_->Update();
}

///-------------------------------------------/// 
/// æç”»å‡¦ç†
///-------------------------------------------///
void PlayerUI::Draw() {
	// ç§»å‹•UIã®æç”»
	moveUI_->Draw();
	// ã‚«ãƒ¡ãƒ©UIã®æç”»
	cameraUI_->Draw();
	// æ”»æ’ƒUIã®æç”»
	attackUI_->Draw();
	// å›é¿UIã®æç”»
	avoidanceUI_->Draw();
	// XButtonUIã®æç”»
	xButton_->Draw();
	// AButtonUIã®æç”»
	aButton_->Draw();
	// å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯UIã®æç”»
	leftStick_->Draw();
	// å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯UIã®æç”»
	rightStick_->Draw();
}

///-------------------------------------------/// 
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void PlayerUI::SpriteUpdate() {

	/// ===ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å–å¾—=== ///
	Vector2 leftStick = player_->GetLeftStickState();
	Vector2 rightStick = player_->GetRightStickState();
	leftStick.y *= -1.0f;
	rightStick.y *= -1.0f;

	/// ===ä½ç½®ã®æ›´æ–°=== ///
	// ç§»å‹•UI
	moveUI_->SetPosition(moveUIPos_ + leftStick * 15.0f);
	// ã‚«ãƒ¡ãƒ©UI
	cameraUI_->SetPosition(cameraUIPos_ + rightStick * 15.0f);

	/// ===ã‚µã‚¤ã‚ºã®ç®¡ç†=== ///
	if (std::abs(leftStick.x) > 0.1f || std::abs(leftStick.y) > 0.1f) {
		// ã‚µã‚¤ã‚ºã‚’å¤§ããã™ã‚‹
		moveUI_->SetSize({ 100.0f * scale_.x, 100.0f * scale_.y });
	} else {
		// ã‚µã‚¤ã‚ºã‚’å…ƒã«æˆ»ã™
		moveUI_->SetSize({ 80.0f * scale_.x, 80.0f * scale_.y });
	}
	if (std::abs(rightStick.x) > 0.1f || std::abs(rightStick.y) > 0.1f) {
		// ã‚µã‚¤ã‚ºã‚’å¤§ããã™ã‚‹
		cameraUI_->SetSize({ 100.0f * scale_.x, 100.0f * scale_.y });
	} else {
		// ã‚µã‚¤ã‚ºã‚’å…ƒã«æˆ»ã™
		cameraUI_->SetSize({ 80.0f * scale_.x, 80.0f * scale_.y });
	}
}

///-------------------------------------------/// 
/// è‰²ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void PlayerUI::ColorUpdate() {
	/// ===è‰²å¤‰æ›´ã®ãƒ•ãƒ©ã‚°ç®¡ç†=== ///
	if (player_->GetAttackComponent()->GetState().isActive && !colorChange_.attackUI) {
		// æ”»æ’ƒUI
		colorChange_.attackUI = true;
	}
	if (player_->GetAvoidanceComponent()->GetState().isActive && !colorChange_.avoidanceUI) {
		// å›é¿UI
		colorChange_.avoidanceUI = true;
	}

	/// ===UIã®è‰²æ›´æ–°=== ///
	if (colorChange_.attackUI) {
		// æ”»æ’ƒUI
		attackUI_->SetColor(activeColor_);
	}
	if (colorChange_.avoidanceUI) {
		// å›é¿UI
		avoidanceUI_->SetColor(activeColor_);
	}
}


============================================================
File Path: Project/application/Game/UI/Game/PlayerUI.h
============================================================
#pragma once
/// ===Include=== ///
#include "application/Drawing/2d/Sprite.h"

/// ===å‰æ–¹å®£è¨€=== ///
class Player;

///-------------------------------------------/// 
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼UI
///-------------------------------------------///
class PlayerUI {
public:

	PlayerUI() = default;
	~PlayerUI();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

public: /// ===Setter=== ///
	// Playerã®ã‚»ãƒƒãƒˆ
	void SetPlayer(Player* player) { player_ = player; }

private:
	// Player
	Player* player_;

	/// ===Sprite=== ///
	// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
	std::shared_ptr<Sprite> moveUI_;      // ç§»å‹•UI
	std::shared_ptr<Sprite> cameraUI_;    // ã‚«ãƒ¡ãƒ©UI
	std::shared_ptr<Sprite> attackUI_;    // æ”»æ’ƒUI
	std::shared_ptr<Sprite> avoidanceUI_; // å›é¿UI
	// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼
	std::shared_ptr<Sprite> xButton_;	  // X
	std::shared_ptr<Sprite> aButton_;	  // A
	std::shared_ptr<Sprite> leftStick_;	  // å·¦ã‚¹ãƒ†ã‚£ãƒƒã‚¯
	std::shared_ptr<Sprite> rightStick_;  // å³ã‚¹ãƒ†ã‚£ãƒƒã‚¯

	/// ===ä½ç½®=== ///
	Vector2 moveUIPos_ = { 100.0f, 500.0f };      // ç§»å‹•UIä½ç½®
	Vector2 cameraUIPos_ = { 300.0f, 500.0f };    // ã‚«ãƒ¡ãƒ©UIä½ç½®

	/// ===Color=== ///
	Vector4 activeColor_ = { 1.0f, 0.0f, 0.0f, 1.0f };   // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ©ãƒ¼

	/// ===ãƒ•ãƒ©ã‚°=== ///
	struct ColorChange {
		bool attackUI = false;    // æ”»æ’ƒUIã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°
		bool avoidanceUI = false; // å›é¿UIã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°
	};
	ColorChange colorChange_;

	/// ===å‚ç…§ã‚¹ã‚±ãƒ¼ãƒ«å€ç‡=== ///
	Vector2 scale_ = { 1.0f, 1.0f }; // ã‚¹ã‚±ãƒ¼ãƒ«

private:

	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°å‡¦ç†
	/// </summary>
	void SpriteUpdate();

	/// <summary>
	/// è‰²ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void ColorUpdate();
};



============================================================
File Path: Project/application/Game/UI/Title/TitleUI.cpp
============================================================
#include "TitleUI.h"


============================================================
File Path: Project/application/Game/UI/Title/TitleUI.h
============================================================
#pragma once
class TitleUI {};



============================================================
File Path: Project/application/Scene/ClearScene.cpp
============================================================
#include "ClearScene.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
ClearScene::~ClearScene() {
	// ISceneã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	IScene::~IScene();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void ClearScene::Initialize() {
	// ISceneã®åˆæœŸåŒ–(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã¨ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£)
	IScene::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void ClearScene::Update() {
	/// ===ãƒ‡ãƒãƒƒã‚¯ç”¨ImGui=== ///
#ifdef USE_IMGUI
	ImGui::Begin("ClearScene");
	ImGui::End();
#endif // USE_IMGUI

	/// ===ISceneã®æ›´æ–°=== ///
	IScene::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void ClearScene::Draw() {
#pragma region èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
#pragma endregion

#pragma region ãƒ¢ãƒ‡ãƒ«æç”»
	/// ===ISceneã®æç”»=== ///
	IScene::Draw();
#pragma endregion

#pragma region å‰æ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
#pragma endregion
}


============================================================
File Path: Project/application/Scene/ClearScene.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/IScene.h"

///=====================================================/// 
/// ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³
///=====================================================///
class ClearScene : public IScene {
public:/// ===ãƒ¡ãƒ³ãƒé–¢æ•°=== ///

	ClearScene() = default;
	~ClearScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;
	
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw() override;

private:/// ===ãƒ¡ãƒ³ãƒå¤‰æ•°=== ///
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”¨
	/// </summary>

};



============================================================
File Path: Project/application/Scene/Debug/AttackEditorScene.cpp
============================================================
#include "AttackEditorScene.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"
// ServiceLocator
#include "Engine/System/Service/DeltaTimeSevice.h"
// ImGui
#ifdef USE_IMGUI
#include <imgui.h>
#endif // USE_IMGUI

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
AttackEditorScene::~AttackEditorScene() {
    attackEditor_.reset();
    previewWeapon_.reset();
    line_.reset();
    // ISceneã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    IScene::~IScene();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void AttackEditorScene::Initialize() {
    // ISceneã®åˆæœŸåŒ–(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã¨ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£)
    IScene::Initialize();

    /// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®åˆæœŸåŒ–=== ///
    attackEditor_ = std::make_unique<AttackEditor>();
    attackEditor_->Initialize();
    attackEditor_->SetVisible(true);

    /// ===Line=== ///
    line_ = std::make_unique<Line>();

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸåŒ–=== ///
    previewWeapon_ = std::make_unique<PlayerWeapon>();
    previewWeapon_->Initialize();

    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã‚«ãƒ¡ãƒ©ã‚’è¨­å®š
    attackEditor_->SetPreviewPlayer(previewWeapon_.get());

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®ä½ç½®ã‚’è¨­å®š
    defaultCamera_->SetTranslate(cameraPosition_);
    defaultCamera_->SetRotate(cameraRotation_);
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void AttackEditorScene::Update() {
    /// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®æ›´æ–°=== ///
    if (attackEditor_) {
        attackEditor_->Update(DeltaTimeSevice::GetDeltaTime());
    }

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ›´æ–°=== ///
    if (previewWeapon_) {
		previewWeapon_->Update();
    }

    /// ===ImGuiæç”»=== ///
#ifdef USE_IMGUI
    RenderMenuBar();
    /// ===ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã‚«ãƒ¡ãƒ©=== ///
    defaultCamera_->ImGuiUpdate();
	defaultCamera_->DebugUpdate();

    // ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ¡ã‚¤ãƒ³ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    attackEditor_->Render();

    // ã‚µãƒ–ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    if (showHelp_) {
        RenderHelpWindow();
    }
    if (showStats_) {
        RenderStatsWindow();
    }
#endif // USE_IMGUI

    /// ===ISceneã®æ›´æ–°=== ///
    IScene::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void AttackEditorScene::Draw() {
    /// ===ã‚°ãƒªãƒƒãƒ‰ã®æç”»=== ///
    if (showGrid_) {
        line_->DrawGrid({ 0.0f, 0.0f, 0.0f }, { 500.0f, 0.0f, 500.0f }, 100, { 1.0f, 1.0f, 1.0f, 1.0f });
    }

    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æç”»=== ///
    if (previewWeapon_) {
        previewWeapon_->Draw(BlendMode::KBlendModeNormal);
    }

    /// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®æç”»=== ///
    if (attackEditor_) {
        attackEditor_->DrawPreview();
    }

    /// ===ISceneã®æç”»=== ///
    IScene::Draw();
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
///-------------------------------------------///
void AttackEditorScene::RenderMenuBar() {
#ifdef USE_IMGUI
    if (ImGui::BeginMainMenuBar()) {
        if (ImGui::BeginMenu("è¡¨ç¤º")) {
            ImGui::Checkbox("ãƒ˜ãƒ«ãƒ—", &showHelp_);
            ImGui::Checkbox("çµ±è¨ˆæƒ…å ±", &showStats_);
            ImGui::Checkbox("ã‚°ãƒªãƒƒãƒ‰", &showGrid_);
            ImGui::EndMenu();
        }
        if (ImGui::BeginMenu("ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼")) {
            if (ImGui::MenuItem("æ”»æ’ƒã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚’è¡¨ç¤º/éè¡¨ç¤º")) {
                attackEditor_->ToggleVisibility();
            }
            ImGui::EndMenu();
        }
        ImGui::EndMainMenuBar();
    }
#endif
}

///-------------------------------------------/// 
/// ãƒ˜ãƒ«ãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
///-------------------------------------------///
void AttackEditorScene::RenderHelpWindow() {
#ifdef USE_IMGUI
    ImGui::Begin("ãƒ˜ãƒ«ãƒ—", &showHelp_);

    ImGui::Text("æ”»æ’ƒã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã®ä½¿ã„æ–¹:");
    ImGui::Separator();
    ImGui::BulletText("å·¦å´ã®ãƒªã‚¹ãƒˆã‹ã‚‰æ”»æ’ƒã‚’é¸æŠ");
    ImGui::BulletText("å³å´ã®ã‚¿ãƒ–ã§å„è¨­å®šã‚’ç·¨é›†");
    ImGui::BulletText("ã€Œä¿å­˜ã€ãƒœã‚¿ãƒ³ã§JSONã«ä¿å­˜");
    ImGui::BulletText("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã§è»Œé“ã‚’ç¢ºèª");

    ImGui::Separator();
    ImGui::Text("ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚­ãƒ¼:");
    ImGui::BulletText("Ctrl+N:  æ–°è¦ä½œæˆ");
    ImGui::BulletText("Ctrl+S: ä¿å­˜");
    ImGui::BulletText("Ctrl+O: èª­ã¿è¾¼ã¿");

    ImGui::End();
#endif
}

///-------------------------------------------/// 
/// çµ±è¨ˆæƒ…å ±ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
///-------------------------------------------///
void AttackEditorScene::RenderStatsWindow() {
#ifdef USE_IMGUI
    ImGui::Begin("çµ±è¨ˆæƒ…å ±", &showStats_);

    ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);
    ImGui::Text("ãƒ•ãƒ¬ãƒ¼ãƒ æ™‚é–“: %.3f ms", 1000.0f / ImGui::GetIO().Framerate);
    ImGui::Separator();
    ImGui::Text("ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ : %.3f", DeltaTimeSevice::GetDeltaTime());

    ImGui::End();
#endif
}

============================================================
File Path: Project/application/Scene/Debug/AttackEditorScene.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/IScene.h"
// Editor
#include "application/Game/Entity/Player/Editor/AttackEditor.h"
// Line 
#include "application/Drawing/3d/Line.h"
// Player
#include "application/Game/Entity/Player/Weapon/PlayerWeapon.h"
// c++
#include <memory>

///=====================================================/// 
/// æ”»æ’ƒã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚·ãƒ¼ãƒ³
///=====================================================///
class AttackEditorScene : public IScene {
public:

    AttackEditorScene() = default;
    ~AttackEditorScene();

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update() override;

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;

private:
    /// ===Line=== ///
    std::unique_ptr<Line> line_;
    /// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼=== ///
    std::unique_ptr<AttackEditor> attackEditor_;
    /// ===ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼=== ///
    std::unique_ptr<PlayerWeapon> previewWeapon_;

    /// ===ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼è¨­å®š=== ///
    bool showHelp_ = false;              // ãƒ˜ãƒ«ãƒ—è¡¨ç¤ºãƒ•ãƒ©ã‚°
    bool showStats_ = true;              // çµ±è¨ˆæƒ…å ±è¡¨ç¤ºãƒ•ãƒ©ã‚°
    bool showGrid_ = true;               // ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºãƒ•ãƒ©ã‚°   

    /// ===ã‚«ãƒ¡ãƒ©=== ///
	Vector3 cameraPosition_{ 0.0f, 10.0f, -50.0f };   // ã‚«ãƒ¡ãƒ©ä½ç½®
	Quaternion cameraRotation_{ 0.0f, 0.0f, 0.0f, 1.0f }; // ã‚«ãƒ¡ãƒ©å›è»¢

private:

    /// <summary>
    /// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ¼ã®æç”»
    /// </summary>
    void RenderMenuBar();

    /// <summary>
    /// ãƒ˜ãƒ«ãƒ—ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
    /// </summary>
    void RenderHelpWindow();

    /// <summary>
    /// çµ±è¨ˆæƒ…å ±ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®æç”»
    /// </summary>
    void RenderStatsWindow();
};

============================================================
File Path: Project/application/Scene/GameOverScene.cpp
============================================================
#include "GameOverScene.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
GameOverScene::~GameOverScene() {
	// ISceneã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	IScene::~IScene();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void GameOverScene::Initialize() {
	// ISceneã®åˆæœŸåŒ–(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã¨ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£)
	IScene::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void GameOverScene::Update() {
	/// ===ãƒ‡ãƒãƒƒã‚¯ç”¨ImGui=== ///
#ifdef USE_IMGUI
	ImGui::Begin("GameOverScene");
	ImGui::End();
#endif // USE_IMGUI

	/// ===ISceneã®æ›´æ–°=== ///
	IScene::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void GameOverScene::Draw() {
#pragma region èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
#pragma endregion

#pragma region ãƒ¢ãƒ‡ãƒ«æç”»
	/// ===ISceneã®æç”»=== ///
	IScene::Draw();
#pragma endregion

#pragma region å‰æ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
#pragma endregion
}


============================================================
File Path: Project/application/Scene/GameOverScene.h
============================================================
#pragma once
/// ===Include=== ///
// IScene
#include "Engine/Scene/IScene.h"

///=====================================================/// 
/// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¼ãƒ³
///=====================================================///
class GameOverScene : public IScene {
public:/// ===ãƒ¡ãƒ³ãƒé–¢æ•°=== ///

	GameOverScene() = default;
	~GameOverScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw() override;

private:/// ===ãƒ¡ãƒ³ãƒå¤‰æ•°=== ///
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”¨
	/// </summary>
};



============================================================
File Path: Project/application/Scene/GameScene.cpp
============================================================
#include "GameScene.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"
// Service
#include "Engine/System/Service/CameraService.h"
#include "Engine/System/Service/ParticleService.h"
#include "Engine/System/Service/ColliderService.h"
#include "Engine/System/Service/InputService.h"
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/OffScreenService.h"
#include "Engine/System/Service/Loader.h"
// Math
#include "Math/SMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
GameScene::~GameScene() {
	// ISceneã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	IScene::~IScene();
	// Colliderã®ãƒªã‚»ãƒƒãƒˆ
	ColliderService::Reset();
	// StartAnimation
	startAnimation_.reset();
	// Camera
	camera_.reset();
	// Player
	player_.reset();
	// Enemy
	enemyManager_.reset();
	// Ground
	stage_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void GameScene::Initialize() {
	// ISceneã®åˆæœŸåŒ–(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã¨ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£)
	IScene::Initialize();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®èª­ã¿è¾¼ã¿
	ParticleService::LoadParticleDefinition("Game.json");
	ParticleService::LoadParticleDefinition("WeaponAttack.json");
	ParticleService::LoadParticleDefinition("nakagawa.json");
	ParticleService::LoadParticleDefinition("PlayerWarke.json");
	ParticleService::LoadParticleDefinition("EnemyAttack.json");
	ParticleService::LoadParticleDefinition("EnemyPrePareAttack.json");
	ParticleService::LoadParticleDefinition("EnemyPrePareAttackCharge.json");
	ParticleService::LoadParticleDefinition("CloseEnemyAttack.json");
	ParticleService::LoadParticleDefinition("LongEnemyAttack.json");

	/// ===Camera=== ///
	camera_ = std::make_shared<GameCamera>();
	camera_->Init(CameraType::Follow);
	camera_->SetRotate(cameraInfo_.rotate);
	camera_->SetFollowCamera(FollowCameraType::TopDown);
	camera_->SetOffset({ 0.0f, 70.0f, -60.0f });
	camera_->SetFollowSpeed(0.1f);
	// Managerã«è¿½åŠ ,ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«
	CameraService::AddCamera("Game", camera_);
	CameraService::SetActiveCamera("Game");

	/// ===Playerã®ç”Ÿæˆ=== ///
	player_ = std::make_unique<Player>();

	/// ===EnemyManagerã®ç”Ÿæˆ=== ///
	enemyManager_ = std::make_unique<EnemyManager>();

	/// ===SponEntity=== ///
	SpawnEntity("Level/EntityData.json");
	// Enemyã«Playerã‚’è¨­å®š
	enemyManager_->SetPlayer(player_.get());

	/// ===GameStage=== ///
	stage_ = std::make_unique<GameStage>();
	stage_->Initialize("Level/StageData.json");

	/// ===StartAnimation=== ///
	startAnimation_ = std::make_unique<StartAnimation>();
	startAnimation_->Initialize(player_.get(), camera_.get());

	/// ===GameOverAnimation=== ///
	gameOverAnimation_ = std::make_unique<GameOverAnimation>();

	/// ===GameClearAnimation=== ///
	gameClearAnimation_ = std::make_unique<GameClearAnimation>();

	/// ===GameSceneUI=== ///
	gameSceneUI_ = std::make_unique<GameSceneUI>();
	gameSceneUI_->Initialize();
	// GameSceneUIã«Playerã‚’è¨­å®š
	gameSceneUI_->SetPlayer(player_.get());
	gameSceneUI_->Update();

	// åˆæœŸãƒ•ã‚§ãƒ¼ã‚ºã‚’FadeInã«è¨­å®š
	currentPhase_ = FadeState::FadeIn;
	/// ===Transition=== ///
	float fadeInDuration = 2.0f;
	sceneManager_->StartFadeIn(TransitionType::ShatterGlass, fadeInDuration); // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³é–‹å§‹
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void GameScene::Update() {
	/// ===ãƒ‡ãƒãƒƒã‚¯ç”¨ImGui=== ///
#ifdef USE_IMGUI
	ImGui::Begin("GameScene");
	ImGui::End();

	// Camera
	camera_->ImGuiUpdate();
	camera_->DebugUpdate();

	// Player
	player_->Information();
	// Enemy
	enemyManager_->UpdateImGui();
	
	// ã‚«ãƒ¡ãƒ©åˆ‡ã‚Šæ›¿ãˆï¼ˆãƒ‡ãƒãƒƒã‚°ï¼‰
	if (InputService::TriggerKey(DIK_O)) {
		CameraService::SetActiveCamera("Game");
	} else if (InputService::TriggerKey(DIK_P)) {
		CameraService::SetActiveCamera("Default");
	}

#endif // USE_IMGUI

	/// ===Groundã®æ›´æ–°=== ///
	stage_->Update();

	/// ===ãƒ•ã‚§ãƒ¼ã‚ºåˆ¥æ›´æ–°=== ///
	switch (currentPhase_) {
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	case FadeState::FadeIn:
		UpdateFadeIn();
		break;
	// é–‹å§‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
	case FadeState::StartAnimation:
		UpdateStartAnimation();
		break;
	// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤
	case FadeState::Game:
		UpdateGame();
		break;
	case FadeState::GameOverAnimation:
		UpdateGameOverAnimation();
		break;
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	case FadeState::GameClearAnimation:
		UpdateGameClearAnimation();
		break;
	}

	/// ===ISceneã®æ›´æ–°=== ///
	IScene::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void GameScene::Draw() {
#pragma region èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
#pragma endregion

#pragma region ãƒ¢ãƒ‡ãƒ«æç”»

	/// ===GameStage=== ///
	stage_->Draw();

	/// ===Enemy=== ///
	enemyManager_->Draw();

	/// ===Player=== ///
	player_->Draw();

	/// ===StartAnimation=== ///
	if (currentPhase_ == FadeState::StartAnimation) {
		startAnimation_->Draw();
	/// ===GameOverAnimation=== ///
	} else if (currentPhase_ == FadeState::GameOverAnimation) {
		gameOverAnimation_->Draw();
	}

	/// ===ISceneã®æç”»=== ///
	IScene::Draw();
#pragma endregion

#pragma region å‰æ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»

	if (currentPhase_ == FadeState::Game) {
		/// ===GameSceneUI=== ///
		gameSceneUI_->Draw();
	}
#pragma endregion
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void GameScene::UpdateFadeIn() {

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Enemyæ›´æ–°
	enemyManager_->UpdateAnimation();

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Playeræ›´æ–°
	player_->UpdateAnimation();

	// FadeInå®Œäº†ã§StartAnimationãƒ•ã‚§ãƒ¼ã‚ºã¸
	if (sceneManager_->GetTransitionFinished()) {
		OffScreenService::SetOffScreenType(OffScreenType::CopyImage);
		currentPhase_ = FadeState::StartAnimation;
	}
}

///-------------------------------------------/// 
/// é–‹å§‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void GameScene::UpdateStartAnimation() {
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	startAnimation_->Update();

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Enemyæ›´æ–°
	enemyManager_->UpdateAnimation();

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Playeræ›´æ–°
	player_->UpdateAnimation();

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã§Gameãƒ•ã‚§ãƒ¼ã‚ºã¸
	if (startAnimation_->IsCompleted()) {
		// ã‚«ãƒ¡ãƒ©ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’Playerã«è¨­å®š
		player_->SetCameraTargetPlayer(); // ãã“ã¡ãªã•ãŒæ®‹ã‚‹
		currentPhase_ = FadeState::Game;
	}
}

///-------------------------------------------/// 
/// ã‚²ãƒ¼ãƒ æ™‚ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void GameScene::UpdateGame() {
	/// ===Playerã®æ›´æ–°=== ///
	player_->Update();

	/// ===Enemy=== ///
	enemyManager_->Update();
	enemyManager_->SetPlayer(player_.get()); // Playerã‚’è¨­å®š

	/// ===GameSceneUIã®æ›´æ–°=== ///
	gameSceneUI_->Update();

	// PlayerãŒæ­»ã‚“ã ã‚‰
	if (player_->GetIsDead() || InputService::TriggerKey(DIK_Q)) {
		gameOverAnimation_->Initialize(camera_.get());
		currentPhase_ = FadeState::GameOverAnimation; // GameOverAnimationã¸

	// ã‚²ãƒ¼ãƒ ãŒçµ‚ã‚ã£ãŸã‚‰FadeOutã¸
	} else if (enemyManager_->GetTotalEnemyCount() <= 0 || InputService::TriggerKey(DIK_W)) {
		gameClearAnimation_->Initialize(player_.get(), camera_.get());
		currentPhase_ = FadeState::GameClearAnimation; // GameClearã¸
	}
}

///-------------------------------------------/// 
/// GameOverã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void GameScene::UpdateGameOverAnimation() {
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	gameOverAnimation_->Update();

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Playeræ›´æ–°
	player_->Update();
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Enemyæ›´æ–°
	enemyManager_->UpdateAnimation();

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã§ã‚·ãƒ¼ãƒ³ç§»å‹•
	//NOTE:ã“ã®éƒ¨åˆ†ã¯ã‚·ãƒ¼ãƒ³ç§»å‹•ã§ã¯ãªãé·ç§»ã«ã™ã‚‹ã€‚ã‚¯ãƒªã‚¢ã‚‚åŒã˜
	if (gameOverAnimation_->IsCompleted()) {
		sceneManager_->ChangeScene(SceneType::Title);
	}
}

///-------------------------------------------/// 
/// ã‚¯ãƒªã‚¢æ™‚ã®æ›´æ–°å‡¦ç†
///-------------------------------------------///
void GameScene::UpdateGameClearAnimation() {

	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
	gameClearAnimation_->Update();
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Playeræ›´æ–°
	player_->UpdateAnimation();
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®Enemyæ›´æ–°
	enemyManager_->UpdateAnimation();
	
	// ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†ã§ã‚·ãƒ¼ãƒ³ç§»å‹•
	if (gameClearAnimation_->IsCompleted()) {
		sceneManager_->ChangeScene(SceneType::Title);
	}
}

///-------------------------------------------/// 
/// é…ç½®é–¢æ•°
///-------------------------------------------///
void GameScene::SpawnEntity(const std::string& json_name) {
	LevelData* levelData = GraphicsResourceGetter::GetLevelData(json_name);

	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆåˆ†å›ã™
	for (const auto& obj : levelData->objects) {
		// OBBã®åŠåˆ†ã®å¤§ãã•ã‚’è¨ˆç®—
		Vector3 obbHalfSize = obj.colliderInfo2 / 2.0f;

		/// ===ã‚¯ãƒ©ã‚¹åã§åˆ†å²=== ///
		switch (obj.classType) {
		case LevelData::ClassTypeLevel::Player1:
			// åˆæœŸåŒ–ã¨åº§æ¨™è¨­å®š
			player_->Initialize();
			player_->SetTranslate(obj.translation);
			player_->SetRotate(Math::QuaternionFromVector(obj.rotation));
			player_->SetHalfSize(obbHalfSize);
			break;
		case LevelData::ClassTypeLevel::Enemy1:
			// Enemyã®åº§æ¨™è¨­å®š
			enemyManager_->Spawn(EnemyType::LongRange, obj.translation, Math::QuaternionFromVector(obj.rotation), obbHalfSize);
			break;
		case LevelData::ClassTypeLevel::Enemy2:
			// Enemyã®åº§æ¨™è¨­å®š
			enemyManager_->Spawn(EnemyType::CloseRange, obj.translation, Math::QuaternionFromVector(obj.rotation), obbHalfSize);
			break;
		}
	}
}

============================================================
File Path: Project/application/Scene/GameScene.h
============================================================
#pragma once
/// ===Include=== ///
#include "Engine/Scene/IScene.h"
// Entity
#include "application/Game/Entity/Player/Player.h"
#include "application/Game/Entity/Enemy/Manager/EnemyManager.h"
#include "application/Game/Entity/Enemy/CloseRange/CloseRangeEnemy.h"
#include "application/Game/Entity/Enemy/LongRange/LongRangeEnemy.h"
// Object
#include "application/Game/Object/GameStage.h"
// Animation
#include "application/Game/Animation/StartAnimation.h"
#include "application/Game/Animation/GameOverAnimation.h"
#include "application/Game/Animation/GameClearAnimation.h"
// UI
#include "application/Game/UI/Game/GameSceneUI.h"

///=====================================================/// 
/// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³
///=====================================================///
class GameScene : public IScene {
public:/// ===ãƒ¡ãƒ³ãƒé–¢æ•°=== ///

	GameScene() = default;
	~GameScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw() override;

private:/// ===ãƒ¡ãƒ³ãƒå¤‰æ•°=== ///
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”¨
	/// </summary>

	/// ===Classã®å®£è¨€=== /// 
	// Camera
	std::shared_ptr<GameCamera> camera_;
	// Player
	std::unique_ptr<Player> player_;
	// Enemy
	std::unique_ptr<EnemyManager> enemyManager_;
	// Enemy
	std::unique_ptr<CloseRangeEnemy> closeRangeEnemy_;
	std::unique_ptr<LongRangeEnemy> longRangeEnemy_;
	// Stage
	std::unique_ptr<GameStage> stage_;
	// StartAnimation
	std::unique_ptr<StartAnimation> startAnimation_;
	// GameOverAnimation
	std::unique_ptr<GameOverAnimation> gameOverAnimation_;
	// GameClearAnimation
	std::unique_ptr<GameClearAnimation> gameClearAnimation_;
	// UI
	std::unique_ptr<GameSceneUI> gameSceneUI_;

	/// ===å¤‰æ•°ã®å®£è¨€=== ///
	// ã‚«ãƒ¡ãƒ©æƒ…å ±
	struct CameraInfo {
		Quaternion rotate = { 0.372f, 0.0f, 0.0f, 1.055f };
	};
	CameraInfo cameraInfo_;

	/// ===ãƒ•ã‚§ãƒ¼ã‚ºç®¡ç†=== ///
	// ã‚²ãƒ¼ãƒ ã®é€²è¡Œãƒ•ã‚§ãƒ¼ã‚º
	enum class FadeState {
		FadeIn,				// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
		StartAnimation,		// é–‹å§‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
		Game,				// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ä¸­
		GameOverAnimation,  // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
		GameClearAnimation  // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
	};
	FadeState currentPhase_ = FadeState::FadeIn;

private: /// ===ãƒ¡ãƒ³ãƒé–¢æ•°=== ///

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateFadeIn();

	/// <summary>
	/// é–‹å§‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateStartAnimation();

	/// <summary>
	/// ã‚²ãƒ¼ãƒ æ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateGame();

	/// <summary>
	/// ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateGameOverAnimation();

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆæ™‚ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateGameClearAnimation();

	/// <summary>
	/// é…ç½®å‡¦ç†
	/// </summary>
	/// <param name="json_name">ä½¿ç”¨ã™ã‚‹Jsonãƒ•ã‚¡ã‚¤ãƒ«å</param>
	void SpawnEntity(const std::string& json_name);
};

============================================================
File Path: Project/application/Scene/SelectScene.cpp
============================================================
#include "SelectScene.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
SelectScene::~SelectScene() {
	// ISceneã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	IScene::~IScene();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void SelectScene::Initialize() {
	// ISceneã®åˆæœŸåŒ–(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã¨ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£)
	IScene::Initialize();
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void SelectScene::Update() {
	/// ===ãƒ‡ãƒãƒƒã‚¯ç”¨ImGui=== ///
#ifdef USE_IMGUI
	ImGui::Begin("SelectScene");
	ImGui::End();
#endif // USE_IMGUI

	/// ===ISceneã®æ›´æ–°=== ///
	IScene::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void SelectScene::Draw() {
#pragma region èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
#pragma endregion

#pragma region ãƒ¢ãƒ‡ãƒ«æç”»
	/// ===ISceneã®æç”»=== ///
	IScene::Draw();
#pragma endregion

#pragma region å‰æ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
#pragma endregion
}


============================================================
File Path: Project/application/Scene/SelectScene.h
============================================================
#pragma once
/// ===Include=== ///
// IScene
#include "Engine/Scene/IScene.h"

///=====================================================/// 
/// ã‚»ãƒ¬ã‚¯ãƒˆã‚·ãƒ¼ãƒ³
///=====================================================///
class SelectScene : public IScene {
public:/// ===ãƒ¡ãƒ³ãƒé–¢æ•°=== ///

	SelectScene() = default;
	~SelectScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw() override;

private:/// ===ãƒ¡ãƒ³ãƒå¤‰æ•°=== ///
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”¨
	/// </summary>
};



============================================================
File Path: Project/application/Scene/TitleScene.cpp
============================================================
#include "TitleScene.h"
// SceneManager
#include "Engine/System/Managers/SceneManager.h"
// Service
#include "Engine/System/Service/InputService.h"
#include "Engine/System/Service/GraphicsResourceGetter.h"
#include "Engine/System/Service/OffScreenService.h"
// Math
#include "Math/sMath.h"
#include "Math/EasingMath.h"

///-------------------------------------------/// 
/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
///-------------------------------------------///
TitleScene::~TitleScene() {
	// ISceneã®ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	IScene::~IScene();
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ãƒªã‚»ãƒƒãƒˆ
	bgSprite_.reset();
	bgKiriSprite_.reset();
	titleSprite_.reset();
	startSprite_.reset();
	optionSprite_.reset();
	exitSprite_.reset();
	selectOverlay_.reset();
	dimSprite_.reset();
	optionMenuSprite_.reset();
}

///-------------------------------------------/// 
/// åˆæœŸåŒ–
///-------------------------------------------///
void TitleScene::Initialize() {
	// ISceneã®åˆæœŸåŒ–(ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã¨ã‚«ãƒ¡ãƒ©ãƒãƒãƒ¼ã‚¸ãƒ£)
	IScene::Initialize();

	// windowã‚µã‚¤ã‚ºã®å–å¾—
	Vector2 windowSize = {
		static_cast<float>(GraphicsResourceGetter::GetWindowWidth()),
		static_cast<float>(GraphicsResourceGetter::GetWindowHeight())
	};

	/// ===Scale=== ///
	// åŸºæº–è§£åƒåº¦
	constexpr float BASE_WIDTH = 1920.0f;
	constexpr float BASE_HEIGHT = 1080.0f;
	// Scale
	scale_ = { windowSize.x / BASE_WIDTH, windowSize.y / BASE_HEIGHT };

	/// ===ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–=== ///
	// èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	bgSprite_ = std::make_unique<Sprite>();
	bgSprite_->Initialize("TitleBG");
	bgSprite_->SetPosition({ 0.0f, 0.0f });
	bgSprite_->SetSize({ windowSize.x, windowSize.y });

	// èƒŒæ™¯Kiriã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	bgKiriSprite_ = std::make_unique<Sprite>();
	bgKiriSprite_->Initialize("TitleBGKiri");
	bgKiriSprite_->SetPosition({ 0.0f, 0.0f });
	bgKiriSprite_->SetSize({ windowSize.x, windowSize.y });

	// ã‚¿ã‚¤ãƒˆãƒ«ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	titleSprite_ = std::make_unique<Sprite>();
	titleSprite_->Initialize("Title"); // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¯é©å®œå¤‰æ›´
	titleSprite_->SetPosition({ windowSize.x / 2.0f, windowSize.y / 4.0f });
	titleSprite_->SetSize({ 1000.0f * scale_.x, 1000.0f * scale_.y });
	titleSprite_->SetAnchorPoint({ 0.5f, 0.5f });
	titleSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 1.0f });

	// é–‹å§‹ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	spaceY_ = windowSize.y / 12.0f; // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®é–“ã®å‚ç›´ã‚¹ãƒšãƒ¼ã‚¹
	startY_ = windowSize.y / 2.0f + windowSize.y / 8.0f; // é–‹å§‹é …ç›®ã®Yä½ç½®

	startSprite_ = std::make_unique<Sprite>();
	startSprite_->Initialize("Start");
	startSprite_->SetPosition({ windowSize.x / 2.0f, startY_ });
	startSprite_->SetSize({ 200.0f * scale_.x, 50.0f * scale_.y });
	startSprite_->SetAnchorPoint({ 0.5f, 0.5f });
	startSprite_->SetColor({ 0.8f, 0.8f, 0.8f, 1.0f }); // é¸æŠä¸­ã¯é»„è‰²

	// ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	optionSprite_ = std::make_unique<Sprite>();
	optionSprite_->Initialize("Option");
	optionSprite_->SetPosition({ windowSize.x / 2.0f, startY_ + spaceY_ });
	optionSprite_->SetSize({ 200.0f * scale_.x, 50.0f * scale_.y });
	optionSprite_->SetAnchorPoint({ 0.5f, 0.5f });
	optionSprite_->SetColor({ 0.8f, 0.8f, 0.8f, 1.0f }); // æœªé¸æŠã¯ç°è‰²

	// çµ‚äº†ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	exitSprite_ = std::make_unique<Sprite>();
	exitSprite_->Initialize("Exit");
	exitSprite_->SetPosition({ windowSize.x / 2.0f, startY_ + spaceY_ * 2.0f });
	exitSprite_->SetSize({ 200.0f * scale_.x, 50.0f * scale_.y });
	exitSprite_->SetAnchorPoint({ 0.5f, 0.5f });
	exitSprite_->SetColor({ 0.8f, 0.8f, 0.8f, 1.0f });

	// é¸æŠã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	selectOverlay_ = std::make_unique<Sprite>();
	selectOverlay_->Initialize("OverLay"); // ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã¯é©å®œå¤‰æ›´
	selectOverlay_->SetPosition({ windowSize.x / 2.0f, startY_ }); // åˆæœŸä½ç½®ã¯é–‹å§‹ã®ä½ç½®
	selectOverlay_->SetSize({ 400.0f * scale_.x, 80.0f * scale_.y }); // ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã‚ˆã‚Šå°‘ã—å¤§ãã‚
	selectOverlay_->SetAnchorPoint({ 0.5f, 0.5f });
	selectOverlay_->SetColor({ 0.8f, 0.8f, 0.8f, 0.8f }); // åŠé€æ˜ã®é»„è‰²

	// è–„æš—ã„ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
	dimSprite_ = std::make_unique<Sprite>();
	dimSprite_->Initialize("uvChecker");
	dimSprite_->SetPosition({ 0.0f, 0.0f });
	dimSprite_->SetSize({ windowSize.x, windowSize.y });
	dimSprite_->SetColor({ 0.0f, 0.0f, 0.0f, 0.7f }); // åŠé€æ˜ã®é»’

	// ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼
	optionMenuSprite_ = std::make_unique<Sprite>();
	optionMenuSprite_->Initialize("uvChecker");
	optionMenuSprite_->SetPosition({ windowSize.x / 2.0f, windowSize.y / 2.0f });
	optionMenuSprite_->SetSize({ 500.0f * scale_.x, 400.0f * scale_.y });
	optionMenuSprite_->SetAnchorPoint({ 0.5f, 0.5f });
	optionMenuSprite_->SetColor({ 0.3f, 0.3f, 0.5f, 1.0f }); // é’ã¿ãŒã‹ã£ãŸè‰²

	// åˆæœŸåŒ–æ™‚ã®ä½ç½®æ›´æ–°
	bgSprite_->Update();
	bgKiriSprite_->Update();
	titleSprite_->Update();
	startSprite_->Update();
	optionSprite_->Update();
	exitSprite_->Update();
	selectOverlay_->Update();
	dimSprite_->Update();
	optionMenuSprite_->Update();

	/// ===Fadeã®è¨­å®š=== ///
	currentFade_ = FadeState::Selecting; // ãƒ‡ãƒãƒƒã‚°ç”¨ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—
}

///-------------------------------------------/// 
/// æ›´æ–°
///-------------------------------------------///
void TitleScene::Update() {
	/// ===ãƒ‡ãƒãƒƒã‚¯ç”¨ImGui=== ///
#ifdef USE_IMGUI
	ImGui::Begin("TitleScene");
	ImGui::Text("Fade State: %d", static_cast<int>(currentFade_));
	ImGui::Text("Current Selection: %d", static_cast<int>(currentSelection_));
	ImGui::Text("Option Open: %s", isOptionOpen_ ? "true" : "false");
	ImGui::End();
#endif // USE_IMGUI

	/// ===ãƒ•ã‚§ãƒ¼ã‚ºåˆ¥æ›´æ–°=== ///
	switch (currentFade_) {
	case TitleScene::FadeState::FadeIn:
		UpdateFadeIn();
		break;
	case TitleScene::FadeState::Selecting:
		UpdateSelecting();
		break;
	case TitleScene::FadeState::FadeOut:
		UpdateFadeOut();
		break;
	}

	/// ===ISceneã®æ›´æ–°=== ///
	IScene::Update();
}

///-------------------------------------------/// 
/// æç”»
///-------------------------------------------///
void TitleScene::Draw() {
#pragma region èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	// èƒŒæ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	bgSprite_->Draw(GroundType::Back);
	//bgKiriSprite_->Draw(GroundType::Back);
	// ã‚¿ã‚¤ãƒˆãƒ«ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	titleSprite_->Draw(GroundType::Back);
#pragma endregion

#pragma region ãƒ¢ãƒ‡ãƒ«æç”»
	/// ===ISceneã®æç”»=== ///
	IScene::Draw();
#pragma endregion

#pragma region å‰æ™¯ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»
	// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	startSprite_->Draw(GroundType::Front);
	optionSprite_->Draw(GroundType::Front);
	exitSprite_->Draw(GroundType::Front);

	// é¸æŠã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ãŒé–‹ã„ã¦ã„ãªã„æ™‚ã®ã¿ï¼‰
	if (!isOptionOpen_) {
		selectOverlay_->Draw(GroundType::Front, BlendMode::kBlendModeAdd); // åŠ ç®—åˆæˆã§å…‰ã‚‰ã›ã‚‹
	}

	// ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢
	if (isOptionOpen_) {
		dimSprite_->Draw(GroundType::Front, BlendMode::KBlendModeNormal);
		optionMenuSprite_->Draw(GroundType::Front);
	}
#pragma endregion
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã®æ›´æ–°
///-------------------------------------------///
void TitleScene::UpdateFadeIn() {
	/// ===Fadeã®å¤‰æ›´=== ///
	if (sceneManager_->GetTransitionFinished()) {
		currentFade_ = FadeState::Selecting;
	}
}

///-------------------------------------------/// 
/// é¸æŠçŠ¶æ…‹ã®æ›´æ–°
///-------------------------------------------///
void TitleScene::UpdateSelecting() {

	/// ===ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°=== ///
	selectOverlay_->Update();

	/// ===ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã®å‡¦ç†=== ///
	if (isOptionOpen_) {
		UpdateOptionMenu();
	} else {
		/// ===ãƒ¡ãƒ‹ãƒ¥ãƒ¼é¸æŠã®æ›´æ–°=== ///
		UpdateMenuSelection();

		/// ===æ±ºå®šå‡¦ç†=== ///
		if (InputService::TriggerButton(0, ControllerButtonType::A) || InputService::TriggerKey(DIK_SPACE)) {
			ConfirmSelection();
		}
	}
}

///-------------------------------------------/// 
/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®æ›´æ–°
///-------------------------------------------///
void TitleScene::UpdateFadeOut() {

	/// ===ã‚·ãƒ¼ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆ=== ///
	if (sceneManager_->GetTransitionFinished()) {
		// ã‚²ãƒ¼ãƒ ã‚·ãƒ¼ãƒ³ã¸é·ç§»
		sceneManager_->ChangeScene(SceneType::Game);
	}
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼é¸æŠã®æ›´æ–°
///-------------------------------------------///
void TitleScene::UpdateMenuSelection() {
	// åå­—ã‚­ãƒ¼ä¸Š
	if (InputService::TriggerButton(0, ControllerButtonType::DPadUP) || InputService::TriggerKey(DIK_UP)) {
		switch (currentSelection_) {
		case MenuSelection::Start:
			currentSelection_ = MenuSelection::Exit; // ä¸€ç•ªä¸Šã‹ã‚‰ä¸€ç•ªä¸‹ã¸
			break;
		case MenuSelection::Option:
			currentSelection_ = MenuSelection::Start;
			break;
		case MenuSelection::Exit:
			currentSelection_ = MenuSelection::Option;
			break;
		}
		UpdateSelectOverlayPosition();
	}

	// åå­—ã‚­ãƒ¼ä¸‹
	if (InputService::TriggerButton(0, ControllerButtonType::DPadDOWN) || InputService::TriggerKey(DIK_DOWN)) {
		switch (currentSelection_) {
		case MenuSelection::Start:
			currentSelection_ = MenuSelection::Option;
			break;
		case MenuSelection::Option:
			currentSelection_ = MenuSelection::Exit;
			break;
		case MenuSelection::Exit:
			currentSelection_ = MenuSelection::Start; // ä¸€ç•ªä¸‹ã‹ã‚‰ä¸€ç•ªä¸Šã¸
			break;
		}
		UpdateSelectOverlayPosition();
	}
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼æ±ºå®šå‡¦ç†
///-------------------------------------------///
void TitleScene::ConfirmSelection() {
	// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³æ™‚é–“
	float fadeInDuration = 1.0f;

	switch (currentSelection_) {
	case MenuSelection::Start:
		sceneManager_->StartFadeOut(TransitionType::ShatterGlass, fadeInDuration);
		currentFade_ = FadeState::FadeOut;
		break;
	case MenuSelection::Option:
		// ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã‚’é–‹ã
		isOptionOpen_ = true;
		break;
	case MenuSelection::Exit:
		// ã‚²ãƒ¼ãƒ çµ‚äº†
		PostQuitMessage(0);
		break;
	}
}

///-------------------------------------------/// 
/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã®è‰²æ›´æ–°
///-------------------------------------------///
void TitleScene::UpdateSelectOverlayPosition() {
	float windowWidth = static_cast<float>(GraphicsResourceGetter::GetWindowWidth());

	// é¸æŠä¸­ã®é …ç›®ã®ä½ç½®ã«å¿œã˜ã¦ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ç§»å‹•
	switch (currentSelection_) {
	case MenuSelection::Start:
		selectOverlay_->SetPosition({ windowWidth / 2.0f, startY_ });
		break;
	case MenuSelection::Option:
		selectOverlay_->SetPosition({ windowWidth / 2.0f, startY_ + spaceY_ });
		break;
	case MenuSelection::Exit:
		selectOverlay_->SetPosition({ windowWidth / 2.0f, startY_ + spaceY_ * 2.0f });
		break;
	}
}

///-------------------------------------------/// 
/// ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã®æ›´æ–°
///-------------------------------------------///
void TitleScene::UpdateOptionMenu() {
	// Bãƒœã‚¿ãƒ³ã§ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã‚’é–‰ã˜ã‚‹
	if (InputService::TriggerButton(0, ControllerButtonType::B) || InputService::TriggerKey(DIK_SPACE)) {
		isOptionOpen_ = false;
	}

	/// ===ã“ã“ã«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã®å‡¦ç†ã‚’è¿½åŠ === ///
}

============================================================
File Path: Project/application/Scene/TitleScene.h
============================================================
#pragma once
/// ===Include=== ///
// IScene
#include "Engine/Scene/IScene.h"
#include "application/Drawing/2d/Sprite.h"
// C++
#include <memory>
#include <array>

///=====================================================/// 
/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³
///=====================================================///
class TitleScene : public IScene {
public:/// ===ãƒ¡ãƒ³ãƒé–¢æ•°=== ///

	TitleScene() = default;
	~TitleScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw() override;

private:/// ===ãƒ¡ãƒ³ãƒå¤‰æ•°=== ///
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”¨
	/// </summary>

	/// ===ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ=== ///
	std::unique_ptr<Sprite> bgSprite_;         // èƒŒæ™¯
	std::unique_ptr<Sprite> bgKiriSprite_;     // èƒŒæ™¯
	std::unique_ptr<Sprite> titleSprite_;      // ã‚¿ã‚¤ãƒˆãƒ«
	std::unique_ptr<Sprite> startSprite_;      // é–‹å§‹
	std::unique_ptr<Sprite> optionSprite_;     // ã‚ªãƒ—ã‚·ãƒ§ãƒ³
	std::unique_ptr<Sprite> exitSprite_;       // çµ‚äº†
	std::unique_ptr<Sprite> selectOverlay_;    // é¸æŠä¸­ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
	std::unique_ptr<Sprite> dimSprite_;        // è–„æš—ã„ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤
	std::unique_ptr<Sprite> optionMenuSprite_; // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼

	/// ===ãƒã‚¤ãƒ³ãƒˆã®å€¤=== ///
	float startY_ = 0.0f;
	float spaceY_ = 0.0f;

	/// ===Fade=== ///
	enum class FadeState {
		FadeIn,
		Selecting,
		FadeOut,
	};
	FadeState currentFade_ = FadeState::FadeIn;

	/// ===ãƒ¡ãƒ‹ãƒ¥ãƒ¼é¸æŠ=== ///
	// ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®ã®åˆ—æŒ™å‹
	enum class MenuSelection {
		Start,    // é–‹å§‹
		Option,   // ã‚ªãƒ—ã‚·ãƒ§ãƒ³
		Exit      // çµ‚äº†
	};
	MenuSelection currentSelection_ = MenuSelection::Start; // ç¾åœ¨ã®é¸æŠ
	bool isOptionOpen_ = false;      // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ãŒé–‹ã„ã¦ã„ã‚‹ã‹

	/// ===å…¥åŠ›åˆ¶å¾¡=== ///
	bool canInput_ = true; // å…¥åŠ›å¯èƒ½ãƒ•ãƒ©ã‚°ï¼ˆé€£ç¶šå…¥åŠ›é˜²æ­¢ï¼‰

	/// ===å‚ç…§ã‚¹ã‚±ãƒ¼ãƒ«å€ç‡=== ///
	Vector2 scale_ = { 1.0f, 1.0f }; // ã‚¹ã‚±ãƒ¼ãƒ«

private:/// ===ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆé–¢æ•°=== ///

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ã®é€²è¡ŒçŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
	/// </summary>
	void UpdateFadeIn();

	/// <summary>
	/// é¸æŠçŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
	/// </summary>
	void UpdateSelecting();

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
	/// </summary>
	void UpdateFadeOut();

	/// <summary>
	/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é¸æŠçŠ¶æ…‹ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateMenuSelection();

	/// <summary>
	/// ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®é¸æŠæ±ºå®šå‡¦ç†
	/// </summary>
	void ConfirmSelection();

	/// <summary>
	/// é¸æŠã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®ä½ç½®ã‚’æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateSelectOverlayPosition();

	/// <summary>
	/// ã‚ªãƒ—ã‚·ãƒ§ãƒ³ç”»é¢ã®æ›´æ–°å‡¦ç†
	/// </summary>
	void UpdateOptionMenu();
};

============================================================
File Path: Project/main.cpp
============================================================
/// ===include=== ///
#include "Engine/Scene/Framework.h"
#include "Engine/Scene/MyGame.h"
#include <windows.h>

/// ===ã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒˆãƒ«=== ///
const wchar_t kWindowTitle[] = L"Fallen Ascent";

// Windowsã‚¢ãƒ—ãƒªã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ(mainé–¢æ•°)
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {
	// å®£è¨€
	Framework* game = new MyGame();
	// å®Ÿè¡Œ
	game->Run(kWindowTitle);
	// è§£æ”¾
	delete game;

	return 0;
}
